(()=>{"use strict";var e={23:e=>{e.exports=require("util")},278:e=>{e.exports=require("net")},317:e=>{e.exports=require("child_process")},608:function(e,r,t){var o,n=this&&this.__createBinding||(Object.create?function(e,r,t,o){void 0===o&&(o=t);var n=Object.getOwnPropertyDescriptor(r,t);n&&!("get"in n?!r.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return r[t]}}),Object.defineProperty(e,o,n)}:function(e,r,t,o){void 0===o&&(o=t),e[o]=r[t]}),s=this&&this.__setModuleDefault||(Object.create?function(e,r){Object.defineProperty(e,"default",{enumerable:!0,value:r})}:function(e,r){e.default=r}),c=this&&this.__importStar||(o=function(e){return o=Object.getOwnPropertyNames||function(e){var r=[];for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(r[r.length]=t);return r},o(e)},function(e){if(e&&e.__esModule)return e;var r={};if(null!=e)for(var t=o(e),c=0;c<t.length;c++)"default"!==t[c]&&n(r,e,t[c]);return s(r,e),r});Object.defineProperty(r,"__esModule",{value:!0});const i=t(317),a=c(t(278)),p=(0,t(23).promisify)(i.exec);function d(e){console.error(`forwarder: ${e}`)}function l(e){console.error(`forwarder error: ${e}`)}class u{async expectContainer(e,r,t){try{const{stdout:o}=await p(`docker inspect -f "{{${r}}}" ${e}`);return o.trim()===t}catch(e){return l(`Error getting container status: ${e.message}`),!1}}async monitorContainer(e){for(;;){const r=await this.expectContainer(e,".State.Running","true"),t=await this.expectContainer(e,".State.Restarting","true");if(!await this.expectContainer(e,".State.Status","created")&&!t&&!r)break;await new Promise(e=>setTimeout(e,1e4))}}generateRemoteNodeJsCode(e){if(e.socket&&e.port||!e.socket&&!e.port)throw new Error("Invalid arguments, exactly one of socket or port must be provided.");const r=e.port?`{ host: '127.0.0.1', port: ${e.port} }`:`{ path: '${e.socket}' }`;return e.port?`\nconst net = require('net');\nconst fs = require('fs');\nprocess.stdin.pause();\nconst client = net.createConnection(${r}, () => {\n    console.error('Connection established');\n    client.pipe(process.stdout);\n    process.stdin.pipe(client);\n});\nclient.on('close', function (hadError) {\n    console.error(hadError ? 'Remote close with error' : 'Remote close');\n    process.exit(hadError ? 1 : 0);\n});\nclient.on('error', function (err) {\n    process.stderr.write(err && (err.stack || err.message) || String(err));\n});\nprocess.stdin.on('close', function (hadError) {\n    console.error(hadError ? 'Remote stdin close with error' : 'Remote stdin close');\n    process.exit(hadError ? 1 : 0);\n});\nprocess.on('uncaughtException', function (err) {\n    fs.writeSync(process.stderr.fd, 'error: ' + (err.stack || err.message) + '\\n');\n    process.exit(1);\n});`:`\nconst net = require('net');\nconst fs = require('fs');\nprocess.stdin.pause();\nconst server = net.createServer(function (socket) {\n    console.error('Connection established');\n    socket.pipe(process.stdout);\n    process.stdin.pipe(socket);\n});\nserver.listen(${r});\nserver.on('close', function (hadError) {\n    console.error(hadError ? 'Remote close with error' : 'Remote close');\n    process.exit(hadError ? 1 : 0);\n});\nserver.on('error', function (err) {\n    process.stderr.write(err && (err.stack || err.message) || String(err));\n});\nprocess.stdin.on('close', function (hadError) {\n    console.error(hadError ? 'Remote stdin close with error' : 'Remote stdin close');\n    process.exit(hadError ? 1 : 0);\n});\nprocess.on('uncaughtException', function (err) {\n    fs.writeSync(process.stderr.fd, 'error: ' + (err.stack || err.message) + '\\n');\n    process.exit(1);\n});\n`}async handleClient({socket:e,containerId:r,options:t,remoteServerNodePath:o,remoteUser:n}){try{const s=["docker","exec","-u",n,"-i",r,"bash","-c",`${o} -e "${this.generateRemoteNodeJsCode(t)}"`],c=(0,i.spawn)(s[0],s.slice(1),{stdio:["pipe","pipe","pipe"]});if(await new Promise(e=>setTimeout(e,500)),null!==c.exitCode)return l(`handleClient Error: subprocess terminated immediately with return code ${c.exitCode}`),void e.end();c.stdin&&c.stdout&&(e.pipe(c.stdin),c.stdout.pipe(e)),e.on("close",()=>{c.kill()}),c.on("error",r=>{l(`handleClient error: ${r.message}`),e.end()})}catch(r){l(`handleClient Error: ${r}`),e.end()}}async startServer(e,r,t,o){const n=a.createServer(n=>{this.handleClient({socket:n,containerId:e,options:{port:r},remoteServerNodePath:t,remoteUser:o})});n.listen(0,"127.0.0.1",()=>{const e=n.address();e&&"string"!=typeof e&&d(`====forwarderPort=${e.port}====`)}),this.monitorContainer(e).then(()=>{n.close(),d(`Stopping forwarding for port ${r}`)})}async startSocketForward(e,r,t,o,n){const s=a.createConnection(r);this.handleClient({socket:s,containerId:e,options:{socket:t},remoteServerNodePath:o,remoteUser:n}),d("====socketForward=success===="),this.monitorContainer(e).then(()=>{s.end(),d(`Stopping forwarding for socket ${r} to ${t}`)})}async forwardPort(e,r,t,o){await this.startServer(e,r,t,o)}async forwardSocket(e,r,t,o,n){await this.startSocketForward(e,r,t,o,n)}}(async function(){const e=process.argv.slice(2);5!==e.length&&6!==e.length&&(l('Expected arguments: "port"|"socket" <container_id> <remote_server_node_path> <remoteUser> (<port> | <local_socket> <remote_socket>)'),process.exit(1));const r=e[0];"port"!==r&&"socket"!==r&&(l('Expected arguments: "port"|"socket" <container_id> <remote_server_node_path> <remoteUser> (<port> | <local_socket> <remote_socket>)'),process.exit(1));const t=e[1],o=e[2],n=e[3];if("port"===r){const r=parseInt(e[4],10);try{await(new u).forwardPort(t,r,o,n)}catch(e){l(String(e)),process.exit(1)}}else if("socket"===r){const r=e[4],s=e[5];try{await(new u).forwardSocket(t,r,s,o,n)}catch(e){l(String(e)),process.exit(1)}}})().catch(e=>{l(String(e)),process.exit(1)})}},r={},t=function t(o){var n=r[o];if(void 0!==n)return n.exports;var s=r[o]={exports:{}};return e[o].call(s.exports,s,s.exports,t),s.exports}(608);module.exports=t})();