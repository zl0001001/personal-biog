"use strict";
(self.webpackChunk_genie_chat_webview_app = self.webpackChunk_genie_chat_webview_app || []).push([
    [
        3011
    ],
    {
        3444: (t, e, r)=>{
            r.d(e, {
                o: ()=>s
            });
            var s = (0, r(35456).K2)(()=>"\n  /* Font Awesome icon styling - consolidated */\n  .label-icon {\n    display: inline-block;\n    height: 1em;\n    overflow: visible;\n    vertical-align: -0.125em;\n  }\n  \n  .node .label-icon path {\n    fill: currentColor;\n    stroke: revert;\n    stroke-width: revert;\n  }\n", "getIconStyles");
        },
        31600: (t, e, r)=>{
            r.d(e, {
                T: ()=>s.T
            });
            var s = r(94628);
        },
        53011: (t, e, r)=>{
            r.d(e, {
                diagram: ()=>Zt
            });
            var s = r(3444), a = r(37703), i = r(56876), n = r(50396), o = r(9147), l = r(94279), c = r(35456), d = r(68766), h = r(58054), g = r(1827), u = r(32551), p = r(31600), y = function() {
                var t = (0, c.K2)(function(t, e, r, s) {
                    for(r = r || {}, s = t.length; s--; r[t[s]] = e);
                    return r;
                }, "o"), e = [
                    1,
                    15
                ], r = [
                    1,
                    7
                ], s = [
                    1,
                    13
                ], a = [
                    1,
                    14
                ], i = [
                    1,
                    19
                ], n = [
                    1,
                    16
                ], o = [
                    1,
                    17
                ], l = [
                    1,
                    18
                ], d = [
                    8,
                    30
                ], h = [
                    8,
                    10,
                    21,
                    28,
                    29,
                    30,
                    31,
                    39,
                    43,
                    46
                ], g = [
                    1,
                    23
                ], u = [
                    1,
                    24
                ], p = [
                    8,
                    10,
                    15,
                    16,
                    21,
                    28,
                    29,
                    30,
                    31,
                    39,
                    43,
                    46
                ], y = [
                    8,
                    10,
                    15,
                    16,
                    21,
                    27,
                    28,
                    29,
                    30,
                    31,
                    39,
                    43,
                    46
                ], b = [
                    1,
                    49
                ], x = {
                    trace: (0, c.K2)(function trace() {}, "trace"),
                    yy: {},
                    symbols_: {
                        error: 2,
                        spaceLines: 3,
                        SPACELINE: 4,
                        NL: 5,
                        separator: 6,
                        SPACE: 7,
                        EOF: 8,
                        start: 9,
                        BLOCK_DIAGRAM_KEY: 10,
                        document: 11,
                        stop: 12,
                        statement: 13,
                        link: 14,
                        LINK: 15,
                        START_LINK: 16,
                        LINK_LABEL: 17,
                        STR: 18,
                        nodeStatement: 19,
                        columnsStatement: 20,
                        SPACE_BLOCK: 21,
                        blockStatement: 22,
                        classDefStatement: 23,
                        cssClassStatement: 24,
                        styleStatement: 25,
                        node: 26,
                        SIZE: 27,
                        COLUMNS: 28,
                        "id-block": 29,
                        end: 30,
                        NODE_ID: 31,
                        nodeShapeNLabel: 32,
                        dirList: 33,
                        DIR: 34,
                        NODE_DSTART: 35,
                        NODE_DEND: 36,
                        BLOCK_ARROW_START: 37,
                        BLOCK_ARROW_END: 38,
                        classDef: 39,
                        CLASSDEF_ID: 40,
                        CLASSDEF_STYLEOPTS: 41,
                        DEFAULT: 42,
                        class: 43,
                        CLASSENTITY_IDS: 44,
                        STYLECLASS: 45,
                        style: 46,
                        STYLE_ENTITY_IDS: 47,
                        STYLE_DEFINITION_DATA: 48,
                        $accept: 0,
                        $end: 1
                    },
                    terminals_: {
                        2: "error",
                        4: "SPACELINE",
                        5: "NL",
                        7: "SPACE",
                        8: "EOF",
                        10: "BLOCK_DIAGRAM_KEY",
                        15: "LINK",
                        16: "START_LINK",
                        17: "LINK_LABEL",
                        18: "STR",
                        21: "SPACE_BLOCK",
                        27: "SIZE",
                        28: "COLUMNS",
                        29: "id-block",
                        30: "end",
                        31: "NODE_ID",
                        34: "DIR",
                        35: "NODE_DSTART",
                        36: "NODE_DEND",
                        37: "BLOCK_ARROW_START",
                        38: "BLOCK_ARROW_END",
                        39: "classDef",
                        40: "CLASSDEF_ID",
                        41: "CLASSDEF_STYLEOPTS",
                        42: "DEFAULT",
                        43: "class",
                        44: "CLASSENTITY_IDS",
                        45: "STYLECLASS",
                        46: "style",
                        47: "STYLE_ENTITY_IDS",
                        48: "STYLE_DEFINITION_DATA"
                    },
                    productions_: [
                        0,
                        [
                            3,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            6,
                            1
                        ],
                        [
                            6,
                            1
                        ],
                        [
                            6,
                            1
                        ],
                        [
                            9,
                            3
                        ],
                        [
                            12,
                            1
                        ],
                        [
                            12,
                            1
                        ],
                        [
                            12,
                            2
                        ],
                        [
                            12,
                            2
                        ],
                        [
                            11,
                            1
                        ],
                        [
                            11,
                            2
                        ],
                        [
                            14,
                            1
                        ],
                        [
                            14,
                            4
                        ],
                        [
                            13,
                            1
                        ],
                        [
                            13,
                            1
                        ],
                        [
                            13,
                            1
                        ],
                        [
                            13,
                            1
                        ],
                        [
                            13,
                            1
                        ],
                        [
                            13,
                            1
                        ],
                        [
                            13,
                            1
                        ],
                        [
                            19,
                            3
                        ],
                        [
                            19,
                            2
                        ],
                        [
                            19,
                            1
                        ],
                        [
                            20,
                            1
                        ],
                        [
                            22,
                            4
                        ],
                        [
                            22,
                            3
                        ],
                        [
                            26,
                            1
                        ],
                        [
                            26,
                            2
                        ],
                        [
                            33,
                            1
                        ],
                        [
                            33,
                            2
                        ],
                        [
                            32,
                            3
                        ],
                        [
                            32,
                            4
                        ],
                        [
                            23,
                            3
                        ],
                        [
                            23,
                            3
                        ],
                        [
                            24,
                            3
                        ],
                        [
                            25,
                            3
                        ]
                    ],
                    performAction: (0, c.K2)(function anonymous(t, e, r, s, a, i, n) {
                        var o = i.length - 1;
                        switch(a){
                            case 4:
                                s.getLogger().debug("Rule: separator (NL) ");
                                break;
                            case 5:
                                s.getLogger().debug("Rule: separator (Space) ");
                                break;
                            case 6:
                                s.getLogger().debug("Rule: separator (EOF) ");
                                break;
                            case 7:
                                s.getLogger().debug("Rule: hierarchy: ", i[o - 1]), s.setHierarchy(i[o - 1]);
                                break;
                            case 8:
                                s.getLogger().debug("Stop NL ");
                                break;
                            case 9:
                                s.getLogger().debug("Stop EOF ");
                                break;
                            case 10:
                                s.getLogger().debug("Stop NL2 ");
                                break;
                            case 11:
                                s.getLogger().debug("Stop EOF2 ");
                                break;
                            case 12:
                                s.getLogger().debug("Rule: statement: ", i[o]), "number" == typeof i[o].length ? this.$ = i[o] : this.$ = [
                                    i[o]
                                ];
                                break;
                            case 13:
                                s.getLogger().debug("Rule: statement #2: ", i[o - 1]), this.$ = [
                                    i[o - 1]
                                ].concat(i[o]);
                                break;
                            case 14:
                                s.getLogger().debug("Rule: link: ", i[o], t), this.$ = {
                                    edgeTypeStr: i[o],
                                    label: ""
                                };
                                break;
                            case 15:
                                s.getLogger().debug("Rule: LABEL link: ", i[o - 3], i[o - 1], i[o]), this.$ = {
                                    edgeTypeStr: i[o],
                                    label: i[o - 1]
                                };
                                break;
                            case 18:
                                const e1 = parseInt(i[o]), r1 = s.generateId();
                                this.$ = {
                                    id: r1,
                                    type: "space",
                                    label: "",
                                    width: e1,
                                    children: []
                                };
                                break;
                            case 23:
                                s.getLogger().debug("Rule: (nodeStatement link node) ", i[o - 2], i[o - 1], i[o], " typestr: ", i[o - 1].edgeTypeStr);
                                const a1 = s.edgeStrToEdgeData(i[o - 1].edgeTypeStr);
                                this.$ = [
                                    {
                                        id: i[o - 2].id,
                                        label: i[o - 2].label,
                                        type: i[o - 2].type,
                                        directions: i[o - 2].directions
                                    },
                                    {
                                        id: i[o - 2].id + "-" + i[o].id,
                                        start: i[o - 2].id,
                                        end: i[o].id,
                                        label: i[o - 1].label,
                                        type: "edge",
                                        directions: i[o].directions,
                                        arrowTypeEnd: a1,
                                        arrowTypeStart: "arrow_open"
                                    },
                                    {
                                        id: i[o].id,
                                        label: i[o].label,
                                        type: s.typeStr2Type(i[o].typeStr),
                                        directions: i[o].directions
                                    }
                                ];
                                break;
                            case 24:
                                s.getLogger().debug("Rule: nodeStatement (abc88 node size) ", i[o - 1], i[o]), this.$ = {
                                    id: i[o - 1].id,
                                    label: i[o - 1].label,
                                    type: s.typeStr2Type(i[o - 1].typeStr),
                                    directions: i[o - 1].directions,
                                    widthInColumns: parseInt(i[o], 10)
                                };
                                break;
                            case 25:
                                s.getLogger().debug("Rule: nodeStatement (node) ", i[o]), this.$ = {
                                    id: i[o].id,
                                    label: i[o].label,
                                    type: s.typeStr2Type(i[o].typeStr),
                                    directions: i[o].directions,
                                    widthInColumns: 1
                                };
                                break;
                            case 26:
                                s.getLogger().debug("APA123", this ? this : "na"), s.getLogger().debug("COLUMNS: ", i[o]), this.$ = {
                                    type: "column-setting",
                                    columns: "auto" === i[o] ? -1 : parseInt(i[o])
                                };
                                break;
                            case 27:
                                s.getLogger().debug("Rule: id-block statement : ", i[o - 2], i[o - 1]);
                                s.generateId();
                                this.$ = {
                                    ...i[o - 2],
                                    type: "composite",
                                    children: i[o - 1]
                                };
                                break;
                            case 28:
                                s.getLogger().debug("Rule: blockStatement : ", i[o - 2], i[o - 1], i[o]);
                                const n1 = s.generateId();
                                this.$ = {
                                    id: n1,
                                    type: "composite",
                                    label: "",
                                    children: i[o - 1]
                                };
                                break;
                            case 29:
                                s.getLogger().debug("Rule: node (NODE_ID separator): ", i[o]), this.$ = {
                                    id: i[o]
                                };
                                break;
                            case 30:
                                s.getLogger().debug("Rule: node (NODE_ID nodeShapeNLabel separator): ", i[o - 1], i[o]), this.$ = {
                                    id: i[o - 1],
                                    label: i[o].label,
                                    typeStr: i[o].typeStr,
                                    directions: i[o].directions
                                };
                                break;
                            case 31:
                                s.getLogger().debug("Rule: dirList: ", i[o]), this.$ = [
                                    i[o]
                                ];
                                break;
                            case 32:
                                s.getLogger().debug("Rule: dirList: ", i[o - 1], i[o]), this.$ = [
                                    i[o - 1]
                                ].concat(i[o]);
                                break;
                            case 33:
                                s.getLogger().debug("Rule: nodeShapeNLabel: ", i[o - 2], i[o - 1], i[o]), this.$ = {
                                    typeStr: i[o - 2] + i[o],
                                    label: i[o - 1]
                                };
                                break;
                            case 34:
                                s.getLogger().debug("Rule: BLOCK_ARROW nodeShapeNLabel: ", i[o - 3], i[o - 2], " #3:", i[o - 1], i[o]), this.$ = {
                                    typeStr: i[o - 3] + i[o],
                                    label: i[o - 2],
                                    directions: i[o - 1]
                                };
                                break;
                            case 35:
                            case 36:
                                this.$ = {
                                    type: "classDef",
                                    id: i[o - 1].trim(),
                                    css: i[o].trim()
                                };
                                break;
                            case 37:
                                this.$ = {
                                    type: "applyClass",
                                    id: i[o - 1].trim(),
                                    styleClass: i[o].trim()
                                };
                                break;
                            case 38:
                                this.$ = {
                                    type: "applyStyles",
                                    id: i[o - 1].trim(),
                                    stylesStr: i[o].trim()
                                };
                        }
                    }, "anonymous"),
                    table: [
                        {
                            9: 1,
                            10: [
                                1,
                                2
                            ]
                        },
                        {
                            1: [
                                3
                            ]
                        },
                        {
                            10: e,
                            11: 3,
                            13: 4,
                            19: 5,
                            20: 6,
                            21: r,
                            22: 8,
                            23: 9,
                            24: 10,
                            25: 11,
                            26: 12,
                            28: s,
                            29: a,
                            31: i,
                            39: n,
                            43: o,
                            46: l
                        },
                        {
                            8: [
                                1,
                                20
                            ]
                        },
                        t(d, [
                            2,
                            12
                        ], {
                            13: 4,
                            19: 5,
                            20: 6,
                            22: 8,
                            23: 9,
                            24: 10,
                            25: 11,
                            26: 12,
                            11: 21,
                            10: e,
                            21: r,
                            28: s,
                            29: a,
                            31: i,
                            39: n,
                            43: o,
                            46: l
                        }),
                        t(h, [
                            2,
                            16
                        ], {
                            14: 22,
                            15: g,
                            16: u
                        }),
                        t(h, [
                            2,
                            17
                        ]),
                        t(h, [
                            2,
                            18
                        ]),
                        t(h, [
                            2,
                            19
                        ]),
                        t(h, [
                            2,
                            20
                        ]),
                        t(h, [
                            2,
                            21
                        ]),
                        t(h, [
                            2,
                            22
                        ]),
                        t(p, [
                            2,
                            25
                        ], {
                            27: [
                                1,
                                25
                            ]
                        }),
                        t(h, [
                            2,
                            26
                        ]),
                        {
                            19: 26,
                            26: 12,
                            31: i
                        },
                        {
                            10: e,
                            11: 27,
                            13: 4,
                            19: 5,
                            20: 6,
                            21: r,
                            22: 8,
                            23: 9,
                            24: 10,
                            25: 11,
                            26: 12,
                            28: s,
                            29: a,
                            31: i,
                            39: n,
                            43: o,
                            46: l
                        },
                        {
                            40: [
                                1,
                                28
                            ],
                            42: [
                                1,
                                29
                            ]
                        },
                        {
                            44: [
                                1,
                                30
                            ]
                        },
                        {
                            47: [
                                1,
                                31
                            ]
                        },
                        t(y, [
                            2,
                            29
                        ], {
                            32: 32,
                            35: [
                                1,
                                33
                            ],
                            37: [
                                1,
                                34
                            ]
                        }),
                        {
                            1: [
                                2,
                                7
                            ]
                        },
                        t(d, [
                            2,
                            13
                        ]),
                        {
                            26: 35,
                            31: i
                        },
                        {
                            31: [
                                2,
                                14
                            ]
                        },
                        {
                            17: [
                                1,
                                36
                            ]
                        },
                        t(p, [
                            2,
                            24
                        ]),
                        {
                            10: e,
                            11: 37,
                            13: 4,
                            14: 22,
                            15: g,
                            16: u,
                            19: 5,
                            20: 6,
                            21: r,
                            22: 8,
                            23: 9,
                            24: 10,
                            25: 11,
                            26: 12,
                            28: s,
                            29: a,
                            31: i,
                            39: n,
                            43: o,
                            46: l
                        },
                        {
                            30: [
                                1,
                                38
                            ]
                        },
                        {
                            41: [
                                1,
                                39
                            ]
                        },
                        {
                            41: [
                                1,
                                40
                            ]
                        },
                        {
                            45: [
                                1,
                                41
                            ]
                        },
                        {
                            48: [
                                1,
                                42
                            ]
                        },
                        t(y, [
                            2,
                            30
                        ]),
                        {
                            18: [
                                1,
                                43
                            ]
                        },
                        {
                            18: [
                                1,
                                44
                            ]
                        },
                        t(p, [
                            2,
                            23
                        ]),
                        {
                            18: [
                                1,
                                45
                            ]
                        },
                        {
                            30: [
                                1,
                                46
                            ]
                        },
                        t(h, [
                            2,
                            28
                        ]),
                        t(h, [
                            2,
                            35
                        ]),
                        t(h, [
                            2,
                            36
                        ]),
                        t(h, [
                            2,
                            37
                        ]),
                        t(h, [
                            2,
                            38
                        ]),
                        {
                            36: [
                                1,
                                47
                            ]
                        },
                        {
                            33: 48,
                            34: b
                        },
                        {
                            15: [
                                1,
                                50
                            ]
                        },
                        t(h, [
                            2,
                            27
                        ]),
                        t(y, [
                            2,
                            33
                        ]),
                        {
                            38: [
                                1,
                                51
                            ]
                        },
                        {
                            33: 52,
                            34: b,
                            38: [
                                2,
                                31
                            ]
                        },
                        {
                            31: [
                                2,
                                15
                            ]
                        },
                        t(y, [
                            2,
                            34
                        ]),
                        {
                            38: [
                                2,
                                32
                            ]
                        }
                    ],
                    defaultActions: {
                        20: [
                            2,
                            7
                        ],
                        23: [
                            2,
                            14
                        ],
                        50: [
                            2,
                            15
                        ],
                        52: [
                            2,
                            32
                        ]
                    },
                    parseError: (0, c.K2)(function parseError(t, e) {
                        if (!e.recoverable) {
                            var r = new Error(t);
                            throw r.hash = e, r;
                        }
                        this.trace(t);
                    }, "parseError"),
                    parse: (0, c.K2)(function parse(t) {
                        var e = this, r = [
                            0
                        ], s = [], a = [
                            null
                        ], i = [], n = this.table, o = "", l = 0, d = 0, h = 0, g = i.slice.call(arguments, 1), u = Object.create(this.lexer), p = {
                            yy: {}
                        };
                        for(var y in this.yy)Object.prototype.hasOwnProperty.call(this.yy, y) && (p.yy[y] = this.yy[y]);
                        u.setInput(t, p.yy), p.yy.lexer = u, p.yy.parser = this, void 0 === u.yylloc && (u.yylloc = {});
                        var b = u.yylloc;
                        i.push(b);
                        var x = u.options && u.options.ranges;
                        function lex() {
                            var t;
                            return "number" != typeof (t = s.pop() || u.lex() || 1) && (t instanceof Array && (t = (s = t).pop()), t = e.symbols_[t] || t), t;
                        }
                        "function" == typeof p.yy.parseError ? this.parseError = p.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError, (0, c.K2)(function popStack(t) {
                            r.length = r.length - 2 * t, a.length = a.length - t, i.length = i.length - t;
                        }, "popStack"), (0, c.K2)(lex, "lex");
                        for(var f, m, w, _, S, L, k, v, E, D = {};;){
                            if (w = r[r.length - 1], this.defaultActions[w] ? _ = this.defaultActions[w] : (null == f && (f = lex()), _ = n[w] && n[w][f]), void 0 === _ || !_.length || !_[0]) {
                                var T = "";
                                for(L in E = [], n[w])this.terminals_[L] && L > 2 && E.push("'" + this.terminals_[L] + "'");
                                T = u.showPosition ? "Parse error on line " + (l + 1) + ":\n" + u.showPosition() + "\nExpecting " + E.join(", ") + ", got '" + (this.terminals_[f] || f) + "'" : "Parse error on line " + (l + 1) + ": Unexpected " + (1 == f ? "end of input" : "'" + (this.terminals_[f] || f) + "'"), this.parseError(T, {
                                    text: u.match,
                                    token: this.terminals_[f] || f,
                                    line: u.yylineno,
                                    loc: b,
                                    expected: E
                                });
                            }
                            if (_[0] instanceof Array && _.length > 1) throw new Error("Parse Error: multiple actions possible at state: " + w + ", token: " + f);
                            switch(_[0]){
                                case 1:
                                    r.push(f), a.push(u.yytext), i.push(u.yylloc), r.push(_[1]), f = null, m ? (f = m, m = null) : (d = u.yyleng, o = u.yytext, l = u.yylineno, b = u.yylloc, h > 0 && h--);
                                    break;
                                case 2:
                                    if (k = this.productions_[_[1]][1], D.$ = a[a.length - k], D._$ = {
                                        first_line: i[i.length - (k || 1)].first_line,
                                        last_line: i[i.length - 1].last_line,
                                        first_column: i[i.length - (k || 1)].first_column,
                                        last_column: i[i.length - 1].last_column
                                    }, x && (D._$.range = [
                                        i[i.length - (k || 1)].range[0],
                                        i[i.length - 1].range[1]
                                    ]), void 0 !== (S = this.performAction.apply(D, [
                                        o,
                                        d,
                                        l,
                                        p.yy,
                                        _[1],
                                        a,
                                        i
                                    ].concat(g)))) return S;
                                    k && (r = r.slice(0, -1 * k * 2), a = a.slice(0, -1 * k), i = i.slice(0, -1 * k)), r.push(this.productions_[_[1]][0]), a.push(D.$), i.push(D._$), v = n[r[r.length - 2]][r[r.length - 1]], r.push(v);
                                    break;
                                case 3:
                                    return !0;
                            }
                        }
                        return !0;
                    }, "parse")
                }, f = function() {
                    return {
                        EOF: 1,
                        parseError: (0, c.K2)(function parseError(t, e) {
                            if (!this.yy.parser) throw new Error(t);
                            this.yy.parser.parseError(t, e);
                        }, "parseError"),
                        setInput: (0, c.K2)(function(t, e) {
                            return this.yy = e || this.yy || {}, this._input = t, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = [
                                "INITIAL"
                            ], this.yylloc = {
                                first_line: 1,
                                first_column: 0,
                                last_line: 1,
                                last_column: 0
                            }, this.options.ranges && (this.yylloc.range = [
                                0,
                                0
                            ]), this.offset = 0, this;
                        }, "setInput"),
                        input: (0, c.K2)(function() {
                            var t = this._input[0];
                            return this.yytext += t, this.yyleng++, this.offset++, this.match += t, this.matched += t, t.match(/(?:\r\n?|\n).*/g) ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), t;
                        }, "input"),
                        unput: (0, c.K2)(function(t) {
                            var e = t.length, r = t.split(/(?:\r\n?|\n)/g);
                            this._input = t + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - e), this.offset -= e;
                            var s = this.match.split(/(?:\r\n?|\n)/g);
                            this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), r.length - 1 && (this.yylineno -= r.length - 1);
                            var a = this.yylloc.range;
                            return this.yylloc = {
                                first_line: this.yylloc.first_line,
                                last_line: this.yylineno + 1,
                                first_column: this.yylloc.first_column,
                                last_column: r ? (r.length === s.length ? this.yylloc.first_column : 0) + s[s.length - r.length].length - r[0].length : this.yylloc.first_column - e
                            }, this.options.ranges && (this.yylloc.range = [
                                a[0],
                                a[0] + this.yyleng - e
                            ]), this.yyleng = this.yytext.length, this;
                        }, "unput"),
                        more: (0, c.K2)(function() {
                            return this._more = !0, this;
                        }, "more"),
                        reject: (0, c.K2)(function() {
                            return this.options.backtrack_lexer ? (this._backtrack = !0, this) : this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
                                text: "",
                                token: null,
                                line: this.yylineno
                            });
                        }, "reject"),
                        less: (0, c.K2)(function(t) {
                            this.unput(this.match.slice(t));
                        }, "less"),
                        pastInput: (0, c.K2)(function() {
                            var t = this.matched.substr(0, this.matched.length - this.match.length);
                            return (t.length > 20 ? "..." : "") + t.substr(-20).replace(/\n/g, "");
                        }, "pastInput"),
                        upcomingInput: (0, c.K2)(function() {
                            var t = this.match;
                            return t.length < 20 && (t += this._input.substr(0, 20 - t.length)), (t.substr(0, 20) + (t.length > 20 ? "..." : "")).replace(/\n/g, "");
                        }, "upcomingInput"),
                        showPosition: (0, c.K2)(function() {
                            var t = this.pastInput(), e = new Array(t.length + 1).join("-");
                            return t + this.upcomingInput() + "\n" + e + "^";
                        }, "showPosition"),
                        test_match: (0, c.K2)(function(t, e) {
                            var r, s, a;
                            if (this.options.backtrack_lexer && (a = {
                                yylineno: this.yylineno,
                                yylloc: {
                                    first_line: this.yylloc.first_line,
                                    last_line: this.last_line,
                                    first_column: this.yylloc.first_column,
                                    last_column: this.yylloc.last_column
                                },
                                yytext: this.yytext,
                                match: this.match,
                                matches: this.matches,
                                matched: this.matched,
                                yyleng: this.yyleng,
                                offset: this.offset,
                                _more: this._more,
                                _input: this._input,
                                yy: this.yy,
                                conditionStack: this.conditionStack.slice(0),
                                done: this.done
                            }, this.options.ranges && (a.yylloc.range = this.yylloc.range.slice(0))), (s = t[0].match(/(?:\r\n?|\n).*/g)) && (this.yylineno += s.length), this.yylloc = {
                                first_line: this.yylloc.last_line,
                                last_line: this.yylineno + 1,
                                first_column: this.yylloc.last_column,
                                last_column: s ? s[s.length - 1].length - s[s.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + t[0].length
                            }, this.yytext += t[0], this.match += t[0], this.matches = t, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [
                                this.offset,
                                this.offset += this.yyleng
                            ]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(t[0].length), this.matched += t[0], r = this.performAction.call(this, this.yy, this, e, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), r) return r;
                            if (this._backtrack) {
                                for(var i in a)this[i] = a[i];
                                return !1;
                            }
                            return !1;
                        }, "test_match"),
                        next: (0, c.K2)(function() {
                            if (this.done) return this.EOF;
                            var t, e, r, s;
                            this._input || (this.done = !0), this._more || (this.yytext = "", this.match = "");
                            for(var a = this._currentRules(), i = 0; i < a.length; i++)if ((r = this._input.match(this.rules[a[i]])) && (!e || r[0].length > e[0].length)) {
                                if (e = r, s = i, this.options.backtrack_lexer) {
                                    if (!1 !== (t = this.test_match(r, a[i]))) return t;
                                    if (this._backtrack) {
                                        e = !1;
                                        continue;
                                    }
                                    return !1;
                                }
                                if (!this.options.flex) break;
                            }
                            return e ? !1 !== (t = this.test_match(e, a[s])) && t : "" === this._input ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
                                text: "",
                                token: null,
                                line: this.yylineno
                            });
                        }, "next"),
                        lex: (0, c.K2)(function lex() {
                            var t = this.next();
                            return t || this.lex();
                        }, "lex"),
                        begin: (0, c.K2)(function begin(t) {
                            this.conditionStack.push(t);
                        }, "begin"),
                        popState: (0, c.K2)(function popState() {
                            return this.conditionStack.length - 1 > 0 ? this.conditionStack.pop() : this.conditionStack[0];
                        }, "popState"),
                        _currentRules: (0, c.K2)(function _currentRules() {
                            return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
                        }, "_currentRules"),
                        topState: (0, c.K2)(function topState(t) {
                            return (t = this.conditionStack.length - 1 - Math.abs(t || 0)) >= 0 ? this.conditionStack[t] : "INITIAL";
                        }, "topState"),
                        pushState: (0, c.K2)(function pushState(t) {
                            this.begin(t);
                        }, "pushState"),
                        stateStackSize: (0, c.K2)(function stateStackSize() {
                            return this.conditionStack.length;
                        }, "stateStackSize"),
                        options: {},
                        performAction: (0, c.K2)(function anonymous(t, e, r, s) {
                            switch(r){
                                case 0:
                                    return t.getLogger().debug("Found block-beta"), 10;
                                case 1:
                                    return t.getLogger().debug("Found id-block"), 29;
                                case 2:
                                    return t.getLogger().debug("Found block"), 10;
                                case 3:
                                    t.getLogger().debug(".", e.yytext);
                                    break;
                                case 4:
                                    t.getLogger().debug("_", e.yytext);
                                    break;
                                case 5:
                                    return 5;
                                case 6:
                                    return e.yytext = -1, 28;
                                case 7:
                                    return e.yytext = e.yytext.replace(/columns\s+/, ""), t.getLogger().debug("COLUMNS (LEX)", e.yytext), 28;
                                case 8:
                                case 76:
                                case 77:
                                case 99:
                                    this.pushState("md_string");
                                    break;
                                case 9:
                                    return "MD_STR";
                                case 10:
                                case 34:
                                case 79:
                                    this.popState();
                                    break;
                                case 11:
                                    this.pushState("string");
                                    break;
                                case 12:
                                    t.getLogger().debug("LEX: POPPING STR:", e.yytext), this.popState();
                                    break;
                                case 13:
                                    return t.getLogger().debug("LEX: STR end:", e.yytext), "STR";
                                case 14:
                                    return e.yytext = e.yytext.replace(/space\:/, ""), t.getLogger().debug("SPACE NUM (LEX)", e.yytext), 21;
                                case 15:
                                    return e.yytext = "1", t.getLogger().debug("COLUMNS (LEX)", e.yytext), 21;
                                case 16:
                                    return 42;
                                case 17:
                                    return "LINKSTYLE";
                                case 18:
                                    return "INTERPOLATE";
                                case 19:
                                    return this.pushState("CLASSDEF"), 39;
                                case 20:
                                    return this.popState(), this.pushState("CLASSDEFID"), "DEFAULT_CLASSDEF_ID";
                                case 21:
                                    return this.popState(), this.pushState("CLASSDEFID"), 40;
                                case 22:
                                    return this.popState(), 41;
                                case 23:
                                    return this.pushState("CLASS"), 43;
                                case 24:
                                    return this.popState(), this.pushState("CLASS_STYLE"), 44;
                                case 25:
                                    return this.popState(), 45;
                                case 26:
                                    return this.pushState("STYLE_STMNT"), 46;
                                case 27:
                                    return this.popState(), this.pushState("STYLE_DEFINITION"), 47;
                                case 28:
                                    return this.popState(), 48;
                                case 29:
                                    return this.pushState("acc_title"), "acc_title";
                                case 30:
                                    return this.popState(), "acc_title_value";
                                case 31:
                                    return this.pushState("acc_descr"), "acc_descr";
                                case 32:
                                    return this.popState(), "acc_descr_value";
                                case 33:
                                    this.pushState("acc_descr_multiline");
                                    break;
                                case 35:
                                    return "acc_descr_multiline_value";
                                case 36:
                                    return 30;
                                case 37:
                                case 38:
                                case 40:
                                case 41:
                                case 44:
                                    return this.popState(), t.getLogger().debug("Lex: (("), "NODE_DEND";
                                case 39:
                                    return this.popState(), t.getLogger().debug("Lex: ))"), "NODE_DEND";
                                case 42:
                                    return this.popState(), t.getLogger().debug("Lex: (-"), "NODE_DEND";
                                case 43:
                                    return this.popState(), t.getLogger().debug("Lex: -)"), "NODE_DEND";
                                case 45:
                                    return this.popState(), t.getLogger().debug("Lex: ]]"), "NODE_DEND";
                                case 46:
                                    return this.popState(), t.getLogger().debug("Lex: ("), "NODE_DEND";
                                case 47:
                                    return this.popState(), t.getLogger().debug("Lex: ])"), "NODE_DEND";
                                case 48:
                                case 49:
                                    return this.popState(), t.getLogger().debug("Lex: /]"), "NODE_DEND";
                                case 50:
                                    return this.popState(), t.getLogger().debug("Lex: )]"), "NODE_DEND";
                                case 51:
                                    return this.popState(), t.getLogger().debug("Lex: )"), "NODE_DEND";
                                case 52:
                                    return this.popState(), t.getLogger().debug("Lex: ]>"), "NODE_DEND";
                                case 53:
                                    return this.popState(), t.getLogger().debug("Lex: ]"), "NODE_DEND";
                                case 54:
                                    return t.getLogger().debug("Lexa: -)"), this.pushState("NODE"), 35;
                                case 55:
                                    return t.getLogger().debug("Lexa: (-"), this.pushState("NODE"), 35;
                                case 56:
                                    return t.getLogger().debug("Lexa: ))"), this.pushState("NODE"), 35;
                                case 57:
                                case 59:
                                case 60:
                                case 61:
                                case 64:
                                    return t.getLogger().debug("Lexa: )"), this.pushState("NODE"), 35;
                                case 58:
                                    return t.getLogger().debug("Lex: ((("), this.pushState("NODE"), 35;
                                case 62:
                                    return t.getLogger().debug("Lexc: >"), this.pushState("NODE"), 35;
                                case 63:
                                    return t.getLogger().debug("Lexa: (["), this.pushState("NODE"), 35;
                                case 65:
                                case 66:
                                case 67:
                                case 68:
                                case 69:
                                case 70:
                                case 71:
                                    return this.pushState("NODE"), 35;
                                case 72:
                                    return t.getLogger().debug("Lexa: ["), this.pushState("NODE"), 35;
                                case 73:
                                    return this.pushState("BLOCK_ARROW"), t.getLogger().debug("LEX ARR START"), 37;
                                case 74:
                                    return t.getLogger().debug("Lex: NODE_ID", e.yytext), 31;
                                case 75:
                                    return t.getLogger().debug("Lex: EOF", e.yytext), 8;
                                case 78:
                                    return "NODE_DESCR";
                                case 80:
                                    t.getLogger().debug("Lex: Starting string"), this.pushState("string");
                                    break;
                                case 81:
                                    t.getLogger().debug("LEX ARR: Starting string"), this.pushState("string");
                                    break;
                                case 82:
                                    return t.getLogger().debug("LEX: NODE_DESCR:", e.yytext), "NODE_DESCR";
                                case 83:
                                    t.getLogger().debug("LEX POPPING"), this.popState();
                                    break;
                                case 84:
                                    t.getLogger().debug("Lex: =>BAE"), this.pushState("ARROW_DIR");
                                    break;
                                case 85:
                                    return e.yytext = e.yytext.replace(/^,\s*/, ""), t.getLogger().debug("Lex (right): dir:", e.yytext), "DIR";
                                case 86:
                                    return e.yytext = e.yytext.replace(/^,\s*/, ""), t.getLogger().debug("Lex (left):", e.yytext), "DIR";
                                case 87:
                                    return e.yytext = e.yytext.replace(/^,\s*/, ""), t.getLogger().debug("Lex (x):", e.yytext), "DIR";
                                case 88:
                                    return e.yytext = e.yytext.replace(/^,\s*/, ""), t.getLogger().debug("Lex (y):", e.yytext), "DIR";
                                case 89:
                                    return e.yytext = e.yytext.replace(/^,\s*/, ""), t.getLogger().debug("Lex (up):", e.yytext), "DIR";
                                case 90:
                                    return e.yytext = e.yytext.replace(/^,\s*/, ""), t.getLogger().debug("Lex (down):", e.yytext), "DIR";
                                case 91:
                                    return e.yytext = "]>", t.getLogger().debug("Lex (ARROW_DIR end):", e.yytext), this.popState(), this.popState(), "BLOCK_ARROW_END";
                                case 92:
                                    return t.getLogger().debug("Lex: LINK", "#" + e.yytext + "#"), 15;
                                case 93:
                                case 94:
                                case 95:
                                    return t.getLogger().debug("Lex: LINK", e.yytext), 15;
                                case 96:
                                case 97:
                                case 98:
                                    return t.getLogger().debug("Lex: START_LINK", e.yytext), this.pushState("LLABEL"), 16;
                                case 100:
                                    return t.getLogger().debug("Lex: Starting string"), this.pushState("string"), "LINK_LABEL";
                                case 101:
                                    return this.popState(), t.getLogger().debug("Lex: LINK", "#" + e.yytext + "#"), 15;
                                case 102:
                                case 103:
                                    return this.popState(), t.getLogger().debug("Lex: LINK", e.yytext), 15;
                                case 104:
                                    return t.getLogger().debug("Lex: COLON", e.yytext), e.yytext = e.yytext.slice(1), 27;
                            }
                        }, "anonymous"),
                        rules: [
                            /^(?:block-beta\b)/,
                            /^(?:block:)/,
                            /^(?:block\b)/,
                            /^(?:[\s]+)/,
                            /^(?:[\n]+)/,
                            /^(?:((\u000D\u000A)|(\u000A)))/,
                            /^(?:columns\s+auto\b)/,
                            /^(?:columns\s+[\d]+)/,
                            /^(?:["][`])/,
                            /^(?:[^`"]+)/,
                            /^(?:[`]["])/,
                            /^(?:["])/,
                            /^(?:["])/,
                            /^(?:[^"]*)/,
                            /^(?:space[:]\d+)/,
                            /^(?:space\b)/,
                            /^(?:default\b)/,
                            /^(?:linkStyle\b)/,
                            /^(?:interpolate\b)/,
                            /^(?:classDef\s+)/,
                            /^(?:DEFAULT\s+)/,
                            /^(?:\w+\s+)/,
                            /^(?:[^\n]*)/,
                            /^(?:class\s+)/,
                            /^(?:(\w+)+((,\s*\w+)*))/,
                            /^(?:[^\n]*)/,
                            /^(?:style\s+)/,
                            /^(?:(\w+)+((,\s*\w+)*))/,
                            /^(?:[^\n]*)/,
                            /^(?:accTitle\s*:\s*)/,
                            /^(?:(?!\n||)*[^\n]*)/,
                            /^(?:accDescr\s*:\s*)/,
                            /^(?:(?!\n||)*[^\n]*)/,
                            /^(?:accDescr\s*\{\s*)/,
                            /^(?:[\}])/,
                            /^(?:[^\}]*)/,
                            /^(?:end\b\s*)/,
                            /^(?:\(\(\()/,
                            /^(?:\)\)\))/,
                            /^(?:[\)]\))/,
                            /^(?:\}\})/,
                            /^(?:\})/,
                            /^(?:\(-)/,
                            /^(?:-\))/,
                            /^(?:\(\()/,
                            /^(?:\]\])/,
                            /^(?:\()/,
                            /^(?:\]\))/,
                            /^(?:\\\])/,
                            /^(?:\/\])/,
                            /^(?:\)\])/,
                            /^(?:[\)])/,
                            /^(?:\]>)/,
                            /^(?:[\]])/,
                            /^(?:-\))/,
                            /^(?:\(-)/,
                            /^(?:\)\))/,
                            /^(?:\))/,
                            /^(?:\(\(\()/,
                            /^(?:\(\()/,
                            /^(?:\{\{)/,
                            /^(?:\{)/,
                            /^(?:>)/,
                            /^(?:\(\[)/,
                            /^(?:\()/,
                            /^(?:\[\[)/,
                            /^(?:\[\|)/,
                            /^(?:\[\()/,
                            /^(?:\)\)\))/,
                            /^(?:\[\\)/,
                            /^(?:\[\/)/,
                            /^(?:\[\\)/,
                            /^(?:\[)/,
                            /^(?:<\[)/,
                            /^(?:[^\(\[\n\-\)\{\}\s\<\>:]+)/,
                            /^(?:$)/,
                            /^(?:["][`])/,
                            /^(?:["][`])/,
                            /^(?:[^`"]+)/,
                            /^(?:[`]["])/,
                            /^(?:["])/,
                            /^(?:["])/,
                            /^(?:[^"]+)/,
                            /^(?:["])/,
                            /^(?:\]>\s*\()/,
                            /^(?:,?\s*right\s*)/,
                            /^(?:,?\s*left\s*)/,
                            /^(?:,?\s*x\s*)/,
                            /^(?:,?\s*y\s*)/,
                            /^(?:,?\s*up\s*)/,
                            /^(?:,?\s*down\s*)/,
                            /^(?:\)\s*)/,
                            /^(?:\s*[xo<]?--+[-xo>]\s*)/,
                            /^(?:\s*[xo<]?==+[=xo>]\s*)/,
                            /^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/,
                            /^(?:\s*~~[\~]+\s*)/,
                            /^(?:\s*[xo<]?--\s*)/,
                            /^(?:\s*[xo<]?==\s*)/,
                            /^(?:\s*[xo<]?-\.\s*)/,
                            /^(?:["][`])/,
                            /^(?:["])/,
                            /^(?:\s*[xo<]?--+[-xo>]\s*)/,
                            /^(?:\s*[xo<]?==+[=xo>]\s*)/,
                            /^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/,
                            /^(?::\d+)/
                        ],
                        conditions: {
                            STYLE_DEFINITION: {
                                rules: [
                                    28
                                ],
                                inclusive: !1
                            },
                            STYLE_STMNT: {
                                rules: [
                                    27
                                ],
                                inclusive: !1
                            },
                            CLASSDEFID: {
                                rules: [
                                    22
                                ],
                                inclusive: !1
                            },
                            CLASSDEF: {
                                rules: [
                                    20,
                                    21
                                ],
                                inclusive: !1
                            },
                            CLASS_STYLE: {
                                rules: [
                                    25
                                ],
                                inclusive: !1
                            },
                            CLASS: {
                                rules: [
                                    24
                                ],
                                inclusive: !1
                            },
                            LLABEL: {
                                rules: [
                                    99,
                                    100,
                                    101,
                                    102,
                                    103
                                ],
                                inclusive: !1
                            },
                            ARROW_DIR: {
                                rules: [
                                    85,
                                    86,
                                    87,
                                    88,
                                    89,
                                    90,
                                    91
                                ],
                                inclusive: !1
                            },
                            BLOCK_ARROW: {
                                rules: [
                                    76,
                                    81,
                                    84
                                ],
                                inclusive: !1
                            },
                            NODE: {
                                rules: [
                                    37,
                                    38,
                                    39,
                                    40,
                                    41,
                                    42,
                                    43,
                                    44,
                                    45,
                                    46,
                                    47,
                                    48,
                                    49,
                                    50,
                                    51,
                                    52,
                                    53,
                                    77,
                                    80
                                ],
                                inclusive: !1
                            },
                            md_string: {
                                rules: [
                                    9,
                                    10,
                                    78,
                                    79
                                ],
                                inclusive: !1
                            },
                            space: {
                                rules: [],
                                inclusive: !1
                            },
                            string: {
                                rules: [
                                    12,
                                    13,
                                    82,
                                    83
                                ],
                                inclusive: !1
                            },
                            acc_descr_multiline: {
                                rules: [
                                    34,
                                    35
                                ],
                                inclusive: !1
                            },
                            acc_descr: {
                                rules: [
                                    32
                                ],
                                inclusive: !1
                            },
                            acc_title: {
                                rules: [
                                    30
                                ],
                                inclusive: !1
                            },
                            INITIAL: {
                                rules: [
                                    0,
                                    1,
                                    2,
                                    3,
                                    4,
                                    5,
                                    6,
                                    7,
                                    8,
                                    11,
                                    14,
                                    15,
                                    16,
                                    17,
                                    18,
                                    19,
                                    23,
                                    26,
                                    29,
                                    31,
                                    33,
                                    36,
                                    54,
                                    55,
                                    56,
                                    57,
                                    58,
                                    59,
                                    60,
                                    61,
                                    62,
                                    63,
                                    64,
                                    65,
                                    66,
                                    67,
                                    68,
                                    69,
                                    70,
                                    71,
                                    72,
                                    73,
                                    74,
                                    75,
                                    92,
                                    93,
                                    94,
                                    95,
                                    96,
                                    97,
                                    98,
                                    104
                                ],
                                inclusive: !0
                            }
                        }
                    };
                }();
                function Parser() {
                    this.yy = {};
                }
                return x.lexer = f, (0, c.K2)(Parser, "Parser"), Parser.prototype = x, x.Parser = Parser, new Parser;
            }();
            y.parser = y;
            var b = y, x = new Map, f = [], m = new Map, w = "color", _ = "fill", S = (0, l.D7)(), L = new Map, k = (0, c.K2)((t)=>l.Y2.sanitizeText(t, S), "sanitizeText"), v = (0, c.K2)(function(t, e = "") {
                let r = L.get(t);
                r || (r = {
                    id: t,
                    styles: [],
                    textStyles: []
                }, L.set(t, r)), null != e && e.split(",").forEach((t)=>{
                    const e = t.replace(/([^;]*);/, "$1").trim();
                    if (RegExp(w).exec(t)) {
                        const t = e.replace(_, "bgFill").replace(w, _);
                        r.textStyles.push(t);
                    }
                    r.styles.push(e);
                });
            }, "addStyleClass"), E = (0, c.K2)(function(t, e = "") {
                const r = x.get(t);
                null != e && (r.styles = e.split(","));
            }, "addStyle2Node"), D = (0, c.K2)(function(t, e) {
                t.split(",").forEach(function(t) {
                    let r = x.get(t);
                    if (void 0 === r) {
                        const e = t.trim();
                        r = {
                            id: e,
                            type: "na",
                            children: []
                        }, x.set(e, r);
                    }
                    r.classes || (r.classes = []), r.classes.push(e);
                });
            }, "setCssClass"), T = (0, c.K2)((t, e)=>{
                const r = t.flat(), s = [], a = r.find((t)=>"column-setting" === t?.type), i = a?.columns ?? -1;
                for (const t of r)if ("number" == typeof i && i > 0 && "column-setting" !== t.type && "number" == typeof t.widthInColumns && t.widthInColumns > i && c.Rm.warn(`Block ${t.id} width ${t.widthInColumns} exceeds configured column width ${i}`), t.label && (t.label = k(t.label)), "classDef" !== t.type) if ("applyClass" !== t.type) if ("applyStyles" !== t.type) if ("column-setting" === t.type) e.columns = t.columns ?? -1;
                else if ("edge" === t.type) {
                    const e = (m.get(t.id) ?? 0) + 1;
                    m.set(t.id, e), t.id = e + "-" + t.id, f.push(t);
                } else {
                    t.label || ("composite" === t.type ? t.label = "" : t.label = t.id);
                    const e = x.get(t.id);
                    if (void 0 === e ? x.set(t.id, t) : ("na" !== t.type && (e.type = t.type), t.label !== t.id && (e.label = t.label)), t.children && T(t.children, t), "space" === t.type) {
                        const e = t.width ?? 1;
                        for(let r = 0; r < e; r++){
                            const e = (0, d.A)(t);
                            e.id = e.id + "-" + r, x.set(e.id, e), s.push(e);
                        }
                    } else void 0 === e && s.push(t);
                }
                else t?.stylesStr && E(t.id, t?.stylesStr);
                else D(t.id, t?.styleClass ?? "");
                else v(t.id, t.css);
                e.children = s;
            }, "populateBlockDatabase"), C = [], R = {
                id: "root",
                type: "composite",
                children: [],
                columns: -1
            }, N = (0, c.K2)(()=>{
                c.Rm.debug("Clear called"), (0, l.IU)(), R = {
                    id: "root",
                    type: "composite",
                    children: [],
                    columns: -1
                }, x = new Map([
                    [
                        "root",
                        R
                    ]
                ]), C = [], L = new Map, f = [], m = new Map;
            }, "clear");
            function typeStr2Type(t) {
                switch(c.Rm.debug("typeStr2Type", t), t){
                    case "[]":
                        return "square";
                    case "()":
                        return c.Rm.debug("we have a round"), "round";
                    case "(())":
                        return "circle";
                    case ">]":
                        return "rect_left_inv_arrow";
                    case "{}":
                        return "diamond";
                    case "{{}}":
                        return "hexagon";
                    case "([])":
                        return "stadium";
                    case "[[]]":
                        return "subroutine";
                    case "[()]":
                        return "cylinder";
                    case "((()))":
                        return "doublecircle";
                    case "[//]":
                        return "lean_right";
                    case "[\\\\]":
                        return "lean_left";
                    case "[/\\]":
                        return "trapezoid";
                    case "[\\/]":
                        return "inv_trapezoid";
                    case "<[]>":
                        return "block_arrow";
                    default:
                        return "na";
                }
            }
            function edgeTypeStr2Type(t) {
                return c.Rm.debug("typeStr2Type", t), "==" === t ? "thick" : "normal";
            }
            function edgeStrToEdgeData(t) {
                switch(t.replace(/^[\s-]+|[\s-]+$/g, "")){
                    case "x":
                        return "arrow_cross";
                    case "o":
                        return "arrow_circle";
                    case ">":
                        return "arrow_point";
                    default:
                        return "";
                }
            }
            (0, c.K2)(typeStr2Type, "typeStr2Type"), (0, c.K2)(edgeTypeStr2Type, "edgeTypeStr2Type"), (0, c.K2)(edgeStrToEdgeData, "edgeStrToEdgeData");
            var K = 0, $ = (0, c.K2)(()=>(K++, "id-" + Math.random().toString(36).substr(2, 12) + "-" + K), "generateId"), B = (0, c.K2)((t)=>{
                R.children = t, T(t, R), C = R.children;
            }, "setHierarchy"), I = (0, c.K2)((t)=>{
                const e = x.get(t);
                return e ? e.columns ? e.columns : e.children ? e.children.length : -1 : -1;
            }, "getColumns"), A = (0, c.K2)(()=>[
                    ...x.values()
                ], "getBlocksFlat"), O = (0, c.K2)(()=>C || [], "getBlocks"), z = (0, c.K2)(()=>f, "getEdges"), P = (0, c.K2)((t)=>x.get(t), "getBlock"), M = (0, c.K2)((t)=>{
                x.set(t.id, t);
            }, "setBlock"), F = (0, c.K2)(()=>c.Rm, "getLogger"), j = (0, c.K2)(function() {
                return L;
            }, "getClasses"), Y = {
                getConfig: (0, c.K2)(()=>(0, l.zj)().block, "getConfig"),
                typeStr2Type,
                edgeTypeStr2Type,
                edgeStrToEdgeData,
                getLogger: F,
                getBlocksFlat: A,
                getBlocks: O,
                getEdges: z,
                setHierarchy: B,
                getBlock: P,
                setBlock: M,
                getColumns: I,
                getClasses: j,
                clear: N,
                generateId: $
            }, W = (0, c.K2)((t, e)=>{
                const r = h.A, s = r(t, "r"), a = r(t, "g"), i = r(t, "b");
                return g.A(s, a, i, e);
            }, "fade"), X = (0, c.K2)((t)=>`.label {\n    font-family: ${t.fontFamily};\n    color: ${t.nodeTextColor || t.textColor};\n  }\n  .cluster-label text {\n    fill: ${t.titleColor};\n  }\n  .cluster-label span,p {\n    color: ${t.titleColor};\n  }\n\n\n\n  .label text,span,p {\n    fill: ${t.nodeTextColor || t.textColor};\n    color: ${t.nodeTextColor || t.textColor};\n  }\n\n  .node rect,\n  .node circle,\n  .node ellipse,\n  .node polygon,\n  .node path {\n    fill: ${t.mainBkg};\n    stroke: ${t.nodeBorder};\n    stroke-width: 1px;\n  }\n  .flowchart-label text {\n    text-anchor: middle;\n  }\n  // .flowchart-label .text-outer-tspan {\n  //   text-anchor: middle;\n  // }\n  // .flowchart-label .text-inner-tspan {\n  //   text-anchor: start;\n  // }\n\n  .node .label {\n    text-align: center;\n  }\n  .node.clickable {\n    cursor: pointer;\n  }\n\n  .arrowheadPath {\n    fill: ${t.arrowheadColor};\n  }\n\n  .edgePath .path {\n    stroke: ${t.lineColor};\n    stroke-width: 2.0px;\n  }\n\n  .flowchart-link {\n    stroke: ${t.lineColor};\n    fill: none;\n  }\n\n  .edgeLabel {\n    background-color: ${t.edgeLabelBackground};\n    rect {\n      opacity: 0.5;\n      background-color: ${t.edgeLabelBackground};\n      fill: ${t.edgeLabelBackground};\n    }\n    text-align: center;\n  }\n\n  /* For html labels only */\n  .labelBkg {\n    background-color: ${W(t.edgeLabelBackground, .5)};\n    // background-color:\n  }\n\n  .node .cluster {\n    // fill: ${W(t.mainBkg, .5)};\n    fill: ${W(t.clusterBkg, .5)};\n    stroke: ${W(t.clusterBorder, .2)};\n    box-shadow: rgba(50, 50, 93, 0.25) 0px 13px 27px -5px, rgba(0, 0, 0, 0.3) 0px 8px 16px -8px;\n    stroke-width: 1px;\n  }\n\n  .cluster text {\n    fill: ${t.titleColor};\n  }\n\n  .cluster span,p {\n    color: ${t.titleColor};\n  }\n  /* .cluster div {\n    color: ${t.titleColor};\n  } */\n\n  div.mermaidTooltip {\n    position: absolute;\n    text-align: center;\n    max-width: 200px;\n    padding: 2px;\n    font-family: ${t.fontFamily};\n    font-size: 12px;\n    background: ${t.tertiaryColor};\n    border: 1px solid ${t.border2};\n    border-radius: 2px;\n    pointer-events: none;\n    z-index: 100;\n  }\n\n  .flowchartTitleText {\n    text-anchor: middle;\n    font-size: 18px;\n    fill: ${t.textColor};\n  }\n  ${(0, s.o)()}\n`, "getStyles"), H = (0, c.K2)((t, e, r, s)=>{
                e.forEach((e)=>{
                    U[e](t, r, s);
                });
            }, "insertMarkers"), U = {
                extension: (0, c.K2)((t, e, r)=>{
                    c.Rm.trace("Making markers for ", r), t.append("defs").append("marker").attr("id", r + "_" + e + "-extensionStart").attr("class", "marker extension " + e).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z"), t.append("defs").append("marker").attr("id", r + "_" + e + "-extensionEnd").attr("class", "marker extension " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z");
                }, "extension"),
                composition: (0, c.K2)((t, e, r)=>{
                    t.append("defs").append("marker").attr("id", r + "_" + e + "-compositionStart").attr("class", "marker composition " + e).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), t.append("defs").append("marker").attr("id", r + "_" + e + "-compositionEnd").attr("class", "marker composition " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
                }, "composition"),
                aggregation: (0, c.K2)((t, e, r)=>{
                    t.append("defs").append("marker").attr("id", r + "_" + e + "-aggregationStart").attr("class", "marker aggregation " + e).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), t.append("defs").append("marker").attr("id", r + "_" + e + "-aggregationEnd").attr("class", "marker aggregation " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
                }, "aggregation"),
                dependency: (0, c.K2)((t, e, r)=>{
                    t.append("defs").append("marker").attr("id", r + "_" + e + "-dependencyStart").attr("class", "marker dependency " + e).attr("refX", 6).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z"), t.append("defs").append("marker").attr("id", r + "_" + e + "-dependencyEnd").attr("class", "marker dependency " + e).attr("refX", 13).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
                }, "dependency"),
                lollipop: (0, c.K2)((t, e, r)=>{
                    t.append("defs").append("marker").attr("id", r + "_" + e + "-lollipopStart").attr("class", "marker lollipop " + e).attr("refX", 13).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6), t.append("defs").append("marker").attr("id", r + "_" + e + "-lollipopEnd").attr("class", "marker lollipop " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6);
                }, "lollipop"),
                point: (0, c.K2)((t, e, r)=>{
                    t.append("marker").attr("id", r + "_" + e + "-pointEnd").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", 6).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), t.append("marker").attr("id", r + "_" + e + "-pointStart").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", 4.5).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 5 L 10 10 L 10 0 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
                }, "point"),
                circle: (0, c.K2)((t, e, r)=>{
                    t.append("marker").attr("id", r + "_" + e + "-circleEnd").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", 11).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), t.append("marker").attr("id", r + "_" + e + "-circleStart").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", -1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
                }, "circle"),
                cross: (0, c.K2)((t, e, r)=>{
                    t.append("marker").attr("id", r + "_" + e + "-crossEnd").attr("class", "marker cross " + e).attr("viewBox", "0 0 11 11").attr("refX", 12).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0"), t.append("marker").attr("id", r + "_" + e + "-crossStart").attr("class", "marker cross " + e).attr("viewBox", "0 0 11 11").attr("refX", -1).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");
                }, "cross"),
                barb: (0, c.K2)((t, e, r)=>{
                    t.append("defs").append("marker").attr("id", r + "_" + e + "-barbEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 14).attr("markerUnits", "strokeWidth").attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
                }, "barb")
            }, Z = H, G = (0, l.D7)()?.block?.padding ?? 8;
            function calculateBlockPosition(t, e) {
                if (0 === t || !Number.isInteger(t)) throw new Error("Columns must be an integer !== 0.");
                if (e < 0 || !Number.isInteger(e)) throw new Error("Position must be a non-negative integer." + e);
                if (t < 0) return {
                    px: e,
                    py: 0
                };
                if (1 === t) return {
                    px: 0,
                    py: e
                };
                return {
                    px: e % t,
                    py: Math.floor(e / t)
                };
            }
            (0, c.K2)(calculateBlockPosition, "calculateBlockPosition");
            var q = (0, c.K2)((t)=>{
                let e = 0, r = 0;
                for (const s of t.children){
                    const { width: a, height: i, x: n, y: o } = s.size ?? {
                        width: 0,
                        height: 0,
                        x: 0,
                        y: 0
                    };
                    c.Rm.debug("getMaxChildSize abc95 child:", s.id, "width:", a, "height:", i, "x:", n, "y:", o, s.type), "space" !== s.type && (a > e && (e = a / (t.widthInColumns ?? 1)), i > r && (r = i));
                }
                return {
                    width: e,
                    height: r
                };
            }, "getMaxChildSize");
            function setBlockSizes(t, e, r = 0, s = 0) {
                c.Rm.debug("setBlockSizes abc95 (start)", t.id, t?.size?.x, "block width =", t?.size, "siblingWidth", r), t?.size?.width || (t.size = {
                    width: r,
                    height: s,
                    x: 0,
                    y: 0
                });
                let a = 0, i = 0;
                if (t.children?.length > 0) {
                    for (const r of t.children)setBlockSizes(r, e);
                    const n = q(t);
                    a = n.width, i = n.height, c.Rm.debug("setBlockSizes abc95 maxWidth of", t.id, ":s children is ", a, i);
                    for (const e of t.children)e.size && (c.Rm.debug(`abc95 Setting size of children of ${t.id} id=${e.id} ${a} ${i} ${JSON.stringify(e.size)}`), e.size.width = a * (e.widthInColumns ?? 1) + G * ((e.widthInColumns ?? 1) - 1), e.size.height = i, e.size.x = 0, e.size.y = 0, c.Rm.debug(`abc95 updating size of ${t.id} children child:${e.id} maxWidth:${a} maxHeight:${i}`));
                    for (const r of t.children)setBlockSizes(r, e, a, i);
                    const o = t.columns ?? -1;
                    let l = 0;
                    for (const e of t.children)l += e.widthInColumns ?? 1;
                    let d = t.children.length;
                    o > 0 && o < l && (d = o);
                    const h = Math.ceil(l / d);
                    let g = d * (a + G) + G, u = h * (i + G) + G;
                    if (g < r) {
                        c.Rm.debug(`Detected to small sibling: abc95 ${t.id} siblingWidth ${r} siblingHeight ${s} width ${g}`), g = r, u = s;
                        const e = (r - d * G - G) / d, n = (s - h * G - G) / h;
                        c.Rm.debug("Size indata abc88", t.id, "childWidth", e, "maxWidth", a), c.Rm.debug("Size indata abc88", t.id, "childHeight", n, "maxHeight", i), c.Rm.debug("Size indata abc88 xSize", d, "padding", G);
                        for (const r of t.children)r.size && (r.size.width = e, r.size.height = n, r.size.x = 0, r.size.y = 0);
                    }
                    if (c.Rm.debug(`abc95 (finale calc) ${t.id} xSize ${d} ySize ${h} columns ${o}${t.children.length} width=${Math.max(g, t.size?.width || 0)}`), g < (t?.size?.width || 0)) {
                        g = t?.size?.width || 0;
                        const e = o > 0 ? Math.min(t.children.length, o) : t.children.length;
                        if (e > 0) {
                            const r = (g - e * G - G) / e;
                            c.Rm.debug("abc95 (growing to fit) width", t.id, g, t.size?.width, r);
                            for (const e of t.children)e.size && (e.size.width = r);
                        }
                    }
                    t.size = {
                        width: g,
                        height: u,
                        x: 0,
                        y: 0
                    };
                }
                c.Rm.debug("setBlockSizes abc94 (done)", t.id, t?.size?.x, t?.size?.width, t?.size?.y, t?.size?.height);
            }
            function layoutBlocks(t, e) {
                c.Rm.debug(`abc85 layout blocks (=>layoutBlocks) ${t.id} x: ${t?.size?.x} y: ${t?.size?.y} width: ${t?.size?.width}`);
                const r = t.columns ?? -1;
                if (c.Rm.debug("layoutBlocks columns abc95", t.id, "=>", r, t), t.children && t.children.length > 0) {
                    const s = t?.children[0]?.size?.width ?? 0, a = t.children.length * s + (t.children.length - 1) * G;
                    c.Rm.debug("widthOfChildren 88", a, "posX");
                    let i = 0;
                    c.Rm.debug("abc91 block?.size?.x", t.id, t?.size?.x);
                    let n = t?.size?.x ? t?.size?.x + (-t?.size?.width / 2 || 0) : -G, o = 0;
                    for (const s of t.children){
                        const a = t;
                        if (!s.size) continue;
                        const { width: l, height: d } = s.size, { px: h, py: g } = calculateBlockPosition(r, i);
                        if (g != o && (o = g, n = t?.size?.x ? t?.size?.x + (-t?.size?.width / 2 || 0) : -G, c.Rm.debug("New row in layout for block", t.id, " and child ", s.id, o)), c.Rm.debug(`abc89 layout blocks (child) id: ${s.id} Pos: ${i} (px, py) ${h},${g} (${a?.size?.x},${a?.size?.y}) parent: ${a.id} width: ${l}${G}`), a.size) {
                            const t = l / 2;
                            s.size.x = n + G + t, c.Rm.debug(`abc91 layout blocks (calc) px, pyid:${s.id} startingPos=X${n} new startingPosX${s.size.x} ${t} padding=${G} width=${l} halfWidth=${t} => x:${s.size.x} y:${s.size.y} ${s.widthInColumns} (width * (child?.w || 1)) / 2 ${l * (s?.widthInColumns ?? 1) / 2}`), n = s.size.x + t, s.size.y = a.size.y - a.size.height / 2 + g * (d + G) + d / 2 + G, c.Rm.debug(`abc88 layout blocks (calc) px, pyid:${s.id}startingPosX${n}${G}${t}=>x:${s.size.x}y:${s.size.y}${s.widthInColumns}(width * (child?.w || 1)) / 2${l * (s?.widthInColumns ?? 1) / 2}`);
                        }
                        s.children && layoutBlocks(s, e);
                        let u = s?.widthInColumns ?? 1;
                        r > 0 && (u = Math.min(u, r - i % r)), i += u, c.Rm.debug("abc88 columnsPos", s, i);
                    }
                }
                c.Rm.debug(`layout blocks (<==layoutBlocks) ${t.id} x: ${t?.size?.x} y: ${t?.size?.y} width: ${t?.size?.width}`);
            }
            function findBounds(t, { minX: e, minY: r, maxX: s, maxY: a } = {
                minX: 0,
                minY: 0,
                maxX: 0,
                maxY: 0
            }) {
                if (t.size && "root" !== t.id) {
                    const { x: i, y: n, width: o, height: l } = t.size;
                    i - o / 2 < e && (e = i - o / 2), n - l / 2 < r && (r = n - l / 2), i + o / 2 > s && (s = i + o / 2), n + l / 2 > a && (a = n + l / 2);
                }
                if (t.children) for (const i of t.children)({ minX: e, minY: r, maxX: s, maxY: a } = findBounds(i, {
                    minX: e,
                    minY: r,
                    maxX: s,
                    maxY: a
                }));
                return {
                    minX: e,
                    minY: r,
                    maxX: s,
                    maxY: a
                };
            }
            function layout(t) {
                const e = t.getBlock("root");
                if (!e) return;
                setBlockSizes(e, t, 0, 0), layoutBlocks(e, t), c.Rm.debug("getBlocks", JSON.stringify(e, null, 2));
                const { minX: r, minY: s, maxX: a, maxY: i } = findBounds(e);
                return {
                    x: r,
                    y: s,
                    width: a - r,
                    height: i - s
                };
            }
            function applyStyle(t, e) {
                e && t.attr("style", e);
            }
            function addHtmlLabel(t, e) {
                const r = (0, u.Ltv)(document.createElementNS("http://www.w3.org/2000/svg", "foreignObject")), s = r.append("xhtml:div"), a = t.label, i = t.isNode ? "nodeLabel" : "edgeLabel", n = s.append("span");
                return n.html((0, l.jZ)(a, e)), applyStyle(n, t.labelStyle), n.attr("class", i), applyStyle(s, t.labelStyle), s.style("display", "inline-block"), s.style("white-space", "nowrap"), s.attr("xmlns", "http://www.w3.org/1999/xhtml"), r.node();
            }
            (0, c.K2)(setBlockSizes, "setBlockSizes"), (0, c.K2)(layoutBlocks, "layoutBlocks"), (0, c.K2)(findBounds, "findBounds"), (0, c.K2)(layout, "layout"), (0, c.K2)(applyStyle, "applyStyle"), (0, c.K2)(addHtmlLabel, "addHtmlLabel");
            var J = (0, c.K2)(async (t, e, r, s)=>{
                let a = t || "";
                "object" == typeof a && (a = a[0]);
                const i = (0, l.D7)();
                if ((0, l._3)(i.flowchart.htmlLabels)) {
                    a = a.replace(/\\n|\n/g, "<br />"), c.Rm.debug("vertexText" + a);
                    return addHtmlLabel({
                        isNode: s,
                        label: await (0, n.hE)((0, o.Sm)(a)),
                        labelStyle: e.replace("fill:", "color:")
                    }, i);
                }
                {
                    const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    t.setAttribute("style", e.replace("color:", "fill:"));
                    let s = [];
                    s = "string" == typeof a ? a.split(/\\n|\n|<br\s*\/?>/gi) : Array.isArray(a) ? a : [];
                    for (const e of s){
                        const s = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
                        s.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), s.setAttribute("dy", "1em"), s.setAttribute("x", "0"), r ? s.setAttribute("class", "title-row") : s.setAttribute("class", "row"), s.textContent = e.trim(), t.appendChild(s);
                    }
                    return t;
                }
            }, "createLabel"), V = (0, c.K2)((t, e, r, s, a)=>{
                e.arrowTypeStart && tt(t, "start", e.arrowTypeStart, r, s, a), e.arrowTypeEnd && tt(t, "end", e.arrowTypeEnd, r, s, a);
            }, "addEdgeMarkers"), Q = {
                arrow_cross: "cross",
                arrow_point: "point",
                arrow_barb: "barb",
                arrow_circle: "circle",
                aggregation: "aggregation",
                extension: "extension",
                composition: "composition",
                dependency: "dependency",
                lollipop: "lollipop"
            }, tt = (0, c.K2)((t, e, r, s, a, i)=>{
                const n = Q[r];
                if (!n) return void c.Rm.warn(`Unknown arrow type: ${r}`);
                const o = "start" === e ? "Start" : "End";
                t.attr(`marker-${e}`, `url(${s}#${a}_${i}-${n}${o})`);
            }, "addEdgeMarker"), et = {}, rt = {}, st = (0, c.K2)(async (t, e)=>{
                const r = (0, l.D7)(), s = (0, l._3)(r.flowchart.htmlLabels), a = "markdown" === e.labelType ? (0, n.GZ)(t, e.label, {
                    style: e.labelStyle,
                    useHtmlLabels: s,
                    addSvgBackground: !0
                }, r) : await J(e.label, e.labelStyle), i = t.insert("g").attr("class", "edgeLabel"), o = i.insert("g").attr("class", "label");
                o.node().appendChild(a);
                let c, d = a.getBBox();
                if (s) {
                    const t = a.children[0], e = (0, u.Ltv)(a);
                    d = t.getBoundingClientRect(), e.attr("width", d.width), e.attr("height", d.height);
                }
                if (o.attr("transform", "translate(" + -d.width / 2 + ", " + -d.height / 2 + ")"), et[e.id] = i, e.width = d.width, e.height = d.height, e.startLabelLeft) {
                    const r = await J(e.startLabelLeft, e.labelStyle), s = t.insert("g").attr("class", "edgeTerminals"), a = s.insert("g").attr("class", "inner");
                    c = a.node().appendChild(r);
                    const i = r.getBBox();
                    a.attr("transform", "translate(" + -i.width / 2 + ", " + -i.height / 2 + ")"), rt[e.id] || (rt[e.id] = {}), rt[e.id].startLeft = s, setTerminalWidth(c, e.startLabelLeft);
                }
                if (e.startLabelRight) {
                    const r = await J(e.startLabelRight, e.labelStyle), s = t.insert("g").attr("class", "edgeTerminals"), a = s.insert("g").attr("class", "inner");
                    c = s.node().appendChild(r), a.node().appendChild(r);
                    const i = r.getBBox();
                    a.attr("transform", "translate(" + -i.width / 2 + ", " + -i.height / 2 + ")"), rt[e.id] || (rt[e.id] = {}), rt[e.id].startRight = s, setTerminalWidth(c, e.startLabelRight);
                }
                if (e.endLabelLeft) {
                    const r = await J(e.endLabelLeft, e.labelStyle), s = t.insert("g").attr("class", "edgeTerminals"), a = s.insert("g").attr("class", "inner");
                    c = a.node().appendChild(r);
                    const i = r.getBBox();
                    a.attr("transform", "translate(" + -i.width / 2 + ", " + -i.height / 2 + ")"), s.node().appendChild(r), rt[e.id] || (rt[e.id] = {}), rt[e.id].endLeft = s, setTerminalWidth(c, e.endLabelLeft);
                }
                if (e.endLabelRight) {
                    const r = await J(e.endLabelRight, e.labelStyle), s = t.insert("g").attr("class", "edgeTerminals"), a = s.insert("g").attr("class", "inner");
                    c = a.node().appendChild(r);
                    const i = r.getBBox();
                    a.attr("transform", "translate(" + -i.width / 2 + ", " + -i.height / 2 + ")"), s.node().appendChild(r), rt[e.id] || (rt[e.id] = {}), rt[e.id].endRight = s, setTerminalWidth(c, e.endLabelRight);
                }
                return a;
            }, "insertEdgeLabel");
            function setTerminalWidth(t, e) {
                (0, l.D7)().flowchart.htmlLabels && t && (t.style.width = 9 * e.length + "px", t.style.height = "12px");
            }
            (0, c.K2)(setTerminalWidth, "setTerminalWidth");
            var at = (0, c.K2)((t, e)=>{
                c.Rm.debug("Moving label abc88 ", t.id, t.label, et[t.id], e);
                let r = e.updatedPath ? e.updatedPath : e.originalPath;
                const s = (0, l.D7)(), { subGraphTitleTotalMargin: a } = (0, i.O)(s);
                if (t.label) {
                    const s = et[t.id];
                    let i = t.x, n = t.y;
                    if (r) {
                        const s = o._K.calcLabelPosition(r);
                        c.Rm.debug("Moving label " + t.label + " from (", i, ",", n, ") to (", s.x, ",", s.y, ") abc88"), e.updatedPath && (i = s.x, n = s.y);
                    }
                    s.attr("transform", `translate(${i}, ${n + a / 2})`);
                }
                if (t.startLabelLeft) {
                    const e = rt[t.id].startLeft;
                    let s = t.x, a = t.y;
                    if (r) {
                        const e = o._K.calcTerminalLabelPosition(t.arrowTypeStart ? 10 : 0, "start_left", r);
                        s = e.x, a = e.y;
                    }
                    e.attr("transform", `translate(${s}, ${a})`);
                }
                if (t.startLabelRight) {
                    const e = rt[t.id].startRight;
                    let s = t.x, a = t.y;
                    if (r) {
                        const e = o._K.calcTerminalLabelPosition(t.arrowTypeStart ? 10 : 0, "start_right", r);
                        s = e.x, a = e.y;
                    }
                    e.attr("transform", `translate(${s}, ${a})`);
                }
                if (t.endLabelLeft) {
                    const e = rt[t.id].endLeft;
                    let s = t.x, a = t.y;
                    if (r) {
                        const e = o._K.calcTerminalLabelPosition(t.arrowTypeEnd ? 10 : 0, "end_left", r);
                        s = e.x, a = e.y;
                    }
                    e.attr("transform", `translate(${s}, ${a})`);
                }
                if (t.endLabelRight) {
                    const e = rt[t.id].endRight;
                    let s = t.x, a = t.y;
                    if (r) {
                        const e = o._K.calcTerminalLabelPosition(t.arrowTypeEnd ? 10 : 0, "end_right", r);
                        s = e.x, a = e.y;
                    }
                    e.attr("transform", `translate(${s}, ${a})`);
                }
            }, "positionEdgeLabel"), it = (0, c.K2)((t, e)=>{
                const r = t.x, s = t.y, a = Math.abs(e.x - r), i = Math.abs(e.y - s), n = t.width / 2, o = t.height / 2;
                return a >= n || i >= o;
            }, "outsideNode"), nt = (0, c.K2)((t, e, r)=>{
                c.Rm.debug(`intersection calc abc89:\n  outsidePoint: ${JSON.stringify(e)}\n  insidePoint : ${JSON.stringify(r)}\n  node        : x:${t.x} y:${t.y} w:${t.width} h:${t.height}`);
                const s = t.x, a = t.y, i = Math.abs(s - r.x), n = t.width / 2;
                let o = r.x < e.x ? n - i : n + i;
                const l = t.height / 2, d = Math.abs(e.y - r.y), h = Math.abs(e.x - r.x);
                if (Math.abs(a - e.y) * n > Math.abs(s - e.x) * l) {
                    let t = r.y < e.y ? e.y - l - a : a - l - e.y;
                    o = h * t / d;
                    const s = {
                        x: r.x < e.x ? r.x + o : r.x - h + o,
                        y: r.y < e.y ? r.y + d - t : r.y - d + t
                    };
                    return 0 === o && (s.x = e.x, s.y = e.y), 0 === h && (s.x = e.x), 0 === d && (s.y = e.y), c.Rm.debug(`abc89 topp/bott calc, Q ${d}, q ${t}, R ${h}, r ${o}`, s), s;
                }
                {
                    o = r.x < e.x ? e.x - n - s : s - n - e.x;
                    let t = d * o / h, a = r.x < e.x ? r.x + h - o : r.x - h + o, i = r.y < e.y ? r.y + t : r.y - t;
                    return c.Rm.debug(`sides calc abc89, Q ${d}, q ${t}, R ${h}, r ${o}`, {
                        _x: a,
                        _y: i
                    }), 0 === o && (a = e.x, i = e.y), 0 === h && (a = e.x), 0 === d && (i = e.y), {
                        x: a,
                        y: i
                    };
                }
            }, "intersection"), ot = (0, c.K2)((t, e)=>{
                c.Rm.debug("abc88 cutPathAtIntersect", t, e);
                let r = [], s = t[0], a = !1;
                return t.forEach((t)=>{
                    if (it(e, t) || a) s = t, a || r.push(t);
                    else {
                        const i = nt(e, s, t);
                        let n = !1;
                        r.forEach((t)=>{
                            n = n || t.x === i.x && t.y === i.y;
                        }), r.some((t)=>t.x === i.x && t.y === i.y) || r.push(i), a = !0;
                    }
                }), r;
            }, "cutPathAtIntersect"), lt = (0, c.K2)(function(t, e, r, s, i, n, o) {
                let d = r.points;
                c.Rm.debug("abc88 InsertEdge: edge=", r, "e=", e);
                let h = !1;
                const g = n.node(e.v);
                var p = n.node(e.w);
                p?.intersect && g?.intersect && (d = d.slice(1, r.points.length - 1), d.unshift(g.intersect(d[0])), d.push(p.intersect(d[d.length - 1]))), r.toCluster && (c.Rm.debug("to cluster abc88", s[r.toCluster]), d = ot(r.points, s[r.toCluster].node), h = !0), r.fromCluster && (c.Rm.debug("from cluster abc88", s[r.fromCluster]), d = ot(d.reverse(), s[r.fromCluster].node).reverse(), h = !0);
                const y = d.filter((t)=>!Number.isNaN(t.y));
                let b = u.qrM;
                !r.curve || "graph" !== i && "flowchart" !== i || (b = r.curve);
                const { x, y: f } = (0, a.RI)(r), m = (0, u.n8j)().x(x).y(f).curve(b);
                let w;
                switch(r.thickness){
                    case "normal":
                        w = "edge-thickness-normal";
                        break;
                    case "thick":
                    case "invisible":
                        w = "edge-thickness-thick";
                        break;
                    default:
                        w = "";
                }
                switch(r.pattern){
                    case "solid":
                        w += " edge-pattern-solid";
                        break;
                    case "dotted":
                        w += " edge-pattern-dotted";
                        break;
                    case "dashed":
                        w += " edge-pattern-dashed";
                }
                const _ = t.append("path").attr("d", m(y)).attr("id", r.id).attr("class", " " + w + (r.classes ? " " + r.classes : "")).attr("style", r.style);
                let S = "";
                ((0, l.D7)().flowchart.arrowMarkerAbsolute || (0, l.D7)().state.arrowMarkerAbsolute) && (S = (0, l.ID)(!0)), V(_, r, S, o, i);
                let L = {};
                return h && (L.updatedPath = d), L.originalPath = r.points, L;
            }, "insertEdge"), ct = (0, c.K2)((t)=>{
                const e = new Set;
                for (const r of t)switch(r){
                    case "x":
                        e.add("right"), e.add("left");
                        break;
                    case "y":
                        e.add("up"), e.add("down");
                        break;
                    default:
                        e.add(r);
                }
                return e;
            }, "expandAndDeduplicateDirections"), dt = (0, c.K2)((t, e, r)=>{
                const s = ct(t), a = e.height + 2 * r.padding, i = a / 2, n = e.width + 2 * i + r.padding, o = r.padding / 2;
                return s.has("right") && s.has("left") && s.has("up") && s.has("down") ? [
                    {
                        x: 0,
                        y: 0
                    },
                    {
                        x: i,
                        y: 0
                    },
                    {
                        x: n / 2,
                        y: 2 * o
                    },
                    {
                        x: n - i,
                        y: 0
                    },
                    {
                        x: n,
                        y: 0
                    },
                    {
                        x: n,
                        y: -a / 3
                    },
                    {
                        x: n + 2 * o,
                        y: -a / 2
                    },
                    {
                        x: n,
                        y: -2 * a / 3
                    },
                    {
                        x: n,
                        y: -a
                    },
                    {
                        x: n - i,
                        y: -a
                    },
                    {
                        x: n / 2,
                        y: -a - 2 * o
                    },
                    {
                        x: i,
                        y: -a
                    },
                    {
                        x: 0,
                        y: -a
                    },
                    {
                        x: 0,
                        y: -2 * a / 3
                    },
                    {
                        x: -2 * o,
                        y: -a / 2
                    },
                    {
                        x: 0,
                        y: -a / 3
                    }
                ] : s.has("right") && s.has("left") && s.has("up") ? [
                    {
                        x: i,
                        y: 0
                    },
                    {
                        x: n - i,
                        y: 0
                    },
                    {
                        x: n,
                        y: -a / 2
                    },
                    {
                        x: n - i,
                        y: -a
                    },
                    {
                        x: i,
                        y: -a
                    },
                    {
                        x: 0,
                        y: -a / 2
                    }
                ] : s.has("right") && s.has("left") && s.has("down") ? [
                    {
                        x: 0,
                        y: 0
                    },
                    {
                        x: i,
                        y: -a
                    },
                    {
                        x: n - i,
                        y: -a
                    },
                    {
                        x: n,
                        y: 0
                    }
                ] : s.has("right") && s.has("up") && s.has("down") ? [
                    {
                        x: 0,
                        y: 0
                    },
                    {
                        x: n,
                        y: -i
                    },
                    {
                        x: n,
                        y: -a + i
                    },
                    {
                        x: 0,
                        y: -a
                    }
                ] : s.has("left") && s.has("up") && s.has("down") ? [
                    {
                        x: n,
                        y: 0
                    },
                    {
                        x: 0,
                        y: -i
                    },
                    {
                        x: 0,
                        y: -a + i
                    },
                    {
                        x: n,
                        y: -a
                    }
                ] : s.has("right") && s.has("left") ? [
                    {
                        x: i,
                        y: 0
                    },
                    {
                        x: i,
                        y: -o
                    },
                    {
                        x: n - i,
                        y: -o
                    },
                    {
                        x: n - i,
                        y: 0
                    },
                    {
                        x: n,
                        y: -a / 2
                    },
                    {
                        x: n - i,
                        y: -a
                    },
                    {
                        x: n - i,
                        y: -a + o
                    },
                    {
                        x: i,
                        y: -a + o
                    },
                    {
                        x: i,
                        y: -a
                    },
                    {
                        x: 0,
                        y: -a / 2
                    }
                ] : s.has("up") && s.has("down") ? [
                    {
                        x: n / 2,
                        y: 0
                    },
                    {
                        x: 0,
                        y: -o
                    },
                    {
                        x: i,
                        y: -o
                    },
                    {
                        x: i,
                        y: -a + o
                    },
                    {
                        x: 0,
                        y: -a + o
                    },
                    {
                        x: n / 2,
                        y: -a
                    },
                    {
                        x: n,
                        y: -a + o
                    },
                    {
                        x: n - i,
                        y: -a + o
                    },
                    {
                        x: n - i,
                        y: -o
                    },
                    {
                        x: n,
                        y: -o
                    }
                ] : s.has("right") && s.has("up") ? [
                    {
                        x: 0,
                        y: 0
                    },
                    {
                        x: n,
                        y: -i
                    },
                    {
                        x: 0,
                        y: -a
                    }
                ] : s.has("right") && s.has("down") ? [
                    {
                        x: 0,
                        y: 0
                    },
                    {
                        x: n,
                        y: 0
                    },
                    {
                        x: 0,
                        y: -a
                    }
                ] : s.has("left") && s.has("up") ? [
                    {
                        x: n,
                        y: 0
                    },
                    {
                        x: 0,
                        y: -i
                    },
                    {
                        x: n,
                        y: -a
                    }
                ] : s.has("left") && s.has("down") ? [
                    {
                        x: n,
                        y: 0
                    },
                    {
                        x: 0,
                        y: 0
                    },
                    {
                        x: n,
                        y: -a
                    }
                ] : s.has("right") ? [
                    {
                        x: i,
                        y: -o
                    },
                    {
                        x: i,
                        y: -o
                    },
                    {
                        x: n - i,
                        y: -o
                    },
                    {
                        x: n - i,
                        y: 0
                    },
                    {
                        x: n,
                        y: -a / 2
                    },
                    {
                        x: n - i,
                        y: -a
                    },
                    {
                        x: n - i,
                        y: -a + o
                    },
                    {
                        x: i,
                        y: -a + o
                    },
                    {
                        x: i,
                        y: -a + o
                    }
                ] : s.has("left") ? [
                    {
                        x: i,
                        y: 0
                    },
                    {
                        x: i,
                        y: -o
                    },
                    {
                        x: n - i,
                        y: -o
                    },
                    {
                        x: n - i,
                        y: -a + o
                    },
                    {
                        x: i,
                        y: -a + o
                    },
                    {
                        x: i,
                        y: -a
                    },
                    {
                        x: 0,
                        y: -a / 2
                    }
                ] : s.has("up") ? [
                    {
                        x: i,
                        y: -o
                    },
                    {
                        x: i,
                        y: -a + o
                    },
                    {
                        x: 0,
                        y: -a + o
                    },
                    {
                        x: n / 2,
                        y: -a
                    },
                    {
                        x: n,
                        y: -a + o
                    },
                    {
                        x: n - i,
                        y: -a + o
                    },
                    {
                        x: n - i,
                        y: -o
                    }
                ] : s.has("down") ? [
                    {
                        x: n / 2,
                        y: 0
                    },
                    {
                        x: 0,
                        y: -o
                    },
                    {
                        x: i,
                        y: -o
                    },
                    {
                        x: i,
                        y: -a + o
                    },
                    {
                        x: n - i,
                        y: -a + o
                    },
                    {
                        x: n - i,
                        y: -o
                    },
                    {
                        x: n,
                        y: -o
                    }
                ] : [
                    {
                        x: 0,
                        y: 0
                    }
                ];
            }, "getArrowPoints");
            function intersectNode(t, e) {
                return t.intersect(e);
            }
            (0, c.K2)(intersectNode, "intersectNode");
            var ht = intersectNode;
            function intersectEllipse(t, e, r, s) {
                var a = t.x, i = t.y, n = a - s.x, o = i - s.y, l = Math.sqrt(e * e * o * o + r * r * n * n), c = Math.abs(e * r * n / l);
                s.x < a && (c = -c);
                var d = Math.abs(e * r * o / l);
                return s.y < i && (d = -d), {
                    x: a + c,
                    y: i + d
                };
            }
            (0, c.K2)(intersectEllipse, "intersectEllipse");
            var gt = intersectEllipse;
            function intersectCircle(t, e, r) {
                return gt(t, e, e, r);
            }
            (0, c.K2)(intersectCircle, "intersectCircle");
            var ut = intersectCircle;
            function intersectLine(t, e, r, s) {
                var a, i, n, o, l, c, d, h, g, u, p, y, b;
                if (a = e.y - t.y, n = t.x - e.x, l = e.x * t.y - t.x * e.y, g = a * r.x + n * r.y + l, u = a * s.x + n * s.y + l, !(0 !== g && 0 !== u && sameSign(g, u) || (i = s.y - r.y, o = r.x - s.x, c = s.x * r.y - r.x * s.y, d = i * t.x + o * t.y + c, h = i * e.x + o * e.y + c, 0 !== d && 0 !== h && sameSign(d, h) || 0 == (p = a * o - i * n)))) return y = Math.abs(p / 2), {
                    x: (b = n * c - o * l) < 0 ? (b - y) / p : (b + y) / p,
                    y: (b = i * l - a * c) < 0 ? (b - y) / p : (b + y) / p
                };
            }
            function sameSign(t, e) {
                return t * e > 0;
            }
            (0, c.K2)(intersectLine, "intersectLine"), (0, c.K2)(sameSign, "sameSign");
            var pt = intersectLine, yt = intersectPolygon;
            function intersectPolygon(t, e, r) {
                var s = t.x, a = t.y, i = [], n = Number.POSITIVE_INFINITY, o = Number.POSITIVE_INFINITY;
                "function" == typeof e.forEach ? e.forEach(function(t) {
                    n = Math.min(n, t.x), o = Math.min(o, t.y);
                }) : (n = Math.min(n, e.x), o = Math.min(o, e.y));
                for(var l = s - t.width / 2 - n, c = a - t.height / 2 - o, d = 0; d < e.length; d++){
                    var h = e[d], g = e[d < e.length - 1 ? d + 1 : 0], u = pt(t, r, {
                        x: l + h.x,
                        y: c + h.y
                    }, {
                        x: l + g.x,
                        y: c + g.y
                    });
                    u && i.push(u);
                }
                return i.length ? (i.length > 1 && i.sort(function(t, e) {
                    var s = t.x - r.x, a = t.y - r.y, i = Math.sqrt(s * s + a * a), n = e.x - r.x, o = e.y - r.y, l = Math.sqrt(n * n + o * o);
                    return i < l ? -1 : i === l ? 0 : 1;
                }), i[0]) : t;
            }
            (0, c.K2)(intersectPolygon, "intersectPolygon");
            var bt = {
                node: ht,
                circle: ut,
                ellipse: gt,
                polygon: yt,
                rect: (0, c.K2)((t, e)=>{
                    var r, s, a = t.x, i = t.y, n = e.x - a, o = e.y - i, l = t.width / 2, c = t.height / 2;
                    return Math.abs(o) * l > Math.abs(n) * c ? (o < 0 && (c = -c), r = 0 === o ? 0 : c * n / o, s = c) : (n < 0 && (l = -l), r = l, s = 0 === n ? 0 : l * o / n), {
                        x: a + r,
                        y: i + s
                    };
                }, "intersectRect")
            }, xt = (0, c.K2)(async (t, e, r, s)=>{
                const a = (0, l.D7)();
                let i;
                const d = e.useHtmlLabels || (0, l._3)(a.flowchart.htmlLabels);
                i = r || "node default";
                const h = t.insert("g").attr("class", i).attr("id", e.domId || e.id), g = h.insert("g").attr("class", "label").attr("style", e.labelStyle);
                let p;
                p = void 0 === e.labelText ? "" : "string" == typeof e.labelText ? e.labelText : e.labelText[0];
                const y = g.node();
                let b;
                b = "markdown" === e.labelType ? (0, n.GZ)(g, (0, l.jZ)((0, o.Sm)(p), a), {
                    useHtmlLabels: d,
                    width: e.width || a.flowchart.wrappingWidth,
                    classes: "markdown-node-label"
                }, a) : y.appendChild(await J((0, l.jZ)((0, o.Sm)(p), a), e.labelStyle, !1, s));
                let x = b.getBBox();
                const f = e.padding / 2;
                if ((0, l._3)(a.flowchart.htmlLabels)) {
                    const t = b.children[0], e = (0, u.Ltv)(b), r = t.getElementsByTagName("img");
                    if (r) {
                        const t = "" === p.replace(/<img[^>]*>/g, "").trim();
                        await Promise.all([
                            ...r
                        ].map((e)=>new Promise((r)=>{
                                function setupImage() {
                                    if (e.style.display = "flex", e.style.flexDirection = "column", t) {
                                        const t = a.fontSize ? a.fontSize : window.getComputedStyle(document.body).fontSize, r = 5, s = parseInt(t, 10) * r + "px";
                                        e.style.minWidth = s, e.style.maxWidth = s;
                                    } else e.style.width = "100%";
                                    r(e);
                                }
                                (0, c.K2)(setupImage, "setupImage"), setTimeout(()=>{
                                    e.complete && setupImage();
                                }), e.addEventListener("error", setupImage), e.addEventListener("load", setupImage);
                            })));
                    }
                    x = t.getBoundingClientRect(), e.attr("width", x.width), e.attr("height", x.height);
                }
                return d ? g.attr("transform", "translate(" + -x.width / 2 + ", " + -x.height / 2 + ")") : g.attr("transform", "translate(0, " + -x.height / 2 + ")"), e.centerLabel && g.attr("transform", "translate(" + -x.width / 2 + ", " + -x.height / 2 + ")"), g.insert("rect", ":first-child"), {
                    shapeSvg: h,
                    bbox: x,
                    halfPadding: f,
                    label: g
                };
            }, "labelHelper"), ft = (0, c.K2)((t, e)=>{
                const r = e.node().getBBox();
                t.width = r.width, t.height = r.height;
            }, "updateNodeBounds");
            function insertPolygonShape(t, e, r, s) {
                return t.insert("polygon", ":first-child").attr("points", s.map(function(t) {
                    return t.x + "," + t.y;
                }).join(" ")).attr("class", "label-container").attr("transform", "translate(" + -e / 2 + "," + r / 2 + ")");
            }
            (0, c.K2)(insertPolygonShape, "insertPolygonShape");
            var mt = (0, c.K2)(async (t, e)=>{
                e.useHtmlLabels || (0, l.D7)().flowchart.htmlLabels || (e.centerLabel = !0);
                const { shapeSvg: r, bbox: s, halfPadding: a } = await xt(t, e, "node " + e.classes, !0);
                c.Rm.info("Classes = ", e.classes);
                const i = r.insert("rect", ":first-child");
                return i.attr("rx", e.rx).attr("ry", e.ry).attr("x", -s.width / 2 - a).attr("y", -s.height / 2 - a).attr("width", s.width + e.padding).attr("height", s.height + e.padding), ft(e, i), e.intersect = function(t) {
                    return bt.rect(e, t);
                }, r;
            }, "note"), wt = (0, c.K2)((t)=>t ? " " + t : "", "formatClass"), _t = (0, c.K2)((t, e)=>`${e || "node default"}${wt(t.classes)} ${wt(t.class)}`, "getClassesFromNode"), St = (0, c.K2)(async (t, e)=>{
                const { shapeSvg: r, bbox: s } = await xt(t, e, _t(e, void 0), !0), a = s.width + e.padding + (s.height + e.padding), i = [
                    {
                        x: a / 2,
                        y: 0
                    },
                    {
                        x: a,
                        y: -a / 2
                    },
                    {
                        x: a / 2,
                        y: -a
                    },
                    {
                        x: 0,
                        y: -a / 2
                    }
                ];
                c.Rm.info("Question main (Circle)");
                const n = insertPolygonShape(r, a, a, i);
                return n.attr("style", e.style), ft(e, n), e.intersect = function(t) {
                    return c.Rm.warn("Intersect called"), bt.polygon(e, i, t);
                }, r;
            }, "question"), Lt = (0, c.K2)((t, e)=>{
                const r = t.insert("g").attr("class", "node default").attr("id", e.domId || e.id), s = [
                    {
                        x: 0,
                        y: 14
                    },
                    {
                        x: 14,
                        y: 0
                    },
                    {
                        x: 0,
                        y: -14
                    },
                    {
                        x: -14,
                        y: 0
                    }
                ];
                return r.insert("polygon", ":first-child").attr("points", s.map(function(t) {
                    return t.x + "," + t.y;
                }).join(" ")).attr("class", "state-start").attr("r", 7).attr("width", 28).attr("height", 28), e.width = 28, e.height = 28, e.intersect = function(t) {
                    return bt.circle(e, 14, t);
                }, r;
            }, "choice"), kt = (0, c.K2)(async (t, e)=>{
                const { shapeSvg: r, bbox: s } = await xt(t, e, _t(e, void 0), !0), a = s.height + e.padding, i = a / 4, n = s.width + 2 * i + e.padding, o = [
                    {
                        x: i,
                        y: 0
                    },
                    {
                        x: n - i,
                        y: 0
                    },
                    {
                        x: n,
                        y: -a / 2
                    },
                    {
                        x: n - i,
                        y: -a
                    },
                    {
                        x: i,
                        y: -a
                    },
                    {
                        x: 0,
                        y: -a / 2
                    }
                ], l = insertPolygonShape(r, n, a, o);
                return l.attr("style", e.style), ft(e, l), e.intersect = function(t) {
                    return bt.polygon(e, o, t);
                }, r;
            }, "hexagon"), vt = (0, c.K2)(async (t, e)=>{
                const { shapeSvg: r, bbox: s } = await xt(t, e, void 0, !0), a = s.height + 2 * e.padding, i = a / 2, n = s.width + 2 * i + e.padding, o = dt(e.directions, s, e), l = insertPolygonShape(r, n, a, o);
                return l.attr("style", e.style), ft(e, l), e.intersect = function(t) {
                    return bt.polygon(e, o, t);
                }, r;
            }, "block_arrow"), Et = (0, c.K2)(async (t, e)=>{
                const { shapeSvg: r, bbox: s } = await xt(t, e, _t(e, void 0), !0), a = s.width + e.padding, i = s.height + e.padding, n = [
                    {
                        x: -i / 2,
                        y: 0
                    },
                    {
                        x: a,
                        y: 0
                    },
                    {
                        x: a,
                        y: -i
                    },
                    {
                        x: -i / 2,
                        y: -i
                    },
                    {
                        x: 0,
                        y: -i / 2
                    }
                ];
                return insertPolygonShape(r, a, i, n).attr("style", e.style), e.width = a + i, e.height = i, e.intersect = function(t) {
                    return bt.polygon(e, n, t);
                }, r;
            }, "rect_left_inv_arrow"), Dt = (0, c.K2)(async (t, e)=>{
                const { shapeSvg: r, bbox: s } = await xt(t, e, _t(e), !0), a = s.width + e.padding, i = s.height + e.padding, n = [
                    {
                        x: -2 * i / 6,
                        y: 0
                    },
                    {
                        x: a - i / 6,
                        y: 0
                    },
                    {
                        x: a + 2 * i / 6,
                        y: -i
                    },
                    {
                        x: i / 6,
                        y: -i
                    }
                ], o = insertPolygonShape(r, a, i, n);
                return o.attr("style", e.style), ft(e, o), e.intersect = function(t) {
                    return bt.polygon(e, n, t);
                }, r;
            }, "lean_right"), Tt = (0, c.K2)(async (t, e)=>{
                const { shapeSvg: r, bbox: s } = await xt(t, e, _t(e, void 0), !0), a = s.width + e.padding, i = s.height + e.padding, n = [
                    {
                        x: 2 * i / 6,
                        y: 0
                    },
                    {
                        x: a + i / 6,
                        y: 0
                    },
                    {
                        x: a - 2 * i / 6,
                        y: -i
                    },
                    {
                        x: -i / 6,
                        y: -i
                    }
                ], o = insertPolygonShape(r, a, i, n);
                return o.attr("style", e.style), ft(e, o), e.intersect = function(t) {
                    return bt.polygon(e, n, t);
                }, r;
            }, "lean_left"), Ct = (0, c.K2)(async (t, e)=>{
                const { shapeSvg: r, bbox: s } = await xt(t, e, _t(e, void 0), !0), a = s.width + e.padding, i = s.height + e.padding, n = [
                    {
                        x: -2 * i / 6,
                        y: 0
                    },
                    {
                        x: a + 2 * i / 6,
                        y: 0
                    },
                    {
                        x: a - i / 6,
                        y: -i
                    },
                    {
                        x: i / 6,
                        y: -i
                    }
                ], o = insertPolygonShape(r, a, i, n);
                return o.attr("style", e.style), ft(e, o), e.intersect = function(t) {
                    return bt.polygon(e, n, t);
                }, r;
            }, "trapezoid"), Rt = (0, c.K2)(async (t, e)=>{
                const { shapeSvg: r, bbox: s } = await xt(t, e, _t(e, void 0), !0), a = s.width + e.padding, i = s.height + e.padding, n = [
                    {
                        x: i / 6,
                        y: 0
                    },
                    {
                        x: a - i / 6,
                        y: 0
                    },
                    {
                        x: a + 2 * i / 6,
                        y: -i
                    },
                    {
                        x: -2 * i / 6,
                        y: -i
                    }
                ], o = insertPolygonShape(r, a, i, n);
                return o.attr("style", e.style), ft(e, o), e.intersect = function(t) {
                    return bt.polygon(e, n, t);
                }, r;
            }, "inv_trapezoid"), Nt = (0, c.K2)(async (t, e)=>{
                const { shapeSvg: r, bbox: s } = await xt(t, e, _t(e, void 0), !0), a = s.width + e.padding, i = s.height + e.padding, n = [
                    {
                        x: 0,
                        y: 0
                    },
                    {
                        x: a + i / 2,
                        y: 0
                    },
                    {
                        x: a,
                        y: -i / 2
                    },
                    {
                        x: a + i / 2,
                        y: -i
                    },
                    {
                        x: 0,
                        y: -i
                    }
                ], o = insertPolygonShape(r, a, i, n);
                return o.attr("style", e.style), ft(e, o), e.intersect = function(t) {
                    return bt.polygon(e, n, t);
                }, r;
            }, "rect_right_inv_arrow"), Kt = (0, c.K2)(async (t, e)=>{
                const { shapeSvg: r, bbox: s } = await xt(t, e, _t(e, void 0), !0), a = s.width + e.padding, i = a / 2, n = i / (2.5 + a / 50), o = s.height + n + e.padding, l = "M 0," + n + " a " + i + "," + n + " 0,0,0 " + a + " 0 a " + i + "," + n + " 0,0,0 " + -a + " 0 l 0," + o + " a " + i + "," + n + " 0,0,0 " + a + " 0 l 0," + -o, c = r.attr("label-offset-y", n).insert("path", ":first-child").attr("style", e.style).attr("d", l).attr("transform", "translate(" + -a / 2 + "," + -(o / 2 + n) + ")");
                return ft(e, c), e.intersect = function(t) {
                    const r = bt.rect(e, t), s = r.x - e.x;
                    if (0 != i && (Math.abs(s) < e.width / 2 || Math.abs(s) == e.width / 2 && Math.abs(r.y - e.y) > e.height / 2 - n)) {
                        let a = n * n * (1 - s * s / (i * i));
                        0 != a && (a = Math.sqrt(a)), a = n - a, t.y - e.y > 0 && (a = -a), r.y += a;
                    }
                    return r;
                }, r;
            }, "cylinder"), $t = (0, c.K2)(async (t, e)=>{
                const { shapeSvg: r, bbox: s, halfPadding: a } = await xt(t, e, "node " + e.classes + " " + e.class, !0), i = r.insert("rect", ":first-child"), n = e.positioned ? e.width : s.width + e.padding, o = e.positioned ? e.height : s.height + e.padding, l = e.positioned ? -n / 2 : -s.width / 2 - a, d = e.positioned ? -o / 2 : -s.height / 2 - a;
                if (i.attr("class", "basic label-container").attr("style", e.style).attr("rx", e.rx).attr("ry", e.ry).attr("x", l).attr("y", d).attr("width", n).attr("height", o), e.props) {
                    const t = new Set(Object.keys(e.props));
                    e.props.borders && (applyNodePropertyBorders(i, e.props.borders, n, o), t.delete("borders")), t.forEach((t)=>{
                        c.Rm.warn(`Unknown node property ${t}`);
                    });
                }
                return ft(e, i), e.intersect = function(t) {
                    return bt.rect(e, t);
                }, r;
            }, "rect"), Bt = (0, c.K2)(async (t, e)=>{
                const { shapeSvg: r, bbox: s, halfPadding: a } = await xt(t, e, "node " + e.classes, !0), i = r.insert("rect", ":first-child"), n = e.positioned ? e.width : s.width + e.padding, o = e.positioned ? e.height : s.height + e.padding, l = e.positioned ? -n / 2 : -s.width / 2 - a, d = e.positioned ? -o / 2 : -s.height / 2 - a;
                if (i.attr("class", "basic cluster composite label-container").attr("style", e.style).attr("rx", e.rx).attr("ry", e.ry).attr("x", l).attr("y", d).attr("width", n).attr("height", o), e.props) {
                    const t = new Set(Object.keys(e.props));
                    e.props.borders && (applyNodePropertyBorders(i, e.props.borders, n, o), t.delete("borders")), t.forEach((t)=>{
                        c.Rm.warn(`Unknown node property ${t}`);
                    });
                }
                return ft(e, i), e.intersect = function(t) {
                    return bt.rect(e, t);
                }, r;
            }, "composite"), It = (0, c.K2)(async (t, e)=>{
                const { shapeSvg: r } = await xt(t, e, "label", !0);
                c.Rm.trace("Classes = ", e.class);
                const s = r.insert("rect", ":first-child");
                if (s.attr("width", 0).attr("height", 0), r.attr("class", "label edgeLabel"), e.props) {
                    const t = new Set(Object.keys(e.props));
                    e.props.borders && (applyNodePropertyBorders(s, e.props.borders, 0, 0), t.delete("borders")), t.forEach((t)=>{
                        c.Rm.warn(`Unknown node property ${t}`);
                    });
                }
                return ft(e, s), e.intersect = function(t) {
                    return bt.rect(e, t);
                }, r;
            }, "labelRect");
            function applyNodePropertyBorders(t, e, r, s) {
                const a = [], i = (0, c.K2)((t)=>{
                    a.push(t, 0);
                }, "addBorder"), n = (0, c.K2)((t)=>{
                    a.push(0, t);
                }, "skipBorder");
                e.includes("t") ? (c.Rm.debug("add top border"), i(r)) : n(r), e.includes("r") ? (c.Rm.debug("add right border"), i(s)) : n(s), e.includes("b") ? (c.Rm.debug("add bottom border"), i(r)) : n(r), e.includes("l") ? (c.Rm.debug("add left border"), i(s)) : n(s), t.attr("stroke-dasharray", a.join(" "));
            }
            (0, c.K2)(applyNodePropertyBorders, "applyNodePropertyBorders");
            var At = (0, c.K2)(async (t, e)=>{
                let r;
                r = e.classes ? "node " + e.classes : "node default";
                const s = t.insert("g").attr("class", r).attr("id", e.domId || e.id), a = s.insert("rect", ":first-child"), i = s.insert("line"), n = s.insert("g").attr("class", "label"), o = e.labelText.flat ? e.labelText.flat() : e.labelText;
                let d = "";
                d = "object" == typeof o ? o[0] : o, c.Rm.info("Label text abc79", d, o, "object" == typeof o);
                const h = n.node().appendChild(await J(d, e.labelStyle, !0, !0));
                let g = {
                    width: 0,
                    height: 0
                };
                if ((0, l._3)((0, l.D7)().flowchart.htmlLabels)) {
                    const t = h.children[0], e = (0, u.Ltv)(h);
                    g = t.getBoundingClientRect(), e.attr("width", g.width), e.attr("height", g.height);
                }
                c.Rm.info("Text 2", o);
                const p = o.slice(1, o.length);
                let y = h.getBBox();
                const b = n.node().appendChild(await J(p.join ? p.join("<br/>") : p, e.labelStyle, !0, !0));
                if ((0, l._3)((0, l.D7)().flowchart.htmlLabels)) {
                    const t = b.children[0], e = (0, u.Ltv)(b);
                    g = t.getBoundingClientRect(), e.attr("width", g.width), e.attr("height", g.height);
                }
                const x = e.padding / 2;
                return (0, u.Ltv)(b).attr("transform", "translate( " + (g.width > y.width ? 0 : (y.width - g.width) / 2) + ", " + (y.height + x + 5) + ")"), (0, u.Ltv)(h).attr("transform", "translate( " + (g.width < y.width ? 0 : -(y.width - g.width) / 2) + ", 0)"), g = n.node().getBBox(), n.attr("transform", "translate(" + -g.width / 2 + ", " + (-g.height / 2 - x + 3) + ")"), a.attr("class", "outer title-state").attr("x", -g.width / 2 - x).attr("y", -g.height / 2 - x).attr("width", g.width + e.padding).attr("height", g.height + e.padding), i.attr("class", "divider").attr("x1", -g.width / 2 - x).attr("x2", g.width / 2 + x).attr("y1", -g.height / 2 - x + y.height + x).attr("y2", -g.height / 2 - x + y.height + x), ft(e, a), e.intersect = function(t) {
                    return bt.rect(e, t);
                }, s;
            }, "rectWithTitle"), Ot = (0, c.K2)(async (t, e)=>{
                const { shapeSvg: r, bbox: s } = await xt(t, e, _t(e, void 0), !0), a = s.height + e.padding, i = s.width + a / 4 + e.padding, n = r.insert("rect", ":first-child").attr("style", e.style).attr("rx", a / 2).attr("ry", a / 2).attr("x", -i / 2).attr("y", -a / 2).attr("width", i).attr("height", a);
                return ft(e, n), e.intersect = function(t) {
                    return bt.rect(e, t);
                }, r;
            }, "stadium"), zt = (0, c.K2)(async (t, e)=>{
                const { shapeSvg: r, bbox: s, halfPadding: a } = await xt(t, e, _t(e, void 0), !0), i = r.insert("circle", ":first-child");
                return i.attr("style", e.style).attr("rx", e.rx).attr("ry", e.ry).attr("r", s.width / 2 + a).attr("width", s.width + e.padding).attr("height", s.height + e.padding), c.Rm.info("Circle main"), ft(e, i), e.intersect = function(t) {
                    return c.Rm.info("Circle intersect", e, s.width / 2 + a, t), bt.circle(e, s.width / 2 + a, t);
                }, r;
            }, "circle"), Pt = (0, c.K2)(async (t, e)=>{
                const { shapeSvg: r, bbox: s, halfPadding: a } = await xt(t, e, _t(e, void 0), !0), i = r.insert("g", ":first-child"), n = i.insert("circle"), o = i.insert("circle");
                return i.attr("class", e.class), n.attr("style", e.style).attr("rx", e.rx).attr("ry", e.ry).attr("r", s.width / 2 + a + 5).attr("width", s.width + e.padding + 10).attr("height", s.height + e.padding + 10), o.attr("style", e.style).attr("rx", e.rx).attr("ry", e.ry).attr("r", s.width / 2 + a).attr("width", s.width + e.padding).attr("height", s.height + e.padding), c.Rm.info("DoubleCircle main"), ft(e, n), e.intersect = function(t) {
                    return c.Rm.info("DoubleCircle intersect", e, s.width / 2 + a + 5, t), bt.circle(e, s.width / 2 + a + 5, t);
                }, r;
            }, "doublecircle"), Mt = (0, c.K2)(async (t, e)=>{
                const { shapeSvg: r, bbox: s } = await xt(t, e, _t(e, void 0), !0), a = s.width + e.padding, i = s.height + e.padding, n = [
                    {
                        x: 0,
                        y: 0
                    },
                    {
                        x: a,
                        y: 0
                    },
                    {
                        x: a,
                        y: -i
                    },
                    {
                        x: 0,
                        y: -i
                    },
                    {
                        x: 0,
                        y: 0
                    },
                    {
                        x: -8,
                        y: 0
                    },
                    {
                        x: a + 8,
                        y: 0
                    },
                    {
                        x: a + 8,
                        y: -i
                    },
                    {
                        x: -8,
                        y: -i
                    },
                    {
                        x: -8,
                        y: 0
                    }
                ], o = insertPolygonShape(r, a, i, n);
                return o.attr("style", e.style), ft(e, o), e.intersect = function(t) {
                    return bt.polygon(e, n, t);
                }, r;
            }, "subroutine"), Ft = (0, c.K2)((t, e)=>{
                const r = t.insert("g").attr("class", "node default").attr("id", e.domId || e.id), s = r.insert("circle", ":first-child");
                return s.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14), ft(e, s), e.intersect = function(t) {
                    return bt.circle(e, 7, t);
                }, r;
            }, "start"), jt = (0, c.K2)((t, e, r)=>{
                const s = t.insert("g").attr("class", "node default").attr("id", e.domId || e.id);
                let a = 70, i = 10;
                "LR" === r && (a = 10, i = 70);
                const n = s.append("rect").attr("x", -1 * a / 2).attr("y", -1 * i / 2).attr("width", a).attr("height", i).attr("class", "fork-join");
                return ft(e, n), e.height = e.height + e.padding / 2, e.width = e.width + e.padding / 2, e.intersect = function(t) {
                    return bt.rect(e, t);
                }, s;
            }, "forkJoin"), Yt = {
                rhombus: St,
                composite: Bt,
                question: St,
                rect: $t,
                labelRect: It,
                rectWithTitle: At,
                choice: Lt,
                circle: zt,
                doublecircle: Pt,
                stadium: Ot,
                hexagon: kt,
                block_arrow: vt,
                rect_left_inv_arrow: Et,
                lean_right: Dt,
                lean_left: Tt,
                trapezoid: Ct,
                inv_trapezoid: Rt,
                rect_right_inv_arrow: Nt,
                cylinder: Kt,
                start: Ft,
                end: (0, c.K2)((t, e)=>{
                    const r = t.insert("g").attr("class", "node default").attr("id", e.domId || e.id), s = r.insert("circle", ":first-child"), a = r.insert("circle", ":first-child");
                    return a.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14), s.attr("class", "state-end").attr("r", 5).attr("width", 10).attr("height", 10), ft(e, a), e.intersect = function(t) {
                        return bt.circle(e, 7, t);
                    }, r;
                }, "end"),
                note: mt,
                subroutine: Mt,
                fork: jt,
                join: jt,
                class_box: (0, c.K2)(async (t, e)=>{
                    const r = e.padding / 2;
                    let s;
                    s = e.classes ? "node " + e.classes : "node default";
                    const a = t.insert("g").attr("class", s).attr("id", e.domId || e.id), i = a.insert("rect", ":first-child"), n = a.insert("line"), o = a.insert("line");
                    let c = 0, d = 4;
                    const h = a.insert("g").attr("class", "label");
                    let g = 0;
                    const p = e.classData.annotations?.[0], y = e.classData.annotations[0] ? "" + e.classData.annotations[0] + "" : "", b = h.node().appendChild(await J(y, e.labelStyle, !0, !0));
                    let x = b.getBBox();
                    if ((0, l._3)((0, l.D7)().flowchart.htmlLabels)) {
                        const t = b.children[0], e = (0, u.Ltv)(b);
                        x = t.getBoundingClientRect(), e.attr("width", x.width), e.attr("height", x.height);
                    }
                    e.classData.annotations[0] && (d += x.height + 4, c += x.width);
                    let f = e.classData.label;
                    void 0 !== e.classData.type && "" !== e.classData.type && ((0, l.D7)().flowchart.htmlLabels ? f += "&lt;" + e.classData.type + "&gt;" : f += "<" + e.classData.type + ">");
                    const m = h.node().appendChild(await J(f, e.labelStyle, !0, !0));
                    (0, u.Ltv)(m).attr("class", "classTitle");
                    let w = m.getBBox();
                    if ((0, l._3)((0, l.D7)().flowchart.htmlLabels)) {
                        const t = m.children[0], e = (0, u.Ltv)(m);
                        w = t.getBoundingClientRect(), e.attr("width", w.width), e.attr("height", w.height);
                    }
                    d += w.height + 4, w.width > c && (c = w.width);
                    const _ = [];
                    e.classData.members.forEach(async (t)=>{
                        const r = t.getDisplayDetails();
                        let s = r.displayText;
                        (0, l.D7)().flowchart.htmlLabels && (s = s.replace(/</g, "&lt;").replace(/>/g, "&gt;"));
                        const a = h.node().appendChild(await J(s, r.cssStyle ? r.cssStyle : e.labelStyle, !0, !0));
                        let i = a.getBBox();
                        if ((0, l._3)((0, l.D7)().flowchart.htmlLabels)) {
                            const t = a.children[0], e = (0, u.Ltv)(a);
                            i = t.getBoundingClientRect(), e.attr("width", i.width), e.attr("height", i.height);
                        }
                        i.width > c && (c = i.width), d += i.height + 4, _.push(a);
                    }), d += 8;
                    const S = [];
                    if (e.classData.methods.forEach(async (t)=>{
                        const r = t.getDisplayDetails();
                        let s = r.displayText;
                        (0, l.D7)().flowchart.htmlLabels && (s = s.replace(/</g, "&lt;").replace(/>/g, "&gt;"));
                        const a = h.node().appendChild(await J(s, r.cssStyle ? r.cssStyle : e.labelStyle, !0, !0));
                        let i = a.getBBox();
                        if ((0, l._3)((0, l.D7)().flowchart.htmlLabels)) {
                            const t = a.children[0], e = (0, u.Ltv)(a);
                            i = t.getBoundingClientRect(), e.attr("width", i.width), e.attr("height", i.height);
                        }
                        i.width > c && (c = i.width), d += i.height + 4, S.push(a);
                    }), d += 8, p) {
                        let t = (c - x.width) / 2;
                        (0, u.Ltv)(b).attr("transform", "translate( " + (-1 * c / 2 + t) + ", " + -1 * d / 2 + ")"), g = x.height + 4;
                    }
                    let L = (c - w.width) / 2;
                    return (0, u.Ltv)(m).attr("transform", "translate( " + (-1 * c / 2 + L) + ", " + (-1 * d / 2 + g) + ")"), g += w.height + 4, n.attr("class", "divider").attr("x1", -c / 2 - r).attr("x2", c / 2 + r).attr("y1", -d / 2 - r + 8 + g).attr("y2", -d / 2 - r + 8 + g), g += 8, _.forEach((t)=>{
                        (0, u.Ltv)(t).attr("transform", "translate( " + -c / 2 + ", " + (-1 * d / 2 + g + 4) + ")");
                        const e = t?.getBBox();
                        g += (e?.height ?? 0) + 4;
                    }), g += 8, o.attr("class", "divider").attr("x1", -c / 2 - r).attr("x2", c / 2 + r).attr("y1", -d / 2 - r + 8 + g).attr("y2", -d / 2 - r + 8 + g), g += 8, S.forEach((t)=>{
                        (0, u.Ltv)(t).attr("transform", "translate( " + -c / 2 + ", " + (-1 * d / 2 + g) + ")");
                        const e = t?.getBBox();
                        g += (e?.height ?? 0) + 4;
                    }), i.attr("style", e.style).attr("class", "outer title-state").attr("x", -c / 2 - r).attr("y", -d / 2 - r).attr("width", c + e.padding).attr("height", d + e.padding), ft(e, i), e.intersect = function(t) {
                        return bt.rect(e, t);
                    }, a;
                }, "class_box")
            }, Wt = {}, Xt = (0, c.K2)(async (t, e, r)=>{
                let s, a;
                if (e.link) {
                    let i;
                    "sandbox" === (0, l.D7)().securityLevel ? i = "_top" : e.linkTarget && (i = e.linkTarget || "_blank"), s = t.insert("svg:a").attr("xlink:href", e.link).attr("target", i), a = await Yt[e.shape](s, e, r);
                } else a = await Yt[e.shape](t, e, r), s = a;
                return e.tooltip && a.attr("title", e.tooltip), e.class && a.attr("class", "node default " + e.class), Wt[e.id] = s, e.haveCallback && Wt[e.id].attr("class", Wt[e.id].attr("class") + " clickable"), s;
            }, "insertNode"), Ht = (0, c.K2)((t)=>{
                const e = Wt[t.id];
                c.Rm.trace("Transforming node", t.diff, t, "translate(" + (t.x - t.width / 2 - 5) + ", " + t.width / 2 + ")");
                const r = t.diff || 0;
                return t.clusterNode ? e.attr("transform", "translate(" + (t.x + r - t.width / 2) + ", " + (t.y - t.height / 2 - 8) + ")") : e.attr("transform", "translate(" + t.x + ", " + t.y + ")"), r;
            }, "positionNode");
            function getNodeFromBlock(t, e, r = !1) {
                const s = t;
                let a = "default";
                (s?.classes?.length || 0) > 0 && (a = (s?.classes ?? []).join(" ")), a += " flowchart-label";
                let i, n = 0, c = "";
                switch(s.type){
                    case "round":
                        n = 5, c = "rect";
                        break;
                    case "composite":
                        n = 0, c = "composite", i = 0;
                        break;
                    case "square":
                    case "group":
                    default:
                        c = "rect";
                        break;
                    case "diamond":
                        c = "question";
                        break;
                    case "hexagon":
                        c = "hexagon";
                        break;
                    case "block_arrow":
                        c = "block_arrow";
                        break;
                    case "odd":
                    case "rect_left_inv_arrow":
                        c = "rect_left_inv_arrow";
                        break;
                    case "lean_right":
                        c = "lean_right";
                        break;
                    case "lean_left":
                        c = "lean_left";
                        break;
                    case "trapezoid":
                        c = "trapezoid";
                        break;
                    case "inv_trapezoid":
                        c = "inv_trapezoid";
                        break;
                    case "circle":
                        c = "circle";
                        break;
                    case "ellipse":
                        c = "ellipse";
                        break;
                    case "stadium":
                        c = "stadium";
                        break;
                    case "subroutine":
                        c = "subroutine";
                        break;
                    case "cylinder":
                        c = "cylinder";
                        break;
                    case "doublecircle":
                        c = "doublecircle";
                }
                const d = (0, o.sM)(s?.styles ?? []), h = s.label, g = s.size ?? {
                    width: 0,
                    height: 0,
                    x: 0,
                    y: 0
                };
                return {
                    labelStyle: d.labelStyle,
                    shape: c,
                    labelText: h,
                    rx: n,
                    ry: n,
                    class: a,
                    style: d.style,
                    id: s.id,
                    directions: s.directions,
                    width: g.width,
                    height: g.height,
                    x: g.x,
                    y: g.y,
                    positioned: r,
                    intersect: void 0,
                    type: s.type,
                    padding: i ?? (0, l.zj)()?.block?.padding ?? 0
                };
            }
            async function calculateBlockSize(t, e, r) {
                const s = getNodeFromBlock(e, 0, !1);
                if ("group" === s.type) return;
                const a = (0, l.zj)(), i = await Xt(t, s, {
                    config: a
                }), n = i.node().getBBox(), o = r.getBlock(s.id);
                o.size = {
                    width: n.width,
                    height: n.height,
                    x: 0,
                    y: 0,
                    node: i
                }, r.setBlock(o), i.remove();
            }
            async function insertBlockPositioned(t, e, r) {
                const s = getNodeFromBlock(e, 0, !0);
                if ("space" !== r.getBlock(s.id).type) {
                    const r = (0, l.zj)();
                    await Xt(t, s, {
                        config: r
                    }), e.intersect = s?.intersect, Ht(s);
                }
            }
            async function performOperations(t, e, r, s) {
                for (const a of e)await s(t, a, r), a.children && await performOperations(t, a.children, r, s);
            }
            async function calculateBlockSizes(t, e, r) {
                await performOperations(t, e, r, calculateBlockSize);
            }
            async function insertBlocks(t, e, r) {
                await performOperations(t, e, r, insertBlockPositioned);
            }
            async function insertEdges(t, e, r, s, a) {
                const i = new p.T({
                    multigraph: !0,
                    compound: !0
                });
                i.setGraph({
                    rankdir: "TB",
                    nodesep: 10,
                    ranksep: 10,
                    marginx: 8,
                    marginy: 8
                });
                for (const t of r)t.size && i.setNode(t.id, {
                    width: t.size.width,
                    height: t.size.height,
                    intersect: t.intersect
                });
                for (const r of e)if (r.start && r.end) {
                    const e = s.getBlock(r.start), n = s.getBlock(r.end);
                    if (e?.size && n?.size) {
                        const s = e.size, o = n.size, l = [
                            {
                                x: s.x,
                                y: s.y
                            },
                            {
                                x: s.x + (o.x - s.x) / 2,
                                y: s.y + (o.y - s.y) / 2
                            },
                            {
                                x: o.x,
                                y: o.y
                            }
                        ];
                        lt(t, {
                            v: r.start,
                            w: r.end,
                            name: r.id
                        }, {
                            ...r,
                            arrowTypeEnd: r.arrowTypeEnd,
                            arrowTypeStart: r.arrowTypeStart,
                            points: l,
                            classes: "edge-thickness-normal edge-pattern-solid flowchart-link LS-a1 LE-b1"
                        }, void 0, "block", i, a), r.label && (await st(t, {
                            ...r,
                            label: r.label,
                            labelStyle: "stroke: #333; stroke-width: 1.5px;fill:none;",
                            arrowTypeEnd: r.arrowTypeEnd,
                            arrowTypeStart: r.arrowTypeStart,
                            points: l,
                            classes: "edge-thickness-normal edge-pattern-solid flowchart-link LS-a1 LE-b1"
                        }), at({
                            ...r,
                            x: l[1].x,
                            y: l[1].y
                        }, {
                            originalPath: l
                        }));
                    }
                }
            }
            (0, c.K2)(getNodeFromBlock, "getNodeFromBlock"), (0, c.K2)(calculateBlockSize, "calculateBlockSize"), (0, c.K2)(insertBlockPositioned, "insertBlockPositioned"), (0, c.K2)(performOperations, "performOperations"), (0, c.K2)(calculateBlockSizes, "calculateBlockSizes"), (0, c.K2)(insertBlocks, "insertBlocks"), (0, c.K2)(insertEdges, "insertEdges");
            var Ut = (0, c.K2)(function(t, e) {
                return e.db.getClasses();
            }, "getClasses"), Zt = {
                parser: b,
                db: Y,
                renderer: {
                    draw: (0, c.K2)(async function(t, e, r, s) {
                        const { securityLevel: a, block: i } = (0, l.zj)(), n = s.db;
                        let o;
                        "sandbox" === a && (o = (0, u.Ltv)("#i" + e));
                        const d = "sandbox" === a ? (0, u.Ltv)(o.nodes()[0].contentDocument.body) : (0, u.Ltv)("body"), h = "sandbox" === a ? d.select(`[id="${e}"]`) : (0, u.Ltv)(`[id="${e}"]`);
                        Z(h, [
                            "point",
                            "circle",
                            "cross"
                        ], s.type, e);
                        const g = n.getBlocks(), p = n.getBlocksFlat(), y = n.getEdges(), b = h.insert("g").attr("class", "block");
                        await calculateBlockSizes(b, g, n);
                        const x = layout(n);
                        if (await insertBlocks(b, g, n), await insertEdges(b, y, p, n, e), x) {
                            const t = x, e = Math.max(1, Math.round(t.width / t.height * .125)), r = t.height + e + 10, s = t.width + 10, { useMaxWidth: a } = i;
                            (0, l.a$)(h, r, s, !!a), c.Rm.debug("Here Bounds", x, t), h.attr("viewBox", `${t.x - 5} ${t.y - 5} ${t.width + 10} ${t.height + 10}`);
                        }
                    }, "draw"),
                    getClasses: Ut
                },
                styles: X
            };
        },
        58054: (t, e, r)=>{
            r.d(e, {
                A: ()=>__WEBPACK_DEFAULT_EXPORT__
            });
            var s = r(77066), a = r(28510);
            const __WEBPACK_DEFAULT_EXPORT__ = (t, e)=>s.A.lang.round(a.A.parse(t)[e]);
        },
        68766: (t, e, r)=>{
            r.d(e, {
                A: ()=>a
            });
            var s = r(66608);
            const a = function clone(t) {
                return (0, s.A)(t, 4);
            };
        },
        94628: (t, e, r)=>{
            r.d(e, {
                T: ()=>Graph
            });
            var s = r(82251), a = r(86727), i = r(27371), n = r(60957), o = r(42858), l = r(94937), c = r(25571), d = r(15096), h = r(79673), g = r(36890), u = r(43182);
            const p = (0, h.A)(function(t) {
                return (0, g.A)((0, d.A)(t, 1, u.A, !0));
            });
            var y = r(53461), b = r(97653), x = "\0";
            let Graph = class Graph {
                isDirected() {
                    return this._isDirected;
                }
                isMultigraph() {
                    return this._isMultigraph;
                }
                isCompound() {
                    return this._isCompound;
                }
                setGraph(t) {
                    return this._label = t, this;
                }
                graph() {
                    return this._label;
                }
                setDefaultNodeLabel(t) {
                    return a.A(t) || (t = s.A(t)), this._defaultNodeLabelFn = t, this;
                }
                nodeCount() {
                    return this._nodeCount;
                }
                nodes() {
                    return i.A(this._nodes);
                }
                sources() {
                    var t = this;
                    return n.A(this.nodes(), function(e) {
                        return o.A(t._in[e]);
                    });
                }
                sinks() {
                    var t = this;
                    return n.A(this.nodes(), function(e) {
                        return o.A(t._out[e]);
                    });
                }
                setNodes(t, e) {
                    var r = arguments, s = this;
                    return l.A(t, function(t) {
                        r.length > 1 ? s.setNode(t, e) : s.setNode(t);
                    }), this;
                }
                setNode(t, e) {
                    return Object.prototype.hasOwnProperty.call(this._nodes, t) ? (arguments.length > 1 && (this._nodes[t] = e), this) : (this._nodes[t] = arguments.length > 1 ? e : this._defaultNodeLabelFn(t), this._isCompound && (this._parent[t] = x, this._children[t] = {}, this._children[x][t] = !0), this._in[t] = {}, this._preds[t] = {}, this._out[t] = {}, this._sucs[t] = {}, ++this._nodeCount, this);
                }
                node(t) {
                    return this._nodes[t];
                }
                hasNode(t) {
                    return Object.prototype.hasOwnProperty.call(this._nodes, t);
                }
                removeNode(t) {
                    if (Object.prototype.hasOwnProperty.call(this._nodes, t)) {
                        var removeEdge = (t)=>this.removeEdge(this._edgeObjs[t]);
                        delete this._nodes[t], this._isCompound && (this._removeFromParentsChildList(t), delete this._parent[t], l.A(this.children(t), (t)=>{
                            this.setParent(t);
                        }), delete this._children[t]), l.A(i.A(this._in[t]), removeEdge), delete this._in[t], delete this._preds[t], l.A(i.A(this._out[t]), removeEdge), delete this._out[t], delete this._sucs[t], --this._nodeCount;
                    }
                    return this;
                }
                setParent(t, e) {
                    if (!this._isCompound) throw new Error("Cannot set parent in a non-compound graph");
                    if (c.A(e)) e = x;
                    else {
                        for(var r = e += ""; !c.A(r); r = this.parent(r))if (r === t) throw new Error("Setting " + e + " as parent of " + t + " would create a cycle");
                        this.setNode(e);
                    }
                    return this.setNode(t), this._removeFromParentsChildList(t), this._parent[t] = e, this._children[e][t] = !0, this;
                }
                _removeFromParentsChildList(t) {
                    delete this._children[this._parent[t]][t];
                }
                parent(t) {
                    if (this._isCompound) {
                        var e = this._parent[t];
                        if (e !== x) return e;
                    }
                }
                children(t) {
                    if (c.A(t) && (t = x), this._isCompound) {
                        var e = this._children[t];
                        if (e) return i.A(e);
                    } else {
                        if (t === x) return this.nodes();
                        if (this.hasNode(t)) return [];
                    }
                }
                predecessors(t) {
                    var e = this._preds[t];
                    if (e) return i.A(e);
                }
                successors(t) {
                    var e = this._sucs[t];
                    if (e) return i.A(e);
                }
                neighbors(t) {
                    var e = this.predecessors(t);
                    if (e) return p(e, this.successors(t));
                }
                isLeaf(t) {
                    return 0 === (this.isDirected() ? this.successors(t) : this.neighbors(t)).length;
                }
                filterNodes(t) {
                    var e = new this.constructor({
                        directed: this._isDirected,
                        multigraph: this._isMultigraph,
                        compound: this._isCompound
                    });
                    e.setGraph(this.graph());
                    var r = this;
                    l.A(this._nodes, function(r, s) {
                        t(s) && e.setNode(s, r);
                    }), l.A(this._edgeObjs, function(t) {
                        e.hasNode(t.v) && e.hasNode(t.w) && e.setEdge(t, r.edge(t));
                    });
                    var s = {};
                    function findParent(t) {
                        var a = r.parent(t);
                        return void 0 === a || e.hasNode(a) ? (s[t] = a, a) : a in s ? s[a] : findParent(a);
                    }
                    return this._isCompound && l.A(e.nodes(), function(t) {
                        e.setParent(t, findParent(t));
                    }), e;
                }
                setDefaultEdgeLabel(t) {
                    return a.A(t) || (t = s.A(t)), this._defaultEdgeLabelFn = t, this;
                }
                edgeCount() {
                    return this._edgeCount;
                }
                edges() {
                    return y.A(this._edgeObjs);
                }
                setPath(t, e) {
                    var r = this, s = arguments;
                    return b.A(t, function(t, a) {
                        return s.length > 1 ? r.setEdge(t, a, e) : r.setEdge(t, a), a;
                    }), this;
                }
                setEdge() {
                    var t, e, r, s, a = !1, i = arguments[0];
                    "object" == typeof i && null !== i && "v" in i ? (t = i.v, e = i.w, r = i.name, 2 === arguments.length && (s = arguments[1], a = !0)) : (t = i, e = arguments[1], r = arguments[3], arguments.length > 2 && (s = arguments[2], a = !0)), t = "" + t, e = "" + e, c.A(r) || (r = "" + r);
                    var n = edgeArgsToId(this._isDirected, t, e, r);
                    if (Object.prototype.hasOwnProperty.call(this._edgeLabels, n)) return a && (this._edgeLabels[n] = s), this;
                    if (!c.A(r) && !this._isMultigraph) throw new Error("Cannot set a named edge when isMultigraph = false");
                    this.setNode(t), this.setNode(e), this._edgeLabels[n] = a ? s : this._defaultEdgeLabelFn(t, e, r);
                    var o = function edgeArgsToObj(t, e, r, s) {
                        var a = "" + e, i = "" + r;
                        if (!t && a > i) {
                            var n = a;
                            a = i, i = n;
                        }
                        var o = {
                            v: a,
                            w: i
                        };
                        s && (o.name = s);
                        return o;
                    }(this._isDirected, t, e, r);
                    return t = o.v, e = o.w, Object.freeze(o), this._edgeObjs[n] = o, incrementOrInitEntry(this._preds[e], t), incrementOrInitEntry(this._sucs[t], e), this._in[e][n] = o, this._out[t][n] = o, this._edgeCount++, this;
                }
                edge(t, e, r) {
                    var s = 1 === arguments.length ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, t, e, r);
                    return this._edgeLabels[s];
                }
                hasEdge(t, e, r) {
                    var s = 1 === arguments.length ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, t, e, r);
                    return Object.prototype.hasOwnProperty.call(this._edgeLabels, s);
                }
                removeEdge(t, e, r) {
                    var s = 1 === arguments.length ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, t, e, r), a = this._edgeObjs[s];
                    return a && (t = a.v, e = a.w, delete this._edgeLabels[s], delete this._edgeObjs[s], decrementOrRemoveEntry(this._preds[e], t), decrementOrRemoveEntry(this._sucs[t], e), delete this._in[e][s], delete this._out[t][s], this._edgeCount--), this;
                }
                inEdges(t, e) {
                    var r = this._in[t];
                    if (r) {
                        var s = y.A(r);
                        return e ? n.A(s, function(t) {
                            return t.v === e;
                        }) : s;
                    }
                }
                outEdges(t, e) {
                    var r = this._out[t];
                    if (r) {
                        var s = y.A(r);
                        return e ? n.A(s, function(t) {
                            return t.w === e;
                        }) : s;
                    }
                }
                nodeEdges(t, e) {
                    var r = this.inEdges(t, e);
                    if (r) return r.concat(this.outEdges(t, e));
                }
                constructor(t = {}){
                    this._isDirected = !Object.prototype.hasOwnProperty.call(t, "directed") || t.directed, this._isMultigraph = !!Object.prototype.hasOwnProperty.call(t, "multigraph") && t.multigraph, this._isCompound = !!Object.prototype.hasOwnProperty.call(t, "compound") && t.compound, this._label = void 0, this._defaultNodeLabelFn = s.A(void 0), this._defaultEdgeLabelFn = s.A(void 0), this._nodes = {}, this._isCompound && (this._parent = {}, this._children = {}, this._children[x] = {}), this._in = {}, this._preds = {}, this._out = {}, this._sucs = {}, this._edgeObjs = {}, this._edgeLabels = {};
                }
            };
            function incrementOrInitEntry(t, e) {
                t[e] ? t[e]++ : t[e] = 1;
            }
            function decrementOrRemoveEntry(t, e) {
                --t[e] || delete t[e];
            }
            function edgeArgsToId(t, e, r, s) {
                var a = "" + e, i = "" + r;
                if (!t && a > i) {
                    var n = a;
                    a = i, i = n;
                }
                return a + "" + i + "" + (c.A(s) ? "\0" : s);
            }
            function edgeObjToId(t, e) {
                return edgeArgsToId(t, e.v, e.w, e.name);
            }
            Graph.prototype._nodeCount = 0, Graph.prototype._edgeCount = 0;
        }
    }
]); //# sourceMappingURL=3011.350055f37b1330b67127.js.map
