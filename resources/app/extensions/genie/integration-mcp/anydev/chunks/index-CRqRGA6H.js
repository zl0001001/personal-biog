import{c as e}from"../index.js";import"node:process";import"events";import"buffer";import"string_decoder";import"path";import"node:crypto";import"http";import"crypto";import"url";import"timers/promises";import"fs";import"tty";import"os";import"util";import"stream";import"node:http";import"node:net";import"querystring";import"node:path";import"node:fs";import"node:zlib";import"node:events";import"node:buffer";import"node:url";import"node:util";import"node:child_process";import"node:fs/promises";import"node:os";import"zlib";import"https";import"net";import"tls";import"fs/promises";function _mergeNamespaces(e,t){return t.forEach(function(t){t&&"string"!=typeof t&&!Array.isArray(t)&&Object.keys(t).forEach(function(r){if("default"!==r&&!(r in e)){var n=Object.getOwnPropertyDescriptor(t,r);Object.defineProperty(e,r,n.get?n:{enumerable:!0,get:function(){return t[r]}})}})}),Object.freeze(e)}const isFunction$1=e=>"function"==typeof e,dual=function(e,t){if("function"==typeof e)return function(){return e(arguments)?t.apply(this,arguments):e=>t(e,...arguments)};switch(e){case 0:case 1:throw new RangeError("Invalid arity "+e);case 2:return function(e,r){return arguments.length>=2?t(e,r):function(r){return t(r,e)}};case 3:return function(e,r,n){return arguments.length>=3?t(e,r,n):function(n){return t(n,e,r)}};case 4:return function(e,r,n,i){return arguments.length>=4?t(e,r,n,i):function(i){return t(i,e,r,n)}};case 5:return function(e,r,n,i,s){return arguments.length>=5?t(e,r,n,i,s):function(s){return t(s,e,r,n,i)}};default:return function(){if(arguments.length>=e)return t.apply(this,arguments);const r=arguments;return function(e){return t(e,...r)}}}},identity$5=e=>e,t=identity$5,constant$2=e=>()=>e,r=constant$2(!0),n=constant$2(!1),i=constant$2(null),s=constant$2(void 0),o=s,a=dual(2,(e,t)=>r=>t(e(r))),absurd$2=e=>{throw Error("Called `absurd` function which should be uncallable")};function pipe(e,t,r,n,i,s,o,a,u){switch(arguments.length){case 1:return e;case 2:return t(e);case 3:return r(t(e));case 4:return n(r(t(e)));case 5:return i(n(r(t(e))));case 6:return s(i(n(r(t(e)))));case 7:return o(s(i(n(r(t(e))))));case 8:return a(o(s(i(n(r(t(e)))))));case 9:return u(a(o(s(i(n(r(t(e))))))));default:{let e=arguments[0];for(let t=1;t<arguments.length;t++)e=arguments[t](e);return e}}}function flow(e,t,r,n,i,s,o,a,u){switch(arguments.length){case 1:return e;case 2:return function(){return t(e.apply(this,arguments))};case 3:return function(){return r(t(e.apply(this,arguments)))};case 4:return function(){return n(r(t(e.apply(this,arguments))))};case 5:return function(){return i(n(r(t(e.apply(this,arguments)))))};case 6:return function(){return s(i(n(r(t(e.apply(this,arguments))))))};case 7:return function(){return o(s(i(n(r(t(e.apply(this,arguments)))))))};case 8:return function(){return a(o(s(i(n(r(t(e.apply(this,arguments))))))))};case 9:return function(){return u(a(o(s(i(n(r(t(e.apply(this,arguments)))))))))}}}const u=t(absurd$2);var c=Object.freeze({__proto__:null,SK:(e,t)=>t,absurd:absurd$2,apply:(...e)=>t=>t(...e),compose:a,constFalse:n,constNull:i,constTrue:r,constUndefined:s,constVoid:o,constant:constant$2,dual,flip:e=>(...t)=>(...r)=>e(...r)(...t),flow,hole:u,identity:identity$5,isFunction:isFunction$1,pipe,satisfies:()=>e=>e,tupled:e=>t=>e(...t),unsafeCoerce:t,untupled:e=>(...t)=>e(t)});const make$2l=e=>(t,r)=>t===r||e(t,r),isStrictEquivalent=(e,t)=>e===t,strict=()=>isStrictEquivalent,l=strict(),p=strict(),d=strict(),m=strict(),g=strict(),y=dual(2,(e,t)=>make$2l((r,n)=>e(r,n)&&t(r,n))),b=dual(2,(e,t)=>make$2l((r,n)=>{if(!e(r,n))return!1;for(const e of t)if(!e(r,n))return!1;return!0})),isAlwaysEquivalent=(e,t)=>!0,S=dual(2,(e,t)=>make$2l((r,n)=>e(t(r),t(n)))),v=S(p,e=>e.getTime()),_=dual(2,(e,t)=>make$2l(([r,n],[i,s])=>e(r,i)&&t(n,s))),all$e=e=>make$2l((t,r)=>{const n=Math.min(t.length,r.length);let i=0;for(const s of e){if(i>=n)break;if(!s(t[i],r[i]))return!1;i++}return!0}),tuple$6=(...e)=>all$e(e),array$7=e=>make$2l((t,r)=>{if(t.length!==r.length)return!1;for(let n=0;n<t.length;n++)if(!e(t[n],r[n]))return!1;return!0}),struct$5=e=>{const t=Object.keys(e);return make$2l((r,n)=>{for(const i of t)if(!e[i](r[i],n[i]))return!1;return!0})};var w=Object.freeze({__proto__:null,Date:v,all:all$e,array:array$7,bigint:m,boolean:d,combine:y,combineAll:e=>b(isAlwaysEquivalent,e),combineMany:b,make:make$2l,mapInput:S,number:p,product:_,productMany:(e,t)=>{const r=all$e(t);return make$2l((t,n)=>!!e(t[0],n[0])&&r(t.slice(1),n.slice(1)))},strict,string:l,struct:struct$5,symbol:g,tuple:tuple$6});const let_$a=e=>dual(3,(t,name,r)=>e(t,e=>({...e,[name]:r(e)}))),bindTo$a=e=>dual(2,(t,name)=>e(t,e=>({[name]:e}))),bind$a=(e,t)=>dual(3,(r,name,n)=>t(r,t=>e(n(t),e=>({...t,[name]:e})))),k="effect/GlobalValue";let x;const globalValue=(e,t)=>(x||(globalThis[k]??=new Map,x=globalThis[k]),x.has(e)||x.set(e,t()),x.get(e));var I=Object.freeze({__proto__:null,globalValue});const T=dual(2,(e,t)=>r=>e(t(r))),O=dual(2,(e,t)=>e.length===t),E=dual(2,(e,t)=>e.length>=t),isTruthy=e=>!!e,isSet=e=>e instanceof Set,isMap=e=>e instanceof Map,isString$1=e=>"string"==typeof e,isNumber$1=e=>"number"==typeof e,isBoolean$1=e=>"boolean"==typeof e,isBigInt$1=e=>"bigint"==typeof e,isSymbol$1=e=>"symbol"==typeof e,isPropertyKey=e=>isString$1(e)||isNumber$1(e)||isSymbol$1(e),A=isFunction$1,isUndefined=e=>void 0===e,isNotUndefined=e=>void 0!==e,isNull=e=>null===e,isNotNull=e=>null!==e,isNever=e=>!1,isRecordOrArray=e=>"object"==typeof e&&null!==e,isObject=e=>isRecordOrArray(e)||A(e),C=dual(2,(e,t)=>isObject(e)&&t in e),M=dual(2,(e,t)=>C(e,"_tag")&&e._tag===t),isNullable=e=>null==e,isNotNullable=e=>null!=e,isUint8Array=e=>e instanceof Uint8Array,isDate=e=>e instanceof Date,isIterable=e=>"string"==typeof e||C(e,Symbol.iterator),isRecord=e=>isRecordOrArray(e)&&!Array.isArray(e),F=isRecord,isPromiseLike=e=>C(e,"then")&&A(e.then),isRegExp$1=e=>e instanceof RegExp,P=dual(2,(e,t)=>r=>e(r)&&t(r)),all$d=e=>t=>{let r=0;for(const n of e){if(r>=t.length)break;if(!1===n(t[r]))return!1;r++}return!0},N=dual(2,(e,t)=>r=>e(r)||t(r)),j=dual(2,(e,t)=>r=>e(r)&&t(r)),R=dual(2,(e,t)=>r=>e(r)!==t(r)),D=dual(2,(e,t)=>r=>e(r)===t(r)),L=dual(2,(e,t)=>r=>!e(r)||t(r)),U=dual(2,(e,t)=>r=>!(e(r)||t(r)));var $=Object.freeze({__proto__:null,all:all$d,and:j,compose:P,eqv:D,every:e=>t=>{for(const r of e)if(!r(t))return!1;return!0},hasProperty:C,implies:L,isBigInt:isBigInt$1,isBoolean:isBoolean$1,isDate,isError:e=>e instanceof Error,isFunction:A,isIterable,isMap,isNever,isNotNull,isNotNullable,isNotUndefined,isNull,isNullable,isNumber:isNumber$1,isObject,isPromise:e=>C(e,"then")&&"catch"in e&&A(e.then)&&A(e.catch),isPromiseLike,isPropertyKey,isReadonlyRecord:F,isRecord,isRecordOrArray,isRegExp:isRegExp$1,isSet,isString:isString$1,isSymbol:isSymbol$1,isTagged:M,isTruthy,isTupleOf:O,isTupleOfAtLeast:E,isUint8Array,isUndefined,isUnknown:e=>!0,mapInput:T,nand:dual(2,(e,t)=>r=>!(e(r)&&t(r))),nor:U,not:e=>t=>!e(t),or:N,product:(e,t)=>([r,n])=>e(r)&&t(n),productMany:(e,t)=>{const r=all$d(t);return([t,...n])=>!1!==e(t)&&r(n)},some:e=>t=>{for(const r of e)if(r(t))return!0;return!1},struct:e=>{const t=Object.keys(e);return r=>{for(const n of t)if(!e[n](r[n]))return!1;return!0}},tuple:(...e)=>all$d(e),xor:R});const getBugErrorMessage=e=>`BUG: ${e} - please report an issue at https://github.com/Effect-TS/effect/issues`,B=Symbol.for("effect/Gen/GenKind"),isGenKind=e=>isObject(e)&&B in e;class GenKindImpl{value;constructor(e){this.value=e}get _F(){return identity$5}get _R(){return e=>e}get _O(){return e=>e}get _E(){return e=>e}[B]=B;[Symbol.iterator](){return new z(this)}}let z=class SingleShotGen{self;called=!1;constructor(e){this.self=e}next(e){return this.called?{value:e,done:!0}:(this.called=!0,{value:this.self,done:!1})}return(e){return{value:e,done:!0}}throw(e){throw e}[Symbol.iterator](){return new SingleShotGen(this.self)}};const adapter$3=()=>function(){let e=arguments[0];for(let t=1;t<arguments.length;t++)e=arguments[t](e);return new GenKindImpl(e)};class PCGRandom{_state;constructor(e,t,r,n){return isNullable(t)&&isNullable(e)?(t=4294967295*Math.random()>>>0,e=0):isNullable(t)&&(t=e,e=0),isNullable(n)&&isNullable(r)?(n=this._state?this._state[3]:4150755663,r=this._state?this._state[2]:335903614):isNullable(n)&&(n=r,r=0),this._state=new Int32Array([0,0,r>>>0,(1|(n||0))>>>0]),this._next(),add64(this._state,this._state[0],this._state[1],e>>>0,t>>>0),this._next(),this}getState(){return[this._state[0],this._state[1],this._state[2],this._state[3]]}setState(e){this._state[0]=e[0],this._state[1]=e[1],this._state[2]=e[2],this._state[3]=1|e[3]}integer(e){return Math.round(this.number()*Number.MAX_SAFE_INTEGER)%e}number(){return(1*(67108863&this._next())*134217728+1*(134217727&this._next()))/9007199254740992}_next(){const e=this._state[0]>>>0,t=this._state[1]>>>0;!function(e,t,r,n,i){let s=32557*(r>>>16)>>>0,o=19605*(65535&r)>>>0,a=32557*(65535&r)>>>0,u=19605*(r>>>16)+((o>>>16)+(s>>>16))>>>0;o=o<<16>>>0,a=a+o>>>0,a>>>0<o>>>0&&(u=u+1>>>0),s=s<<16>>>0,a=a+s>>>0,a>>>0<s>>>0&&(u=u+1>>>0),u=u+Math.imul(r,1481765933)>>>0,u=u+Math.imul(t,i)>>>0,e[0]=u,e[1]=a}(this._state,e,t,0,1284865837),add64(this._state,this._state[0],this._state[1],this._state[2],this._state[3]);let r=e>>>18,n=(t>>>18|e<<14)>>>0;r=(r^e)>>>0,n=(n^t)>>>0;const i=(n>>>27|r<<5)>>>0,s=e>>>27;return(i>>>s|i<<((-s>>>0&31)>>>0))>>>0}}function add64(e,t,r,n,i){let s=t+n>>>0;const o=r+i>>>0;o>>>0<r>>>0&&(s=s+1|0),e[0]=s,e[1]=o}const q=Symbol.for("effect/Utils/YieldWrap");class YieldWrap{#e;constructor(e){this.#e=e}[q](){return this.#e}}function yieldWrapGet(e){if("object"==typeof e&&null!==e&&q in e)return e[q]();throw Error(getBugErrorMessage("yieldWrapGet"))}const W=globalValue("effect/Utils/isStructuralRegion",()=>({enabled:!1,tester:void 0})),V={effect_internal_function:e=>e()},K=!0===V.effect_internal_function(()=>Error().stack)?.includes("effect_internal_function")?V.effect_internal_function:e=>{try{return e()}finally{}},G=function*(){}.constructor,isGeneratorFunction=e=>isObject(e)&&e.constructor===G;var J=Object.freeze({__proto__:null,GenKindImpl,GenKindTypeId:B,PCGRandom,SingleShotGen:z,YieldWrap,YieldWrapTypeId:q,adapter:adapter$3,internalCall:K,isGenKind,isGeneratorFunction,makeGenKind:e=>new GenKindImpl(e),structuralRegion:(e,t)=>{const r=W.enabled,n=W.tester;W.enabled=!0,t&&(W.tester=t);try{return e()}finally{W.enabled=r,W.tester=n}},structuralRegionState:W,yieldWrapGet});const H=globalValue(Symbol.for("effect/Hash/randomHashCache"),()=>new WeakMap),Z=Symbol.for("effect/Hash"),hash$3=e=>{if(!0===W.enabled)return 0;switch(typeof e){case"number":return number$4(e);case"bigint":return string$6(e.toString(10));case"boolean":case"symbol":return string$6(e+"");case"string":return string$6(e);case"undefined":return string$6("undefined");case"function":case"object":return null===e?string$6("null"):e instanceof Date?hash$3(e.toISOString()):e instanceof URL?hash$3(e.href):isHash(e)?e[Z]():random$2(e);default:throw Error(`BUG: unhandled typeof ${typeof e} - please report an issue at https://github.com/Effect-TS/effect/issues`)}},random$2=e=>(H.has(e)||H.set(e,number$4(Math.floor(Math.random()*Number.MAX_SAFE_INTEGER))),H.get(e)),combine$h=e=>t=>53*t^e,optimize=e=>3221225471&e|e>>>1&1073741824,isHash=e=>C(e,Z),number$4=e=>{if(e!=e||e===1/0)return 0;let t=0|e;for(t!==e&&(t^=4294967295*e);e>4294967295;)t^=e/=4294967295;return optimize(t)},string$6=e=>{let t=5381,r=e.length;for(;r;)t=33*t^e.charCodeAt(--r);return optimize(t)},structureKeys=(e,t)=>{let r=12289;for(let n=0;n<t.length;n++)r^=pipe(string$6(t[n]),combine$h(hash$3(e[t[n]])));return optimize(r)},structure=e=>structureKeys(e,Object.keys(e)),array$6=e=>{let t=6151;for(let r=0;r<e.length;r++)t=pipe(t,combine$h(hash$3(e[r])));return optimize(t)},cached$2=function(){if(1===arguments.length){const e=arguments[0];return function(t){return Object.defineProperty(e,Z,{value:()=>t,enumerable:!1}),t}}const e=arguments[1];return Object.defineProperty(arguments[0],Z,{value:()=>e,enumerable:!1}),e};var Q=Object.freeze({__proto__:null,array:array$6,cached:cached$2,combine:combine$h,hash:hash$3,isHash,number:number$4,optimize,random:random$2,string:string$6,structure,structureKeys,symbol:Z});const Y=Symbol.for("effect/Equal");function equals$4(){return 1===arguments.length?e=>compareBoth(e,arguments[0]):compareBoth(arguments[0],arguments[1])}function compareBoth(e,t){if(e===t)return!0;const r=typeof e;if(r!==typeof t)return!1;if("object"===r||"function"===r){if(null!==e&&null!==t){if(isEqual(e)&&isEqual(t))return!(hash$3(e)!==hash$3(t)||!e[Y](t))||!(!W.enabled||!W.tester)&&W.tester(e,t);if(e instanceof Date&&t instanceof Date)return e.toISOString()===t.toISOString();if(e instanceof URL&&t instanceof URL)return e.href===t.href}if(W.enabled){if(Array.isArray(e)&&Array.isArray(t))return e.length===t.length&&e.every((e,r)=>compareBoth(e,t[r]));if(Object.getPrototypeOf(e)===Object.prototype&&Object.getPrototypeOf(e)===Object.prototype){const r=Object.keys(e),n=Object.keys(t);if(r.length===n.length){for(const n of r)if(!(n in t)||!compareBoth(e[n],t[n]))return!!W.tester&&W.tester(e,t);return!0}}return!!W.tester&&W.tester(e,t)}}return!(!W.enabled||!W.tester)&&W.tester(e,t)}const isEqual=e=>C(e,Y),equivalence$1=()=>equals$4;var X=Object.freeze({__proto__:null,equals:equals$4,equivalence:equivalence$1,isEqual,symbol:Y});const ee=Symbol.for("nodejs.util.inspect.custom"),toJSON=e=>{try{if(C(e,"toJSON")&&A(e.toJSON)&&0===e.toJSON.length)return e.toJSON();if(Array.isArray(e))return e.map(toJSON)}catch{return{}}return redact(e)},format$6=e=>JSON.stringify(e,null,2),te={toJSON(){return toJSON(this)},[ee](){return this.toJSON()},toString(){return format$6(this.toJSON())}},toStringUnknown=(e,t=2)=>{if("string"==typeof e)return e;try{return"object"==typeof e?stringifyCircular(e,t):e+""}catch{return e+""}},stringifyCircular=(e,t)=>{let r=[];const n=JSON.stringify(e,(e,t)=>"object"==typeof t&&null!==t?r.includes(t)?void 0:r.push(t)&&(void 0!==ne.fiberRefs&&isRedactable(t)?t[re](ne.fiberRefs):t):t,t);return r=void 0,n},re=Symbol.for("effect/Inspectable/Redactable"),isRedactable=e=>"object"==typeof e&&null!==e&&re in e,ne=globalValue("effect/Inspectable/redactableState",()=>({fiberRefs:void 0})),withRedactableContext=(e,t)=>{const r=ne.fiberRefs;ne.fiberRefs=e;try{return t()}finally{ne.fiberRefs=r}},redact=e=>isRedactable(e)&&void 0!==ne.fiberRefs?e[re](ne.fiberRefs):e;var ie=Object.freeze({__proto__:null,BaseProto:te,Class:class{[ee](){return this.toJSON()}toString(){return format$6(this.toJSON())}},NodeInspectSymbol:ee,format:format$6,isRedactable,redact,stringifyCircular,symbolRedactable:re,toJSON,toStringUnknown,withRedactableContext});const pipeArguments=(e,t)=>{switch(t.length){case 0:return e;case 1:return t[0](e);case 2:return t[1](t[0](e));case 3:return t[2](t[1](t[0](e)));case 4:return t[3](t[2](t[1](t[0](e))));case 5:return t[4](t[3](t[2](t[1](t[0](e)))));case 6:return t[5](t[4](t[3](t[2](t[1](t[0](e))))));case 7:return t[6](t[5](t[4](t[3](t[2](t[1](t[0](e)))))));case 8:return t[7](t[6](t[5](t[4](t[3](t[2](t[1](t[0](e))))))));case 9:return t[8](t[7](t[6](t[5](t[4](t[3](t[2](t[1](t[0](e)))))))));default:{let r=e;for(let e=0,n=t.length;e<n;e++)r=t[e](r);return r}}},se={pipe(){return pipeArguments(this,arguments)}},oe=function(){function PipeableBase(){}return PipeableBase.prototype=se,PipeableBase}();var ae=Object.freeze({__proto__:null,Class:e=>e?class extends e{pipe(){return pipeArguments(this,arguments)}}:oe,Prototype:se,pipeArguments});const ue="Async",ce="Commit",le="Failure",pe="OnFailure",fe="OnSuccess",he="OnSuccessAndFailure",de="Success",me="Sync",ge="Tag",ye="UpdateRuntimeFlags",be="While",Se="Iterator",ve="WithRuntime",_e="Yield",we="RevertFlags";let ke="3.18.4";const getCurrentVersion$1=()=>ke,xe=Symbol.for("effect/Effect"),Ie=Symbol.for("effect/Stream"),Te=Symbol.for("effect/Sink"),Oe=Symbol.for("effect/Channel"),Ee={_R:e=>e,_E:e=>e,_A:e=>e,_V:getCurrentVersion$1()},Ae={[xe]:Ee,[Ie]:Ee,[Te]:{_A:e=>e,_In:e=>e,_L:e=>e,_E:e=>e,_R:e=>e},[Oe]:{_Env:e=>e,_InErr:e=>e,_InElem:e=>e,_InDone:e=>e,_OutErr:e=>e,_OutElem:e=>e,_OutDone:e=>e},[Y](e){return this===e},[Z](){return cached$2(this,random$2(this))},[Symbol.iterator](){return new z(new YieldWrap(this))},pipe(){return pipeArguments(this,arguments)}},Ce={[Z](){return cached$2(this,structure(this))},[Y](e){const t=Object.keys(this),r=Object.keys(e);if(t.length!==r.length)return!1;for(const r of t)if(!(r in e)||!equals$4(this[r],e[r]))return!1;return!0}},Me={...Ae,_op:ce},Fe={...Me,...Ce},Pe=function(){function Base(){}return Base.prototype=Me,Base}(),Ne=function(){function Base(){}return Base.prototype=Fe,Base}(),je=Symbol.for("effect/Option"),Re={...Ae,[je]:{_A:e=>e},[ee](){return this.toJSON()},toString(){return format$6(this.toJSON())}},De=Object.assign(Object.create(Re),{_tag:"Some",_op:"Some",[Y](e){return isOption$1(e)&&isSome$1(e)&&equals$4(this.value,e.value)},[Z](){return cached$2(this,combine$h(hash$3(this._tag))(hash$3(this.value)))},toJSON(){return{_id:"Option",_tag:this._tag,value:toJSON(this.value)}}}),Le=hash$3("None"),Ue=Object.assign(Object.create(Re),{_tag:"None",_op:"None",[Y]:e=>isOption$1(e)&&isNone$3(e),[Z]:()=>Le,toJSON(){return{_id:"Option",_tag:this._tag}}}),isOption$1=e=>C(e,je),isNone$3=e=>"None"===e._tag,isSome$1=e=>"Some"===e._tag,$e=Object.create(Ue),some$k=e=>{const t=Object.create(De);return t.value=e,t},Be=Symbol.for("effect/Either"),ze={...Ae,[Be]:{_R:e=>e},[ee](){return this.toJSON()},toString(){return format$6(this.toJSON())}},qe=Object.assign(Object.create(ze),{_tag:"Right",_op:"Right",[Y](e){return isEither$4(e)&&isRight$3(e)&&equals$4(this.right,e.right)},[Z](){return combine$h(hash$3(this._tag))(hash$3(this.right))},toJSON(){return{_id:"Either",_tag:this._tag,right:toJSON(this.right)}}}),We=Object.assign(Object.create(ze),{_tag:"Left",_op:"Left",[Y](e){return isEither$4(e)&&isLeft$3(e)&&equals$4(this.left,e.left)},[Z](){return combine$h(hash$3(this._tag))(hash$3(this.left))},toJSON(){return{_id:"Either",_tag:this._tag,left:toJSON(this.left)}}}),isEither$4=e=>C(e,Be),isLeft$3=e=>"Left"===e._tag,isRight$3=e=>"Right"===e._tag,left$1=e=>{const t=Object.create(We);return t.left=e,t},right$1=e=>{const t=Object.create(qe);return t.right=e,t},getLeft$2=e=>isRight$3(e)?$e:some$k(e.left),getRight$2=e=>isLeft$3(e)?$e:some$k(e.right),Ve=dual(2,(e,t)=>isNone$3(e)?left$1(t()):right$1(e.value)),Ke=Be,Ge=right$1,Je=Ge(void 0),He=left$1,Ze=dual(2,(e,t)=>null==e?He(t(e)):Ge(e)),Qe=Ve,try_$5=e=>{if(A(e))try{return Ge(e())}catch(e){return He(e)}else try{return Ge(e.try())}catch(t){return He(e.catch(t))}},Ye=isEither$4,Xe=isLeft$3,et=isRight$3,tt=getRight$2,rt=getLeft$2,getEquivalence$9=({left:e,right:t})=>make$2l((r,n)=>Xe(r)?Xe(n)&&e(r.left,n.left):et(n)&&t(r.right,n.right)),nt=dual(2,(e,{onLeft:t,onRight:r})=>Xe(e)?He(t(e.left)):Ge(r(e.right))),it=dual(2,(e,t)=>Xe(e)?He(t(e.left)):Ge(e.right)),st=dual(2,(e,t)=>et(e)?Ge(t(e.right)):He(e.left)),ot=dual(2,(e,{onLeft:t,onRight:r})=>Xe(e)?t(e.left):r(e.right)),at=dual(3,(e,t,r)=>t(e)?Ge(e):He(r(e))),ut=dual(3,(e,t,r)=>gt(e,e=>t(e)?Ge(e):He(r(e)))),ct=ot({onLeft:identity$5,onRight:identity$5}),lt=dual(2,(e,t)=>Xe(e)?t(e.left):e.right),pt=lt(i),ft=lt(s),ht=dual(2,(e,t)=>{if(et(e))return e.right;throw t(e.left)}),dt=ht(()=>Error("getOrThrow called on a Left")),mt=dual(2,(e,t)=>Xe(e)?t(e.left):Ge(e.right)),gt=dual(2,(e,t)=>Xe(e)?He(e.left):t(e.right)),yt=dual(2,(e,t)=>gt(e,e=>{const r=A(t)?t(e):t;return Ye(r)?r:Ge(r)})),bt=dual(3,(e,t,r)=>gt(e,e=>st(t,t=>r(e,t)))),St=dual(2,(e,t)=>bt(e,t,(e,t)=>e(t))),all$c=e=>{if(Symbol.iterator in e){const t=[];for(const r of e){if(Xe(r))return r;t.push(r.right)}return Ge(t)}const t={};for(const r of Object.keys(e)){const n=e[r];if(Xe(n))return n;t[r]=n.right}return Ge(t)},vt=adapter$3(),_t=Ge({}),wt=bind$a(st,gt),kt=bindTo$a(st),xt=let_$a(st),It=dual(2,(e,t)=>isNone$3(e)?Ge($e):st(t(e.value),some$k));var Tt=Object.freeze({__proto__:null,Do:_t,TypeId:Ke,all:all$c,andThen:yt,ap:St,bind:wt,bindTo:kt,filterOrLeft:ut,flatMap:gt,flip:e=>Xe(e)?Ge(e.left):He(e.right),fromNullable:Ze,fromOption:Qe,gen:(...e)=>{const t=(1===e.length?e[0]:e[1].bind(e[0]))(vt);let r=t.next();for(;!r.done;){const e=isGenKind(r.value)?r.value.value:yieldWrapGet(r.value);if(Xe(e))return e;r=t.next(e.right)}return Ge(r.value)},getEquivalence:getEquivalence$9,getLeft:rt,getOrElse:lt,getOrNull:pt,getOrThrow:dt,getOrThrowWith:ht,getOrUndefined:ft,getRight:tt,isEither:Ye,isLeft:Xe,isRight:et,left:He,let:xt,liftPredicate:at,map:st,mapBoth:nt,mapLeft:it,match:ot,merge:ct,orElse:mt,right:Ge,transposeMapOption:It,transposeOption:e=>isNone$3(e)?Ge($e):st(e.value,some$k),try:try_$5,void:Je,zipWith:bt});const isNonEmptyArray$1=e=>e.length>0,make$2k=e=>(t,r)=>t===r?0:e(t,r),Ot=make$2k((e,t)=>e<t?-1:1),Et=make$2k((e,t)=>e<t?-1:1),At=make$2k((e,t)=>e<t?-1:1),Ct=make$2k((e,t)=>e<t?-1:1),Mt=dual(2,(e,t)=>make$2k((r,n)=>{const i=e(r,n);return 0!==i?i:t(r,n)})),Ft=dual(2,(e,t)=>make$2k((r,n)=>{let i=e(r,n);if(0!==i)return i;for(const e of t)if(i=e(r,n),0!==i)return i;return i})),empty$X=()=>make$2k(()=>0),combineAll$3=e=>Ft(empty$X(),e),Pt=dual(2,(e,t)=>make$2k((r,n)=>e(t(r),t(n)))),Nt=Pt(Et,e=>e.getTime()),jt=dual(2,(e,t)=>make$2k(([r,n],[i,s])=>{const o=e(r,i);return 0!==o?o:t(n,s)})),all$b=e=>make$2k((t,r)=>{const n=Math.min(t.length,r.length);let i=0;for(const s of e){if(i>=n)break;const e=s(t[i],r[i]);if(0!==e)return e;i++}return 0}),Rt=dual(2,(e,t)=>{const r=all$b(t);return make$2k((t,n)=>{const i=e(t[0],n[0]);return 0!==i?i:r(t.slice(1),n.slice(1))})}),tuple$4=(...e)=>all$b(e),array$5=e=>make$2k((t,r)=>{const n=t.length,i=r.length,s=Math.min(n,i);for(let n=0;n<s;n++){const i=e(t[n],r[n]);if(0!==i)return i}return Et(n,i)}),struct$3=e=>{const t=Object.keys(e);return make$2k((r,n)=>{for(const i of t){const t=e[i](r[i],n[i]);if(0!==t)return t}return 0})},lessThan$e=e=>dual(2,(t,r)=>-1===e(t,r)),greaterThan$a=e=>dual(2,(t,r)=>1===e(t,r)),lessThanOrEqualTo$7=e=>dual(2,(t,r)=>1!==e(t,r)),greaterThanOrEqualTo$7=e=>dual(2,(t,r)=>-1!==e(t,r)),min$9=e=>dual(2,(t,r)=>t===r||e(t,r)<1?t:r),max$b=e=>dual(2,(t,r)=>t===r||e(t,r)>-1?t:r),clamp$8=e=>dual(2,(t,r)=>min$9(e)(r.maximum,max$b(e)(r.minimum,t))),between$7=e=>dual(2,(t,r)=>!lessThan$e(e)(t,r.minimum)&&!greaterThan$a(e)(t,r.maximum));var Dt=Object.freeze({__proto__:null,Date:Nt,all:all$b,array:array$5,between:between$7,bigint:Ct,boolean:At,clamp:clamp$8,combine:Mt,combineAll:combineAll$3,combineMany:Ft,empty:empty$X,greaterThan:greaterThan$a,greaterThanOrEqualTo:greaterThanOrEqualTo$7,lessThan:lessThan$e,lessThanOrEqualTo:lessThanOrEqualTo$7,make:make$2k,mapInput:Pt,max:max$b,min:min$9,number:Et,product:jt,productMany:Rt,reverse:e=>make$2k((t,r)=>e(r,t)),string:Ot,struct:struct$3,tuple:tuple$4});const Lt=Symbol.for("effect/Option"),none$c=()=>$e,Ut=some$k,$t=isOption$1,Bt=isNone$3,zt=isSome$1,qt=dual(2,(e,{onNone:t,onSome:r})=>Bt(e)?t():r(e.value)),Wt=getRight$2,Vt=getLeft$2,Kt=dual(2,(e,t)=>Bt(e)?t():e.value),Gt=dual(2,(e,t)=>Bt(e)?t():e),Jt=dual(2,(e,t)=>Bt(e)?Ut(t()):e),Ht=dual(2,(e,t)=>Bt(e)?er(t(),right$1):er(e,left$1)),fromNullable$3=e=>null==e?none$c():Ut(e),Zt=Kt(i),Qt=Kt(s),liftThrowable=e=>(...t)=>{try{return Ut(e(...t))}catch{return none$c()}},Yt=dual(2,(e,t)=>{if(zt(e))return e.value;throw t()}),Xt=Yt(()=>Error("getOrThrow called on a None")),er=dual(2,(e,t)=>Bt(e)?none$c():Ut(t(e.value))),tr=dual(2,(e,t)=>er(e,()=>t)),rr=tr(void 0),nr=Ut(void 0),ir=dual(2,(e,t)=>Bt(e)?none$c():t(e.value)),sr=dual(2,(e,t)=>ir(e,e=>{const r=isFunction$1(t)?t(e):t;return $t(r)?r:Ut(r)})),or=dual(2,(e,t)=>Bt(e)?none$c():fromNullable$3(t(e.value))),ar=ir(identity$5),ur=dual(2,(e,t)=>ir(e,()=>t)),cr=dual(2,(e,t)=>pr(e,()=>t)),lr=dual(2,(e,t)=>r=>ir(e(r),t)),pr=dual(2,(e,t)=>ir(e,e=>er(t(e),()=>e))),product=(e,t)=>zt(e)&&zt(t)?Ut([e.value,t.value]):none$c(),all$a=e=>{if(Symbol.iterator in e){const t=[];for(const r of e){if(Bt(r))return none$c();t.push(r.value)}return Ut(t)}const t={};for(const r of Object.keys(e)){const n=e[r];if(Bt(n))return none$c();t[r]=n.value}return Ut(t)},fr=dual(3,(e,t,r)=>er(product(e,t),([e,t])=>r(e,t))),hr=dual(2,(e,t)=>fr(e,t,(e,t)=>e(t))),dr=dual(3,(e,t,r)=>{let n=t;for(const t of e)zt(t)&&(n=r(n,t.value));return n}),toArray$a=e=>Bt(e)?[]:[e.value],mr=dual(2,(e,t)=>{if(Bt(e))return[none$c(),none$c()];const r=t(e.value);return isLeft$3(r)?[Ut(r.left),none$c()]:[none$c(),Ut(r.right)]}),gr=ir,yr=dual(2,(e,t)=>gr(e,e=>t(e)?some$k(e):$e)),getEquivalence$8=e=>make$2l((t,r)=>Bt(t)?Bt(r):!Bt(r)&&e(t.value,r.value)),br=dual(2,(e,t)=>t(e)?Ut(e):none$c()),containsWith$3=e=>dual(2,(t,r)=>!Bt(t)&&e(t.value,r)),Sr=containsWith$3(equivalence$1()),vr=dual(2,(e,t)=>!Bt(e)&&t(e.value)),_r=bindTo$a(er),wr=let_$a(er),kr=bind$a(er,ir),xr=Ut({}),Ir=adapter$3(),mergeWith$4=e=>(t,r)=>Bt(t)?r:Bt(r)?t:Ut(e(t.value,r.value));var Tr=Object.freeze({__proto__:null,Do:xr,TypeId:Lt,all:all$a,andThen:sr,ap:hr,as:tr,asVoid:rr,bind:kr,bindTo:_r,composeK:lr,contains:Sr,containsWith:containsWith$3,exists:vr,filter:yr,filterMap:gr,firstSomeOf:e=>{let t=none$c();for(t of e)if(zt(t))return t;return t},flatMap:ir,flatMapNullable:or,flatten:ar,fromIterable:e=>{for(const t of e)return Ut(t);return none$c()},fromNullable:fromNullable$3,gen:(...e)=>{const t=(1===e.length?e[0]:e[1].bind(e[0]))(Ir);let r=t.next();for(;!r.done;){const e=isGenKind(r.value)?r.value.value:yieldWrapGet(r.value);if(Bt(e))return e;r=t.next(e.value)}return Ut(r.value)},getEquivalence:getEquivalence$8,getLeft:Vt,getOrElse:Kt,getOrNull:Zt,getOrThrow:Xt,getOrThrowWith:Yt,getOrUndefined:Qt,getOrder:e=>make$2k((t,r)=>zt(t)?zt(r)?e(t.value,r.value):1:-1),getRight:Wt,isNone:Bt,isOption:$t,isSome:zt,let:wr,lift2:e=>dual(2,(t,r)=>fr(t,r,e)),liftNullable:e=>(...t)=>fromNullable$3(e(...t)),liftPredicate:br,liftThrowable,map:er,match:qt,mergeWith:mergeWith$4,none:none$c,orElse:Gt,orElseEither:Ht,orElseSome:Jt,partitionMap:mr,product,productMany:(e,t)=>{if(Bt(e))return none$c();const r=[e.value];for(const e of t){if(Bt(e))return none$c();r.push(e.value)}return Ut(r)},reduceCompact:dr,some:Ut,tap:pr,toArray:toArray$a,toRefinement:e=>t=>zt(e(t)),void:nr,zipLeft:cr,zipRight:ur,zipWith:fr});const make$2j=(...e)=>e,Or=dual(2,(e,t)=>e.map(e=>t(e))),Er=dual(2,(e,{onFirst:t,onSecond:r})=>[t(e[0]),r(e[1])]),Ar=dual(2,(e,t)=>[t(e[0]),e[1]]),Cr=dual(2,(e,t)=>[e[0],t(e[1])]),Mr=tuple$6,Fr=tuple$4;var Pr=Object.freeze({__proto__:null,appendElement:dual(2,(e,t)=>[...e,t]),at:dual(2,(e,t)=>e[t]),getEquivalence:Mr,getFirst:e=>e[0],getOrder:Fr,getSecond:e=>e[1],isTupleOf:O,isTupleOfAtLeast:E,make:make$2j,map:Or,mapBoth:Er,mapFirst:Ar,mapSecond:Cr,swap:e=>[e[1],e[0]]});const makeBy$2=(e,t)=>{const r=void 0!==t?.length?Math.max(1,Math.floor(t.length)):1/0;return{[Symbol.iterator](){let t=0;return{next:()=>t<r?{value:e(t++),done:!1}:{done:!0,value:void 0}}}}},Nr=dual(2,(e,t)=>makeBy$2(()=>e,{length:t})),jr=dual(2,(e,t)=>Rr(e,[t])),Rr=dual(2,(e,t)=>Lr(t,e)),Dr=dual(2,(e,t)=>Lr(e,[t])),Lr=dual(2,(e,t)=>({[Symbol.iterator](){const r=e[Symbol.iterator]();let n,i=!1;return{next(){if(!i){const e=r.next();return e.done?(i=!0,n=t[Symbol.iterator](),n.next()):e}return n.next()}}}})),Ur=dual(3,(e,t,r)=>({[Symbol.iterator](){let n,i=t;return{next:function(){if(void 0===n)return n=e[Symbol.iterator](),{done:!1,value:i};const t=n.next();return t.done?t:(i=r(i,t.value),{done:!1,value:i})}}}})),head$b=e=>{const t=e[Symbol.iterator]().next();return t.done?none$c():Ut(t.value)},unsafeHead$2=e=>{const t=e[Symbol.iterator]().next();if(t.done)throw Error("unsafeHead: empty iterable");return t.value},$r=dual(2,(e,t)=>({[Symbol.iterator](){let r=0;const n=e[Symbol.iterator]();return{next:()=>r<t?(r++,n.next()):{done:!0,value:void 0}}}})),Br=dual(2,(e,t)=>({[Symbol.iterator](){const r=e[Symbol.iterator]();let n=0;return{next(){const e=r.next();return e.done||!t(e.value,n++)?{done:!0,value:void 0}:e}}}})),zr=dual(2,(e,t)=>({[Symbol.iterator](){const r=e[Symbol.iterator]();let n=0;return{next(){for(;n<t;){if(r.next().done)return{done:!0,value:void 0};n++}return r.next()}}}})),qr=dual(2,(e,t)=>{let r=0;for(const n of e){const e=t(n,r);if(isBoolean$1(e)){if(e)return Ut(n)}else if(zt(e))return e;r++}return none$c()}),Wr=dual(2,(e,t)=>{let r=0,n=none$c();for(const i of e){const e=t(i,r);isBoolean$1(e)?e&&(n=Ut(i)):zt(e)&&(n=e),r++}return n}),Vr=dual(2,(e,t)=>Kr(e,t,make$2j)),Kr=dual(3,(e,t,r)=>({[Symbol.iterator](){const n=e[Symbol.iterator](),i=t[Symbol.iterator]();return{next(){const e=n.next(),t=i.next();return e.done||t.done?{done:!0,value:void 0}:{done:!1,value:r(e.value,t.value)}}}}})),Gr=dual(2,(e,t)=>({[Symbol.iterator](){const r=e[Symbol.iterator]();let n=r.next(),i=!1;return{next(){if(n.done)return n;if(i)return i=!1,{done:!1,value:t};i=!0;const e=n;return n=r.next(),e}}}})),containsWith$2=e=>dual(2,(t,r)=>{for(const n of t)if(e(r,n))return!0;return!1}),Jr=containsWith$2(equivalence$1()),Hr=dual(2,(e,t)=>{const r=Math.max(1,Math.floor(t));return{[Symbol.iterator](){let t=e[Symbol.iterator]();return{next(){if(void 0===t)return{done:!0,value:void 0};const e=[];for(let n=0;n<r;n++){const r=t.next();if(r.done)return t=void 0,0===e.length?{done:!0,value:void 0}:{done:!1,value:e};e.push(r.value)}return{done:!1,value:e}}}}}}),Zr=dual(2,(e,t)=>({[Symbol.iterator](){const r=e[Symbol.iterator]();let n;return{next(){let e;if(void 0!==n){if(n.done)return{done:!0,value:void 0};e=n,n=void 0}else if(e=r.next(),e.done)return{done:!0,value:void 0};const i=[e.value];for(;;){const s=r.next();if(s.done||!t(e.value,s.value))return n=s,{done:!1,value:i};i.push(s.value)}}}}})),Qr=Zr(equivalence$1()),Yr=dual(2,(e,t)=>{const r={};for(const n of e){const e=t(n);Object.prototype.hasOwnProperty.call(r,e)?r[e].push(n):r[e]=[n]}return r}),Xr={[Symbol.iterator]:()=>en},en={next:()=>({done:!0,value:void 0})},empty$W=()=>Xr,tn=dual(2,(e,t)=>({[Symbol.iterator](){const r=e[Symbol.iterator]();let n=0;return{next(){const e=r.next();return e.done?{done:!0,value:void 0}:{done:!1,value:t(e.value,n++)}}}}})),rn=dual(2,(e,t)=>flatten$i(tn(e,t))),flatten$i=e=>({[Symbol.iterator](){const t=e[Symbol.iterator]();let r;return{next:function next(){if(void 0===r){const e=t.next();if(e.done)return e;r=e.value[Symbol.iterator]()}const e=r.next();return e.done?(r=void 0,next()):e}}}}),nn=dual(2,(e,t)=>({[Symbol.iterator](){const r=e[Symbol.iterator]();let n=0;return{next(){let e=r.next();for(;!e.done;){const i=t(e.value,n++);if(zt(i))return{done:!1,value:i.value};e=r.next()}return{done:!0,value:void 0}}}}})),sn=dual(2,(e,t)=>({[Symbol.iterator](){const r=e[Symbol.iterator]();let n=0;return{next(){const e=r.next();if(e.done)return{done:!0,value:void 0};const i=t(e.value,n++);return zt(i)?{done:!1,value:i.value}:{done:!0,value:void 0}}}}})),on=nn(identity$5),an=dual(2,(e,t)=>({[Symbol.iterator](){const r=e[Symbol.iterator]();let n=0;return{next(){let e=r.next();for(;!e.done;){if(t(e.value,n++))return{done:!1,value:e.value};e=r.next()}return{done:!0,value:void 0}}}}})),un=dual(2,(e,t)=>nn(e,e=>{const r=t(e);return null==r?none$c():Ut(r)})),cn=dual(2,(e,t)=>{let r=0;for(const n of e)if(t(n,r++))return!0;return!1}),ln=dual(2,(e,t)=>{let r=0;for(const n of e)t(n,r++)}),pn=dual(3,(e,t,r)=>{if(Array.isArray(e))return e.reduce(r,t);let n=0,i=t;for(const t of e)i=r(i,t,n++);return i}),hn=dual(2,(e,t)=>({[Symbol.iterator](){const r=e[Symbol.iterator]();let n,i=!0;return{next:function next(){const e=r.next();if(e.done)return{done:!0,value:void 0};if(i)return i=!1,n=e.value,e;const s=e.value;return t(n,s)?next():(n=s,e)}}}})),dn=hn(equivalence$1()),mn=dual(3,(e,t,r)=>rn(e,e=>tn(t,t=>r(e,t))));var gn=Object.freeze({__proto__:null,append:Dr,appendAll:Lr,cartesian:dual(2,(e,t)=>mn(e,t,(e,t)=>[e,t])),cartesianWith:mn,chunksOf:Hr,contains:Jr,containsWith:containsWith$2,countBy:dual(2,(e,t)=>{let r=0,n=0;for(const i of e)t(i,n)&&r++,n++;return r}),dedupeAdjacent:dn,dedupeAdjacentWith:hn,drop:zr,empty:empty$W,filter:an,filterMap:nn,filterMapWhile:sn,findFirst:qr,findLast:Wr,flatMap:rn,flatMapNullable:un,flatten:flatten$i,forEach:ln,fromRecord:e=>({*[Symbol.iterator](){for(const t in e)Object.prototype.hasOwnProperty.call(e,t)&&(yield[t,e[t]])}}),getLefts:e=>nn(e,rt),getRights:e=>nn(e,tt),getSomes:on,group:Qr,groupBy:Yr,groupWith:Zr,head:head$b,intersperse:Gr,isEmpty:e=>!0===e[Symbol.iterator]().next().done,makeBy:makeBy$2,map:tn,of:e=>[e],prepend:jr,prependAll:Rr,range:(start,e)=>void 0===e?makeBy$2(e=>start+e):makeBy$2(e=>start+e,{length:start<=e?e-start+1:1}),reduce:pn,replicate:Nr,scan:Ur,size:e=>{const t=e[Symbol.iterator]();let r=0;for(;!t.next().done;)r++;return r},some:cn,take:$r,takeWhile:Br,unfold:(e,t)=>({[Symbol.iterator](){let r=e;return{next(){const e=t(r);if(Bt(e))return{done:!0,value:void 0};const[n,i]=e.value;return r=i,{done:!1,value:n}}}}}),unsafeHead:unsafeHead$2,zip:Vr,zipWith:Kr});const isEmptyRecord=e=>0===keys$d(e).length,yn=isEmptyRecord,bn=dual(2,(e,t)=>{const r={};for(const n of e){const[e,i]=t(n);r[e]=i}return r}),Sn=Object.fromEntries,vn=dual(2,(e,t)=>{const r=[];for(const n of keys$d(e))r.push(t(n,e[n]));return r}),_n=vn((e,t)=>[e,t]),wn=dual(2,(e,t)=>Object.prototype.hasOwnProperty.call(e,t)),kn=dual(2,(e,t)=>wn(e,t)?Ut(e[t]):none$c()),xn=dual(3,(e,t,r)=>wn(e,t)?{...e,[t]:r(e[t])}:{...e}),In=dual(3,(e,t,r)=>wn(e,t)?Ut({...e,[t]:r(e[t])}):none$c()),Tn=dual(3,(e,t,r)=>In(e,t,()=>r)),On=dual(2,(e,t)=>{if(!wn(e,t))return{...e};const r={...e};return delete r[t],r}),En=dual(2,(e,t)=>wn(e,t)?Ut([e[t],On(e,t)]):none$c()),An=dual(2,(e,t)=>{const r={...e};for(const n of keys$d(e))r[n]=t(e[n],n);return r}),Cn=dual(2,(e,t)=>{const r={};for(const n of keys$d(e)){const i=e[n];r[t(n,i)]=i}return r}),Mn=dual(2,(e,t)=>{const r={};for(const n of keys$d(e)){const[i,s]=t(e[n],n);r[i]=s}return r}),Fn=dual(2,(e,t)=>{const r={};for(const n of keys$d(e)){const i=t(e[n],n);zt(i)&&(r[n]=i.value)}return r}),Pn=dual(2,(e,t)=>{const r={};for(const n of keys$d(e))t(e[n],n)&&(r[n]=e[n]);return r}),Nn=Fn(identity$5),jn=dual(2,(e,t)=>{const r={},n={};for(const i of keys$d(e)){const s=t(e[i],i);Xe(s)?r[i]=s.left:n[i]=s.right}return[r,n]}),Rn=jn(identity$5),Dn=dual(2,(e,t)=>{const r={},n={};for(const i of keys$d(e))t(e[i],i)?n[i]=e[i]:r[i]=e[i];return[r,n]}),keys$d=e=>Object.keys(e),Ln=dual(3,(e,t,r)=>({...e,[t]:r})),Un=dual(3,(e,t,r)=>wn(e,t)?{...e,[t]:r}:{...e}),isSubrecordBy=e=>dual(2,(t,r)=>{for(const n of keys$d(t))if(!wn(r,n)||!e(t[n],r[n]))return!1;return!0}),$n=isSubrecordBy(equivalence$1()),Bn=dual(3,(e,t,r)=>{let n=t;for(const t of keys$d(e))n=r(n,e[t],t);return n}),zn=dual(2,(e,t)=>{for(const r of keys$d(e))if(!t(e[r],r))return!1;return!0}),qn=dual(2,(e,t)=>{for(const r of keys$d(e))if(t(e[r],r))return!0;return!1}),Wn=dual(3,(e,t,r)=>{if(isEmptyRecord(e))return{...t};if(isEmptyRecord(t))return{...e};const n={};for(const i of keys$d(e))wn(t,i)?n[i]=r(e[i],t[i]):n[i]=e[i];for(const e of keys$d(t))wn(n,e)||(n[e]=t[e]);return n}),Vn=dual(3,(e,t,r)=>{const n={};if(isEmptyRecord(e)||isEmptyRecord(t))return n;for(const i of keys$d(e))wn(t,i)&&(n[i]=r(e[i],t[i]));return n});var Kn=Object.freeze({__proto__:null,collect:vn,difference:dual(2,(e,t)=>{if(isEmptyRecord(e))return{...t};if(isEmptyRecord(t))return{...e};const r={};for(const n of keys$d(e))wn(t,n)||(r[n]=e[n]);for(const n of keys$d(t))wn(e,n)||(r[n]=t[n]);return r}),empty:()=>({}),every:zn,filter:Pn,filterMap:Fn,findFirst:dual(2,(e,t)=>{const r=keys$d(e);for(let n=0;n<r.length;n++){const i=r[n];if(t(e[i],i))return Ut([i,e[i]])}return none$c()}),fromEntries:Sn,fromIterableBy:(e,t)=>bn(e,e=>[t(e),e]),fromIterableWith:bn,get:kn,getEquivalence:e=>{const t=isSubrecordBy(e);return(e,r)=>t(e,r)&&t(r,e)},getLefts:e=>{const t={};for(const r of keys$d(e)){const n=e[r];Xe(n)&&(t[r]=n.left)}return t},getRights:e=>{const t={};for(const r of keys$d(e)){const n=e[r];et(n)&&(t[r]=n.right)}return t},getSomes:Nn,has:wn,intersection:Vn,isEmptyReadonlyRecord:yn,isEmptyRecord,isSubrecord:$n,isSubrecordBy,keys:keys$d,map:An,mapEntries:Mn,mapKeys:Cn,modify:xn,modifyOption:In,partition:Dn,partitionMap:jn,pop:En,reduce:Bn,remove:On,replace:Un,replaceOption:Tn,separate:Rn,set:Ln,singleton:(e,t)=>({[e]:t}),size:e=>keys$d(e).length,some:qn,toEntries:_n,union:Wn,values:e=>vn(e,(e,t)=>t)});const make$2i=(...e)=>e,allocate$1=e=>Array(e),Gn=dual(2,(e,t)=>{const r=Math.max(1,Math.floor(e)),n=Array(r);for(let e=0;e<r;e++)n[e]=t(e);return n}),Jn=dual(2,(e,t)=>Gn(t,()=>e)),fromIterable$v=e=>Array.isArray(e)?e:Array.from(e),ensure=e=>Array.isArray(e)?e:[e],Hn=_n,Zn=toArray$a,Qn=dual(2,(e,{onEmpty:t,onNonEmpty:r})=>ci(e)?r(e):t()),Yn=dual(2,(e,{onEmpty:t,onNonEmpty:r})=>ci(e)?r(hi(e),tailNonEmpty$1(e)):t()),Xn=dual(2,(e,{onEmpty:t,onNonEmpty:r})=>ci(e)?r(initNonEmpty(e),lastNonEmpty$1(e)):t()),ei=dual(2,(e,t)=>[t,...e]),ti=dual(2,(e,t)=>fromIterable$v(t).concat(fromIterable$v(e))),ri=dual(2,(e,t)=>[...e,t]),ni=dual(2,(e,t)=>fromIterable$v(e).concat(fromIterable$v(t))),ii=dual(3,(e,t,r)=>{const n=[t];let i=0;for(const t of e)n[i+1]=r(n[i],t),i++;return n}),si=dual(3,(e,t,r)=>{const n=fromIterable$v(e),i=Array(n.length+1);i[n.length]=t;for(let e=n.length-1;e>=0;e--)i[e]=r(i[e+1],n[e]);return i}),oi=Array.isArray,isEmptyArray=e=>0===e.length,ai=isEmptyArray,ui=isNonEmptyArray$1,ci=isNonEmptyArray$1,isOutOfBounds=(e,t)=>e<0||e>=t.length,clamp$7=(e,t)=>Math.floor(Math.min(Math.max(0,e),t.length)),li=dual(2,(e,t)=>{const r=Math.floor(t);return isOutOfBounds(r,e)?none$c():Ut(e[r])}),pi=dual(2,(e,t)=>{const r=Math.floor(t);if(isOutOfBounds(r,e))throw Error(`Index ${r} out of bounds`);return e[r]}),fi=li(0),hi=pi(0),last$6=e=>ci(e)?Ut(lastNonEmpty$1(e)):none$c(),lastNonEmpty$1=e=>e[e.length-1],tailNonEmpty$1=e=>e.slice(1),initNonEmpty=e=>e.slice(0,-1),di=dual(2,(e,t)=>{const r=fromIterable$v(e);return r.slice(0,clamp$7(t,r))}),mi=dual(2,(e,t)=>{const r=fromIterable$v(e),n=clamp$7(t,r);return 0===n?[]:r.slice(-n)}),gi=dual(2,(e,t)=>{let r=0;const n=[];for(const i of e){if(!t(i,r))break;n.push(i),r++}return n}),spanIndex=(e,t)=>{let r=0;for(const n of e){if(!t(n,r))break;r++}return r},yi=dual(2,(e,t)=>Gi(e,spanIndex(e,t))),bi=dual(2,(e,t)=>{const r=fromIterable$v(e);return r.slice(clamp$7(t,r),r.length)}),Si=dual(2,(e,t)=>{const r=fromIterable$v(e);return r.slice(0,r.length-clamp$7(t,r))}),vi=dual(2,(e,t)=>fromIterable$v(e).slice(spanIndex(e,t))),_i=dual(2,(e,t)=>{let r=0;for(const n of e){if(t(n,r))return Ut(r);r++}return none$c()}),wi=dual(2,(e,t)=>{const r=fromIterable$v(e);for(let e=r.length-1;e>=0;e--)if(t(r[e],e))return Ut(e);return none$c()}),ki=qr,xi=dual(2,(e,t)=>{const r=fromIterable$v(e);for(let e=r.length-1;e>=0;e--){const n=r[e],i=t(n,e);if(isBoolean$1(i)){if(i)return Ut(n)}else if(zt(i))return i}return none$c()}),Ii=dual(2,(e,t)=>{let r=0;for(const n of e){const e=t(n,r);if(isBoolean$1(e)){if(e)return Ut([n,r])}else if(zt(e))return Ut([e.value,r]);r++}return none$c()}),Ti=dual(2,(e,t)=>{let r=0;const n=fromIterable$v(e);for(let e=0;e<n.length;e++)t(n[e],e)&&r++;return r}),Oi=dual(3,(e,t,r)=>{const n=Array.from(e);return t<0||t>n.length?none$c():(n.splice(t,0,r),Ut(n))}),Ei=dual(3,(e,t,r)=>Ci(e,t,()=>r)),Ai=dual(3,(e,t,r)=>Mi(e,t,()=>r)),Ci=dual(3,(e,t,r)=>{const n=Array.from(e);if(isOutOfBounds(t,n))return n;const i=r(n[t]);return n[t]=i,n}),Mi=dual(3,(e,t,r)=>{const n=fromIterable$v(e);if(isOutOfBounds(t,n))return none$c();const i=Array.isArray(e)?e.slice():n,s=r(n[t]);return i[t]=s,Ut(i)}),Fi=dual(2,(e,t)=>{const r=Array.from(e);return isOutOfBounds(t,r)||r.splice(t,1),r}),Pi=dual(2,(e,t)=>{const r=fromIterable$v(e);if(isOutOfBounds(t,r))return none$c();const n=Array.isArray(e)?e.slice():r;return n.splice(t,1),Ut(n)}),reverse$4=e=>Array.from(e).reverse(),Ni=dual(2,(e,t)=>{const r=Array.from(e);return r.sort(t),r}),ji=dual(3,(e,t,r)=>Array.from(e).map(e=>[e,t(e)]).sort(([,e],[,t])=>r(e,t)).map(([e])=>e)),Ri=dual(2,(e,t)=>Di(e,t,make$2j)),Di=dual(3,(e,t,r)=>{const n=fromIterable$v(e),i=fromIterable$v(t);if(ci(n)&&ci(i)){const e=[r(hi(n),hi(i))],t=Math.min(n.length,i.length);for(let s=1;s<t;s++)e[s]=r(n[s],i[s]);return e}return[]}),unzip$1=e=>{const t=fromIterable$v(e);if(ci(t)){const e=[t[0][0]],r=[t[0][1]];for(let n=1;n<t.length;n++)e[n]=t[n][0],r[n]=t[n][1];return[e,r]}return[[],[]]},Li=dual(2,(e,t)=>{const r=fromIterable$v(e);if(ci(r)){const e=[hi(r)],n=tailNonEmpty$1(r);for(let r=0;r<n.length;r++)r<n.length&&e.push(t),e.push(n[r]);return e}return[]}),Ui=dual(2,(e,t)=>[t(hi(e)),...tailNonEmpty$1(e)]),$i=dual(2,(e,t)=>Ui(e,()=>t)),Bi=dual(2,(e,t)=>ri(initNonEmpty(e),t(lastNonEmpty$1(e)))),zi=dual(2,(e,t)=>Bi(e,()=>t)),qi=dual(2,(e,t)=>{const r=fromIterable$v(e);if(ci(r)){const n=r.length,i=Math.round(t)%n;if(isOutOfBounds(Math.abs(i),r)||0===i)return copy$2(r);if(i<0){const[e,t]=Ji(r,-i);return ni(t,e)}return qi(e,i-n)}return[]}),containsWith$1=e=>dual(2,(t,r)=>{for(const n of t)if(e(r,n))return!0;return!1}),Wi=equivalence$1(),Vi=containsWith$1(Wi),Ki=dual(2,(e,t)=>{const r=fromIterable$v(e);if(ci(r)){const[e,n]=t(r),i=[e];let s=n;for(;isNonEmptyArray$1(s);){const[e,r]=t(s);i.push(e),s=r}return i}return[]}),Gi=dual(2,(e,t)=>{const r=Array.from(e),n=Math.floor(t);return ci(r)?n>=1?Ji(r,n):[[],r]:[r,[]]}),Ji=dual(2,(e,t)=>{const r=Math.max(1,Math.floor(t));return r>=e.length?[copy$2(e),[]]:[ei(e.slice(1,r),hi(e)),e.slice(r)]}),Hi=dual(2,(e,t)=>{const r=fromIterable$v(e);return Yi(r,Math.ceil(r.length/Math.floor(t)))}),Zi=dual(2,(e,t)=>yi(e,(e,r)=>!t(e,r))),copy$2=e=>e.slice(),Qi=dual(3,(e,t,r)=>e.length>=t?di(e,t):ni(e,Gn(t-e.length,()=>r))),Yi=dual(2,(e,t)=>{const r=fromIterable$v(e);return ci(r)?Ki(r,Ji(t)):[]}),Xi=dual(2,(e,t)=>{const r=fromIterable$v(e);return t>0&&ci(r)?Array.from({length:r.length-(t-1)},(e,n)=>r.slice(n,n+t)):[]}),es=dual(2,(e,t)=>Ki(e,e=>{const r=hi(e),n=[r];let i=1;for(;i<e.length;i++){const s=e[i];if(!t(s,r))break;n.push(s)}return[n,e.slice(i)]})),ts=es(equivalence$1()),rs=dual(2,(e,t)=>{const r={};for(const n of e){const e=t(n);Object.prototype.hasOwnProperty.call(r,e)?r[e].push(n):r[e]=[n]}return r}),ns=dual(3,(e,t,r)=>{const n=fromIterable$v(e),i=fromIterable$v(t);return ci(n)?ci(i)?Es(r)(ni(n,i)):n:i}),is=dual(2,(e,t)=>ns(e,t,Wi)),intersectionWith=e=>{const t=containsWith$1(e);return dual(2,(e,r)=>fromIterable$v(e).filter(e=>t(r,e)))},ss=intersectionWith(Wi),differenceWith$1=e=>{const t=containsWith$1(e);return dual(2,(e,r)=>fromIterable$v(e).filter(e=>!t(r,e)))},os=differenceWith$1(Wi),empty$U=()=>[],of$6=e=>[e],as=dual(2,(e,t)=>e.map(t)),us=dual(2,(e,t)=>{if(ai(e))return[];const r=[];for(let n=0;n<e.length;n++){const i=t(e[n],n);for(let e=0;e<i.length;e++)r.push(i[e])}return r}),cs=us(identity$5),ls=dual(2,(e,t)=>{const r=fromIterable$v(e),n=[];for(let e=0;e<r.length;e++){const i=t(r[e],e);zt(i)&&n.push(i.value)}return n}),ps=dual(2,(e,t)=>{let r=0;const n=[];for(const i of e){const e=t(i,r);if(!zt(e))break;n.push(e.value),r++}return n}),fs=dual(2,(e,t)=>{const r=[],n=[],i=fromIterable$v(e);for(let e=0;e<i.length;e++){const s=t(i[e],e);Xe(s)?r.push(s.left):n.push(s.right)}return[r,n]}),hs=ls(identity$5),ds=dual(2,(e,t)=>{const r=fromIterable$v(e),n=[];for(let e=0;e<r.length;e++)t(r[e],e)&&n.push(r[e]);return n}),ms=dual(2,(e,t)=>{const r=[],n=[],i=fromIterable$v(e);for(let e=0;e<i.length;e++)t(i[e],e)?n.push(i[e]):r.push(i[e]);return[r,n]}),gs=fs(identity$5),ys=dual(3,(e,t,r)=>fromIterable$v(e).reduce((e,t,n)=>r(e,t,n),t)),bs=dual(3,(e,t,r)=>fromIterable$v(e).reduceRight((e,t,n)=>r(e,t,n),t)),fromNullable$2=e=>null==e?[]:[e],Ss=dual(2,(e,t)=>us(e,e=>fromNullable$2(t(e)))),vs=dual(2,(e,t)=>e.every(t)),_s=dual(2,(e,t)=>e.some(t)),ws=dual(2,(e,t)=>e.map((e,r,n)=>t(n.slice(r)))),ks=dual(2,(e,t)=>e.reduce(min$9(t))),xs=dual(2,(e,t)=>e.reduce(max$b(t))),unfold$4=(e,t)=>{const r=[];let n,i=e;for(;zt(n=t(i));){const[e,t]=n.value;r.push(e),i=t}return r},Is=array$5,Ts=array$7,Os=dual(2,(e,t)=>fromIterable$v(e).forEach((e,r)=>t(e,r))),Es=dual(2,(e,t)=>{const r=fromIterable$v(e);if(ci(r)){const e=[hi(r)],n=tailNonEmpty$1(r);for(const r of n)e.every(e=>!t(r,e))&&e.push(r);return e}return[]}),dedupe$1=e=>Es(e,equivalence$1()),As=dual(2,(e,t)=>{const r=[];let n=none$c();for(const i of e)!Bt(n)&&t(i,n.value)||(r.push(i),n=Ut(i));return r}),Cs=As(equivalence$1()),Ms=dual(2,(e,t)=>fromIterable$v(e).join(t)),Fs=dual(3,(e,t,r)=>{let n=0,i=t;const s=[];for(const t of e){const e=r(i,t,n);i=e[0],s.push(e[1]),n++}return[i,s]}),Ps=dual(3,(e,t,r)=>us(e,e=>as(t,t=>r(e,t)))),Ns=dual(2,(e,t)=>Ps(e,t,(e,t)=>[e,t]));var js=Object.freeze({__proto__:null,Do:of$6({}),allocate:allocate$1,append:ri,appendAll:ni,bind:bind$a(as,us),bindTo:bindTo$a(as),cartesian:Ns,cartesianWith:Ps,chop:Ki,chunksOf:Yi,contains:Vi,containsWith:containsWith$1,copy:copy$2,countBy:Ti,dedupe:dedupe$1,dedupeAdjacent:Cs,dedupeAdjacentWith:As,dedupeWith:Es,difference:os,differenceWith:differenceWith$1,drop:bi,dropRight:Si,dropWhile:vi,empty:empty$U,ensure,every:vs,extend:ws,filter:ds,filterMap:ls,filterMapWhile:ps,findFirst:ki,findFirstIndex:_i,findFirstWithIndex:Ii,findLast:xi,findLastIndex:wi,flatMap:us,flatMapNullable:Ss,flatten:cs,forEach:Os,fromIterable:fromIterable$v,fromNullable:fromNullable$2,fromOption:Zn,fromRecord:Hn,get:li,getEquivalence:Ts,getLefts:e=>{const t=[];for(const r of e)Xe(r)&&t.push(r.left);return t},getOrder:Is,getRights:e=>{const t=[];for(const r of e)et(r)&&t.push(r.right);return t},getSomes:hs,group:ts,groupBy:rs,groupWith:es,head:fi,headNonEmpty:hi,init:e=>{const t=fromIterable$v(e);return ci(t)?Ut(initNonEmpty(t)):none$c()},initNonEmpty,insertAt:Oi,intersection:ss,intersectionWith,intersperse:Li,isArray:oi,isEmptyArray,isEmptyReadonlyArray:ai,isNonEmptyArray:ui,isNonEmptyReadonlyArray:ci,join:Ms,last:last$6,lastNonEmpty:lastNonEmpty$1,length:e=>e.length,let:let_$a(as),liftEither:e=>(...t)=>{const r=e(...t);return Xe(r)?[]:[r.right]},liftNullable:e=>(...t)=>fromNullable$2(e(...t)),liftOption:e=>(...t)=>Zn(e(...t)),liftPredicate:e=>t=>e(t)?[t]:[],make:make$2i,makeBy:Gn,map:as,mapAccum:Fs,match:Qn,matchLeft:Yn,matchRight:Xn,max:xs,min:ks,modify:Ci,modifyNonEmptyHead:Ui,modifyNonEmptyLast:Bi,modifyOption:Mi,of:of$6,pad:Qi,partition:ms,partitionMap:fs,prepend:ei,prependAll:ti,range:(start,e)=>start<=e?Gn(e-start+1,e=>start+e):[start],reduce:ys,reduceRight:bs,remove:Fi,removeOption:Pi,replace:Ei,replaceOption:Ai,replicate:Jn,reverse:reverse$4,rotate:qi,scan:ii,scanRight:si,separate:gs,setNonEmptyHead:$i,setNonEmptyLast:zi,some:_s,sort:Ni,sortBy:(...e)=>{const t=Ni(combineAll$3(e));return e=>{const r=fromIterable$v(e);return ci(r)?t(r):[]}},sortWith:ji,span:yi,split:Hi,splitAt:Gi,splitNonEmptyAt:Ji,splitWhere:Zi,tail:e=>{const t=fromIterable$v(e);return ci(t)?Ut(tailNonEmpty$1(t)):none$c()},tailNonEmpty:tailNonEmpty$1,take:di,takeRight:mi,takeWhile:gi,unappend:e=>[initNonEmpty(e),lastNonEmpty$1(e)],unfold:unfold$4,union:is,unionWith:ns,unprepend:e=>[hi(e),tailNonEmpty$1(e)],unsafeGet:pi,unzip:unzip$1,window:Xi,zip:Ri,zipWith:Di}),Rs={},Ds={},Ls={},Us={};Object.defineProperty(Us,"__esModule",{value:!0}),Us.PreconditionFailure=void 0;class PreconditionFailure extends Error{constructor(e=!1){super(),this.interruptExecution=e,this.footprint=PreconditionFailure.SharedFootPrint}static isFailure(e){return null!=e&&e.footprint===PreconditionFailure.SharedFootPrint}}Us.PreconditionFailure=PreconditionFailure,PreconditionFailure.SharedFootPrint=Symbol.for("fast-check/PreconditionFailure"),Object.defineProperty(Ls,"__esModule",{value:!0}),Ls.pre=function(e){if(!e)throw new $s.PreconditionFailure};const $s=Us;var Bs={},zs={},qs={},Ws={};Object.defineProperty(Ws,"__esModule",{value:!0}),Ws.nilHelper=function(){return Nil.nil},Ws.mapHelper=function*(e,t){for(const r of e)yield t(r)},Ws.flatMapHelper=function*(e,t){for(const r of e)yield*t(r)},Ws.filterHelper=function*(e,t){for(const r of e)t(r)&&(yield r)},Ws.takeNHelper=function*(e,t){for(let r=0;r<t;++r){const t=e.next();if(t.done)break;yield t.value}},Ws.takeWhileHelper=function*(e,t){let r=e.next();for(;!r.done&&t(r.value);)yield r.value,r=e.next()},Ws.joinHelper=function*(e,t){for(let t=e.next();!t.done;t=e.next())yield t.value;for(const e of t)for(let t=e.next();!t.done;t=e.next())yield t.value};class Nil{[Symbol.iterator](){return this}next(e){return{value:e,done:!0}}}Nil.nil=new Nil,Object.defineProperty(qs,"__esModule",{value:!0}),qs.Stream=void 0,qs.stream=function(e){return new Gs(e)};const Vs=Ws,Ks=Symbol.iterator;let Gs=class Stream{static nil(){return new Stream((0,Vs.nilHelper)())}static of(...e){return new Stream(e[Ks]())}constructor(e){this.g=e}next(){return this.g.next()}[Symbol.iterator](){return this.g}map(e){return new Stream((0,Vs.mapHelper)(this.g,e))}flatMap(e){return new Stream((0,Vs.flatMapHelper)(this.g,e))}dropWhile(e){let t=!1;return this.flatMap(function*(r){!t&&e(r)||(t=!0,yield r)})}drop(e){if(e<=0)return this;let t=0;return this.dropWhile(function(){return t++<e})}takeWhile(e){return new Stream((0,Vs.takeWhileHelper)(this.g,e))}take(e){return new Stream((0,Vs.takeNHelper)(this.g,e))}filter(e){return new Stream((0,Vs.filterHelper)(this.g,e))}every(e){for(const t of this.g)if(!e(t))return!1;return!0}has(e){for(const t of this.g)if(e(t))return[!0,t];return[!1,null]}join(...e){return new Stream((0,Vs.joinHelper)(this.g,e))}getNthOrLast(e){let t=e,r=null;for(const e of this.g){if(0===t--)return e;r=e}return r}};qs.Stream=Gs;var Js={};!function(e){function hasCloneMethod(t){return null!==t&&("object"==typeof t||"function"==typeof t)&&e.cloneMethod in t&&"function"==typeof t[e.cloneMethod]}Object.defineProperty(e,"__esModule",{value:!0}),e.cloneMethod=void 0,e.hasCloneMethod=hasCloneMethod,e.cloneIfNeeded=function(t){return hasCloneMethod(t)?t[e.cloneMethod]():t},e.cloneMethod=Symbol.for("fast-check/cloneMethod")}(Js);var Hs={};Object.defineProperty(Hs,"__esModule",{value:!0}),Hs.Value=void 0;const Zs=Js,Qs=Object.defineProperty;Hs.Value=class{constructor(e,t,r=void 0){this.value_=e,this.context=t,this.hasToBeCloned=void 0!==r||(0,Zs.hasCloneMethod)(e),this.readOnce=!1,this.hasToBeCloned?Qs(this,"value",{get:void 0!==r?r:this.getValue}):this.value=e}getValue(){return this.hasToBeCloned?this.readOnce?this.value_[Zs.cloneMethod]():(this.readOnce=!0,this.value_):this.value_}},Object.defineProperty(zs,"__esModule",{value:!0}),zs.Arbitrary=void 0,zs.isArbitrary=isArbitrary,zs.assertIsArbitrary=function(e){if(!isArbitrary(e))throw Error("Unexpected value received: not an instance of Arbitrary")};const Ys=qs,Xs=Js,eo=Hs,to=Object.assign;let ro=class{filter(e){return new FilterArbitrary(this,e)}map(e,t){return new MapArbitrary(this,e,t)}chain(e){return new ChainArbitrary(this,e)}noShrink(){return new NoShrinkArbitrary(this)}noBias(){return new NoBiasArbitrary(this)}};zs.Arbitrary=ro;class ChainArbitrary extends ro{constructor(e,t){super(),this.arb=e,this.chainer=t}generate(e,t){const r=e.clone(),n=this.arb.generate(e,t);return this.valueChainer(n,e,r,t)}canShrinkWithoutContext(e){return!1}shrink(e,t){return this.isSafeContext(t)?(t.stoppedForOriginal?Ys.Stream.nil():this.arb.shrink(t.originalValue,t.originalContext).map(e=>this.valueChainer(e,t.clonedMrng.clone(),t.clonedMrng,t.originalBias))).join(t.chainedArbitrary.shrink(e,t.chainedContext).map(e=>{const r=to(to({},t),{chainedContext:e.context,stoppedForOriginal:!0});return new eo.Value(e.value_,r)})):Ys.Stream.nil()}valueChainer(e,t,r,n){const i=this.chainer(e.value_),s=i.generate(t,n),o={originalBias:n,originalValue:e.value_,originalContext:e.context,stoppedForOriginal:!1,chainedArbitrary:i,chainedContext:s.context,clonedMrng:r};return new eo.Value(s.value_,o)}isSafeContext(e){return null!=e&&"object"==typeof e&&"originalBias"in e&&"originalValue"in e&&"originalContext"in e&&"stoppedForOriginal"in e&&"chainedArbitrary"in e&&"chainedContext"in e&&"clonedMrng"in e}}class MapArbitrary extends ro{constructor(e,t,r){super(),this.arb=e,this.mapper=t,this.unmapper=r,this.bindValueMapper=e=>this.valueMapper(e)}generate(e,t){const r=this.arb.generate(e,t);return this.valueMapper(r)}canShrinkWithoutContext(e){if(void 0!==this.unmapper)try{const t=this.unmapper(e);return this.arb.canShrinkWithoutContext(t)}catch(e){return!1}return!1}shrink(e,t){if(this.isSafeContext(t))return this.arb.shrink(t.originalValue,t.originalContext).map(this.bindValueMapper);if(void 0!==this.unmapper){const t=this.unmapper(e);return this.arb.shrink(t,void 0).map(this.bindValueMapper)}return Ys.Stream.nil()}mapperWithCloneIfNeeded(e){const t=e.value,r=this.mapper(t);return e.hasToBeCloned&&("object"==typeof r&&null!==r||"function"==typeof r)&&Object.isExtensible(r)&&!(0,Xs.hasCloneMethod)(r)&&Object.defineProperty(r,Xs.cloneMethod,{get:()=>()=>this.mapperWithCloneIfNeeded(e)[0]}),[r,t]}valueMapper(e){const[t,r]=this.mapperWithCloneIfNeeded(e),n={originalValue:r,originalContext:e.context};return new eo.Value(t,n)}isSafeContext(e){return null!=e&&"object"==typeof e&&"originalValue"in e&&"originalContext"in e}}class FilterArbitrary extends ro{constructor(e,t){super(),this.arb=e,this.refinement=t,this.bindRefinementOnValue=e=>this.refinementOnValue(e)}generate(e,t){for(;;){const r=this.arb.generate(e,t);if(this.refinementOnValue(r))return r}}canShrinkWithoutContext(e){return this.arb.canShrinkWithoutContext(e)&&this.refinement(e)}shrink(e,t){return this.arb.shrink(e,t).filter(this.bindRefinementOnValue)}refinementOnValue(e){return this.refinement(e.value)}}class NoShrinkArbitrary extends ro{constructor(e){super(),this.arb=e}generate(e,t){return this.arb.generate(e,t)}canShrinkWithoutContext(e){return this.arb.canShrinkWithoutContext(e)}shrink(e,t){return Ys.Stream.nil()}noShrink(){return this}}class NoBiasArbitrary extends ro{constructor(e){super(),this.arb=e}generate(e,t){return this.arb.generate(e,void 0)}canShrinkWithoutContext(e){return this.arb.canShrinkWithoutContext(e)}shrink(e,t){return this.arb.shrink(e,t)}noBias(){return this}}function isArbitrary(e){return"object"==typeof e&&null!==e&&"generate"in e&&"shrink"in e&&"canShrinkWithoutContext"in e}var no={},io={},so={},oo={};Object.defineProperty(oo,"__esModule",{value:!0}),oo.safeApply=function(e,t,r){return function(e){try{return e.apply}catch(e){return}}(e)===ao?e.apply(t,r):function(e,t,r){const n=e;n[uo]=ao;const i=n[uo](t,r);return delete n[uo],i}(e,t,r)};const ao=Function.prototype.apply,uo=Symbol("apply");Object.defineProperty(so,"__esModule",{value:!0}),so.Symbol=so.Map=so.encodeURIComponent=so.Uint32Array=so.Uint16Array=so.Uint8ClampedArray=so.Uint8Array=so.Set=so.String=so.Number=so.Int32Array=so.Int16Array=so.Int8Array=so.Float64Array=so.Float32Array=so.Error=so.Date=so.Boolean=so.BigUint64Array=so.BigInt64Array=so.BigInt=so.Array=void 0,so.safeForEach=function(e,t){return function(e){try{return e.forEach}catch(e){return}}(e)===No?e.forEach(t):(0,co.safeApply)(No,e,[t])},so.safeIndexOf=function(e,...t){return function(e){try{return e.indexOf}catch(e){return}}(e)===jo?e.indexOf(...t):(0,co.safeApply)(jo,e,t)},so.safeJoin=function(e,...t){return function(e){try{return e.join}catch(e){return}}(e)===Ro?e.join(...t):(0,co.safeApply)(Ro,e,t)},so.safeMap=function(e,t){return function(e){try{return e.map}catch(e){return}}(e)===Do?e.map(t):(0,co.safeApply)(Do,e,[t])},so.safeFilter=function(e,t){return function(e){try{return e.filter}catch(e){return}}(e)===Lo?e.filter(t):(0,co.safeApply)(Lo,e,[t])},so.safePush=function(e,...t){return function(e){try{return e.push}catch(e){return}}(e)===Uo?e.push(...t):(0,co.safeApply)(Uo,e,t)},so.safePop=function(e){return function(e){try{return e.pop}catch(e){return}}(e)===$o?e.pop():(0,co.safeApply)($o,e,[])},so.safeSplice=function(e,...t){return function(e){try{return e.splice}catch(e){return}}(e)===Bo?e.splice(...t):(0,co.safeApply)(Bo,e,t)},so.safeSlice=function(e,...t){return function(e){try{return e.slice}catch(e){return}}(e)===zo?e.slice(...t):(0,co.safeApply)(zo,e,t)},so.safeSort=function(e,...t){return function(e){try{return e.sort}catch(e){return}}(e)===qo?e.sort(...t):(0,co.safeApply)(qo,e,t)},so.safeEvery=function(e,...t){return function(e){try{return e.every}catch(e){return}}(e)===Wo?e.every(...t):(0,co.safeApply)(Wo,e,t)},so.safeGetTime=function(e){return function(e){try{return e.getTime}catch(e){return}}(e)===Vo?e.getTime():(0,co.safeApply)(Vo,e,[])},so.safeToISOString=function(e){return function(e){try{return e.toISOString}catch(e){return}}(e)===Ko?e.toISOString():(0,co.safeApply)(Ko,e,[])},so.safeAdd=function(e,t){return function(e){try{return e.add}catch(e){return}}(e)===Go?e.add(t):(0,co.safeApply)(Go,e,[t])},so.safeHas=function(e,t){return function(e){try{return e.has}catch(e){return}}(e)===Jo?e.has(t):(0,co.safeApply)(Jo,e,[t])},so.safeSet=function(e,t,r){return function(e){try{return e.set}catch(e){return}}(e)===Ho?e.set(t,r):(0,co.safeApply)(Ho,e,[t,r])},so.safeGet=function(e,t){return function(e){try{return e.get}catch(e){return}}(e)===Zo?e.get(t):(0,co.safeApply)(Zo,e,[t])},so.safeMapSet=function(e,t,r){return function(e){try{return e.set}catch(e){return}}(e)===Qo?e.set(t,r):(0,co.safeApply)(Qo,e,[t,r])},so.safeMapGet=function(e,t){return function(e){try{return e.get}catch(e){return}}(e)===Yo?e.get(t):(0,co.safeApply)(Yo,e,[t])},so.safeSplit=function(e,...t){return function(e){try{return e.split}catch(e){return}}(e)===Xo?e.split(...t):(0,co.safeApply)(Xo,e,t)},so.safeStartsWith=function(e,...t){return function(e){try{return e.startsWith}catch(e){return}}(e)===ea?e.startsWith(...t):(0,co.safeApply)(ea,e,t)},so.safeEndsWith=function(e,...t){return function(e){try{return e.endsWith}catch(e){return}}(e)===ta?e.endsWith(...t):(0,co.safeApply)(ta,e,t)},so.safeSubstring=function(e,...t){return function(e){try{return e.substring}catch(e){return}}(e)===ra?e.substring(...t):(0,co.safeApply)(ra,e,t)},so.safeToLowerCase=function(e){return function(e){try{return e.toLowerCase}catch(e){return}}(e)===na?e.toLowerCase():(0,co.safeApply)(na,e,[])},so.safeToUpperCase=function(e){return function(e){try{return e.toUpperCase}catch(e){return}}(e)===ia?e.toUpperCase():(0,co.safeApply)(ia,e,[])},so.safePadStart=function(e,...t){return function(e){try{return e.padStart}catch(e){return}}(e)===sa?e.padStart(...t):(0,co.safeApply)(sa,e,t)},so.safeCharCodeAt=function(e,t){return function(e){try{return e.charCodeAt}catch(e){return}}(e)===oa?e.charCodeAt(t):(0,co.safeApply)(oa,e,[t])},so.safeNormalize=function(e,t){return function(e){try{return e.normalize}catch(e){return}}(e)===aa?e.normalize(t):(0,co.safeApply)(aa,e,[t])},so.safeReplace=function(e,t,r){return function(e){try{return e.replace}catch(e){return}}(e)===ua?e.replace(t,r):(0,co.safeApply)(ua,e,[t,r])},so.safeNumberToString=function(e,...t){return function(e){try{return e.toString}catch(e){return}}(e)===ca?e.toString(...t):(0,co.safeApply)(ca,e,t)},so.safeHasOwnProperty=function(e,t){return(0,co.safeApply)(la,e,[t])},so.safeToString=function(e){return(0,co.safeApply)(pa,e,[])};const co=oo,lo=void 0!==Array?Array:void 0;so.Array=lo;const po="undefined"!=typeof BigInt?BigInt:void 0;so.BigInt=po;const fo="undefined"!=typeof BigInt64Array?BigInt64Array:void 0;so.BigInt64Array=fo;const ho="undefined"!=typeof BigUint64Array?BigUint64Array:void 0;so.BigUint64Array=ho;const mo=void 0!==Boolean?Boolean:void 0;so.Boolean=mo;const yo=void 0!==Date?Date:void 0;so.Date=yo;const bo=void 0!==Error?Error:void 0;so.Error=bo;const So="undefined"!=typeof Float32Array?Float32Array:void 0;so.Float32Array=So;const vo="undefined"!=typeof Float64Array?Float64Array:void 0;so.Float64Array=vo;const _o="undefined"!=typeof Int8Array?Int8Array:void 0;so.Int8Array=_o;const wo="undefined"!=typeof Int16Array?Int16Array:void 0;so.Int16Array=wo;const ko="undefined"!=typeof Int32Array?Int32Array:void 0;so.Int32Array=ko;const xo=void 0!==Number?Number:void 0;so.Number=xo;const Io=void 0!==String?String:void 0;so.String=Io;const To="undefined"!=typeof Set?Set:void 0;so.Set=To;const Oo="undefined"!=typeof Uint8Array?Uint8Array:void 0;so.Uint8Array=Oo;const Eo="undefined"!=typeof Uint8ClampedArray?Uint8ClampedArray:void 0;so.Uint8ClampedArray=Eo;const Ao="undefined"!=typeof Uint16Array?Uint16Array:void 0;so.Uint16Array=Ao;const Co="undefined"!=typeof Uint32Array?Uint32Array:void 0;so.Uint32Array=Co;const Mo=void 0!==encodeURIComponent?encodeURIComponent:void 0;so.encodeURIComponent=Mo;const Fo=Map;so.Map=Fo;const Po=Symbol;so.Symbol=Po;const No=Array.prototype.forEach,jo=Array.prototype.indexOf,Ro=Array.prototype.join,Do=Array.prototype.map,Lo=Array.prototype.filter,Uo=Array.prototype.push,$o=Array.prototype.pop,Bo=Array.prototype.splice,zo=Array.prototype.slice,qo=Array.prototype.sort,Wo=Array.prototype.every,Vo=Date.prototype.getTime,Ko=Date.prototype.toISOString,Go=Set.prototype.add,Jo=Set.prototype.has,Ho=WeakMap.prototype.set,Zo=WeakMap.prototype.get,Qo=Map.prototype.set,Yo=Map.prototype.get,Xo=String.prototype.split,ea=String.prototype.startsWith,ta=String.prototype.endsWith,ra=String.prototype.substring,na=String.prototype.toLowerCase,ia=String.prototype.toUpperCase,sa=String.prototype.padStart,oa=String.prototype.charCodeAt,aa=String.prototype.normalize,ua=String.prototype.replace,ca=Number.prototype.toString,la=Object.prototype.hasOwnProperty,pa=Object.prototype.toString;var fa={};Object.defineProperty(fa,"__esModule",{value:!0}),fa.makeLazy=function(e){return new LazyIterableIterator(e)};class LazyIterableIterator{constructor(e){this.producer=e}[Symbol.iterator](){return void 0===this.it&&(this.it=this.producer()),this.it}next(){return void 0===this.it&&(this.it=this.producer()),this.it.next()}}Object.defineProperty(io,"__esModule",{value:!0}),io.TupleArbitrary=void 0,io.tupleShrink=tupleShrink;const ha=qs,da=Js,ma=zs,ga=Hs,ya=so,ba=fa,Sa=Array.isArray,va=Object.defineProperty;function tupleMakeItCloneable(e,t){return va(e,da.cloneMethod,{value:()=>{const e=[];for(let r=0;r!==t.length;++r)(0,ya.safePush)(e,t[r].value);return tupleMakeItCloneable(e,t),e}})}function tupleWrapper(e){let t=!1;const r=[],n=[];for(let i=0;i!==e.length;++i){const s=e[i];t=t||s.hasToBeCloned,(0,ya.safePush)(r,s.value),(0,ya.safePush)(n,s.context)}return t&&tupleMakeItCloneable(r,e),new ga.Value(r,n)}function tupleShrink(e,t,r){const n=[],i=Sa(r)?r:[];for(let r=0;r!==e.length;++r)(0,ya.safePush)(n,(0,ba.makeLazy)(()=>e[r].shrink(t[r],i[r]).map(e=>{const n=(0,ya.safeMap)(t,(e,t)=>new ga.Value((0,da.cloneIfNeeded)(e),i[t]));return[...(0,ya.safeSlice)(n,0,r),e,...(0,ya.safeSlice)(n,r+1)]}).map(tupleWrapper)));return ha.Stream.nil().join(...n)}class TupleArbitrary extends ma.Arbitrary{constructor(e){super(),this.arbs=e;for(let t=0;t!==e.length;++t){const r=e[t];if(null==r||null==r.generate)throw Error(`Invalid parameter encountered at index ${t}: expecting an Arbitrary`)}}generate(e,t){const r=[];for(let n=0;n!==this.arbs.length;++n)(0,ya.safePush)(r,this.arbs[n].generate(e,t));return tupleWrapper(r)}canShrinkWithoutContext(e){if(!Sa(e)||e.length!==this.arbs.length)return!1;for(let t=0;t!==this.arbs.length;++t)if(!this.arbs[t].canShrinkWithoutContext(e[t]))return!1;return!0}shrink(e,t){return tupleShrink(this.arbs,e,t)}}io.TupleArbitrary=TupleArbitrary,Object.defineProperty(no,"__esModule",{value:!0}),no.tuple=function(...e){return new _a.TupleArbitrary(e)};const _a=io;var wa={},ka={};Object.defineProperty(ka,"__esModule",{value:!0}),ka.runIdToFrequency=function(e){return 2+~~(.4342944819032518*xa(e+1))};const xa=Math.log;var Ia={};Object.defineProperty(Ia,"__esModule",{value:!0}),Ia.configureGlobal=function(parameters){Ta=parameters},Ia.readConfigureGlobal=function(){return Ta},Ia.resetConfigureGlobal=function(){Ta={}};let Ta={};var Oa={};!function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.UndefinedContextPlaceholder=void 0,e.noUndefinedAsContext=function(r){return void 0!==r.context?r:r.hasToBeCloned?new t.Value(r.value_,e.UndefinedContextPlaceholder,()=>r.value):new t.Value(r.value_,e.UndefinedContextPlaceholder)};const t=Hs;e.UndefinedContextPlaceholder=Symbol("UndefinedContextPlaceholder")}(Oa),Object.defineProperty(wa,"__esModule",{value:!0}),wa.AsyncProperty=void 0;const Ea=Us,Aa=ka,Ca=Ia,Ma=qs,Fa=Oa,Pa=so;class AsyncProperty{constructor(e,t){this.arb=e,this.predicate=t;const{asyncBeforeEach:r,asyncAfterEach:n,beforeEach:i,afterEach:s}=(0,Ca.readConfigureGlobal)()||{};if(void 0!==r&&void 0!==i)throw(0,Pa.Error)('Global "asyncBeforeEach" and "beforeEach" parameters can\'t be set at the same time when running async properties');if(void 0!==n&&void 0!==s)throw(0,Pa.Error)('Global "asyncAfterEach" and "afterEach" parameters can\'t be set at the same time when running async properties');this.beforeEachHook=r||i||AsyncProperty.dummyHook,this.afterEachHook=n||s||AsyncProperty.dummyHook}isAsync(){return!0}generate(e,t){const r=this.arb.generate(e,null!=t?(0,Aa.runIdToFrequency)(t):void 0);return(0,Fa.noUndefinedAsContext)(r)}shrink(e){if(void 0===e.context&&!this.arb.canShrinkWithoutContext(e.value_))return Ma.Stream.nil();const t=e.context!==Fa.UndefinedContextPlaceholder?e.context:void 0;return this.arb.shrink(e.value_,t).map(Fa.noUndefinedAsContext)}async runBeforeEach(){await this.beforeEachHook()}async runAfterEach(){await this.afterEachHook()}async run(e,t){t||await this.beforeEachHook();try{const t=await this.predicate(e);return null==t||!0===t?null:{error:new Pa.Error("Property failed by returning false"),errorMessage:"Error: Property failed by returning false"}}catch(e){return Ea.PreconditionFailure.isFailure(e)?e:e instanceof Pa.Error&&e.stack?{error:e,errorMessage:e.stack}:{error:e,errorMessage:(0,Pa.String)(e)}}finally{t||await this.afterEachHook()}}beforeEach(e){const t=this.beforeEachHook;return this.beforeEachHook=()=>e(t),this}afterEach(e){const t=this.afterEachHook;return this.afterEachHook=()=>e(t),this}}wa.AsyncProperty=AsyncProperty,AsyncProperty.dummyHook=()=>{};var Na={};Object.defineProperty(Na,"__esModule",{value:!0}),Na.AlwaysShrinkableArbitrary=void 0;const ja=zs,Ra=qs,Da=Oa;class AlwaysShrinkableArbitrary extends ja.Arbitrary{constructor(e){super(),this.arb=e}generate(e,t){const r=this.arb.generate(e,t);return(0,Da.noUndefinedAsContext)(r)}canShrinkWithoutContext(e){return!0}shrink(e,t){if(void 0===t&&!this.arb.canShrinkWithoutContext(e))return Ra.Stream.nil();const r=t!==Da.UndefinedContextPlaceholder?t:void 0;return this.arb.shrink(e,r).map(Da.noUndefinedAsContext)}}Na.AlwaysShrinkableArbitrary=AlwaysShrinkableArbitrary,Object.defineProperty(Bs,"__esModule",{value:!0}),Bs.asyncProperty=function(...e){if(e.length<2)throw Error("asyncProperty expects at least two parameters");const t=(0,za.safeSlice)(e,0,e.length-1),r=e[e.length-1];(0,za.safeForEach)(t,La.assertIsArbitrary);const n=(0,za.safeMap)(t,e=>new Ba.AlwaysShrinkableArbitrary(e));return new $a.AsyncProperty((0,Ua.tuple)(...n),e=>r(...e))};const La=zs,Ua=no,$a=wa,Ba=Na,za=so;var qa={},Wa={};Object.defineProperty(Wa,"__esModule",{value:!0}),Wa.Property=void 0;const Va=Us,Ka=ka,Ga=Ia,Ja=qs,Ha=Oa,Za=so;class Property{constructor(e,t){this.arb=e,this.predicate=t;const{beforeEach:r=Property.dummyHook,afterEach:n=Property.dummyHook,asyncBeforeEach:i,asyncAfterEach:s}=(0,Ga.readConfigureGlobal)()||{};if(void 0!==i)throw(0,Za.Error)('"asyncBeforeEach" can\'t be set when running synchronous properties');if(void 0!==s)throw(0,Za.Error)('"asyncAfterEach" can\'t be set when running synchronous properties');this.beforeEachHook=r,this.afterEachHook=n}isAsync(){return!1}generate(e,t){const r=this.arb.generate(e,null!=t?(0,Ka.runIdToFrequency)(t):void 0);return(0,Ha.noUndefinedAsContext)(r)}shrink(e){if(void 0===e.context&&!this.arb.canShrinkWithoutContext(e.value_))return Ja.Stream.nil();const t=e.context!==Ha.UndefinedContextPlaceholder?e.context:void 0;return this.arb.shrink(e.value_,t).map(Ha.noUndefinedAsContext)}runBeforeEach(){this.beforeEachHook()}runAfterEach(){this.afterEachHook()}run(e,t){t||this.beforeEachHook();try{const t=this.predicate(e);return null==t||!0===t?null:{error:new Za.Error("Property failed by returning false"),errorMessage:"Error: Property failed by returning false"}}catch(e){return Va.PreconditionFailure.isFailure(e)?e:e instanceof Za.Error&&e.stack?{error:e,errorMessage:e.stack}:{error:e,errorMessage:(0,Za.String)(e)}}finally{t||this.afterEachHook()}}beforeEach(e){const t=this.beforeEachHook;return this.beforeEachHook=()=>e(t),this}afterEach(e){const t=this.afterEachHook;return this.afterEachHook=()=>e(t),this}}Wa.Property=Property,Property.dummyHook=()=>{},Object.defineProperty(qa,"__esModule",{value:!0}),qa.property=function(...e){if(e.length<2)throw Error("property expects at least two parameters");const t=(0,tu.safeSlice)(e,0,e.length-1),r=e[e.length-1];(0,tu.safeForEach)(t,Qa.assertIsArbitrary);const n=(0,tu.safeMap)(t,e=>new eu.AlwaysShrinkableArbitrary(e));return new Xa.Property((0,Ya.tuple)(...n),e=>r(...e))};const Qa=zs,Ya=no,Xa=Wa,eu=Na,tu=so;var ru={},nu={},iu={},su={},ou={};function unsafeGenerateN(e,t){for(var r=[],n=0;n!=t;++n)r.push(e.unsafeNext());return r}function unsafeSkipN(e,t){for(var r=0;r!=t;++r)e.unsafeNext()}ou.__esModule=!0,ou.skipN=ou.unsafeSkipN=ou.generateN=ou.unsafeGenerateN=void 0,ou.unsafeGenerateN=unsafeGenerateN,ou.generateN=function(e,t){var r=e.clone();return[unsafeGenerateN(r,t),r]},ou.unsafeSkipN=unsafeSkipN,ou.skipN=function(e,t){var r=e.clone();return unsafeSkipN(r,t),r};var au={__esModule:!0,congruential32:void 0},computeNextSeed=function(e){return 214013*e+2531011&4294967295},computeValueFromNextSeed=function(e){return(-2147483649&e)>>16},uu=function(){function LinearCongruential32(e){this.seed=e}return LinearCongruential32.prototype.clone=function(){return new LinearCongruential32(this.seed)},LinearCongruential32.prototype.next=function(){var e=new LinearCongruential32(this.seed);return[e.unsafeNext(),e]},LinearCongruential32.prototype.unsafeNext=function(){var e=computeNextSeed(this.seed),t=computeValueFromNextSeed(e),r=computeNextSeed(e),n=computeValueFromNextSeed(r);return this.seed=computeNextSeed(r),0|computeValueFromNextSeed(this.seed)+(n+(t<<15)<<15)},LinearCongruential32.prototype.getState=function(){return[this.seed]},LinearCongruential32}();au.congruential32=Object.assign(function(e){return new uu(e)},{fromState:function(e){if(1!==e.length)throw Error("The state must have been produced by a congruential32 RandomGenerator");return new uu(e[0])}});var cu={};!function(t){var r=e&&e.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,s=r.call(e),o=[];try{for(;(void 0===t||t-- >0)&&!(n=s.next()).done;)o.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=s.return)&&r.call(s)}finally{if(i)throw i.error}}return o},n=e&&e.__spreadArray||function(e,t,r){if(r||2===arguments.length)for(var n,i=0,s=t.length;i<s;i++)!n&&i in t||(n||(n=Array.prototype.slice.call(t,0,i)),n[i]=t[i]);return e.concat(n||Array.prototype.slice.call(t))};t.__esModule=!0;var i=function(){function MersenneTwister(e,t){this.states=e,this.index=t}return MersenneTwister.twist=function(e){for(var t=e.slice(),r=0;r!==MersenneTwister.N-MersenneTwister.M;++r){var n=(t[r]&MersenneTwister.MASK_UPPER)+(t[r+1]&MersenneTwister.MASK_LOWER);t[r]=t[r+MersenneTwister.M]^n>>>1^-(1&n)&MersenneTwister.A}for(r=MersenneTwister.N-MersenneTwister.M;r!==MersenneTwister.N-1;++r){var i=(t[r]&MersenneTwister.MASK_UPPER)+(t[r+1]&MersenneTwister.MASK_LOWER);t[r]=t[r+MersenneTwister.M-MersenneTwister.N]^i>>>1^-(1&i)&MersenneTwister.A}var s=(t[MersenneTwister.N-1]&MersenneTwister.MASK_UPPER)+(t[0]&MersenneTwister.MASK_LOWER);return t[MersenneTwister.N-1]=t[MersenneTwister.M-1]^s>>>1^-(1&s)&MersenneTwister.A,t},MersenneTwister.seeded=function(e){var t=Array(MersenneTwister.N);t[0]=e;for(var r=1;r!==MersenneTwister.N;++r){var n=t[r-1]^t[r-1]>>>30;t[r]=Math.imul(MersenneTwister.F,n)+r|0}return t},MersenneTwister.from=function(e){return new MersenneTwister(MersenneTwister.twist(MersenneTwister.seeded(e)),0)},MersenneTwister.prototype.clone=function(){return new MersenneTwister(this.states,this.index)},MersenneTwister.prototype.next=function(){var e=new MersenneTwister(this.states,this.index);return[e.unsafeNext(),e]},MersenneTwister.prototype.unsafeNext=function(){var e=this.states[this.index];return e^=this.states[this.index]>>>MersenneTwister.U,e^=e<<MersenneTwister.S&MersenneTwister.B,e^=e<<MersenneTwister.T&MersenneTwister.C,e^=e>>>MersenneTwister.L,++this.index>=MersenneTwister.N&&(this.states=MersenneTwister.twist(this.states),this.index=0),e},MersenneTwister.prototype.getState=function(){return n([this.index],r(this.states),!1)},MersenneTwister.fromState=function(e){if(!(e.length===MersenneTwister.N+1&&e[0]>=0&&e[0]<MersenneTwister.N))throw Error("The state must have been produced by a mersenne RandomGenerator");return new MersenneTwister(e.slice(1),e[0])},MersenneTwister.N=624,MersenneTwister.M=397,MersenneTwister.R=31,MersenneTwister.A=2567483615,MersenneTwister.F=1812433253,MersenneTwister.U=11,MersenneTwister.S=7,MersenneTwister.B=2636928640,MersenneTwister.T=15,MersenneTwister.C=4022730752,MersenneTwister.L=18,MersenneTwister.MASK_LOWER=Math.pow(2,MersenneTwister.R)-1,MersenneTwister.MASK_UPPER=Math.pow(2,MersenneTwister.R),MersenneTwister}();t.default=Object.assign(function(e){return i.from(e)},{fromState:function(e){return i.fromState(e)}})}(cu);var lu={__esModule:!0,xorshift128plus:void 0},pu=function(){function XorShift128Plus(e,t,r,n){this.s01=e,this.s00=t,this.s11=r,this.s10=n}return XorShift128Plus.prototype.clone=function(){return new XorShift128Plus(this.s01,this.s00,this.s11,this.s10)},XorShift128Plus.prototype.next=function(){var e=new XorShift128Plus(this.s01,this.s00,this.s11,this.s10);return[e.unsafeNext(),e]},XorShift128Plus.prototype.unsafeNext=function(){var e=this.s00^this.s00<<23,t=this.s01^(this.s01<<23|this.s00>>>9),r=e^this.s10^(e>>>18|t<<14)^(this.s10>>>5|this.s11<<27),n=t^this.s11^t>>>18^this.s11>>>5,i=this.s00+this.s10|0;return this.s01=this.s11,this.s00=this.s10,this.s11=n,this.s10=r,i},XorShift128Plus.prototype.jump=function(){var e=new XorShift128Plus(this.s01,this.s00,this.s11,this.s10);return e.unsafeJump(),e},XorShift128Plus.prototype.unsafeJump=function(){for(var e=0,t=0,r=0,n=0,i=[1667051007,2321340297,1548169110,304075285],s=0;4!==s;++s)for(var o=1;o;o<<=1)i[s]&o&&(e^=this.s01,t^=this.s00,r^=this.s11,n^=this.s10),this.unsafeNext();this.s01=e,this.s00=t,this.s11=r,this.s10=n},XorShift128Plus.prototype.getState=function(){return[this.s01,this.s00,this.s11,this.s10]},XorShift128Plus}();lu.xorshift128plus=Object.assign(function(e){return new pu(-1,~e,0|e,0)},{fromState:function(e){if(4!==e.length)throw Error("The state must have been produced by a xorshift128plus RandomGenerator");return new pu(e[0],e[1],e[2],e[3])}});var fu={__esModule:!0,xoroshiro128plus:void 0},hu=function(){function XoroShiro128Plus(e,t,r,n){this.s01=e,this.s00=t,this.s11=r,this.s10=n}return XoroShiro128Plus.prototype.clone=function(){return new XoroShiro128Plus(this.s01,this.s00,this.s11,this.s10)},XoroShiro128Plus.prototype.next=function(){var e=new XoroShiro128Plus(this.s01,this.s00,this.s11,this.s10);return[e.unsafeNext(),e]},XoroShiro128Plus.prototype.unsafeNext=function(){var e=this.s00+this.s10|0,t=this.s10^this.s00,r=this.s11^this.s01,n=this.s00,i=this.s01;return this.s00=n<<24^i>>>8^t^t<<16,this.s01=i<<24^n>>>8^r^(r<<16|t>>>16),this.s10=r<<5^t>>>27,this.s11=t<<5^r>>>27,e},XoroShiro128Plus.prototype.jump=function(){var e=new XoroShiro128Plus(this.s01,this.s00,this.s11,this.s10);return e.unsafeJump(),e},XoroShiro128Plus.prototype.unsafeJump=function(){for(var e=0,t=0,r=0,n=0,i=[3639956645,3750757012,1261568508,386426335],s=0;4!==s;++s)for(var o=1;o;o<<=1)i[s]&o&&(e^=this.s01,t^=this.s00,r^=this.s11,n^=this.s10),this.unsafeNext();this.s01=e,this.s00=t,this.s11=r,this.s10=n},XoroShiro128Plus.prototype.getState=function(){return[this.s01,this.s00,this.s11,this.s10]},XoroShiro128Plus}();fu.xoroshiro128plus=Object.assign(function(e){return new hu(-1,~e,0|e,0)},{fromState:function(e){if(4!==e.length)throw Error("The state must have been produced by a xoroshiro128plus RandomGenerator");return new hu(e[0],e[1],e[2],e[3])}});var du={},mu={},gu={};function addArrayIntToNew(e,t){if(e.sign!==t.sign)return substractArrayIntToNew(e,{sign:-t.sign,data:t.data});for(var r=[],n=0,i=e.data,s=t.data,o=i.length-1,a=s.length-1;o>=0||a>=0;--o,--a){var u=(o>=0?i[o]:0)+(a>=0?s[a]:0)+n;r.push(u>>>0),n=~~(u/4294967296)}return 0!==n&&r.push(n),{sign:e.sign,data:r.reverse()}}function substractArrayIntToNew(e,t){if(e.sign!==t.sign)return addArrayIntToNew(e,{sign:-t.sign,data:t.data});var r=e.data,n=t.data;if(function(e,t){for(var r=Math.max(e.length,t.length),n=0;n<r;++n){var i=n+e.length-r,s=n+t.length-r,o=i>=0?e[i]:0,a=s>=0?t[s]:0;if(o<a)return!0;if(o>a)return!1}return!1}(r,n)){var i=substractArrayIntToNew(t,e);return i.sign=-i.sign,i}for(var s=[],o=0,a=r.length-1,u=n.length-1;a>=0||u>=0;--a,--u){var c=(a>=0?r[a]:0)-(u>=0?n[u]:0)-o;s.push(c>>>0),o=c<0?1:0}return{sign:e.sign,data:s.reverse()}}gu.__esModule=!0,gu.substractArrayInt64=gu.fromNumberToArrayInt64=gu.trimArrayIntInplace=gu.substractArrayIntToNew=gu.addOneToPositiveArrayInt=gu.addArrayIntToNew=void 0,gu.addArrayIntToNew=addArrayIntToNew,gu.addOneToPositiveArrayInt=function(e){e.sign=1;for(var t=e.data,r=t.length-1;r>=0;--r){if(4294967295!==t[r])return t[r]+=1,e;t[r]=0}return t.unshift(1),e},gu.substractArrayIntToNew=substractArrayIntToNew,gu.trimArrayIntInplace=function(e){for(var t=e.data,r=0;r!==t.length&&0===t[r];++r);return r===t.length?(e.sign=1,e.data=[0],e):(t.splice(0,r),e)},gu.fromNumberToArrayInt64=function(e,t){if(t<0){var r=-t;e.sign=-1,e.data[0]=~~(r/4294967296),e.data[1]=r>>>0}else e.sign=1,e.data[0]=~~(t/4294967296),e.data[1]=t>>>0;return e},gu.substractArrayInt64=function(e,t,r){var n=t.data[1],i=t.data[0],s=t.sign,o=r.data[1],a=r.data[0],u=r.sign;if(e.sign=1,1===s&&-1===u){var c=n+o,l=i+a+(c>4294967295?1:0);return e.data[0]=l>>>0,e.data[1]=c>>>0,e}var p=n,d=i,m=o,g=a;-1===s&&(p=o,d=a,m=n,g=i);var y=0,b=p-m;return b<0&&(y=1,b>>>=0),e.data[0]=d-g-y,e.data[1]=b,e};var yu={},bu={__esModule:!0,unsafeUniformIntDistributionInternal:(void 0,function(e,t){for(var r=e>2?~~(4294967296/e)*e:4294967296,n=t.unsafeNext()+2147483648;n>=r;)n=t.unsafeNext()+2147483648;return n%e})};yu.__esModule=!0,yu.unsafeUniformArrayIntDistributionInternal=void 0;var Su=bu;yu.unsafeUniformArrayIntDistributionInternal=function(e,t,r){for(var n=t.length;;){for(var i=0;i!==n;++i){var s=0===i?t[0]+1:4294967296,o=(0,Su.unsafeUniformIntDistributionInternal)(s,r);e[i]=o}for(i=0;i!==n;++i){var a=e[i],u=t[i];if(a<u)return e;if(a>u)break}}},mu.__esModule=!0,mu.unsafeUniformArrayIntDistribution=void 0;var vu=gu,_u=yu;mu.unsafeUniformArrayIntDistribution=function(e,t,r){var n=(0,vu.trimArrayIntInplace)((0,vu.addOneToPositiveArrayInt)((0,vu.substractArrayIntToNew)(t,e))),i=n.data.slice(0),s=(0,_u.unsafeUniformArrayIntDistributionInternal)(i,n.data,r);return(0,vu.trimArrayIntInplace)((0,vu.addArrayIntToNew)({sign:1,data:s},e))},du.__esModule=!0,du.uniformArrayIntDistribution=void 0;var wu=mu;du.uniformArrayIntDistribution=function(e,t,r){if(null!=r){var n=r.clone();return[(0,wu.unsafeUniformArrayIntDistribution)(e,t,n),n]}return function(r){var n=r.clone();return[(0,wu.unsafeUniformArrayIntDistribution)(e,t,n),n]}};var ku={},xu={__esModule:!0,unsafeUniformBigIntDistribution:void 0},Iu="undefined"!=typeof BigInt?BigInt:void 0;xu.unsafeUniformBigIntDistribution=function(e,t,r){for(var n=t-e+Iu(1),i=Iu(-2147483648),s=Iu(4294967296),o=s,a=1;o<n;)o*=s,++a;for(var u=o-o%n;;){for(var c=Iu(0),l=0;l!==a;++l){var p=r.unsafeNext();c=s*c+(Iu(p)-i)}if(c<u)return c%n+e}},ku.__esModule=!0,ku.uniformBigIntDistribution=void 0;var Tu=xu;ku.uniformBigIntDistribution=function(e,t,r){if(null!=r){var n=r.clone();return[(0,Tu.unsafeUniformBigIntDistribution)(e,t,n),n]}return function(r){var n=r.clone();return[(0,Tu.unsafeUniformBigIntDistribution)(e,t,n),n]}};var Ou={},Eu={__esModule:!0,unsafeUniformIntDistribution:void 0},Au=bu,Cu=gu,Mu=yu,Fu=Number.MAX_SAFE_INTEGER,Pu={sign:1,data:[0,0]},Nu={sign:1,data:[0,0]},ju={sign:1,data:[0,0]},Ru=[0,0];Eu.unsafeUniformIntDistribution=function(e,t,r){var n=t-e;return n<=4294967295?(0,Au.unsafeUniformIntDistributionInternal)(n+1,r)+e:function(e,t,r,n){var i=r<=Fu?(0,Cu.fromNumberToArrayInt64)(ju,r):(0,Cu.substractArrayInt64)(ju,(0,Cu.fromNumberToArrayInt64)(Pu,t),(0,Cu.fromNumberToArrayInt64)(Nu,e));return 4294967295===i.data[1]?(i.data[0]+=1,i.data[1]=0):i.data[1]+=1,(0,Mu.unsafeUniformArrayIntDistributionInternal)(Ru,i.data,n),4294967296*Ru[0]+Ru[1]+e}(e,t,n,r)},Ou.__esModule=!0,Ou.uniformIntDistribution=void 0;var Du=Eu;Ou.uniformIntDistribution=function(e,t,r){if(null!=r){var n=r.clone();return[(0,Du.unsafeUniformIntDistribution)(e,t,n),n]}return function(r){var n=r.clone();return[(0,Du.unsafeUniformIntDistribution)(e,t,n),n]}},su.__esModule=!0,su.unsafeUniformIntDistribution=su.unsafeUniformBigIntDistribution=su.unsafeUniformArrayIntDistribution=su.uniformIntDistribution=su.uniformBigIntDistribution=su.uniformArrayIntDistribution=su.xoroshiro128plus=su.xorshift128plus=su.mersenne=su.congruential32=su.unsafeSkipN=su.unsafeGenerateN=su.skipN=su.generateN=su.__commitHash=su.__version=su.__type=void 0;var Lu=ou;su.generateN=Lu.generateN,su.skipN=Lu.skipN,su.unsafeGenerateN=Lu.unsafeGenerateN,su.unsafeSkipN=Lu.unsafeSkipN;var Uu=au;su.congruential32=Uu.congruential32;var $u=cu;su.mersenne=$u.default;var Bu=lu;su.xorshift128plus=Bu.xorshift128plus;var zu=fu;su.xoroshiro128plus=zu.xoroshiro128plus;var qu=du;su.uniformArrayIntDistribution=qu.uniformArrayIntDistribution;var Wu=ku;su.uniformBigIntDistribution=Wu.uniformBigIntDistribution;var Vu=Ou;su.uniformIntDistribution=Vu.uniformIntDistribution;var Ku=mu;su.unsafeUniformArrayIntDistribution=Ku.unsafeUniformArrayIntDistribution;var Gu=xu;su.unsafeUniformBigIntDistribution=Gu.unsafeUniformBigIntDistribution;var Ju=Eu;su.unsafeUniformIntDistribution=Ju.unsafeUniformIntDistribution,su.__type="commonjs",su.__version="6.1.0",su.__commitHash="a413dd2b721516be2ef29adffb515c5ae67bfbad",function(t){var r=e&&e.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),n=e&&e.__exportStar||function(e,t){for(var n in e)"default"===n||Object.prototype.hasOwnProperty.call(t,n)||r(t,e,n)};t.__esModule=!0;var i=su;t.default=i,n(su,t)}(iu);var Hu,Zu={};Object.defineProperty(Zu,"__esModule",{value:!0}),Zu.VerbosityLevel=void 0,function(e){e[e.None=0]="None",e[e.Verbose=1]="Verbose",e[e.VeryVerbose=2]="VeryVerbose"}(Hu||(Zu.VerbosityLevel=Hu={})),Object.defineProperty(nu,"__esModule",{value:!0}),nu.QualifiedParameters=void 0;const Qu=iu,Yu=Zu,Xu=Date.now,ec=Math.min,tc=Math.random;class QualifiedParameters{constructor(e){const t=e||{};this.seed=QualifiedParameters.readSeed(t),this.randomType=QualifiedParameters.readRandomType(t),this.numRuns=QualifiedParameters.readNumRuns(t),this.verbose=QualifiedParameters.readVerbose(t),this.maxSkipsPerRun=QualifiedParameters.readOrDefault(t,"maxSkipsPerRun",100),this.timeout=QualifiedParameters.safeTimeout(QualifiedParameters.readOrDefault(t,"timeout",null)),this.skipAllAfterTimeLimit=QualifiedParameters.safeTimeout(QualifiedParameters.readOrDefault(t,"skipAllAfterTimeLimit",null)),this.interruptAfterTimeLimit=QualifiedParameters.safeTimeout(QualifiedParameters.readOrDefault(t,"interruptAfterTimeLimit",null)),this.markInterruptAsFailure=QualifiedParameters.readBoolean(t,"markInterruptAsFailure"),this.skipEqualValues=QualifiedParameters.readBoolean(t,"skipEqualValues"),this.ignoreEqualValues=QualifiedParameters.readBoolean(t,"ignoreEqualValues"),this.logger=QualifiedParameters.readOrDefault(t,"logger",e=>{console.log(e)}),this.path=QualifiedParameters.readOrDefault(t,"path",""),this.unbiased=QualifiedParameters.readBoolean(t,"unbiased"),this.examples=QualifiedParameters.readOrDefault(t,"examples",[]),this.endOnFailure=QualifiedParameters.readBoolean(t,"endOnFailure"),this.reporter=QualifiedParameters.readOrDefault(t,"reporter",null),this.asyncReporter=QualifiedParameters.readOrDefault(t,"asyncReporter",null),this.errorWithCause=QualifiedParameters.readBoolean(t,"errorWithCause")}toParameters(){const orUndefined=e=>null!==e?e:void 0;return{seed:this.seed,randomType:this.randomType,numRuns:this.numRuns,maxSkipsPerRun:this.maxSkipsPerRun,timeout:orUndefined(this.timeout),skipAllAfterTimeLimit:orUndefined(this.skipAllAfterTimeLimit),interruptAfterTimeLimit:orUndefined(this.interruptAfterTimeLimit),markInterruptAsFailure:this.markInterruptAsFailure,skipEqualValues:this.skipEqualValues,ignoreEqualValues:this.ignoreEqualValues,path:this.path,logger:this.logger,unbiased:this.unbiased,verbose:this.verbose,examples:this.examples,endOnFailure:this.endOnFailure,reporter:orUndefined(this.reporter),asyncReporter:orUndefined(this.asyncReporter),errorWithCause:this.errorWithCause}}static read(e){return new QualifiedParameters(e)}}nu.QualifiedParameters=QualifiedParameters,QualifiedParameters.createQualifiedRandomGenerator=e=>t=>{const r=e(t);return void 0===r.unsafeJump&&(r.unsafeJump=()=>(0,Qu.unsafeSkipN)(r,42)),r},QualifiedParameters.readSeed=e=>{if(null==e.seed)return Xu()^4294967296*tc();const t=0|e.seed;return e.seed===t?t:t^4294967296*(e.seed-t)},QualifiedParameters.readRandomType=e=>{if(null==e.randomType)return Qu.default.xorshift128plus;if("string"==typeof e.randomType)switch(e.randomType){case"mersenne":return QualifiedParameters.createQualifiedRandomGenerator(Qu.default.mersenne);case"congruential":case"congruential32":return QualifiedParameters.createQualifiedRandomGenerator(Qu.default.congruential32);case"xorshift128plus":return Qu.default.xorshift128plus;case"xoroshiro128plus":return Qu.default.xoroshiro128plus;default:throw Error(`Invalid random specified: '${e.randomType}'`)}const t=e.randomType(0);if("min"in t&&-2147483648!==t.min)throw Error("Invalid random number generator: min must equal -0x80000000, got "+t.min);if("max"in t&&2147483647!==t.max)throw Error("Invalid random number generator: max must equal 0x7fffffff, got "+t.max);return"unsafeJump"in t?e.randomType:QualifiedParameters.createQualifiedRandomGenerator(e.randomType)},QualifiedParameters.readNumRuns=e=>null!=e.numRuns?e.numRuns:null!=e.num_runs?e.num_runs:100,QualifiedParameters.readVerbose=e=>null==e.verbose?Yu.VerbosityLevel.None:"boolean"==typeof e.verbose?!0===e.verbose?Yu.VerbosityLevel.Verbose:Yu.VerbosityLevel.None:e.verbose<=Yu.VerbosityLevel.None?Yu.VerbosityLevel.None:e.verbose>=Yu.VerbosityLevel.VeryVerbose?Yu.VerbosityLevel.VeryVerbose:0|e.verbose,QualifiedParameters.readBoolean=(e,t)=>!0===e[t],QualifiedParameters.readOrDefault=(e,t,r)=>{const n=e[t];return null!=n?n:r},QualifiedParameters.safeTimeout=e=>null===e?null:ec(e,2147483647);var rc={},nc={};Object.defineProperty(nc,"__esModule",{value:!0}),nc.SkipAfterProperty=void 0;const ic=Us;nc.SkipAfterProperty=class{constructor(e,t,r,n,i,s){this.property=e,this.getTime=t,this.interruptExecution=n,this.setTimeoutSafe=i,this.clearTimeoutSafe=s,this.skipAfterTime=this.getTime()+r,void 0!==this.property.runBeforeEach&&void 0!==this.property.runAfterEach&&(this.runBeforeEach=()=>this.property.runBeforeEach(),this.runAfterEach=()=>this.property.runAfterEach())}isAsync(){return this.property.isAsync()}generate(e,t){return this.property.generate(e,t)}shrink(e){return this.property.shrink(e)}run(e,t){const r=this.skipAfterTime-this.getTime();if(r<=0){const e=new ic.PreconditionFailure(this.interruptExecution);return this.isAsync()?Promise.resolve(e):e}if(this.interruptExecution&&this.isAsync()){const n=function(e,t,r){let n=null;return{clear:()=>r(n),promise:new Promise(r=>{n=t(()=>{const e=new ic.PreconditionFailure(!0);r(e)},e)})}}(r,this.setTimeoutSafe,this.clearTimeoutSafe),i=Promise.race([this.property.run(e,t),n.promise]);return i.then(n.clear,n.clear),i}return this.property.run(e,t)}};var sc={};Object.defineProperty(sc,"__esModule",{value:!0}),sc.TimeoutProperty=void 0;const oc=so;sc.TimeoutProperty=class{constructor(e,t,r,n){this.property=e,this.timeMs=t,this.setTimeoutSafe=r,this.clearTimeoutSafe=n,void 0!==this.property.runBeforeEach&&void 0!==this.property.runAfterEach&&(this.runBeforeEach=()=>Promise.resolve(this.property.runBeforeEach()),this.runAfterEach=()=>Promise.resolve(this.property.runAfterEach()))}isAsync(){return!0}generate(e,t){return this.property.generate(e,t)}shrink(e){return this.property.shrink(e)}async run(e,t){const r=((e,t,r)=>{let n=null;return{clear:()=>r(n),promise:new Promise(r=>{n=t(()=>{r({error:new oc.Error(`Property timeout: exceeded limit of ${e} milliseconds`),errorMessage:`Property timeout: exceeded limit of ${e} milliseconds`})},e)})}})(this.timeMs,this.setTimeoutSafe,this.clearTimeoutSafe),n=Promise.race([this.property.run(e,t),r.promise]);return n.then(r.clear,r.clear),n}};var ac={};Object.defineProperty(ac,"__esModule",{value:!0}),ac.UnbiasedProperty=void 0,ac.UnbiasedProperty=class{constructor(e){this.property=e,void 0!==this.property.runBeforeEach&&void 0!==this.property.runAfterEach&&(this.runBeforeEach=()=>this.property.runBeforeEach(),this.runAfterEach=()=>this.property.runAfterEach())}isAsync(){return this.property.isAsync()}generate(e,t){return this.property.generate(e,void 0)}shrink(e){return this.property.shrink(e)}run(e,t){return this.property.run(e,t)}};var uc={},cc={};!function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.asyncToStringMethod=e.toStringMethod=void 0,e.hasToStringMethod=hasToStringMethod,e.hasAsyncToStringMethod=hasAsyncToStringMethod,e.stringifyInternal=stringifyInternal,e.stringify=function(e){return stringifyInternal(e,[],()=>({state:"unknown",value:void 0}))},e.possiblyAsyncStringify=possiblyAsyncStringify,e.asyncStringify=async function(e){return Promise.resolve(possiblyAsyncStringify(e))};const t=so,r=Array.from,n="undefined"!=typeof Buffer?Buffer.isBuffer:void 0,i=JSON.stringify,s=Number.isNaN,o=Object.keys,a=Object.getOwnPropertySymbols,u=Object.getOwnPropertyDescriptor,c=Object.getPrototypeOf,l=-1/0,p=1/0;function hasToStringMethod(t){return null!==t&&("object"==typeof t||"function"==typeof t)&&e.toStringMethod in t&&"function"==typeof t[e.toStringMethod]}function hasAsyncToStringMethod(t){return null!==t&&("object"==typeof t||"function"==typeof t)&&e.asyncToStringMethod in t&&"function"==typeof t[e.asyncToStringMethod]}e.toStringMethod=Symbol.for("fast-check/toStringMethod"),e.asyncToStringMethod=Symbol.for("fast-check/asyncToStringMethod");const d=/^Symbol\((.*)\)$/;function stringifyNumber(e){switch(e){case 0:return 1/e===l?"-0":"0";case l:return"Number.NEGATIVE_INFINITY";case p:return"Number.POSITIVE_INFINITY";default:return e==e?(0,t.String)(e):"Number.NaN"}}function stringifyInternal(l,p,m){const g=[...p,l];if("object"==typeof l&&-1!==(0,t.safeIndexOf)(p,l))return"[cyclic]";if(hasAsyncToStringMethod(l)){const e=m(l);if("fulfilled"===e.state)return e.value}if(hasToStringMethod(l))try{return l[e.toStringMethod]()}catch(e){}switch((0,t.safeToString)(l)){case"[object Array]":{const e=l;if(e.length>=50&&function(e){let t=-1;for(const r in e){const e=Number(r);if(e!==t+1)return!0;t=e}return t+1!==e.length}(e)){const r=[];for(const n in e)s(Number(n))||(0,t.safePush)(r,`${n}:${stringifyInternal(e[n],g,m)}`);return 0!==r.length?`Object.assign(Array(${e.length}),{${(0,t.safeJoin)(r,",")}})`:`Array(${e.length})`}const r=(0,t.safeJoin)((0,t.safeMap)(e,e=>stringifyInternal(e,g,m)),",");return 0===e.length||e.length-1 in e?`[${r}]`:`[${r},]`}case"[object BigInt]":return l+"n";case"[object Boolean]":{const e=1==l?"true":"false";return"boolean"==typeof l?e:`new Boolean(${e})`}case"[object Date]":{const e=l;return s((0,t.safeGetTime)(e))?"new Date(NaN)":`new Date(${i((0,t.safeToISOString)(e))})`}case"[object Map]":return`new Map(${stringifyInternal(Array.from(l),g,m)})`;case"[object Null]":return"null";case"[object Number]":return"number"==typeof l?stringifyNumber(l):`new Number(${stringifyNumber(Number(l))})`;case"[object Object]":{try{const e=l.toString;if("function"==typeof e&&e!==Object.prototype.toString)return l.toString()}catch(e){return"[object Object]"}const mapper=e=>`${"__proto__"===e?'["__proto__"]':"symbol"==typeof e?`[${stringifyInternal(e,g,m)}]`:i(e)}:${stringifyInternal(l[e],g,m)}`,e=[...(0,t.safeMap)(o(l),mapper),...(0,t.safeMap)((0,t.safeFilter)(a(l),e=>{const t=u(l,e);return t&&t.enumerable}),mapper)],r="{"+(0,t.safeJoin)(e,",")+"}";return null===c(l)?"{}"===r?"Object.create(null)":`Object.assign(Object.create(null),${r})`:r}case"[object Set]":return`new Set(${stringifyInternal(Array.from(l),g,m)})`;case"[object String]":return"string"==typeof l?i(l):`new String(${i(l)})`;case"[object Symbol]":{const e=l;if(void 0!==t.Symbol.keyFor(e))return`Symbol.for(${i(t.Symbol.keyFor(e))})`;const r=function(e){if(void 0!==e.description)return e.description;const r=d.exec((0,t.String)(e));return r&&r[1].length?r[1]:null}(e);return null===r?"Symbol()":e===(r.startsWith("Symbol.")&&t.Symbol[r.substring(7)])?r:`Symbol(${i(r)})`}case"[object Promise]":{const e=m(l);switch(e.state){case"fulfilled":return`Promise.resolve(${stringifyInternal(e.value,g,m)})`;case"rejected":return`Promise.reject(${stringifyInternal(e.value,g,m)})`;case"pending":return"new Promise(() => {/*pending*/})";default:return"new Promise(() => {/*unknown*/})"}}case"[object Error]":if(l instanceof Error)return`new Error(${stringifyInternal(l.message,g,m)})`;break;case"[object Undefined]":return"undefined";case"[object Int8Array]":case"[object Uint8Array]":case"[object Uint8ClampedArray]":case"[object Int16Array]":case"[object Uint16Array]":case"[object Int32Array]":case"[object Uint32Array]":case"[object Float32Array]":case"[object Float64Array]":case"[object BigInt64Array]":case"[object BigUint64Array]":{if("function"==typeof n&&n(l))return`Buffer.from(${stringifyInternal(r(l.values()),g,m)})`;const e=c(l),t=e&&e.constructor&&e.constructor.name;if("string"==typeof t){const e=l.values();return`${t}.from(${stringifyInternal(r(e),g,m)})`}break}}try{return l.toString()}catch(e){return(0,t.safeToString)(l)}}function possiblyAsyncStringify(r){const n=(0,t.Symbol)(),i=[],s=new t.Map,o={state:"unknown",value:void 0},getAsyncContent=function(t){const r=t;if(s.has(r))return s.get(r);const a=function(){let e=null;return{delay:new Promise(t=>{e=setTimeout(()=>{e=null,t(n)},0)}),cancel:()=>{null!==e&&clearTimeout(e)}}}(),u=e.asyncToStringMethod in t?Promise.resolve().then(()=>t[e.asyncToStringMethod]()):t;return u.catch(()=>{}),i.push(Promise.race([u,a.delay]).then(e=>{e===n?s.set(r,{state:"pending",value:void 0}):s.set(r,{state:"fulfilled",value:e}),a.cancel()},e=>{s.set(r,{state:"rejected",value:e}),a.cancel()})),s.set(r,o),o};return function loop(){const e=stringifyInternal(r,[],getAsyncContent);return 0===i.length?e:Promise.all(i.splice(0)).then(loop)}()}}(cc),Object.defineProperty(uc,"__esModule",{value:!0}),uc.IgnoreEqualValuesProperty=void 0;const lc=cc,pc=Us;function fromSyncCached(e){return null===e?new pc.PreconditionFailure:e}uc.IgnoreEqualValuesProperty=class{constructor(e,t){this.property=e,this.skipRuns=t,this.coveredCases=new Map,void 0!==this.property.runBeforeEach&&void 0!==this.property.runAfterEach&&(this.runBeforeEach=()=>this.property.runBeforeEach(),this.runAfterEach=()=>this.property.runAfterEach())}isAsync(){return this.property.isAsync()}generate(e,t){return this.property.generate(e,t)}shrink(e){return this.property.shrink(e)}run(e,t){const r=(0,lc.stringify)(e);if(this.coveredCases.has(r)){const e=this.coveredCases.get(r);return this.skipRuns?(n=e,i=this.property.isAsync(),function(...e){return e[1]?e[0].then(fromSyncCached):fromSyncCached(e[0])}(n,i)):e}var n,i;const s=this.property.run(e,t);return this.coveredCases.set(r,s),s}},Object.defineProperty(rc,"__esModule",{value:!0}),rc.decorateProperty=function(e,t){let r=e;return e.isAsync()&&null!=t.timeout&&(r=new hc.TimeoutProperty(r,t.timeout,yc,bc)),t.unbiased&&(r=new dc.UnbiasedProperty(r)),null!=t.skipAllAfterTimeLimit&&(r=new fc.SkipAfterProperty(r,gc,t.skipAllAfterTimeLimit,!1,yc,bc)),null!=t.interruptAfterTimeLimit&&(r=new fc.SkipAfterProperty(r,gc,t.interruptAfterTimeLimit,!0,yc,bc)),t.skipEqualValues&&(r=new mc.IgnoreEqualValuesProperty(r,!0)),t.ignoreEqualValues&&(r=new mc.IgnoreEqualValuesProperty(r,!1)),r};const fc=nc,hc=sc,dc=ac,mc=uc,gc=Date.now,yc=setTimeout,bc=clearTimeout;var Sc,vc={},_c={},wc={};Object.defineProperty(wc,"__esModule",{value:!0}),wc.ExecutionStatus=void 0,function(e){e[e.Success=0]="Success",e[e.Skipped=-1]="Skipped",e[e.Failure=1]="Failure"}(Sc||(wc.ExecutionStatus=Sc={})),Object.defineProperty(_c,"__esModule",{value:!0}),_c.RunExecution=void 0;const kc=Zu,xc=wc,Ic=so;class RunExecution{constructor(e,t){this.verbosity=e,this.interruptedAsFailure=t,this.isSuccess=()=>null==this.pathToFailure,this.firstFailure=()=>this.pathToFailure?+(0,Ic.safeSplit)(this.pathToFailure,":")[0]:-1,this.numShrinks=()=>this.pathToFailure?(0,Ic.safeSplit)(this.pathToFailure,":").length-1:0,this.rootExecutionTrees=[],this.currentLevelExecutionTrees=this.rootExecutionTrees,this.failure=null,this.numSkips=0,this.numSuccesses=0,this.interrupted=!1}appendExecutionTree(e,t){const r={status:e,value:t,children:[]};return this.currentLevelExecutionTrees.push(r),r}fail(e,t,r){if(this.verbosity>=kc.VerbosityLevel.Verbose){const t=this.appendExecutionTree(xc.ExecutionStatus.Failure,e);this.currentLevelExecutionTrees=t.children}null==this.pathToFailure?this.pathToFailure=""+t:this.pathToFailure+=":"+t,this.value=e,this.failure=r}skip(e){this.verbosity>=kc.VerbosityLevel.VeryVerbose&&this.appendExecutionTree(xc.ExecutionStatus.Skipped,e),null==this.pathToFailure&&++this.numSkips}success(e){this.verbosity>=kc.VerbosityLevel.VeryVerbose&&this.appendExecutionTree(xc.ExecutionStatus.Success,e),null==this.pathToFailure&&++this.numSuccesses}interrupt(){this.interrupted=!0}extractFailures(){if(this.isSuccess())return[];const e=[];let t=this.rootExecutionTrees;for(;t.length>0&&t[t.length-1].status===xc.ExecutionStatus.Failure;){const r=t[t.length-1];e.push(r.value),t=r.children}return e}toRunDetails(e,t,r,n){if(!this.isSuccess())return{failed:!0,interrupted:this.interrupted,numRuns:this.firstFailure()+1-this.numSkips,numSkips:this.numSkips,numShrinks:this.numShrinks(),seed:e,counterexample:this.value,counterexamplePath:RunExecution.mergePaths(t,this.pathToFailure),error:this.failure.errorMessage,errorInstance:this.failure.error,failures:this.extractFailures(),executionSummary:this.rootExecutionTrees,verbose:this.verbosity,runConfiguration:n.toParameters()};const i=this.interruptedAsFailure||0===this.numSuccesses;return{failed:this.numSkips>r||this.interrupted&&i,interrupted:this.interrupted,numRuns:this.numSuccesses,numSkips:this.numSkips,numShrinks:0,seed:e,counterexample:null,counterexamplePath:null,error:null,errorInstance:null,failures:[],executionSummary:this.rootExecutionTrees,verbose:this.verbosity,runConfiguration:n.toParameters()}}}_c.RunExecution=RunExecution,RunExecution.mergePaths=(e,t)=>{if(0===e.length)return t;const r=e.split(":"),n=t.split(":"),i=+r[r.length-1]+ +n[0];return[...r.slice(0,r.length-1),""+i,...n.slice(1)].join(":")},Object.defineProperty(vc,"__esModule",{value:!0}),vc.RunnerIterator=void 0;const Tc=Us,Oc=_c;class RunnerIterator{constructor(e,t,r,n){this.sourceValues=e,this.shrink=t,this.runExecution=new Oc.RunExecution(r,n),this.currentIdx=-1,this.nextValues=e}[Symbol.iterator](){return this}next(){const e=this.nextValues.next();return e.done||this.runExecution.interrupted?{done:!0,value:void 0}:(this.currentValue=e.value,++this.currentIdx,{done:!1,value:e.value.value_})}handleResult(e){null==e||"object"!=typeof e||Tc.PreconditionFailure.isFailure(e)?null!=e?e.interruptExecution?this.runExecution.interrupt():(this.runExecution.skip(this.currentValue.value_),this.sourceValues.skippedOne()):this.runExecution.success(this.currentValue.value_):(this.runExecution.fail(this.currentValue.value_,this.currentIdx,e),this.currentIdx=-1,this.nextValues=this.shrink(this.currentValue))}}vc.RunnerIterator=RunnerIterator;var Ec={};Object.defineProperty(Ec,"__esModule",{value:!0}),Ec.SourceValuesIterator=void 0;class SourceValuesIterator{constructor(e,t,r){this.initialValues=e,this.maxInitialIterations=t,this.remainingSkips=r}[Symbol.iterator](){return this}next(){if(-1!==--this.maxInitialIterations&&this.remainingSkips>=0){const e=this.initialValues.next();if(!e.done)return{value:e.value,done:!1}}return{value:void 0,done:!0}}skippedOne(){--this.remainingSkips,++this.maxInitialIterations}}Ec.SourceValuesIterator=SourceValuesIterator;var Ac={},Cc={};Object.defineProperty(Cc,"__esModule",{value:!0}),Cc.Random=void 0;const Mc=iu;let Fc=class Random{constructor(e){this.internalRng=e.clone()}clone(){return new Random(this.internalRng)}next(e){return(0,Mc.unsafeUniformIntDistribution)(0,(1<<e)-1,this.internalRng)}nextBoolean(){return 1==(0,Mc.unsafeUniformIntDistribution)(0,1,this.internalRng)}nextInt(e,t){return(0,Mc.unsafeUniformIntDistribution)(e??Random.MIN_INT,t??Random.MAX_INT,this.internalRng)}nextBigInt(e,t){return(0,Mc.unsafeUniformBigIntDistribution)(e,t,this.internalRng)}nextArrayInt(e,t){return(0,Mc.unsafeUniformArrayIntDistribution)(e,t,this.internalRng)}nextDouble(){const e=this.next(26),t=this.next(27);return(e*Random.DBL_FACTOR+t)*Random.DBL_DIVISOR}getState(){if("getState"in this.internalRng&&"function"==typeof this.internalRng.getState)return this.internalRng.getState()}};Cc.Random=Fc,Fc.MIN_INT=-2147483648,Fc.MAX_INT=2147483647,Fc.DBL_FACTOR=134217728,Fc.DBL_DIVISOR=Math.pow(2,-53),Object.defineProperty(Ac,"__esModule",{value:!0}),Ac.toss=function*(e,t,r,n){for(let e=0;e!==n.length;++e)yield new jc.Value(n[e],void 0);for(let n=0,i=r(t);;++n)yield tossNext(e,i,n)},Ac.lazyToss=function*(e,t,r,n){yield*(0,Rc.safeMap)(n,e=>()=>new jc.Value(e,void 0));let i=0,s=r(t);for(;;)s=s.jump?s.jump():(0,Pc.skipN)(s,42),yield lazyGenerate(e,s,i++)};const Pc=iu,Nc=Cc,jc=Hs,Rc=so;function tossNext(e,t,r){return t.unsafeJump(),e.generate(new Nc.Random(t),r)}function lazyGenerate(e,t,r){return()=>e.generate(new Nc.Random(t),r)}var Dc={};function produce(e){return e()}Object.defineProperty(Dc,"__esModule",{value:!0}),Dc.pathWalk=function(e,t,r){const n=t,i=e.split(":").map(e=>+e);if(0===i.length)return n.map(produce);if(!i.every(e=>!Number.isNaN(e)))throw Error("Unable to replay, got invalid path="+e);let s=n.drop(i[0]).map(produce);for(const t of i.slice(1)){const n=s.getNthOrLast(0);if(null===n)throw Error("Unable to replay, got wrong path="+e);s=r(n).drop(t)}return s};var Lc={};Object.defineProperty(Lc,"__esModule",{value:!0}),Lc.reportRunDetails=function(e){return e.runConfiguration.asyncReporter?e.runConfiguration.asyncReporter(e):e.runConfiguration.reporter?e.runConfiguration.reporter(e):function(e){if(e.failed)throw buildError(defaultReportMessage(e),e)}(e)},Lc.asyncReportRunDetails=async function(e){return e.runConfiguration.asyncReporter?e.runConfiguration.asyncReporter(e):e.runConfiguration.reporter?e.runConfiguration.reporter(e):async function(e){if(e.failed)throw buildError(await asyncDefaultReportMessage(e),e)}(e)},Lc.defaultReportMessage=defaultReportMessage,Lc.asyncDefaultReportMessage=asyncDefaultReportMessage;const Uc=so,$c=cc,Bc=Zu,zc=wc,qc=Object.assign;function formatExecutionSummary(e,t){const r=[],n=[];for(const t of e.slice().reverse())n.push({depth:1,tree:t});for(;0!==n.length;){const e=n.pop(),i=e.tree,s=e.depth,o=i.status===zc.ExecutionStatus.Success?"\x1b[32m\u221a\x1b[0m":i.status===zc.ExecutionStatus.Failure?"\x1b[31m\xd7\x1b[0m":"\x1b[33m!\x1b[0m",a=Array(s).join(". ");r.push(`${a}${o} ${t(i.value)}`);for(const e of i.children.slice().reverse())n.push({depth:s+1,tree:e})}return"Execution summary:\n"+r.join("\n")}function defaultReportMessageInternal(e,t){if(!e.failed)return;const{message:r,details:n,hints:i}=null===e.counterexamplePath?e.interrupted?function(e,t){const r=`Property interrupted after ${e.numRuns} tests\n{ seed: ${e.seed} }`;let n=null;const i=[];return e.verbose>=Bc.VerbosityLevel.VeryVerbose?n=formatExecutionSummary(e.executionSummary,t):(0,Uc.safePush)(i,"Enable verbose mode at level VeryVerbose in order to check all generated values and their associated status"),{message:r,details:n,hints:i}}(e,t):function(e,t){const r=`Failed to run property, too many pre-condition failures encountered\n{ seed: ${e.seed} }\n\nRan ${e.numRuns} time(s)\nSkipped ${e.numSkips} time(s)`;let n=null;const i=["Try to reduce the number of rejected values by combining map, flatMap and built-in arbitraries","Increase failure tolerance by setting maxSkipsPerRun to an higher value"];return e.verbose>=Bc.VerbosityLevel.VeryVerbose?n=formatExecutionSummary(e.executionSummary,t):(0,Uc.safePush)(i,"Enable verbose mode at level VeryVerbose in order to check all generated values and their associated status"),{message:r,details:n,hints:i}}(e,t):function(e,t){const r=e.runConfiguration.errorWithCause?"":"\nGot "+(0,Uc.safeReplace)(e.error,/^Error: /,"error: "),n=`Property failed after ${e.numRuns} tests\n{ seed: ${e.seed}, path: "${e.counterexamplePath}", endOnFailure: true }\nCounterexample: ${t(e.counterexample)}\nShrunk ${e.numShrinks} time(s)${r}`;let i=null;const s=[];return e.verbose>=Bc.VerbosityLevel.VeryVerbose?i=formatExecutionSummary(e.executionSummary,t):e.verbose===Bc.VerbosityLevel.Verbose?i=function(e,t){return"Encountered failures were:\n- "+e.map(t).join("\n- ")}(e.failures,t):(0,Uc.safePush)(s,"Enable verbose mode in order to have the list of all failing values encountered during the run"),{message:n,details:i,hints:s}}(e,t);let s=r;return null!=n&&(s+="\n\n"+n),i.length>0&&(s+="\n\n"+function(e){return 1===e.length?"Hint: "+e[0]:e.map((e,t)=>`Hint (${t+1}): ${e}`).join("\n")}(i)),s}function defaultReportMessage(e){return defaultReportMessageInternal(e,$c.stringify)}async function asyncDefaultReportMessage(e){const t=[],r=defaultReportMessageInternal(e,function(e){const r=(0,$c.possiblyAsyncStringify)(e);return"string"==typeof r?r:(t.push(Promise.all([e,r])),"\u2026")});if(0===t.length)return r;const n=new Uc.Map(await Promise.all(t));return defaultReportMessageInternal(e,function(e){const t=(0,Uc.safeMapGet)(n,e);return void 0!==t?t:(0,$c.stringify)(e)})}function buildError(e,t){if(!t.runConfiguration.errorWithCause)throw new Uc.Error(e);const r=new(0,Uc.Error)(e,{cause:t.errorInstance});return"cause"in r||qc(r,{cause:t.errorInstance}),r}Object.defineProperty(ru,"__esModule",{value:!0}),ru.check=check$4,ru.assert=function(e,t){const r=check$4(e,t);if(e.isAsync())return r.then(Yc.asyncReportRunDetails);(0,Yc.reportRunDetails)(r)};const Wc=qs,Vc=Ia,Kc=nu,Gc=rc,Jc=vc,Hc=Ec,Zc=Ac,Qc=Dc,Yc=Lc,Xc=Object.assign;function check$4(e,t){if(null==e||null==e.generate)throw Error("Invalid property encountered, please use a valid property");if(null==e.run)throw Error("Invalid property encountered, please use a valid property not an arbitrary");const r=Kc.QualifiedParameters.read(Xc(Xc({},(0,Vc.readConfigureGlobal)()),t));if(null!==r.reporter&&null!==r.asyncReporter)throw Error("Invalid parameters encountered, reporter and asyncReporter cannot be specified together");if(null!==r.asyncReporter&&!e.isAsync())throw Error("Invalid parameters encountered, only asyncProperty can be used when asyncReporter specified");const n=(0,Gc.decorateProperty)(e,r),i=0===r.path.length||-1===r.path.indexOf(":")?r.numRuns:-1,s=r.numRuns*r.maxSkipsPerRun,shrink=(...e)=>n.shrink(...e),o=0===r.path.length?(0,Zc.toss)(n,r.seed,r.randomType,r.examples):(0,Qc.pathWalk)(r.path,(0,Wc.stream)((0,Zc.lazyToss)(n,r.seed,r.randomType,r.examples)),shrink),a=new Hc.SourceValuesIterator(o,i,s),u=r.endOnFailure?Wc.Stream.nil:shrink;return n.isAsync()?async function(e,t,r,n,i){const s=void 0!==e.runBeforeEach&&void 0!==e.runAfterEach,o=new Jc.RunnerIterator(r,t,n,i);for(const t of o){s&&await e.runBeforeEach();const r=await e.run(t,s);s&&await e.runAfterEach(),o.handleResult(r)}return o.runExecution}(n,u,a,r.verbose,r.markInterruptAsFailure).then(e=>e.toRunDetails(r.seed,r.path,s,r)):function(e,t,r,n,i){const s=void 0!==e.runBeforeEach&&void 0!==e.runAfterEach,o=new Jc.RunnerIterator(r,t,n,i);for(const t of o){s&&e.runBeforeEach();const r=e.run(t,s);s&&e.runAfterEach(),o.handleResult(r)}return o.runExecution}(n,u,a,r.verbose,r.markInterruptAsFailure).toRunDetails(r.seed,r.path,s,r)}var el={};Object.defineProperty(el,"__esModule",{value:!0}),el.sample=function(e,t){return[...streamSample(e,t)]},el.statistics=function(e,t,r){const n=Object.assign(Object.assign({},(0,il.readConfigureGlobal)()),"number"==typeof r?{numRuns:r}:r),i=sl.QualifiedParameters.read(n),s={};for(const n of streamSample(e,r)){const e=t(n),r=Array.isArray(e)?e:[e];for(const e of r)s[e]=(s[e]||0)+1}const o=Object.entries(s).sort((e,t)=>t[1]-e[1]).map(e=>{return[e[0],(t=100*e[1]/i.numRuns,(Math.round(100*t)/100).toFixed(2)+"%")];var t}),a=o.map(e=>e[0].length).reduce((e,t)=>Math.max(e,t),0),u=o.map(e=>e[1].length).reduce((e,t)=>Math.max(e,t),0);for(const e of o)i.logger(`${e[0].padEnd(a,".")}..${e[1].padStart(u,".")}`)};const tl=qs,rl=Wa,nl=ac,il=Ia,sl=nu,ol=Ac,al=Dc;function streamSample(e,t){const r=Object.assign(Object.assign({},(0,il.readConfigureGlobal)()),"number"==typeof t?{numRuns:t}:t),n=sl.QualifiedParameters.read(r),i=function(e,t){const r=Object.prototype.hasOwnProperty.call(e,"isAsync")?e:new rl.Property(e,()=>!0);return!0===t.unbiased?new nl.UnbiasedProperty(r):r}(e,n),s=i.shrink.bind(i);return(0===n.path.length?(0,tl.stream)((0,ol.toss)(i,n.seed,n.randomType,n.examples)):(0,al.pathWalk)(n.path,(0,tl.stream)((0,ol.lazyToss)(i,n.seed,n.randomType,n.examples)),s)).take(n.numRuns).map(e=>e.value_)}var ul={},cl={},ll={};Object.defineProperty(ll,"__esModule",{value:!0}),ll.buildGeneratorValue=function buildGeneratorValue(e,t,r,n){const i=r();let s=e.clone();const o={mrng:e.clone(),biasFactor:t,history:[]},a={values:()=>(0,hl.safeMap)(o.history,e=>e.value),[fl.cloneMethod]:()=>buildGeneratorValue(e,t,r,n).value,[dl.toStringMethod]:()=>(0,dl.stringify)((0,hl.safeMap)(o.history,e=>e.value))},u=ml((e,...r)=>(e=>{const r=i[o.history.length];if(void 0!==r&&r.arb===e){const t=r.value;return(0,hl.safePush)(o.history,{arb:e,value:t,context:r.context,mrng:r.mrng}),s=r.mrng.clone(),t}const n=e.generate(s,t);return(0,hl.safePush)(o.history,{arb:e,value:n.value_,context:n.context,mrng:s.clone()}),n.value})(n(e,r)),a);return new pl.Value(u,o)};const pl=Hs,fl=Js,hl=so,dl=cc,ml=Object.assign;var gl={};Object.defineProperty(gl,"__esModule",{value:!0}),gl.buildStableArbitraryGeneratorCache=function(e){const t=new yl.Map;return function(r,n){const i=(0,yl.safeMapGet)(t,r);if(void 0===i){const e=r(...n);return(0,yl.safeMapSet)(t,r,[{args:n,value:e}]),e}const s=i;for(const t of s)if(e(n,t.args))return t.value;const o=r(...n);return(0,yl.safePush)(s,{args:n,value:o}),o}},gl.naiveIsEqual=function naiveIsEqual(e,t){if(null!==e&&"object"==typeof e&&null!==t&&"object"==typeof t){if(bl(e)){if(!bl(t))return!1;if(e.length!==t.length)return!1}else if(bl(t))return!1;if(Sl(e).length!==Sl(t).length)return!1;for(const r in e){if(!(r in t))return!1;if(!naiveIsEqual(e[r],t[r]))return!1}return!0}return vl(e,t)};const yl=so,bl=Array.isArray,Sl=Object.keys,vl=Object.is;Object.defineProperty(cl,"__esModule",{value:!0}),cl.GeneratorArbitrary=void 0;const _l=zs,wl=qs,kl=so,xl=ll,Il=gl,Tl=io;class GeneratorArbitrary extends _l.Arbitrary{constructor(){super(...arguments),this.arbitraryCache=(0,Il.buildStableArbitraryGeneratorCache)(Il.naiveIsEqual)}generate(e,t){return(0,xl.buildGeneratorValue)(e,t,()=>[],this.arbitraryCache)}canShrinkWithoutContext(e){return!1}shrink(e,t){if(void 0===t)return wl.Stream.nil();const r=t,n=r.mrng,i=r.biasFactor,s=r.history;return(0,Tl.tupleShrink)(s.map(e=>e.arb),s.map(e=>e.value),s.map(e=>e.context)).map(e=>(0,xl.buildGeneratorValue)(n,i,function(){const t=e.value,r=e.context;return(0,kl.safeMap)(s,(e,n)=>({arb:e.arb,value:t[n],context:r[n],mrng:e.mrng}))},this.arbitraryCache))}}cl.GeneratorArbitrary=GeneratorArbitrary,Object.defineProperty(ul,"__esModule",{value:!0}),ul.gen=function(){return new Ol.GeneratorArbitrary};const Ol=cl;var El={},Al={},Cl={},Ml={},Fl={};Object.defineProperty(Fl,"__esModule",{value:!0}),Fl.integerLogLike=function(e){return Nl(jl(e)/jl(2))},Fl.bigIntLogLike=function(e){return e===(0,Pl.BigInt)(0)?(0,Pl.BigInt)(0):(0,Pl.BigInt)((0,Pl.String)(e).length)},Fl.biasNumericRange=function(e,t,r){if(e===t)return[{min:e,max:t}];if(e<0&&t>0){const n=r(-e),i=r(t);return[{min:-n,max:i},{min:t-i,max:t},{min:e,max:e+n}]}const n=r(t-e),i={min:e,max:e+n},s={min:t-n,max:t};return e<0?[s,i]:[i,s]};const Pl=so,Nl=Math.floor,jl=Math.log;var Rl={};Object.defineProperty(Rl,"__esModule",{value:!0}),Rl.shrinkInteger=function(e,t,r){const n=e-t;return n>0?(0,Ll.stream)(function*(){let i=r?void 0:t;for(let s=r?n:halvePosInteger(n);s>0;s=halvePosInteger(s)){const r=s===n?t:e-s;yield new Dl.Value(r,i),i=r}}()):(0,Ll.stream)(function*(){let i=r?void 0:t;for(let s=r?n:halveNegInteger(n);s<0;s=halveNegInteger(s)){const r=s===n?t:e-s;yield new Dl.Value(r,i),i=r}}())};const Dl=Hs,Ll=qs,Ul=Math.ceil,$l=Math.floor;function halvePosInteger(e){return $l(e/2)}function halveNegInteger(e){return Ul(e/2)}Object.defineProperty(Ml,"__esModule",{value:!0}),Ml.IntegerArbitrary=void 0;const Bl=zs,zl=Hs,ql=qs,Wl=Fl,Vl=Rl,Kl=Math.sign,Gl=Number.isInteger,Jl=Object.is;class IntegerArbitrary extends Bl.Arbitrary{constructor(e,t){super(),this.min=e,this.max=t}generate(e,t){const r=this.computeGenerateRange(e,t);return new zl.Value(e.nextInt(r.min,r.max),void 0)}canShrinkWithoutContext(e){return"number"==typeof e&&Gl(e)&&!Jl(e,-0)&&this.min<=e&&e<=this.max}shrink(e,t){if(!IntegerArbitrary.isValidContext(e,t)){const t=this.defaultTarget();return(0,Vl.shrinkInteger)(e,t,!0)}return this.isLastChanceTry(e,t)?ql.Stream.of(new zl.Value(t,void 0)):(0,Vl.shrinkInteger)(e,t,!1)}defaultTarget(){return this.min<=0&&this.max>=0?0:this.min<0?this.max:this.min}computeGenerateRange(e,t){if(void 0===t||1!==e.nextInt(1,t))return{min:this.min,max:this.max};const r=(0,Wl.biasNumericRange)(this.min,this.max,Wl.integerLogLike);if(1===r.length)return r[0];const n=e.nextInt(-2*(r.length-1),r.length-2);return n<0?r[0]:r[n+1]}isLastChanceTry(e,t){return e>0?e===t+1&&e>this.min:e<0&&e===t-1&&e<this.max}static isValidContext(e,t){if(void 0===t)return!1;if("number"!=typeof t)throw Error("Invalid context type passed to IntegerArbitrary (#1)");if(0!==t&&Kl(e)!==Kl(t))throw Error("Invalid context value passed to IntegerArbitrary (#2)");return!0}}Ml.IntegerArbitrary=IntegerArbitrary,Object.defineProperty(Cl,"__esModule",{value:!0}),Cl.integer=function(e={}){const t=function(e){return{min:void 0!==e.min?e.min:-2147483648,max:void 0!==e.max?e.max:2147483647}}(e);if(t.min>t.max)throw Error("fc.integer maximum value should be equal or greater than the minimum one");if(!Zl(t.min))throw Error("fc.integer minimum value should be an integer");if(!Zl(t.max))throw Error("fc.integer maximum value should be an integer");return new Hl.IntegerArbitrary(t.min,t.max)};const Hl=Ml,Zl=Number.isInteger;var Ql={};Object.defineProperty(Ql,"__esModule",{value:!0}),Ql.getDepthContextFor=function(e){if(void 0===e)return{depth:0};if("string"!=typeof e)return e;const t=(0,Yl.safeMapGet)(Xl,e);if(void 0!==t)return t;const r={depth:0};return(0,Yl.safeMapSet)(Xl,e,r),r},Ql.createDepthIdentifier=function(){return{depth:0}};const Yl=so,Xl=new Map;var ep={},tp={};Object.defineProperty(tp,"__esModule",{value:!0}),tp.NoopSlicedGenerator=void 0,tp.NoopSlicedGenerator=class{constructor(e,t,r){this.arb=e,this.mrng=t,this.biasFactor=r}attemptExact(){}next(){return this.arb.generate(this.mrng,this.biasFactor)}};var rp={};Object.defineProperty(rp,"__esModule",{value:!0}),rp.SlicedBasedGenerator=void 0;const np=Hs,ip=so,sp=Math.min,op=Math.max;rp.SlicedBasedGenerator=class{constructor(e,t,r,n){this.arb=e,this.mrng=t,this.slices=r,this.biasFactor=n,this.activeSliceIndex=0,this.nextIndexInSlice=0,this.lastIndexInSlice=-1}attemptExact(e){if(0!==e&&1===this.mrng.nextInt(1,this.biasFactor)){const t=[];for(let r=0;r!==this.slices.length;++r)this.slices[r].length===e&&(0,ip.safePush)(t,r);if(0===t.length)return;this.activeSliceIndex=t[this.mrng.nextInt(0,t.length-1)],this.nextIndexInSlice=0,this.lastIndexInSlice=e-1}}next(){if(this.nextIndexInSlice<=this.lastIndexInSlice)return new np.Value(this.slices[this.activeSliceIndex][this.nextIndexInSlice++],void 0);if(1!==this.mrng.nextInt(1,this.biasFactor))return this.arb.generate(this.mrng,this.biasFactor);this.activeSliceIndex=this.mrng.nextInt(0,this.slices.length-1);const e=this.slices[this.activeSliceIndex];if(1!==this.mrng.nextInt(1,this.biasFactor))return this.nextIndexInSlice=1,this.lastIndexInSlice=e.length-1,new np.Value(e[0],void 0);const t=this.mrng.nextInt(0,e.length-1),r=this.mrng.nextInt(0,e.length-1);return this.nextIndexInSlice=sp(t,r),this.lastIndexInSlice=op(t,r),new np.Value(e[this.nextIndexInSlice++],void 0)}},Object.defineProperty(ep,"__esModule",{value:!0}),ep.buildSlicedGenerator=function(e,t,r,n){return void 0===n||0===r.length||1!==t.nextInt(1,n)?new ap.NoopSlicedGenerator(e,t,n):new up.SlicedBasedGenerator(e,t,r,n)};const ap=tp,up=rp;Object.defineProperty(Al,"__esModule",{value:!0}),Al.ArrayArbitrary=void 0;const cp=qs,lp=Js,pp=Cl,fp=fa,hp=zs,dp=Hs,mp=Ql,gp=ep,yp=so,bp=Math.floor,Sp=Math.log,vp=Math.max,_p=Array.isArray;function biasedMaxLength(e,t){return e===t?e:e+bp(Sp(t-e)/Sp(2))}class ArrayArbitrary extends hp.Arbitrary{constructor(e,t,r,n,i,s,o){super(),this.arb=e,this.minLength=t,this.maxGeneratedLength=r,this.maxLength=n,this.setBuilder=s,this.customSlices=o,this.lengthArb=(0,pp.integer)({min:t,max:r}),this.depthContext=(0,mp.getDepthContextFor)(i)}preFilter(e){if(void 0===this.setBuilder)return e;const t=this.setBuilder();for(let r=0;r!==e.length;++r)t.tryAdd(e[r]);return t.getData()}static makeItCloneable(e,t){return e[lp.cloneMethod]=()=>{const e=[];for(let r=0;r!==t.length;++r)(0,yp.safePush)(e,t[r].value);return this.makeItCloneable(e,t),e},e}generateNItemsNoDuplicates(e,t,r,n){let i=0;const s=e(),o=(0,gp.buildSlicedGenerator)(this.arb,r,this.customSlices,n);for(;s.size()<t&&i<this.maxGeneratedLength;){const e=o.next();s.tryAdd(e)?i=0:i+=1}return s.getData()}safeGenerateNItemsNoDuplicates(e,t,r,n){const i=vp(0,t-biasedMaxLength(this.minLength,this.maxGeneratedLength));this.depthContext.depth+=i;try{return this.generateNItemsNoDuplicates(e,t,r,n)}finally{this.depthContext.depth-=i}}generateNItems(e,t,r){const n=[],i=(0,gp.buildSlicedGenerator)(this.arb,t,this.customSlices,r);i.attemptExact(e);for(let t=0;t!==e;++t){const e=i.next();(0,yp.safePush)(n,e)}return n}safeGenerateNItems(e,t,r){const n=vp(0,e-biasedMaxLength(this.minLength,this.maxGeneratedLength));this.depthContext.depth+=n;try{return this.generateNItems(e,t,r)}finally{this.depthContext.depth-=n}}wrapper(e,t,r,n){const i=t?this.preFilter(e):e;let s=!1;const o=[],a=[];for(let e=0;e!==i.length;++e){const t=i[e];s=s||t.hasToBeCloned,(0,yp.safePush)(o,t.value),(0,yp.safePush)(a,t.context)}s&&ArrayArbitrary.makeItCloneable(o,i);const u={shrunkOnce:t,lengthContext:e.length===i.length&&void 0!==r?r:void 0,itemsContexts:a,startIndex:n};return new dp.Value(o,u)}generate(e,t){const r=this.applyBias(e,t),n=r.size,i=void 0!==this.setBuilder?this.safeGenerateNItemsNoDuplicates(this.setBuilder,n,e,r.biasFactorItems):this.safeGenerateNItems(n,e,r.biasFactorItems);return this.wrapper(i,!1,void 0,0)}applyBias(e,t){if(void 0===t)return{size:this.lengthArb.generate(e,void 0).value};if(this.minLength===this.maxGeneratedLength)return{size:this.lengthArb.generate(e,void 0).value,biasFactorItems:t};if(1!==e.nextInt(1,t))return{size:this.lengthArb.generate(e,void 0).value};if(1!==e.nextInt(1,t)||this.minLength===this.maxGeneratedLength)return{size:this.lengthArb.generate(e,void 0).value,biasFactorItems:t};const r=biasedMaxLength(this.minLength,this.maxGeneratedLength);return{size:(0,pp.integer)({min:this.minLength,max:r}).generate(e,void 0).value,biasFactorItems:t}}canShrinkWithoutContext(e){if(!_p(e)||this.minLength>e.length||e.length>this.maxLength)return!1;for(let t=0;t!==e.length;++t){if(!(t in e))return!1;if(!this.arb.canShrinkWithoutContext(e[t]))return!1}return this.preFilter((0,yp.safeMap)(e,e=>new dp.Value(e,void 0))).length===e.length}shrinkItemByItem(e,t,r){const n=[];for(let i=t.startIndex;i<r;++i)(0,yp.safePush)(n,(0,fp.makeLazy)(()=>this.arb.shrink(e[i],t.itemsContexts[i]).map(r=>{const n=(0,yp.safeMap)((0,yp.safeSlice)(e,0,i),(e,r)=>new dp.Value((0,lp.cloneIfNeeded)(e),t.itemsContexts[r])),s=(0,yp.safeMap)((0,yp.safeSlice)(e,i+1),(e,r)=>new dp.Value((0,lp.cloneIfNeeded)(e),t.itemsContexts[r+i+1]));return[[...n,r,...s],void 0,i]})));return cp.Stream.nil().join(...n)}shrinkImpl(e,t){if(0===e.length)return cp.Stream.nil();const r=void 0!==t?t:{shrunkOnce:!1,lengthContext:void 0,itemsContexts:[],startIndex:0};return this.lengthArb.shrink(e.length,r.lengthContext).drop(r.shrunkOnce&&void 0===r.lengthContext&&e.length>this.minLength+1?1:0).map(t=>{const n=e.length-t.value;return[(0,yp.safeMap)((0,yp.safeSlice)(e,n),(e,t)=>new dp.Value((0,lp.cloneIfNeeded)(e),r.itemsContexts[t+n])),t.context,0]}).join((0,fp.makeLazy)(()=>e.length>this.minLength?this.shrinkItemByItem(e,r,1):this.shrinkItemByItem(e,r,e.length))).join(e.length>this.minLength?(0,fp.makeLazy)(()=>{const t={shrunkOnce:!1,lengthContext:void 0,itemsContexts:(0,yp.safeSlice)(r.itemsContexts,1),startIndex:0};return this.shrinkImpl((0,yp.safeSlice)(e,1),t).filter(e=>this.minLength<=e[0].length+1).map(t=>[[new dp.Value((0,lp.cloneIfNeeded)(e[0]),r.itemsContexts[0]),...t[0]],void 0,0])}):cp.Stream.nil())}shrink(e,t){return this.shrinkImpl(e,t).map(e=>this.wrapper(e[0],!0,e[1],e[2]))}}Al.ArrayArbitrary=ArrayArbitrary;var wp={};!function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.DefaultSize=e.MaxLengthUpperBound=void 0,e.maxLengthFromMinLength=maxLengthFromMinLength,e.relativeSizeToSize=relativeSizeToSize,e.maxGeneratedLengthFromSizeForArbitrary=function(r,n,s,o){const{baseSize:a=e.DefaultSize,defaultSizeToMaxWhenMaxSpecified:u}=(0,t.readConfigureGlobal)()||{},c=void 0!==r?r:o&&u?"max":a;if("max"===c)return s;const l=relativeSizeToSize(c,a);return i(maxLengthFromMinLength(n,l),s)},e.depthBiasFromSizeForArbitrary=function(r,n){if("number"==typeof r)return 1/r;const{baseSize:i=e.DefaultSize,defaultSizeToMaxWhenMaxSpecified:s}=(0,t.readConfigureGlobal)()||{},o=void 0!==r?r:n&&s?"max":i;if("max"===o)return 0;switch(relativeSizeToSize(o,i)){case"xsmall":return 1;case"small":return.5;case"medium":return.25;case"large":return.125;case"xlarge":return.0625}},e.resolveSize=function(r){const{baseSize:n=e.DefaultSize}=(0,t.readConfigureGlobal)()||{};return void 0===r?n:relativeSizeToSize(r,n)};const t=Ia,r=so,n=Math.floor,i=Math.min;e.MaxLengthUpperBound=2147483647;const s=["xsmall","small","medium","large","xlarge"],o=["-4","-3","-2","-1","=","+1","+2","+3","+4"];function maxLengthFromMinLength(e,t){switch(t){case"xsmall":return n(1.1*e)+1;case"small":return 2*e+10;case"medium":return 11*e+100;case"large":return 101*e+1e3;case"xlarge":return 1001*e+1e4;default:throw Error("Unable to compute lengths based on received size: "+t)}}function relativeSizeToSize(e,t){const n=(0,r.safeIndexOf)(o,e);if(-1===n)return e;const i=(0,r.safeIndexOf)(s,t);if(-1===i)throw Error("Unable to offset size based on the unknown defaulted one: "+t);const a=i+n-4;return a<0?s[0]:a>=s.length?s[s.length-1]:s[a]}e.DefaultSize="small"}(wp),Object.defineProperty(El,"__esModule",{value:!0}),El.array=function(e,t={}){const r=t.size,n=t.minLength||0,i=t.maxLength,s=t.depthIdentifier,o=void 0!==i?i:xp.MaxLengthUpperBound,a=void 0!==i,u=(0,xp.maxGeneratedLengthFromSizeForArbitrary)(r,n,o,a),c=t.experimentalCustomSlices||[];return new kp.ArrayArbitrary(e,n,u,o,s,void 0,c)};const kp=Al,xp=wp;var Ip={},Tp={},Op={};Object.defineProperty(Op,"__esModule",{value:!0}),Op.shrinkBigInt=function(e,t,r){const n=e-t;return n>0?(0,Ep.stream)(function*(){let i=r?void 0:t;for(let t=r?n:halveBigInt(n);t>0;t=halveBigInt(t)){const r=e-t;yield new Ap.Value(r,i),i=r}}()):(0,Ep.stream)(function*(){let i=r?void 0:t;for(let t=r?n:halveBigInt(n);t<0;t=halveBigInt(t)){const r=e-t;yield new Ap.Value(r,i),i=r}}())};const Ep=qs,Ap=Hs,Cp=so;function halveBigInt(e){return e/(0,Cp.BigInt)(2)}Object.defineProperty(Tp,"__esModule",{value:!0}),Tp.BigIntArbitrary=void 0;const Mp=qs,Fp=zs,Pp=Hs,Np=Fl,jp=Op,Rp=so;class BigIntArbitrary extends Fp.Arbitrary{constructor(e,t){super(),this.min=e,this.max=t}generate(e,t){const r=this.computeGenerateRange(e,t);return new Pp.Value(e.nextBigInt(r.min,r.max),void 0)}computeGenerateRange(e,t){if(void 0===t||1!==e.nextInt(1,t))return{min:this.min,max:this.max};const r=(0,Np.biasNumericRange)(this.min,this.max,Np.bigIntLogLike);if(1===r.length)return r[0];const n=e.nextInt(-2*(r.length-1),r.length-2);return n<0?r[0]:r[n+1]}canShrinkWithoutContext(e){return"bigint"==typeof e&&this.min<=e&&e<=this.max}shrink(e,t){if(!BigIntArbitrary.isValidContext(e,t)){const t=this.defaultTarget();return(0,jp.shrinkBigInt)(e,t,!0)}return this.isLastChanceTry(e,t)?Mp.Stream.of(new Pp.Value(t,void 0)):(0,jp.shrinkBigInt)(e,t,!1)}defaultTarget(){return this.min<=0&&this.max>=0?(0,Rp.BigInt)(0):this.min<0?this.max:this.min}isLastChanceTry(e,t){return e>0?e===t+(0,Rp.BigInt)(1)&&e>this.min:e<0&&e===t-(0,Rp.BigInt)(1)&&e<this.max}static isValidContext(e,t){if(void 0===t)return!1;if("bigint"!=typeof t)throw Error("Invalid context type passed to BigIntArbitrary (#1)");const r=e>0&&t<0||e<0&&t>0;if(t!==(0,Rp.BigInt)(0)&&r)throw Error("Invalid context value passed to BigIntArbitrary (#2)");return!0}}Tp.BigIntArbitrary=BigIntArbitrary,Object.defineProperty(Ip,"__esModule",{value:!0}),Ip.bigInt=function(...e){const t=function(e){const t=(0,Dp.BigInt)(-1)<<(0,Dp.BigInt)(255),r=((0,Dp.BigInt)(1)<<(0,Dp.BigInt)(255))-(0,Dp.BigInt)(1),n=e.min,i=e.max;return{min:void 0!==n?n:t-(void 0!==i&&i<(0,Dp.BigInt)(0)?i*i:(0,Dp.BigInt)(0)),max:void 0!==i?i:r+(void 0!==n&&n>(0,Dp.BigInt)(0)?n*n:(0,Dp.BigInt)(0))}}(function(e){return void 0===e[0]?{}:void 0===e[1]?e[0]:{min:e[0],max:e[1]}}(e));if(t.min>t.max)throw Error("fc.bigInt expects max to be greater than or equal to min");return new Lp.BigIntArbitrary(t.min,t.max)};const Dp=so,Lp=Tp;var Up={};Object.defineProperty(Up,"__esModule",{value:!0}),Up.bigIntN=function(e){if(e<1)throw Error("fc.bigIntN expects requested number of bits to be superior or equal to 1");const t=(0,$p.BigInt)(-1)<<(0,$p.BigInt)(e-1),r=((0,$p.BigInt)(1)<<(0,$p.BigInt)(e-1))-(0,$p.BigInt)(1);return new Bp.BigIntArbitrary(t,r)};const $p=so,Bp=Tp;var zp={};Object.defineProperty(zp,"__esModule",{value:!0}),zp.bigUint=function(e){const t="object"==typeof e?e.max:e,r=void 0!==t?t:((0,qp.BigInt)(1)<<(0,qp.BigInt)(256))-(0,qp.BigInt)(1);if(r<0)throw Error("fc.bigUint expects max to be greater than or equal to zero");return new Wp.BigIntArbitrary((0,qp.BigInt)(0),r)};const qp=so,Wp=Tp;var Vp={};Object.defineProperty(Vp,"__esModule",{value:!0}),Vp.bigUintN=function(e){if(e<0)throw Error("fc.bigUintN expects requested number of bits to be superior or equal to 0");const t=(0,Kp.BigInt)(0),r=((0,Kp.BigInt)(1)<<(0,Kp.BigInt)(e))-(0,Kp.BigInt)(1);return new Gp.BigIntArbitrary(t,r)};const Kp=so,Gp=Tp;var Jp={},Hp={};Object.defineProperty(Hp,"__esModule",{value:!0}),Hp.noBias=function(e){return e.noBias()},Object.defineProperty(Jp,"__esModule",{value:!0}),Jp.boolean=function(){return(0,Qp.noBias)((0,Zp.integer)({min:0,max:1}).map(booleanMapper,booleanUnmapper))};const Zp=Cl,Qp=Hp;function booleanMapper(e){return 1===e}function booleanUnmapper(e){if("boolean"!=typeof e)throw Error("Unsupported input type");return!0===e?1:0}var Yp={},Xp={},ef={};Object.defineProperty(ef,"__esModule",{value:!0}),ef.ConstantArbitrary=void 0;const tf=qs,rf=zs,nf=Hs,sf=Js,of=so,af=Object.is;class ConstantArbitrary extends rf.Arbitrary{constructor(e){super(),this.values=e}generate(e,t){const r=1===this.values.length?0:e.nextInt(0,this.values.length-1),n=this.values[r];return(0,sf.hasCloneMethod)(n)?new nf.Value(n,r,()=>n[sf.cloneMethod]()):new nf.Value(n,r)}canShrinkWithoutContext(e){return 1===this.values.length?af(this.values[0],e):(void 0===this.fastValues&&(this.fastValues=new FastConstantValuesLookup(this.values)),this.fastValues.has(e))}shrink(e,t){return 0===t||af(e,this.values[0])?tf.Stream.nil():tf.Stream.of(new nf.Value(this.values[0],0))}}ef.ConstantArbitrary=ConstantArbitrary;class FastConstantValuesLookup{constructor(e){this.values=e,this.fastValues=new of.Set(this.values);let t=!1,r=!1;if((0,of.safeHas)(this.fastValues,0))for(let e=0;e!==this.values.length;++e){const n=this.values[e];t=t||af(n,-0),r=r||af(n,0)}this.hasMinusZero=t,this.hasPlusZero=r}has(e){return 0===e?af(e,0)?this.hasPlusZero:this.hasMinusZero:(0,of.safeHas)(this.fastValues,e)}}Object.defineProperty(Xp,"__esModule",{value:!0}),Xp.constantFrom=function(...e){if(0===e.length)throw Error("fc.constantFrom expects at least one parameter");return new uf.ConstantArbitrary(e)};const uf=ef;Object.defineProperty(Yp,"__esModule",{value:!0}),Yp.falsy=function(e){return e&&e.withBigInt?(0,lf.constantFrom)(!1,null,void 0,0,"",NaN,(0,cf.BigInt)(0)):(0,lf.constantFrom)(!1,null,void 0,0,"",NaN)};const cf=so,lf=Xp;var pf={},ff={},hf={};Object.defineProperty(hf,"__esModule",{value:!0}),hf.indexToCharStringMapper=void 0,hf.indexToCharStringUnmapper=function(e){if("string"!=typeof e)throw Error("Cannot unmap non-string");if(0===e.length||e.length>2)throw Error("Cannot unmap string with more or less than one character");const t=(0,df.safeCharCodeAt)(e,0);if(1===e.length)return t;const r=(0,df.safeCharCodeAt)(e,1);if(t<55296||t>56319||r<56320||r>57343)throw Error("Cannot unmap invalid surrogate pairs");return e.codePointAt(0)};const df=so;hf.indexToCharStringMapper=String.fromCodePoint,Object.defineProperty(ff,"__esModule",{value:!0}),ff.buildCharacterArbitrary=function(e,t,r,n){return(0,mf.integer)({min:e,max:t}).map(e=>(0,gf.indexToCharStringMapper)(r(e)),e=>n((0,gf.indexToCharStringUnmapper)(e)))};const mf=Cl,gf=hf;var yf={};Object.defineProperty(yf,"__esModule",{value:!0}),yf.indexToPrintableIndexMapper=function(e){return e<95?e+32:e<=126?e-95:e},yf.indexToPrintableIndexUnmapper=function(e){return e>=32&&e<=126?e-32:e>=0&&e<=31?e+95:e},Object.defineProperty(pf,"__esModule",{value:!0}),pf.ascii=function(){return(0,bf.buildCharacterArbitrary)(0,127,Sf.indexToPrintableIndexMapper,Sf.indexToPrintableIndexUnmapper)};const bf=ff,Sf=yf;var vf={};Object.defineProperty(vf,"__esModule",{value:!0}),vf.base64=function(){return(0,_f.buildCharacterArbitrary)(0,63,base64Mapper,base64Unmapper)};const _f=ff;function base64Mapper(e){return e<26?e+65:e<52?e+97-26:e<62?e+48-52:62===e?43:47}function base64Unmapper(e){return e>=65&&e<=90?e-65:e>=97&&e<=122?e-97+26:e>=48&&e<=57?e-48+52:43===e?62:47===e?63:-1}var wf={};Object.defineProperty(wf,"__esModule",{value:!0}),wf.char=function(){return(0,kf.buildCharacterArbitrary)(32,126,identity$4,identity$4)};const kf=ff;function identity$4(e){return e}var xf={};Object.defineProperty(xf,"__esModule",{value:!0}),xf.char16bits=function(){return(0,If.buildCharacterArbitrary)(0,65535,Tf.indexToPrintableIndexMapper,Tf.indexToPrintableIndexUnmapper)};const If=ff,Tf=yf;var Of={};Object.defineProperty(Of,"__esModule",{value:!0}),Of.fullUnicode=function(){return(0,Ef.buildCharacterArbitrary)(0,1114111-Cf,unicodeMapper$1,unicodeUnmapper$1)};const Ef=ff,Af=yf,Cf=2048;function unicodeMapper$1(e){return e<55296?(0,Af.indexToPrintableIndexMapper)(e):e+Cf}function unicodeUnmapper$1(e){return e<55296?(0,Af.indexToPrintableIndexUnmapper)(e):e<=57343?-1:e-Cf}var Mf={};Object.defineProperty(Mf,"__esModule",{value:!0}),Mf.hexa=function(){return(0,Ff.buildCharacterArbitrary)(0,15,hexaMapper,hexaUnmapper)};const Ff=ff;function hexaMapper(e){return e<10?e+48:e+97-10}function hexaUnmapper(e){return e<58?e-48:e>=97&&e<103?e-97+10:-1}var Pf={};Object.defineProperty(Pf,"__esModule",{value:!0}),Pf.unicode=function(){return(0,Nf.buildCharacterArbitrary)(0,65535-Rf,unicodeMapper,unicodeUnmapper)};const Nf=ff,jf=yf,Rf=2048;function unicodeMapper(e){return e<55296?(0,jf.indexToPrintableIndexMapper)(e):e+Rf}function unicodeUnmapper(e){return e<55296?(0,jf.indexToPrintableIndexUnmapper)(e):e<=57343?-1:e-Rf}var Df={};Object.defineProperty(Df,"__esModule",{value:!0}),Df.constant=function(e){return new Lf.ConstantArbitrary([e])};const Lf=ef;var Uf={};Object.defineProperty(Uf,"__esModule",{value:!0}),Uf.context=function(){return(0,Bf.constant)(new ContextImplem)};const $f=Js,Bf=Df;class ContextImplem{constructor(){this.receivedLogs=[]}log(e){this.receivedLogs.push(e)}size(){return this.receivedLogs.length}toString(){return JSON.stringify({logs:this.receivedLogs})}[$f.cloneMethod](){return new ContextImplem}}var zf={},qf={};Object.defineProperty(qf,"__esModule",{value:!0}),qf.timeToDateMapper=timeToDateMapper,qf.timeToDateUnmapper=timeToDateUnmapper,qf.timeToDateMapperWithNaN=function(e){return t=>t===e?new Wf.Date(Vf):timeToDateMapper(t)},qf.timeToDateUnmapperWithNaN=function(e){return t=>{const r=timeToDateUnmapper(t);return Kf(r)?e:r}};const Wf=so,Vf=NaN,Kf=Number.isNaN;function timeToDateMapper(e){return new Wf.Date(e)}function timeToDateUnmapper(e){if(!(e instanceof Wf.Date)||e.constructor!==Wf.Date)throw new Wf.Error("Not a valid value for date unmapper");return(0,Wf.safeGetTime)(e)}Object.defineProperty(zf,"__esModule",{value:!0}),zf.date=function(e={}){const t=void 0!==e.min?(0,Gf.safeGetTime)(e.min):-864e13,r=void 0!==e.max?(0,Gf.safeGetTime)(e.max):864e13,n=void 0===e.noInvalidDate||e.noInvalidDate;if(Zf(t))throw Error("fc.date min must be valid instance of Date");if(Zf(r))throw Error("fc.date max must be valid instance of Date");if(t>r)throw Error("fc.date max must be greater or equal to min");if(n)return(0,Jf.integer)({min:t,max:r}).map(Hf.timeToDateMapper,Hf.timeToDateUnmapper);const i=r+1;return(0,Jf.integer)({min:t,max:r+1}).map((0,Hf.timeToDateMapperWithNaN)(i),(0,Hf.timeToDateUnmapperWithNaN)(i))};const Gf=so,Jf=Cl,Hf=qf,Zf=Number.isNaN;var Qf={},Yf={};Object.defineProperty(Yf,"__esModule",{value:!0}),Yf.CloneArbitrary=void 0;const Xf=zs,eh=Hs,th=Js,rh=qs,nh=so,ih=Symbol.iterator,sh=Array.isArray,oh=Object.is;class CloneArbitrary extends Xf.Arbitrary{constructor(e,t){super(),this.arb=e,this.numValues=t}generate(e,t){const r=[];if(this.numValues<=0)return this.wrapper(r);for(let n=0;n!==this.numValues-1;++n)(0,nh.safePush)(r,this.arb.generate(e.clone(),t));return(0,nh.safePush)(r,this.arb.generate(e,t)),this.wrapper(r)}canShrinkWithoutContext(e){if(!sh(e)||e.length!==this.numValues)return!1;if(0===e.length)return!0;for(let t=1;t<e.length;++t)if(!oh(e[0],e[t]))return!1;return this.arb.canShrinkWithoutContext(e[0])}shrink(e,t){return 0===e.length?rh.Stream.nil():new rh.Stream(this.shrinkImpl(e,void 0!==t?t:[])).map(e=>this.wrapper(e))}*shrinkImpl(e,t){const r=(0,nh.safeMap)(e,(e,r)=>this.arb.shrink(e,t[r])[ih]());let n=(0,nh.safeMap)(r,e=>e.next());for(;!n[0].done;)yield(0,nh.safeMap)(n,e=>e.value),n=(0,nh.safeMap)(r,e=>e.next())}static makeItCloneable(e,t){return e[th.cloneMethod]=()=>{const e=[];for(let r=0;r!==t.length;++r)(0,nh.safePush)(e,t[r].value);return this.makeItCloneable(e,t),e},e}wrapper(e){let t=!1;const r=[],n=[];for(let i=0;i!==e.length;++i){const s=e[i];t=t||s.hasToBeCloned,(0,nh.safePush)(r,s.value),(0,nh.safePush)(n,s.context)}return t&&CloneArbitrary.makeItCloneable(r,e),new eh.Value(r,n)}}Yf.CloneArbitrary=CloneArbitrary,Object.defineProperty(Qf,"__esModule",{value:!0}),Qf.clone=function(e,t){return new ah.CloneArbitrary(e,t)};const ah=Yf;var uh={},ch={},lh={};Object.defineProperty(lh,"__esModule",{value:!0}),lh.CustomEqualSet=void 0;const ph=so;lh.CustomEqualSet=class{constructor(e){this.isEqual=e,this.data=[]}tryAdd(e){for(let t=0;t!==this.data.length;++t)if(this.isEqual(this.data[t],e))return!1;return(0,ph.safePush)(this.data,e),!0}size(){return this.data.length}getData(){return this.data}};var fh={};Object.defineProperty(fh,"__esModule",{value:!0}),fh.StrictlyEqualSet=void 0;const hh=so,dh=Number.isNaN;fh.StrictlyEqualSet=class{constructor(e){this.selector=e,this.selectedItemsExceptNaN=new hh.Set,this.data=[]}tryAdd(e){const t=this.selector(e);if(dh(t))return(0,hh.safePush)(this.data,e),!0;const r=this.selectedItemsExceptNaN.size;return(0,hh.safeAdd)(this.selectedItemsExceptNaN,t),r!==this.selectedItemsExceptNaN.size&&((0,hh.safePush)(this.data,e),!0)}size(){return this.data.length}getData(){return this.data}};var mh={};Object.defineProperty(mh,"__esModule",{value:!0}),mh.SameValueSet=void 0;const gh=so,yh=Object.is;mh.SameValueSet=class{constructor(e){this.selector=e,this.selectedItemsExceptMinusZero=new gh.Set,this.data=[],this.hasMinusZero=!1}tryAdd(e){const t=this.selector(e);if(yh(t,-0))return!this.hasMinusZero&&((0,gh.safePush)(this.data,e),this.hasMinusZero=!0,!0);const r=this.selectedItemsExceptMinusZero.size;return(0,gh.safeAdd)(this.selectedItemsExceptMinusZero,t),r!==this.selectedItemsExceptMinusZero.size&&((0,gh.safePush)(this.data,e),!0)}size(){return this.data.length}getData(){return this.data}};var bh={};Object.defineProperty(bh,"__esModule",{value:!0}),bh.SameValueZeroSet=void 0;const Sh=so;bh.SameValueZeroSet=class{constructor(e){this.selector=e,this.selectedItems=new Sh.Set,this.data=[]}tryAdd(e){const t=this.selector(e),r=this.selectedItems.size;return(0,Sh.safeAdd)(this.selectedItems,t),r!==this.selectedItems.size&&((0,Sh.safePush)(this.data,e),!0)}size(){return this.data.length}getData(){return this.data}},Object.defineProperty(ch,"__esModule",{value:!0}),ch.uniqueArray=function(e,t={}){const r=void 0!==t.minLength?t.minLength:0,n=void 0!==t.maxLength?t.maxLength:_h.MaxLengthUpperBound,i=(0,_h.maxGeneratedLengthFromSizeForArbitrary)(t.size,r,n,void 0!==t.maxLength),s=t.depthIdentifier,o=function(e){if("function"==typeof e.comparator){if(void 0===e.selector){const t=e.comparator,isEqualForBuilder=(e,r)=>t(e.value_,r.value_);return()=>new wh.CustomEqualSet(isEqualForBuilder)}const t=e.comparator,r=e.selector,refinedSelector=e=>r(e.value_),isEqualForBuilder=(e,r)=>t(refinedSelector(e),refinedSelector(r));return()=>new wh.CustomEqualSet(isEqualForBuilder)}const t=e.selector||(e=>e),refinedSelector=e=>t(e.value_);switch(e.comparator){case"IsStrictlyEqual":return()=>new kh.StrictlyEqualSet(refinedSelector);case"SameValueZero":return()=>new Ih.SameValueZeroSet(refinedSelector);case"SameValue":case void 0:return()=>new xh.SameValueSet(refinedSelector)}}(t),a=new vh.ArrayArbitrary(e,r,i,n,s,o,[]);return 0===r?a:a.filter(e=>e.length>=r)};const vh=Al,_h=wp,wh=lh,kh=fh,xh=mh,Ih=bh;var Th={};Object.defineProperty(Th,"__esModule",{value:!0}),Th.keyValuePairsToObjectMapper=function(e){const t=e[1]?Eh(null):{};for(const r of e[0])Ah(t,r[0],{enumerable:!0,configurable:!0,writable:!0,value:r[1]});return t},Th.keyValuePairsToObjectUnmapper=function(e){if("object"!=typeof e||null===e)throw new Oh.Error("Incompatible instance received: should be a non-null object");const t=null===Mh(e),r="constructor"in e&&e.constructor===Object;if(!t&&!r)throw new Oh.Error("Incompatible instance received: should be of exact type Object");if(Fh(e).length>0)throw new Oh.Error("Incompatible instance received: should contain symbols");if(!(0,Oh.safeEvery)(Ph(e),(n=e,function(e){const t=Ch(n,e);return void 0!==t&&!!t.configurable&&!!t.enumerable&&!!t.writable&&void 0===t.get&&void 0===t.set})))throw new Oh.Error("Incompatible instance received: should contain only c/e/w properties without get/set");var n;return[Nh(e),t]};const Oh=so,Eh=Object.create,Ah=Object.defineProperty,Ch=Object.getOwnPropertyDescriptor,Mh=Object.getPrototypeOf,Fh=Object.getOwnPropertySymbols,Ph=Object.getOwnPropertyNames,Nh=Object.entries;Object.defineProperty(uh,"__esModule",{value:!0}),uh.dictionary=function(e,t,r={}){const n=!1!==r.noNullPrototype;return(0,jh.tuple)((0,Rh.uniqueArray)((0,jh.tuple)(e,t),{minLength:r.minKeys,maxLength:r.maxKeys,size:r.size,selector:dictionaryKeyExtractor,depthIdentifier:r.depthIdentifier}),n?(0,Lh.constant)(!1):(0,Uh.boolean)()).map(Dh.keyValuePairsToObjectMapper,Dh.keyValuePairsToObjectUnmapper)};const jh=no,Rh=ch,Dh=Th,Lh=Df,Uh=Jp;function dictionaryKeyExtractor(e){return e[0]}var $h={},Bh={},zh={},qh={};Object.defineProperty(qh,"__esModule",{value:!0}),qh.FrequencyArbitrary=void 0;const Wh=qs,Vh=zs,Kh=Hs,Gh=Ql,Jh=wp,Hh=so,Zh=1/0,Qh=Number.MAX_SAFE_INTEGER,Yh=Number.isInteger,Xh=Math.floor,ed=Math.pow,td=Math.min;class FrequencyArbitrary extends Vh.Arbitrary{static from(e,t,r){if(0===e.length)throw Error(r+" expects at least one weighted arbitrary");let n=0;for(let t=0;t!==e.length;++t){if(void 0===e[t].arbitrary)throw Error(r+" expects arbitraries to be specified");const i=e[t].weight;if(n+=i,!Yh(i))throw Error(r+" expects weights to be integer values");if(i<0)throw Error(r+" expects weights to be superior or equal to 0")}if(n<=0)throw Error(r+" expects the sum of weights to be strictly superior to 0");const i={depthBias:(0,Jh.depthBiasFromSizeForArbitrary)(t.depthSize,void 0!==t.maxDepth),maxDepth:null!=t.maxDepth?t.maxDepth:Zh,withCrossShrink:!!t.withCrossShrink};return new FrequencyArbitrary(e,i,(0,Gh.getDepthContextFor)(t.depthIdentifier))}constructor(e,t,r){super(),this.warbs=e,this.constraints=t,this.context=r;let n=0;this.cumulatedWeights=[];for(let t=0;t!==e.length;++t)n+=e[t].weight,(0,Hh.safePush)(this.cumulatedWeights,n);this.totalWeight=n}generate(e,t){if(this.mustGenerateFirst())return this.safeGenerateForIndex(e,0,t);const r=e.nextInt(this.computeNegDepthBenefit(),this.totalWeight-1);for(let n=0;n!==this.cumulatedWeights.length;++n)if(r<this.cumulatedWeights[n])return this.safeGenerateForIndex(e,n,t);throw Error("Unable to generate from fc.frequency")}canShrinkWithoutContext(e){return-1!==this.canShrinkWithoutContextIndex(e)}shrink(e,t){if(void 0!==t){const r=t,n=r.selectedIndex,i=r.originalBias,s=this.warbs[n].arbitrary.shrink(e,r.originalContext).map(e=>this.mapIntoValue(n,e,null,i));if(null!==r.clonedMrngForFallbackFirst){void 0===r.cachedGeneratedForFirst&&(r.cachedGeneratedForFirst=this.safeGenerateForIndex(r.clonedMrngForFallbackFirst,0,i));const e=r.cachedGeneratedForFirst;return Wh.Stream.of(e).join(s)}return s}const r=this.canShrinkWithoutContextIndex(e);return-1===r?Wh.Stream.nil():this.defaultShrinkForFirst(r).join(this.warbs[r].arbitrary.shrink(e,void 0).map(e=>this.mapIntoValue(r,e,null,void 0)))}defaultShrinkForFirst(e){++this.context.depth;try{if(!this.mustFallbackToFirstInShrink(e)||void 0===this.warbs[0].fallbackValue)return Wh.Stream.nil()}finally{--this.context.depth}const t=new Kh.Value(this.warbs[0].fallbackValue.default,void 0);return Wh.Stream.of(this.mapIntoValue(0,t,null,void 0))}canShrinkWithoutContextIndex(e){if(this.mustGenerateFirst())return this.warbs[0].arbitrary.canShrinkWithoutContext(e)?0:-1;try{++this.context.depth;for(let t=0;t!==this.warbs.length;++t){const r=this.warbs[t];if(0!==r.weight&&r.arbitrary.canShrinkWithoutContext(e))return t}return-1}finally{--this.context.depth}}mapIntoValue(e,t,r,n){const i={selectedIndex:e,originalBias:n,originalContext:t.context,clonedMrngForFallbackFirst:r};return new Kh.Value(t.value,i)}safeGenerateForIndex(e,t,r){++this.context.depth;try{const n=this.warbs[t].arbitrary.generate(e,r),i=this.mustFallbackToFirstInShrink(t)?e.clone():null;return this.mapIntoValue(t,n,i,r)}finally{--this.context.depth}}mustGenerateFirst(){return this.constraints.maxDepth<=this.context.depth}mustFallbackToFirstInShrink(e){return 0!==e&&this.constraints.withCrossShrink&&0!==this.warbs[0].weight}computeNegDepthBenefit(){const e=this.constraints.depthBias;if(e<=0||0===this.warbs[0].weight)return 0;const t=Xh(ed(1+e,this.context.depth))-1;return-td(this.totalWeight*t,Qh)||0}}qh.FrequencyArbitrary=FrequencyArbitrary,Object.defineProperty(zh,"__esModule",{value:!0}),zh.oneof=function(...e){const t=e[0];if(null!=(r=t)&&"object"==typeof r&&!("generate"in r)&&!("arbitrary"in r)&&!("weight"in r)){const r=(0,nd.safeMap)((0,nd.safeSlice)(e,1),toWeightedArbitrary);return id.FrequencyArbitrary.from(r,t,"fc.oneof")}var r;const n=(0,nd.safeMap)(e,toWeightedArbitrary);return id.FrequencyArbitrary.from(n,{},"fc.oneof")};const rd=zs,nd=so,id=qh;function toWeightedArbitrary(e){return(0,rd.isArbitrary)(e)?{arbitrary:e,weight:1}:e}var sd={},od={};Object.defineProperty(od,"__esModule",{value:!0}),od.nat=function(e){const t="number"==typeof e?e:e&&void 0!==e.max?e.max:2147483647;if(t<0)throw Error("fc.nat value should be greater than or equal to 0");if(!ud(t))throw Error("fc.nat maximum value should be an integer");return new ad.IntegerArbitrary(0,t)};const ad=Ml,ud=Number.isInteger;var cd={};Object.defineProperty(cd,"__esModule",{value:!0}),cd.indexToMappedConstantMapperFor=function(e){const t=function(e){let t=0;const r=[];for(const n of e){const e=t;t=e+n.num;const i=t-1;r.push({from:e,to:i,entry:n})}return r}(e);return function(e){const r=function(e,t){let r=0,n=e.length;for(;n-r>1;){const i=~~((r+n)/2);t<e[i].from?n=i:r=i}return e[r]}(t,e);return r.entry.build(e-r.from)}},cd.indexToMappedConstantUnmapperFor=function(e){let t=null;return function(r){null===t&&(t=function(e){const t={mapping:new ld.Map,negativeZeroIndex:void 0};let r=0;for(let n=0;n!==e.length;++n){const i=e[n];for(let e=0;e!==i.num;++e){const n=i.build(e);0===n&&1/n===ld.Number.NEGATIVE_INFINITY?t.negativeZeroIndex=r:(0,ld.safeMapSet)(t.mapping,n,r),++r}}return t}(e));const n=pd(r,-0)?t.negativeZeroIndex:(0,ld.safeMapGet)(t.mapping,r);if(void 0===n)throw new ld.Error("Unknown value encountered cannot be built using this mapToConstant");return n}};const ld=so,pd=Object.is;Object.defineProperty(sd,"__esModule",{value:!0}),sd.mapToConstant=function(...e){const t=function(e){if(0===e.length)throw new dd.Error("fc.mapToConstant expects at least one option");let t=0;for(let r=0;r!==e.length;++r){if(e[r].num<0)throw new dd.Error("fc.mapToConstant expects all options to have a number of entries greater or equal to zero");t+=e[r].num}if(0===t)throw new dd.Error("fc.mapToConstant expects at least one choice among options");return t}(e);return(0,fd.nat)({max:t-1}).map((0,hd.indexToMappedConstantMapperFor)(e),(0,hd.indexToMappedConstantUnmapperFor)(e))};const fd=od,hd=cd,dd=so;Object.defineProperty(Bh,"__esModule",{value:!0}),Bh.getOrCreateLowerAlphaArbitrary=function(){return void 0===xd&&(xd=(0,gd.mapToConstant)(vd)),xd},Bh.getOrCreateLowerAlphaNumericArbitrary=function(e){void 0===Id&&(Id=new bd);let t=(0,yd.safeMapGet)(Id,e);return void 0===t&&(t=(0,gd.mapToConstant)(vd,wd,{num:e.length,build:t=>e[t]}),(0,yd.safeMapSet)(Id,e,t)),t},Bh.getOrCreateAlphaNumericPercentArbitrary=function(e){void 0===Td&&(Td=new bd);let t=(0,yd.safeMapGet)(Td,e);return void 0===t&&(t=(0,md.oneof)({weight:10,arbitrary:buildAlphaNumericArbitrary(e)},{weight:1,arbitrary:kd}),(0,yd.safeMapSet)(Td,e,t)),t};const md=zh,gd=sd,yd=so,bd=Map,Sd=String.fromCharCode,vd={num:26,build:e=>Sd(e+97)},_d={num:26,build:e=>Sd(e+65)},wd={num:10,build:e=>Sd(e+48)},kd=(0,Of.fullUnicode)().map(function(e){const t=(0,yd.encodeURIComponent)(e);return e!==t?t:"%"+(0,yd.safeNumberToString)((0,yd.safeCharCodeAt)(e,0),16)},function(e){if("string"!=typeof e)throw Error("Unsupported");return decodeURIComponent(e)});let xd,Id,Td;function buildAlphaNumericArbitrary(e){return(0,gd.mapToConstant)(vd,_d,wd,{num:e.length,build:t=>e[t]})}var Od={},Ed={};Object.defineProperty(Ed,"__esModule",{value:!0}),Ed.option=function(e,t={}){const r=null==t.freq?5:t.freq,n=(0,Md.safeHasOwnProperty)(t,"nil")?t.nil:null,i=[{arbitrary:(0,Ad.constant)(n),weight:1,fallbackValue:{default:n}},{arbitrary:e,weight:r}],s={withCrossShrink:!0,depthSize:t.depthSize,maxDepth:t.maxDepth,depthIdentifier:t.depthIdentifier};return Cd.FrequencyArbitrary.from(i,s,"fc.option")};const Ad=Df,Cd=qh,Md=so;var Fd={},Pd={},Nd={},jd={};Object.defineProperty(jd,"__esModule",{value:!0}),jd.tokenizeString=function(e,t,r,n){if(0===t.length){if(r>0)return;return[]}if(n<=0)return;const i=[{endIndexChunks:0,nextStartIndex:1,chunks:[]}];for(;i.length>0;){const s=(0,Rd.safePop)(i);for(let o=s.nextStartIndex;o<=t.length;++o){const a=(0,Rd.safeSubstring)(t,s.endIndexChunks,o);if(e.canShrinkWithoutContext(a)){const e=[...s.chunks,a];if(o===t.length){if(e.length<r)break;return e}(0,Rd.safePush)(i,{endIndexChunks:s.endIndexChunks,nextStartIndex:o+1,chunks:s.chunks}),e.length<n&&(0,Rd.safePush)(i,{endIndexChunks:o,nextStartIndex:o+1,chunks:e});break}}}};const Rd=so;Object.defineProperty(Nd,"__esModule",{value:!0}),Nd.patternsToStringMapper=function(e){return(0,Ld.safeJoin)(e,"")},Nd.patternsToStringUnmapperIsValidLength=function(e,t){return minLengthFrom(t)<=e.length&&e.length<=maxLengthFrom(t)},Nd.patternsToStringUnmapperFor=function(e,t){return function(r){if("string"!=typeof r)throw new Ld.Error("Unsupported value");const n=(0,Ud.tokenizeString)(e,r,minLengthFrom(t),maxLengthFrom(t));if(void 0===n)throw new Ld.Error("Unable to unmap received string");return n}};const Dd=wp,Ld=so,Ud=jd;function minLengthFrom(e){return void 0!==e.minLength?e.minLength:0}function maxLengthFrom(e){return void 0!==e.maxLength?e.maxLength:Dd.MaxLengthUpperBound}Object.defineProperty(Pd,"__esModule",{value:!0}),Pd.createSlicesForStringLegacy=function(e,t){const r=[];for(const n of Wd){const i=computeCandidateStringLegacy(n,e,t);void 0!==i&&(0,$d.safePush)(r,i)}return r},Pd.createSlicesForString=function(e,t){let r=(0,$d.safeGet)(Vd,e);void 0===r&&(r=function(e){const t=[];for(const r of Wd){const n=(0,qd.tokenizeString)(e,r,0,zd.MaxLengthUpperBound);void 0!==n&&(0,$d.safePush)(t,n)}return t}(e),(0,$d.safeSet)(Vd,e,r));const n=[];for(const e of r)(0,Bd.patternsToStringUnmapperIsValidLength)(e,t)&&(0,$d.safePush)(n,e);return n};const $d=so,Bd=Nd,zd=wp,qd=jd,Wd=["__defineGetter__","__defineSetter__","__lookupGetter__","__lookupSetter__","__proto__","constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf","apply","arguments","bind","call","caller","length","name","prototype","key","ref"];function computeCandidateStringLegacy(e,t,r){let n;try{n=r(e)}catch(e){return}for(const e of n)if(!t.canShrinkWithoutContext(e))return;return n}const Vd=new WeakMap;var Kd={},Gd={};Object.defineProperty(Gd,"__esModule",{value:!0}),Gd.autonomousDecomposableGraphemeRanges=Gd.autonomousGraphemeRanges=Gd.fullAlphabetRanges=Gd.asciiAlphabetRanges=void 0,Gd.asciiAlphabetRanges=[[0,127]],Gd.fullAlphabetRanges=[[0,55295],[57344,1114111]],Gd.autonomousGraphemeRanges=[[32,126],[160,172],[174,767],[880,887],[890,895],[900,906],[908],[910,929],[931,1154],[1162,1327],[1329,1366],[1369,1418],[1421,1423],[1470],[1472],[1475],[1478],[1488,1514],[1519,1524],[1542,1551],[1563],[1565,1610],[1632,1647],[1649,1749],[1758],[1765,1766],[1769],[1774,1805],[1808],[1810,1839],[1869,1957],[1969],[1984,2026],[2036,2042],[2046,2069],[2074],[2084],[2088],[2096,2110],[2112,2136],[2142],[2144,2154],[2160,2190],[2208,2249],[2308,2361],[2365],[2384],[2392,2401],[2404,2432],[2437,2444],[2447,2448],[2451,2472],[2474,2480],[2482],[2486,2489],[2493],[2510],[2524,2525],[2527,2529],[2534,2557],[2565,2570],[2575,2576],[2579,2600],[2602,2608],[2610,2611],[2613,2614],[2616,2617],[2649,2652],[2654],[2662,2671],[2674,2676],[2678],[2693,2701],[2703,2705],[2707,2728],[2730,2736],[2738,2739],[2741,2745],[2749],[2768],[2784,2785],[2790,2801],[2809],[2821,2828],[2831,2832],[2835,2856],[2858,2864],[2866,2867],[2869,2873],[2877],[2908,2909],[2911,2913],[2918,2935],[2947],[2949,2954],[2958,2960],[2962,2965],[2969,2970],[2972],[2974,2975],[2979,2980],[2984,2986],[2990,3001],[3024],[3046,3066],[3077,3084],[3086,3088],[3090,3112],[3114,3129],[3133],[3160,3162],[3165],[3168,3169],[3174,3183],[3191,3200],[3204,3212],[3214,3216],[3218,3240],[3242,3251],[3253,3257],[3261],[3293,3294],[3296,3297],[3302,3311],[3313,3314],[3332,3340],[3342,3344],[3346,3386],[3389],[3407],[3412,3414],[3416,3425],[3430,3455],[3461,3478],[3482,3505],[3507,3515],[3517],[3520,3526],[3558,3567],[3572],[3585,3632],[3634],[3647,3654],[3663,3675],[3713,3714],[3716],[3718,3722],[3724,3747],[3749],[3751,3760],[3762],[3773],[3776,3780],[3782],[3792,3801],[3804,3807],[3840,3863],[3866,3892],[3894],[3896],[3898,3901],[3904,3911],[3913,3948],[3973],[3976,3980],[4030,4037],[4039,4044],[4046,4058],[4096,4138],[4159,4181],[4186,4189],[4193],[4197,4198],[4206,4208],[4213,4225],[4238],[4240,4249],[4254,4293],[4295],[4301],[4304,4351],[4608,4680],[4682,4685],[4688,4694],[4696],[4698,4701],[4704,4744],[4746,4749],[4752,4784],[4786,4789],[4792,4798],[4800],[4802,4805],[4808,4822],[4824,4880],[4882,4885],[4888,4954],[4960,4988],[4992,5017],[5024,5109],[5112,5117],[5120,5788],[5792,5880],[5888,5905],[5919,5937],[5941,5942],[5952,5969],[5984,5996],[5998,6e3],[6016,6067],[6100,6108],[6112,6121],[6128,6137],[6144,6154],[6160,6169],[6176,6264],[6272,6276],[6279,6312],[6314],[6320,6389],[6400,6430],[6464],[6468,6509],[6512,6516],[6528,6571],[6576,6601],[6608,6618],[6622,6678],[6686,6740],[6784,6793],[6800,6809],[6816,6829],[6917,6963],[6981,6988],[6992,7018],[7028,7038],[7043,7072],[7086,7141],[7164,7203],[7227,7241],[7245,7304],[7312,7354],[7357,7367],[7379],[7401,7404],[7406,7411],[7413,7414],[7418],[7424,7615],[7680,7957],[7960,7965],[7968,8005],[8008,8013],[8016,8023],[8025],[8027],[8029],[8031,8061],[8064,8116],[8118,8132],[8134,8147],[8150,8155],[8157,8175],[8178,8180],[8182,8190],[8192,8202],[8208,8233],[8239,8287],[8304,8305],[8308,8334],[8336,8348],[8352,8384],[8448,8587],[8592,9254],[9280,9290],[9312,11123],[11126,11157],[11159,11502],[11506,11507],[11513,11557],[11559],[11565],[11568,11623],[11631,11632],[11648,11670],[11680,11686],[11688,11694],[11696,11702],[11704,11710],[11712,11718],[11720,11726],[11728,11734],[11736,11742],[11776,11869],[11904,11929],[11931,12019],[12032,12245],[12272,12329],[12336,12351],[12353,12438],[12443,12543],[12549,12591],[12593,12686],[12688,12771],[12783,12830],[12832,13312],[19903,19968],[40959,42124],[42128,42182],[42192,42539],[42560,42606],[42611],[42622,42653],[42656,42735],[42738,42743],[42752,42954],[42960,42961],[42963],[42965,42969],[42994,43009],[43011,43013],[43015,43018],[43020,43042],[43048,43051],[43056,43065],[43072,43127],[43138,43187],[43214,43225],[43250,43262],[43264,43301],[43310,43334],[43359],[43396,43442],[43457,43469],[43471,43481],[43486,43492],[43494,43518],[43520,43560],[43584,43586],[43588,43595],[43600,43609],[43612,43642],[43646,43695],[43697],[43701,43702],[43705,43709],[43712],[43714],[43739,43754],[43760,43764],[43777,43782],[43785,43790],[43793,43798],[43808,43814],[43816,43822],[43824,43883],[43888,44002],[44011],[44016,44025],[44032],[55203],[63744,64109],[64112,64217],[64256,64262],[64275,64279],[64285],[64287,64310],[64312,64316],[64318],[64320,64321],[64323,64324],[64326,64450],[64467,64911],[64914,64967],[64975],[65008,65023],[65040,65049],[65072,65106],[65108,65126],[65128,65131],[65136,65140],[65142,65276],[65281,65437],[65440,65470],[65474,65479],[65482,65487],[65490,65495],[65498,65500],[65504,65510],[65512,65518],[65532,65533],[65536,65547],[65549,65574],[65576,65594],[65596,65597],[65599,65613],[65616,65629],[65664,65786],[65792,65794],[65799,65843],[65847,65934],[65936,65948],[65952],[66e3,66044],[66176,66204],[66208,66256],[66273,66299],[66304,66339],[66349,66378],[66384,66421],[66432,66461],[66463,66499],[66504,66517],[66560,66717],[66720,66729],[66736,66771],[66776,66811],[66816,66855],[66864,66915],[66927,66938],[66940,66954],[66956,66962],[66964,66965],[66967,66977],[66979,66993],[66995,67001],[67003,67004],[67072,67382],[67392,67413],[67424,67431],[67456,67461],[67463,67504],[67506,67514],[67584,67589],[67592],[67594,67637],[67639,67640],[67644],[67647,67669],[67671,67742],[67751,67759],[67808,67826],[67828,67829],[67835,67867],[67871,67897],[67903],[67968,68023],[68028,68047],[68050,68096],[68112,68115],[68117,68119],[68121,68149],[68160,68168],[68176,68184],[68192,68255],[68288,68324],[68331,68342],[68352,68405],[68409,68437],[68440,68466],[68472,68497],[68505,68508],[68521,68527],[68608,68680],[68736,68786],[68800,68850],[68858,68899],[68912,68921],[69216,69246],[69248,69289],[69293],[69296,69297],[69376,69415],[69424,69445],[69457,69465],[69488,69505],[69510,69513],[69552,69579],[69600,69622],[69635,69687],[69703,69709],[69714,69743],[69745,69746],[69749],[69763,69807],[69819,69820],[69822,69825],[69840,69864],[69872,69881],[69891,69926],[69942,69956],[69959],[69968,70002],[70004,70006],[70019,70066],[70081],[70084,70088],[70093],[70096,70111],[70113,70132],[70144,70161],[70163,70187],[70200,70205],[70207,70208],[70272,70278],[70280],[70282,70285],[70287,70301],[70303,70313],[70320,70366],[70384,70393],[70405,70412],[70415,70416],[70419,70440],[70442,70448],[70450,70451],[70453,70457],[70461],[70480],[70493,70497],[70656,70708],[70727,70747],[70749],[70751,70753],[70784,70831],[70852,70855],[70864,70873],[71040,71086],[71105,71131],[71168,71215],[71233,71236],[71248,71257],[71264,71276],[71296,71338],[71352,71353],[71360,71369],[71424,71450],[71472,71494],[71680,71723],[71739],[71840,71922],[71935,71942],[71945],[71948,71955],[71957,71958],[71960,71983],[72004,72006],[72016,72025],[72096,72103],[72106,72144],[72161,72163],[72192],[72203,72242],[72255,72262],[72272],[72284,72323],[72346,72354],[72368,72440],[72448,72457],[72704,72712],[72714,72750],[72768,72773],[72784,72812],[72816,72847],[72960,72966],[72968,72969],[72971,73008],[73040,73049],[73056,73061],[73063,73064],[73066,73097],[73112],[73120,73129],[73440,73458],[73463,73464],[73476,73488],[73490,73523],[73539,73561],[73648],[73664,73713],[73727,74649],[74752,74862],[74864,74868],[74880,75075],[77712,77810],[77824,78895],[78913,78918],[82944,83526],[92160,92728],[92736,92766],[92768,92777],[92782,92862],[92864,92873],[92880,92909],[92917],[92928,92975],[92983,92997],[93008,93017],[93019,93025],[93027,93047],[93053,93071],[93760,93850],[93952,94026],[94032],[94099,94111],[94176,94179],[94208],[100343],[100352,101589],[101632],[101640],[110576,110579],[110581,110587],[110589,110590],[110592,110882],[110898],[110928,110930],[110933],[110948,110951],[110960,111355],[113664,113770],[113776,113788],[113792,113800],[113808,113817],[113820],[113823],[118608,118723],[118784,119029],[119040,119078],[119081,119140],[119146,119148],[119171,119172],[119180,119209],[119214,119274],[119296,119361],[119365],[119488,119507],[119520,119539],[119552,119638],[119648,119672],[119808,119892],[119894,119964],[119966,119967],[119970],[119973,119974],[119977,119980],[119982,119993],[119995],[119997,120003],[120005,120069],[120071,120074],[120077,120084],[120086,120092],[120094,120121],[120123,120126],[120128,120132],[120134],[120138,120144],[120146,120485],[120488,120779],[120782,121343],[121399,121402],[121453,121460],[121462,121475],[121477,121483],[122624,122654],[122661,122666],[122928,122989],[123136,123180],[123191,123197],[123200,123209],[123214,123215],[123536,123565],[123584,123627],[123632,123641],[123647],[124112,124139],[124144,124153],[124896,124902],[124904,124907],[124909,124910],[124912,124926],[124928,125124],[125127,125135],[125184,125251],[125259],[125264,125273],[125278,125279],[126065,126132],[126209,126269],[126464,126467],[126469,126495],[126497,126498],[126500],[126503],[126505,126514],[126516,126519],[126521],[126523],[126530],[126535],[126537],[126539],[126541,126543],[126545,126546],[126548],[126551],[126553],[126555],[126557],[126559],[126561,126562],[126564],[126567,126570],[126572,126578],[126580,126583],[126585,126588],[126590],[126592,126601],[126603,126619],[126625,126627],[126629,126633],[126635,126651],[126704,126705],[126976,127019],[127024,127123],[127136,127150],[127153,127167],[127169,127183],[127185,127221],[127232,127405],[127488,127490],[127504,127547],[127552,127560],[127568,127569],[127584,127589],[127744,127994],[128e3,128727],[128732,128748],[128752,128764],[128768,128886],[128891,128985],[128992,129003],[129008],[129024,129035],[129040,129095],[129104,129113],[129120,129159],[129168,129197],[129200,129201],[129280,129619],[129632,129645],[129648,129660],[129664,129672],[129680,129725],[129727,129733],[129742,129755],[129760,129768],[129776,129784],[129792,129938],[129940,129994],[130032,130041],[131072],[173791],[173824],[177977],[177984],[178205],[178208],[183969],[183984],[191456],[191472],[192093],[194560,195101],[196608],[201546],[201552],[205743]],Gd.autonomousDecomposableGraphemeRanges=[[192,197],[199,207],[209,214],[217,221],[224,229],[231,239],[241,246],[249,253],[255,271],[274,293],[296,304],[308,311],[313,318],[323,328],[332,337],[340,357],[360,382],[416,417],[431,432],[461,476],[478,483],[486,496],[500,501],[504,539],[542,543],[550,563],[901,902],[904,906],[908],[910,912],[938,944],[970,974],[979,980],[1024,1025],[1027],[1031],[1036,1038],[1049],[1081],[1104,1105],[1107],[1111],[1116,1118],[1142,1143],[1217,1218],[1232,1235],[1238,1239],[1242,1247],[1250,1255],[1258,1269],[1272,1273],[1570,1574],[1728],[1730],[1747],[2345],[2353],[2356],[2392,2399],[2524,2525],[2527],[2611],[2614],[2649,2651],[2654],[2908,2909],[2964],[3907],[3917],[3922],[3927],[3932],[3945],[4134],[6918],[6920],[6922],[6924],[6926],[6930],[7680,7833],[7835],[7840,7929],[7936,7957],[7960,7965],[7968,8005],[8008,8013],[8016,8023],[8025],[8027],[8029],[8031,8048],[8050],[8052],[8054],[8056],[8058],[8060],[8064,8116],[8118,8122],[8124],[8129,8132],[8134,8136],[8138],[8140,8146],[8150,8154],[8157,8162],[8164,8170],[8172,8173],[8178,8180],[8182,8184],[8186],[8188],[8602,8603],[8622],[8653,8655],[8708],[8713],[8716],[8740],[8742],[8769],[8772],[8775],[8777],[8800],[8802],[8813,8817],[8820,8821],[8824,8825],[8832,8833],[8836,8837],[8840,8841],[8876,8879],[8928,8931],[8938,8941],[10972],[12364],[12366],[12368],[12370],[12372],[12374],[12376],[12378],[12380],[12382],[12384],[12386],[12389],[12391],[12393],[12400,12401],[12403,12404],[12406,12407],[12409,12410],[12412,12413],[12436],[12446],[12460],[12462],[12464],[12466],[12468],[12470],[12472],[12474],[12476],[12478],[12480],[12482],[12485],[12487],[12489],[12496,12497],[12499,12500],[12502,12503],[12505,12506],[12508,12509],[12532],[12535,12538],[12542],[44032],[55203],[64285],[64287],[64298,64310],[64312,64316],[64318],[64320,64321],[64323,64324],[64326,64334],[69786],[69788],[69803],[119134,119140],[119227,119232]];var Jd={};Object.defineProperty(Jd,"__esModule",{value:!0}),Jd.convertGraphemeRangeToMapToConstantEntry=function(e){if(1===e.length){const t=Zd(e[0]);return{num:1,build:()=>t}}const t=e[0];return{num:e[1]-e[0]+1,build:e=>Zd(t+e)}},Jd.intersectGraphemeRanges=function(e,t){const r=[];let n=0,i=0;for(;n<e.length&&i<t.length;){const s=e[n],o=s[0],a=1===s.length?s[0]:s[1],u=t[i],c=u[0],l=1===u.length?u[0]:u[1];if(a<c)n+=1;else if(l<o)i+=1;else{let e=Yd(o,c);const t=Qd(a,l);if(r.length>=1){const t=r[r.length-1];(1===t.length?t[0]:t[1])+1===e&&(e=t[0],(0,Hd.safePop)(r))}(0,Hd.safePush)(r,e===t?[e]:[e,t]),a<=t&&(n+=1),l<=t&&(i+=1)}}return r};const Hd=so,Zd=String.fromCodePoint,Qd=Math.min,Yd=Math.max;Object.defineProperty(Kd,"__esModule",{value:!0}),Kd.stringUnit=function(e,t){return function(e,t){const r=`${e}:${t}`,n=nm[r];if(void 0!==n)return n;const i=function(e){switch(e){case"full":return tm.fullAlphabetRanges;case"ascii":return tm.asciiAlphabetRanges}}(t),s="binary"===e?i:(0,rm.intersectGraphemeRanges)(i,tm.autonomousGraphemeRanges),o=[];for(const e of s)(0,Xd.safePush)(o,(0,rm.convertGraphemeRangeToMapToConstantEntry)(e));if("grapheme"===e){const e=(0,rm.intersectGraphemeRanges)(i,tm.autonomousDecomposableGraphemeRanges);for(const t of e){const e=(0,rm.convertGraphemeRangeToMapToConstantEntry)(t);(0,Xd.safePush)(o,{num:e.num,build:t=>(0,Xd.safeNormalize)(e.build(t),"NFD")})}}const a=(0,em.mapToConstant)(...o);return nm[r]=a,a}(e,t)};const Xd=so,em=sd,tm=Gd,rm=Jd,nm=Object.create(null);Object.defineProperty(Fd,"__esModule",{value:!0}),Fd.string=function(e={}){const t=function(e){if("object"==typeof e.unit)return e.unit;switch(e.unit){case"grapheme":return(0,om.stringUnit)("grapheme","full");case"grapheme-composite":return(0,om.stringUnit)("composite","full");case"grapheme-ascii":case void 0:return(0,om.stringUnit)("grapheme","ascii");case"binary":return(0,om.stringUnit)("binary","full");case"binary-ascii":return(0,om.stringUnit)("binary","ascii")}}(e),r=(0,am.patternsToStringUnmapperFor)(t,e),n=(0,sm.createSlicesForString)(t,e),i=um(um({},e),{experimentalCustomSlices:n});return(0,im.array)(t,i).map(am.patternsToStringMapper,r)};const im=El,sm=Pd,om=Kd,am=Nd,um=Object.assign;var cm={};Object.defineProperty(cm,"__esModule",{value:!0}),cm.filterInvalidSubdomainLabel=function(e){return!(e.length>63)&&(e.length<4||"x"!==e[0]||"n"!==e[1]||"-"!==e[2]||"-"!==e[3])};var lm={};Object.defineProperty(lm,"__esModule",{value:!0}),lm.adapter=function(e,t){return new AdapterArbitrary(e,t)};const pm=zs,fm=Hs,hm=qs,dm=Symbol("adapted-value");class AdapterArbitrary extends pm.Arbitrary{constructor(e,t){super(),this.sourceArb=e,this.adapter=t,this.adaptValue=e=>function(e,t){const r=t(e.value_);return r.adapted?new fm.Value(r.value,dm):e}(e,t)}generate(e,t){const r=this.sourceArb.generate(e,t);return this.adaptValue(r)}canShrinkWithoutContext(e){return this.sourceArb.canShrinkWithoutContext(e)&&!this.adapter(e).adapted}shrink(e,t){return t===dm?this.sourceArb.canShrinkWithoutContext(e)?this.sourceArb.shrink(e,void 0).map(this.adaptValue):hm.Stream.nil():this.sourceArb.shrink(e,t).map(this.adaptValue)}}Object.defineProperty(Od,"__esModule",{value:!0}),Od.domain=function(e={}){const t=(0,_m.resolveSize)(e.size),r=(0,_m.relativeSizeToSize)("-1",t),n=(0,gm.getOrCreateLowerAlphaArbitrary)(),i=(0,bm.string)({unit:n,minLength:2,maxLength:63,size:r});return(0,wm.adapter)((0,Sm.tuple)((0,mm.array)(function(e){const t=(0,gm.getOrCreateLowerAlphaNumericArbitrary)(""),r=(0,gm.getOrCreateLowerAlphaNumericArbitrary)("-");return(0,Sm.tuple)(t,(0,ym.option)((0,Sm.tuple)((0,bm.string)({unit:r,size:e,maxLength:61}),t))).map(toSubdomainLabelMapper,toSubdomainLabelUnmapper).filter(vm.filterInvalidSubdomainLabel)}(t),{size:r,minLength:1,maxLength:127}),i),labelsAdapter).map(labelsMapper,labelsUnmapper)};const mm=El,gm=Bh,ym=Ed,bm=Fd,Sm=no,vm=cm,_m=wp,wm=lm,km=so;function toSubdomainLabelMapper([e,t]){return null===t?e:`${e}${t[0]}${t[1]}`}function toSubdomainLabelUnmapper(e){if("string"!=typeof e||0===e.length)throw Error("Unsupported");return 1===e.length?[e[0],null]:[e[0],[(0,km.safeSubstring)(e,1,e.length-1),e[e.length-1]]]}function labelsMapper(e){return`${(0,km.safeJoin)(e[0],".")}.${e[1]}`}function labelsUnmapper(e){if("string"!=typeof e)throw Error("Unsupported type");const t=e.lastIndexOf(".");return[(0,km.safeSplit)((0,km.safeSubstring)(e,0,t),"."),(0,km.safeSubstring)(e,t+1)]}function labelsAdapter(e){const[t,r]=e;let n=r.length;for(let e=0;e!==t.length;++e)if(n+=1+t[e].length,n>255)return{adapted:!0,value:[(0,km.safeSlice)(t,0,e),r]};return{adapted:!1,value:e}}Object.defineProperty($h,"__esModule",{value:!0}),$h.emailAddress=function(e={}){const t=(0,Im.getOrCreateLowerAlphaNumericArbitrary)("!#$%&'*+-/=?^_`{|}~"),r=(0,Am.adapter)((0,xm.array)((0,Om.string)({unit:t,minLength:1,maxLength:64,size:e.size}),{minLength:1,maxLength:32,size:e.size}),dotAdapter).map(dotMapper,dotUnmapper);return(0,Em.tuple)(r,(0,Tm.domain)({size:e.size})).map(atMapper,atUnmapper)};const xm=El,Im=Bh,Tm=Od,Om=Fd,Em=no,Am=lm,Cm=so;function dotAdapter(e){let t=e[0].length;for(let r=1;r!==e.length;++r)if(t+=1+e[r].length,t>64)return{adapted:!0,value:(0,Cm.safeSlice)(e,0,r)};return{adapted:!1,value:e}}function dotMapper(e){return(0,Cm.safeJoin)(e,".")}function dotUnmapper(e){if("string"!=typeof e)throw Error("Unsupported");return(0,Cm.safeSplit)(e,".")}function atMapper(e){return`${e[0]}@${e[1]}`}function atUnmapper(e){if("string"!=typeof e)throw Error("Unsupported");return(0,Cm.safeSplit)(e,"@",2)}var Mm={},Fm={};!function(e){function isZero64(e){return 0===e.data[0]&&0===e.data[1]}function isStrictlySmaller64Internal(e,t){return e[0]<t[0]||e[0]===t[0]&&e[1]<t[1]}function isStrictlySmaller64(e,t){return e.sign===t.sign?1===e.sign?isStrictlySmaller64Internal(e.data,t.data):isStrictlySmaller64Internal(t.data,e.data):!(-1!==e.sign||isZero64(e)&&isZero64(t))}function clone64(e){return{sign:e.sign,data:[e.data[0],e.data[1]]}}function substract64DataInternal(e,t){let r=0,n=e[1]-t[1];return n<0&&(r=1,n>>>=0),[e[0]-t[0]-r,n]}function substract64Internal(e,t){if(1===e.sign&&-1===t.sign){const r=e.data[1]+t.data[1];return{sign:1,data:[e.data[0]+t.data[0]+(r>4294967295?1:0)>>>0,r>>>0]}}return{sign:1,data:1===e.sign?substract64DataInternal(e.data,t.data):substract64DataInternal(t.data,e.data)}}function substract64(e,t){if(isStrictlySmaller64(e,t)){const r=substract64Internal(t,e);return r.sign=-1,r}return substract64Internal(e,t)}function negative64(e){return{sign:-e.sign,data:[e.data[0],e.data[1]]}}Object.defineProperty(e,"__esModule",{value:!0}),e.Unit64=e.Zero64=void 0,e.isZero64=isZero64,e.isStrictlyNegative64=function(e){return-1===e.sign&&!isZero64(e)},e.isStrictlyPositive64=function(e){return 1===e.sign&&!isZero64(e)},e.isEqual64=function(e,t){return e.data[0]===t.data[0]&&e.data[1]===t.data[1]&&(e.sign===t.sign||0===e.data[0]&&0===e.data[1])},e.isStrictlySmaller64=isStrictlySmaller64,e.clone64=clone64,e.substract64=substract64,e.negative64=negative64,e.add64=function(t,r){return isZero64(r)?isZero64(t)?clone64(e.Zero64):clone64(t):substract64(t,negative64(r))},e.halve64=function(e){return{sign:e.sign,data:[Math.floor(e.data[0]/2),(e.data[0]%2==1?2147483648:0)+Math.floor(e.data[1]/2)]}},e.logLike64=function(e){return{sign:e.sign,data:[0,Math.floor(Math.log(4294967296*e.data[0]+e.data[1])/Math.log(2))]}},e.Zero64={sign:1,data:[0,0]},e.Unit64={sign:1,data:[0,1]}}(Fm);var Pm={};Object.defineProperty(Pm,"__esModule",{value:!0}),Pm.arrayInt64=function(e,t){return new ArrayInt64Arbitrary(e,t)};const Nm=qs,jm=zs,Rm=Hs,Dm=Fm;class ArrayInt64Arbitrary extends jm.Arbitrary{constructor(e,t){super(),this.min=e,this.max=t,this.biasedRanges=null}generate(e,t){const r=this.computeGenerateRange(e,t),n=e.nextArrayInt(r.min,r.max);return 1===n.data.length&&n.data.unshift(0),new Rm.Value(n,void 0)}computeGenerateRange(e,t){if(void 0===t||1!==e.nextInt(1,t))return{min:this.min,max:this.max};const r=this.retrieveBiasedRanges();if(1===r.length)return r[0];const n=e.nextInt(-2*(r.length-1),r.length-2);return n<0?r[0]:r[n+1]}canShrinkWithoutContext(e){const t=e;return"object"==typeof e&&null!==e&&(-1===t.sign||1===t.sign)&&Array.isArray(t.data)&&2===t.data.length&&((0,Dm.isStrictlySmaller64)(this.min,t)&&(0,Dm.isStrictlySmaller64)(t,this.max)||(0,Dm.isEqual64)(this.min,t)||(0,Dm.isEqual64)(this.max,t))}shrinkArrayInt64(e,t,r){const n=(0,Dm.substract64)(e,t);return(0,Nm.stream)(function*(){let i=r?void 0:t;for(let t=r?n:(0,Dm.halve64)(n);!(0,Dm.isZero64)(t);t=(0,Dm.halve64)(t)){const r=(0,Dm.substract64)(e,t);yield new Rm.Value(r,i),i=r}}())}shrink(e,t){if(!ArrayInt64Arbitrary.isValidContext(e,t)){const t=this.defaultTarget();return this.shrinkArrayInt64(e,t,!0)}return this.isLastChanceTry(e,t)?Nm.Stream.of(new Rm.Value(t,void 0)):this.shrinkArrayInt64(e,t,!1)}defaultTarget(){return(0,Dm.isStrictlyPositive64)(this.min)||(0,Dm.isStrictlyNegative64)(this.max)?(0,Dm.isStrictlyNegative64)(this.min)?this.max:this.min:Dm.Zero64}isLastChanceTry(e,t){return!(0,Dm.isZero64)(e)&&(1===e.sign?(0,Dm.isEqual64)(e,(0,Dm.add64)(t,Dm.Unit64))&&(0,Dm.isStrictlyPositive64)((0,Dm.substract64)(e,this.min)):(0,Dm.isEqual64)(e,(0,Dm.substract64)(t,Dm.Unit64))&&(0,Dm.isStrictlyNegative64)((0,Dm.substract64)(e,this.max)))}static isValidContext(e,t){if(void 0===t)return!1;if("object"!=typeof t||null===t||!("sign"in t)||!("data"in t))throw Error("Invalid context type passed to ArrayInt64Arbitrary (#1)");return!0}retrieveBiasedRanges(){if(null!=this.biasedRanges)return this.biasedRanges;if((0,Dm.isEqual64)(this.min,this.max))return this.biasedRanges=[{min:this.min,max:this.max}],this.biasedRanges;const e=(0,Dm.isStrictlyNegative64)(this.min),t=(0,Dm.isStrictlyPositive64)(this.max);if(e&&t){const e=(0,Dm.logLike64)(this.min),t=(0,Dm.logLike64)(this.max);this.biasedRanges=[{min:e,max:t},{min:(0,Dm.substract64)(this.max,t),max:this.max},{min:this.min,max:(0,Dm.substract64)(this.min,e)}]}else{const t=(0,Dm.logLike64)((0,Dm.substract64)(this.max,this.min)),r={min:this.min,max:(0,Dm.add64)(this.min,t)},n={min:(0,Dm.substract64)(this.max,t),max:this.max};this.biasedRanges=e?[n,r]:[r,n]}return this.biasedRanges}}var Lm={};Object.defineProperty(Lm,"__esModule",{value:!0}),Lm.decomposeDouble=decomposeDouble,Lm.doubleToIndex=function(e){if(e===Bm)return(0,Um.clone64)(qm);if(e===$m)return(0,Um.clone64)(Wm);const t=decomposeDouble(e),r=t.exponent,n=t.significand;if(e>0||0===e&&1/e===Bm)return{sign:1,data:indexInDoubleFromDecomp(r,n)};{const e=indexInDoubleFromDecomp(r,-n);return 4294967295===e[1]?(e[0]+=1,e[1]=0):e[1]+=1,{sign:-1,data:e}}},Lm.indexToDouble=function indexToDouble(e){if(-1===e.sign){const t={sign:1,data:[e.data[0],e.data[1]]};return 0===t.data[1]?(t.data[0]-=1,t.data[1]=4294967295):t.data[1]-=1,-indexToDouble(t)}if((0,Um.isEqual64)(e,qm))return Bm;if(e.data[0]<2097152)return 5e-324*(4294967296*e.data[0]+e.data[1]);const t=e.data[0]-2097152,r=(t>>20)-1021;return(1+((1048575&t)*2**32+e.data[1])*zm)*2**r};const Um=Fm,$m=-1/0,Bm=1/0,zm=Number.EPSILON,qm={sign:1,data:[2146435072,0]},Wm={sign:-1,data:[2146435072,1]},Vm=new Float64Array(1),Km=new Uint32Array(Vm.buffer,Vm.byteOffset);function decomposeDouble(e){const{0:t,1:r}=(n=e,Vm[0]=n,[Km[1],Km[0]]);var n;const i=t>>>20&2047;let s=0===i?0:1;return s+=(4294967296*(1048575&t)+r)/2**52,s*=0==t>>>31?1:-1,{exponent:0===i?-1022:i-1023,significand:s}}function positiveNumberToInt64(e){return[~~(e/4294967296),e>>>0]}function indexInDoubleFromDecomp(e,t){if(-1022===e)return positiveNumberToInt64(t*2**52);const r=(e+1023)*2**20,n=positiveNumberToInt64((t-1)*2**52);return n[0]+=r,n}var Gm={},Jm={};Object.defineProperty(Jm,"__esModule",{value:!0}),Jm.refineConstraintsForFloatingOnly=function(e,t,r,n){const{noDefaultInfinity:i=!1,minExcluded:s=!1,maxExcluded:o=!1,min:a=(i?-t:Qm),max:u=(i?t:Ym)}=e,c=s?a<-r?-n:Math.max(a,-r):Math.max(a,a===Qm?-n:-r),l=o?u>r?n:Math.min(u,r):Math.min(u,u===Ym?n:r);return{noDefaultInfinity:!1,minExcluded:s||(a!==Qm||s)&&Hm(c),maxExcluded:o||(u!==Ym||o)&&Hm(l),min:Zm(c,-0)?0:c,max:Zm(l,0)?-0:l,noNaN:e.noNaN||!1}};const Hm=Number.isInteger,Zm=Object.is,Qm=-1/0,Ym=1/0;!function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.onlyIntegersAfterThisValue=e.maxNonIntegerValue=void 0,e.refineConstraintsForDoubleOnly=function(r){return(0,t.refineConstraintsForFloatingOnly)(r,i,e.maxNonIntegerValue,e.onlyIntegersAfterThisValue)},e.doubleOnlyMapper=function(t){return t===e.onlyIntegersAfterThisValue?n:t===-e.onlyIntegersAfterThisValue?r:t},e.doubleOnlyUnmapper=function(t){if("number"!=typeof t)throw Error("Unsupported type");return t===n?e.onlyIntegersAfterThisValue:t===r?-e.onlyIntegersAfterThisValue:t};const t=Jm,r=-1/0,n=1/0,i=Number.MAX_VALUE;e.maxNonIntegerValue=4503599627370495.5,e.onlyIntegersAfterThisValue=4503599627370496}(Gm),Object.defineProperty(Mm,"__esModule",{value:!0}),Mm.double=function(e={}){return e.noInteger?anyDouble((0,rg.refineConstraintsForDoubleOnly)(e)).map(rg.doubleOnlyMapper,rg.doubleOnlyUnmapper).filter(numberIsNotInteger$1):anyDouble(e)};const Xm=Fm,eg=Pm,tg=Lm,rg=Gm,ng=Number.isInteger,ig=Number.isNaN,sg=-1/0,og=1/0,ag=Number.MAX_VALUE,ug=NaN;function safeDoubleToIndex(e,t){if(ig(e))throw Error("fc.double constraints."+t+" must be a 64-bit float");return(0,tg.doubleToIndex)(e)}function unmapperDoubleToIndex(e){if("number"!=typeof e)throw Error("Unsupported type");return(0,tg.doubleToIndex)(e)}function numberIsNotInteger$1(e){return!ng(e)}function anyDouble(e){const{noDefaultInfinity:t=!1,noNaN:r=!1,minExcluded:n=!1,maxExcluded:i=!1,min:s=(t?-ag:sg),max:o=(t?ag:og)}=e,a=safeDoubleToIndex(s,"min"),u=n?(0,Xm.add64)(a,Xm.Unit64):a,c=safeDoubleToIndex(o,"max"),l=i?(0,Xm.substract64)(c,Xm.Unit64):c;if((0,Xm.isStrictlySmaller64)(l,u))throw Error("fc.double constraints.min must be smaller or equal to constraints.max");if(r)return(0,eg.arrayInt64)(u,l).map(tg.indexToDouble,unmapperDoubleToIndex);const p=(0,Xm.isStrictlyPositive64)(l),d=p?u:(0,Xm.substract64)(u,Xm.Unit64),m=p?(0,Xm.add64)(l,Xm.Unit64):l;return(0,eg.arrayInt64)(d,m).map(e=>(0,Xm.isStrictlySmaller64)(l,e)||(0,Xm.isStrictlySmaller64)(e,u)?ug:(0,tg.indexToDouble)(e),e=>{if("number"!=typeof e)throw Error("Unsupported type");return ig(e)?(0,Xm.isEqual64)(l,m)?d:m:(0,tg.doubleToIndex)(e)})}var cg={},lg={};Object.defineProperty(lg,"__esModule",{value:!0}),lg.EPSILON_32=lg.MAX_VALUE_32=lg.MIN_VALUE_32=void 0,lg.decomposeFloat=decomposeFloat,lg.floatToIndex=function(e){if(e===fg)return hg;if(e===pg)return dg;const t=decomposeFloat(e),r=t.exponent,n=t.significand;return e>0||0===e&&1/e===fg?indexInFloatFromDecomp(r,n):-indexInFloatFromDecomp(r,-n)-1},lg.indexToFloat=function indexToFloat(e){if(e<0)return-indexToFloat(-e-1);if(e===hg)return fg;if(e<16777216)return e*2**-149;const t=e-16777216;return(1+(8388607&t)/8388608)*2**((t>>23)-125)};const pg=-1/0,fg=1/0;lg.MIN_VALUE_32=2**-126*2**-23,lg.MAX_VALUE_32=2**127*(1+8388607/2**23),lg.EPSILON_32=2**-23;const hg=2139095040,dg=-2139095041,mg=new Float32Array(1),gg=new Uint32Array(mg.buffer,mg.byteOffset);function decomposeFloat(e){const t=function(e){return mg[0]=e,gg[0]}(e),r=t>>>23&255;let n=0===r?0:1;return n+=(8388607&t)/2**23,n*=0==t>>>31?1:-1,{exponent:0===r?-126:r-127,significand:n}}function indexInFloatFromDecomp(e,t){return-126===e?8388608*t:8388608*(e+127)+8388608*(t-1)}var yg={};!function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.onlyIntegersAfterThisValue=e.maxNonIntegerValue=void 0,e.refineConstraintsForFloatOnly=function(r){return(0,t.refineConstraintsForFloatingOnly)(r,i,e.maxNonIntegerValue,e.onlyIntegersAfterThisValue)},e.floatOnlyMapper=function(t){return t===e.onlyIntegersAfterThisValue?n:t===-e.onlyIntegersAfterThisValue?r:t},e.floatOnlyUnmapper=function(t){if("number"!=typeof t)throw Error("Unsupported type");return t===n?e.onlyIntegersAfterThisValue:t===r?-e.onlyIntegersAfterThisValue:t};const t=Jm,r=-1/0,n=1/0,i=lg.MAX_VALUE_32;e.maxNonIntegerValue=8388607.5,e.onlyIntegersAfterThisValue=8388608}(yg),Object.defineProperty(cg,"__esModule",{value:!0}),cg.float=function(e={}){return e.noInteger?anyFloat((0,vg.refineConstraintsForFloatOnly)(e)).map(vg.floatOnlyMapper,vg.floatOnlyUnmapper).filter(numberIsNotInteger):anyFloat(e)};const bg=Cl,Sg=lg,vg=yg,_g=Number.isInteger,wg=Number.isNaN,kg=Math.fround,xg=-1/0,Ig=1/0,Tg=NaN;function safeFloatToIndex(e,t){const r="fc.float constraints."+t+" must be a 32-bit float - you can convert any double to a 32-bit float by using `Math.fround(myDouble)`";if(wg(e)||kg(e)!==e)throw Error(r);return(0,Sg.floatToIndex)(e)}function unmapperFloatToIndex(e){if("number"!=typeof e)throw Error("Unsupported type");return(0,Sg.floatToIndex)(e)}function numberIsNotInteger(e){return!_g(e)}function anyFloat(e){const{noDefaultInfinity:t=!1,noNaN:r=!1,minExcluded:n=!1,maxExcluded:i=!1,min:s=(t?-Sg.MAX_VALUE_32:xg),max:o=(t?Sg.MAX_VALUE_32:Ig)}=e,a=safeFloatToIndex(s,"min"),u=n?a+1:a,c=safeFloatToIndex(o,"max"),l=i?c-1:c;if(u>l)throw Error("fc.float constraints.min must be smaller or equal to constraints.max");if(r)return(0,bg.integer)({min:u,max:l}).map(Sg.indexToFloat,unmapperFloatToIndex);const p=l>0?u:u-1,d=l>0?l+1:l;return(0,bg.integer)({min:p,max:d}).map(e=>e>l||e<u?Tg:(0,Sg.indexToFloat)(e),e=>{if("number"!=typeof e)throw Error("Unsupported type");return wg(e)?l!==d?d:p:(0,Sg.floatToIndex)(e)})}var Og={},Eg={},Ag={};Object.defineProperty(Ag,"__esModule",{value:!0}),Ag.escapeForTemplateString=function(e){return e.replace(/([$`\\])/g,"\\$1").replace(/\r/g,"\\r")},Ag.escapeForMultilineComments=function(e){return e.replace(/\*\//g,"*\\/")};var Cg={};Object.defineProperty(Cg,"__esModule",{value:!0}),Cg.hash=function(e){let t=4294967295;for(let r=0;r<e.length;++r){const n=(0,Mg.safeCharCodeAt)(e,r);if(n<128)t=Fg[255&t^n]^t>>8;else if(n<2048)t=Fg[255&t^(192|n>>6&31)]^t>>8,t=Fg[255&t^(128|63&n)]^t>>8;else if(n>=55296&&n<57344){const i=(0,Mg.safeCharCodeAt)(e,++r);if(n>=56320||i<56320||i>57343||Number.isNaN(i))r-=1,t=Fg[255&t^239]^t>>8,t=Fg[255&t^191]^t>>8,t=Fg[255&t^189]^t>>8;else{const e=64+(1023&n),r=1023&i;t=Fg[255&t^(240|e>>8&7)]^t>>8,t=Fg[255&t^(128|e>>2&63)]^t>>8,t=Fg[255&t^(128|r>>6&15|(3&e)<<4)]^t>>8,t=Fg[255&t^(128|63&r)]^t>>8}}else t=Fg[255&t^(224|n>>12&15)]^t>>8,t=Fg[255&t^(128|n>>6&63)]^t>>8,t=Fg[255&t^(128|63&n)]^t>>8}return 2147483648+(0|t)};const Mg=so,Fg=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,936918e3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117];var Pg={};Object.defineProperty(Pg,"__esModule",{value:!0}),Pg.noShrink=function(e){return e.noShrink()},Object.defineProperty(Eg,"__esModule",{value:!0}),Eg.buildCompareFunctionArbitrary=function(e){return(0,$g.tuple)((0,Ug.noShrink)((0,Lg.integer)()),(0,Ug.noShrink)((0,Lg.integer)({min:1,max:4294967295}))).map(([t,r])=>{const producer=()=>{const n={};return zg((i,s)=>{const o=(0,Dg.stringify)(i),a=(0,Dg.stringify)(s),u=(0,Rg.hash)(`${t}${o}`)%r,c=(0,Rg.hash)(`${t}${a}`)%r,l=e(u,c);return n[`[${o},${a}]`]=l,l},{toString:()=>{const i=qg(n).sort().map(e=>`${e} => ${(0,Dg.stringify)(n[e])}`).map(e=>`/* ${(0,Ng.escapeForMultilineComments)(e)} */`);return`function(a, b) {\n  // With hash and stringify coming from fast-check${0!==i.length?"\n  "+(0,Bg.safeJoin)(i,"\n  "):""}\n  const cmp = ${e};\n  const hA = hash('${t}' + stringify(a)) % ${r};\n  const hB = hash('${t}' + stringify(b)) % ${r};\n  return cmp(hA, hB);\n}`},[jg.cloneMethod]:producer})};return producer()})};const Ng=Ag,jg=Js,Rg=Cg,Dg=cc,Lg=Cl,Ug=Pg,$g=no,Bg=so,zg=Object.assign,qg=Object.keys;Object.defineProperty(Og,"__esModule",{value:!0}),Og.compareBooleanFunc=function(){return(0,Wg.buildCompareFunctionArbitrary)(Vg((e,t)=>e<t,{toString:()=>"(hA, hB) => hA < hB"}))};const Wg=Eg,Vg=Object.assign;var Kg={};Object.defineProperty(Kg,"__esModule",{value:!0}),Kg.compareFunc=function(){return(0,Gg.buildCompareFunctionArbitrary)(Jg((e,t)=>e-t,{toString:()=>"(hA, hB) => hA - hB"}))};const Gg=Eg,Jg=Object.assign;var Hg={};Object.defineProperty(Hg,"__esModule",{value:!0}),Hg.func=function(e){return(0,ry.tuple)((0,Xg.array)(e,{minLength:1}),(0,ty.noShrink)((0,ey.integer)())).map(([e,t])=>{const producer=()=>{const r={};function prettyPrint(e){const n=(0,iy.safeMap)((0,iy.safeMap)((0,iy.safeSort)(oy(r)),e=>`${e} => ${(0,Qg.stringify)(r[e])}`),e=>`/* ${(0,ny.escapeForMultilineComments)(e)} */`);return`function(...args) {\n  // With hash and stringify coming from fast-check${0!==n.length?"\n  "+n.join("\n  "):""}\n  const outs = ${e};\n  return outs[hash('${t}' + stringify(args)) % outs.length];\n}`}return sy((...n)=>{const i=(0,Qg.stringify)(n),s=e[(0,Zg.hash)(`${t}${i}`)%e.length];return r[i]=s,(0,Yg.hasCloneMethod)(s)?s[Yg.cloneMethod]():s},{toString:{value:()=>prettyPrint((0,Qg.stringify)(e))},[Qg.toStringMethod]:{value:()=>prettyPrint((0,Qg.stringify)(e))},[Qg.asyncToStringMethod]:{value:async()=>prettyPrint(await(0,Qg.asyncStringify)(e))},[Yg.cloneMethod]:{value:producer,configurable:!0}})};return producer()})};const Zg=Cg,Qg=cc,Yg=Js,Xg=El,ey=Cl,ty=Pg,ry=no,ny=Ag,iy=so,sy=Object.defineProperties,oy=Object.keys;var ay={};Object.defineProperty(ay,"__esModule",{value:!0}),ay.maxSafeInteger=function(){return new uy.IntegerArbitrary(cy,ly)};const uy=Ml,cy=Number.MIN_SAFE_INTEGER,ly=Number.MAX_SAFE_INTEGER;var py={};Object.defineProperty(py,"__esModule",{value:!0}),py.maxSafeNat=function(){return new fy.IntegerArbitrary(0,hy)};const fy=Ml,hy=Number.MAX_SAFE_INTEGER;var dy={},my={};Object.defineProperty(my,"__esModule",{value:!0}),my.natToStringifiedNatMapper=function(e){const[t,r]=e;switch(t){case"oct":return"0"+(0,gy.safeNumberToString)(r,8);case"hex":return"0x"+(0,gy.safeNumberToString)(r,16);default:return""+r}},my.tryParseStringifiedNat=tryParseStringifiedNat,my.natToStringifiedNatUnmapper=function(e){if("string"!=typeof e)throw Error("Invalid type");return e.length>=2&&"0"===e[0]?"x"===e[1]?["hex",tryParseStringifiedNat((0,gy.safeSubstring)(e,2),16)]:["oct",tryParseStringifiedNat((0,gy.safeSubstring)(e,1),8)]:["dec",tryParseStringifiedNat(e,10)]};const gy=so,yy=Number.parseInt;function tryParseStringifiedNat(e,t){const r=yy(e,t);if((0,gy.safeNumberToString)(r,t)!==e)throw Error("Invalid value");return r}Object.defineProperty(dy,"__esModule",{value:!0}),dy.ipV4=function(){return(0,vy.tuple)((0,Sy.nat)(255),(0,Sy.nat)(255),(0,Sy.nat)(255),(0,Sy.nat)(255)).map(dotJoinerMapper$1,dotJoinerUnmapper$1)};const by=so,Sy=od,vy=no,_y=my;function dotJoinerMapper$1(e){return(0,by.safeJoin)(e,".")}function dotJoinerUnmapper$1(e){if("string"!=typeof e)throw Error("Invalid type");return(0,by.safeMap)((0,by.safeSplit)(e,"."),e=>(0,_y.tryParseStringifiedNat)(e,10))}var wy={},ky={};Object.defineProperty(ky,"__esModule",{value:!0}),ky.buildStringifiedNatArbitrary=function(e){return(0,Ty.tuple)((0,xy.constantFrom)("dec","oct","hex"),(0,Iy.nat)(e)).map(Oy.natToStringifiedNatMapper,Oy.natToStringifiedNatUnmapper)};const xy=Xp,Iy=od,Ty=no,Oy=my;Object.defineProperty(wy,"__esModule",{value:!0}),wy.ipV4Extended=function(){return(0,Ay.oneof)((0,Cy.tuple)((0,My.buildStringifiedNatArbitrary)(255),(0,My.buildStringifiedNatArbitrary)(255),(0,My.buildStringifiedNatArbitrary)(255),(0,My.buildStringifiedNatArbitrary)(255)).map(dotJoinerMapper,dotJoinerUnmapper),(0,Cy.tuple)((0,My.buildStringifiedNatArbitrary)(255),(0,My.buildStringifiedNatArbitrary)(255),(0,My.buildStringifiedNatArbitrary)(65535)).map(dotJoinerMapper,dotJoinerUnmapper),(0,Cy.tuple)((0,My.buildStringifiedNatArbitrary)(255),(0,My.buildStringifiedNatArbitrary)(16777215)).map(dotJoinerMapper,dotJoinerUnmapper),(0,My.buildStringifiedNatArbitrary)(4294967295))};const Ey=so,Ay=zh,Cy=no,My=ky;function dotJoinerMapper(e){return(0,Ey.safeJoin)(e,".")}function dotJoinerUnmapper(e){if("string"!=typeof e)throw Error("Invalid type");return(0,Ey.safeSplit)(e,".")}var Fy={},Py={},Ny={};Object.defineProperty(Ny,"__esModule",{value:!0}),Ny.codePointsToStringMapper=function(e){return(0,jy.safeJoin)(e,"")},Ny.codePointsToStringUnmapper=function(e){if("string"!=typeof e)throw Error("Cannot unmap the passed value");return[...e]};const jy=so;Object.defineProperty(Py,"__esModule",{value:!0}),Py.hexaString=function(e={}){const t=(0,Dy.hexa)(),r=(0,Uy.createSlicesForStringLegacy)(t,Ly.codePointsToStringUnmapper),n=$y($y({},e),{experimentalCustomSlices:r});return(0,Ry.array)(t,n).map(Ly.codePointsToStringMapper,Ly.codePointsToStringUnmapper)};const Ry=El,Dy=Mf,Ly=Ny,Uy=Pd,$y=Object.assign;var By={};Object.defineProperty(By,"__esModule",{value:!0}),By.fullySpecifiedMapper=function(e){return`${(0,zy.safeJoin)(e[0],":")}:${e[1]}`},By.fullySpecifiedUnmapper=function(e){if("string"!=typeof e)throw Error("Invalid type");return extractEhAndL(e)},By.onlyTrailingMapper=function(e){return`::${(0,zy.safeJoin)(e[0],":")}:${e[1]}`},By.onlyTrailingUnmapper=function(e){if("string"!=typeof e)throw Error("Invalid type");if(!(0,zy.safeStartsWith)(e,"::"))throw Error("Invalid value");return extractEhAndL((0,zy.safeSubstring)(e,2))},By.multiTrailingMapper=multiTrailingMapper,By.multiTrailingUnmapper=multiTrailingUnmapper,By.multiTrailingMapperOne=function(e){return multiTrailingMapper([e[0],[e[1]],e[2]])},By.multiTrailingUnmapperOne=function(e){const t=multiTrailingUnmapper(e);return[t[0],(0,zy.safeJoin)(t[1],":"),t[2]]},By.singleTrailingMapper=function(e){return`${(0,zy.safeJoin)(e[0],":")}::${e[1]}`},By.singleTrailingUnmapper=function(e){if("string"!=typeof e)throw Error("Invalid type");const[t,r]=(0,zy.safeSplit)(e,"::",2);return[readBh(t),r]},By.noTrailingMapper=function(e){return(0,zy.safeJoin)(e[0],":")+"::"},By.noTrailingUnmapper=function(e){if("string"!=typeof e)throw Error("Invalid type");if(!(0,zy.safeEndsWith)(e,"::"))throw Error("Invalid value");return[readBh((0,zy.safeSubstring)(e,0,e.length-2))]};const zy=so;function readBh(e){return 0===e.length?[]:(0,zy.safeSplit)(e,":")}function extractEhAndL(e){const t=(0,zy.safeSplit)(e,":");return t.length>=2&&t[t.length-1].length<=4?[(0,zy.safeSlice)(t,0,t.length-2),`${t[t.length-2]}:${t[t.length-1]}`]:[(0,zy.safeSlice)(t,0,t.length-1),t[t.length-1]]}function multiTrailingMapper(e){return`${(0,zy.safeJoin)(e[0],":")}::${(0,zy.safeJoin)(e[1],":")}:${e[2]}`}function multiTrailingUnmapper(e){if("string"!=typeof e)throw Error("Invalid type");const[t,r]=(0,zy.safeSplit)(e,"::",2),[n,i]=extractEhAndL(r);return[readBh(t),n,i]}Object.defineProperty(Fy,"__esModule",{value:!0}),Fy.ipV6=function(){const e=(0,Vy.hexaString)({minLength:1,maxLength:4,size:"max"}),t=(0,Wy.oneof)((0,Ky.tuple)(e,e).map(h16sTol32Mapper,h16sTol32Unmapper),(0,Gy.ipV4)());return(0,Wy.oneof)((0,Ky.tuple)((0,qy.array)(e,{minLength:6,maxLength:6,size:"max"}),t).map(Jy.fullySpecifiedMapper,Jy.fullySpecifiedUnmapper),(0,Ky.tuple)((0,qy.array)(e,{minLength:5,maxLength:5,size:"max"}),t).map(Jy.onlyTrailingMapper,Jy.onlyTrailingUnmapper),(0,Ky.tuple)((0,qy.array)(e,{minLength:0,maxLength:1,size:"max"}),(0,qy.array)(e,{minLength:4,maxLength:4,size:"max"}),t).map(Jy.multiTrailingMapper,Jy.multiTrailingUnmapper),(0,Ky.tuple)((0,qy.array)(e,{minLength:0,maxLength:2,size:"max"}),(0,qy.array)(e,{minLength:3,maxLength:3,size:"max"}),t).map(Jy.multiTrailingMapper,Jy.multiTrailingUnmapper),(0,Ky.tuple)((0,qy.array)(e,{minLength:0,maxLength:3,size:"max"}),(0,qy.array)(e,{minLength:2,maxLength:2,size:"max"}),t).map(Jy.multiTrailingMapper,Jy.multiTrailingUnmapper),(0,Ky.tuple)((0,qy.array)(e,{minLength:0,maxLength:4,size:"max"}),e,t).map(Jy.multiTrailingMapperOne,Jy.multiTrailingUnmapperOne),(0,Ky.tuple)((0,qy.array)(e,{minLength:0,maxLength:5,size:"max"}),t).map(Jy.singleTrailingMapper,Jy.singleTrailingUnmapper),(0,Ky.tuple)((0,qy.array)(e,{minLength:0,maxLength:6,size:"max"}),e).map(Jy.singleTrailingMapper,Jy.singleTrailingUnmapper),(0,Ky.tuple)((0,qy.array)(e,{minLength:0,maxLength:7,size:"max"})).map(Jy.noTrailingMapper,Jy.noTrailingUnmapper))};const qy=El,Wy=zh,Vy=Py,Ky=no,Gy=dy,Jy=By;function h16sTol32Mapper([e,t]){return`${e}:${t}`}function h16sTol32Unmapper(e){if("string"!=typeof e)throw Error("Invalid type");if(!e.includes(":"))throw Error("Invalid value");return e.split(":",2)}var Hy={},Zy={};Object.defineProperty(Zy,"__esModule",{value:!0}),Zy.LazyArbitrary=void 0;const Qy=zs;class LazyArbitrary extends Qy.Arbitrary{constructor(name){super(),this.name=name,this.underlying=null}generate(e,t){if(!this.underlying)throw Error(`Lazy arbitrary ${JSON.stringify(this.name)} not correctly initialized`);return this.underlying.generate(e,t)}canShrinkWithoutContext(e){if(!this.underlying)throw Error(`Lazy arbitrary ${JSON.stringify(this.name)} not correctly initialized`);return this.underlying.canShrinkWithoutContext(e)}shrink(e,t){if(!this.underlying)throw Error(`Lazy arbitrary ${JSON.stringify(this.name)} not correctly initialized`);return this.underlying.shrink(e,t)}}Zy.LazyArbitrary=LazyArbitrary,Object.defineProperty(Hy,"__esModule",{value:!0}),Hy.letrec=function(e){const t=eb(null),r=e(e=>((0,Xy.safeHasOwnProperty)(t,e)||(t[e]=new Yy.LazyArbitrary(e+"")),t[e]));for(const e in r){if(!(0,Xy.safeHasOwnProperty)(r,e))continue;const n=t[e],i=void 0!==n?n:new Yy.LazyArbitrary(e);i.underlying=r[e],t[e]=i}return r};const Yy=Zy,Xy=so,eb=Object.create;var tb={},rb={};Object.defineProperty(rb,"__esModule",{value:!0}),rb.wordsToJoinedStringMapper=function(e){return(0,nb.safeJoin)((0,nb.safeMap)(e,e=>","===e[e.length-1]?(0,nb.safeSubstring)(e,0,e.length-1):e)," ")},rb.wordsToJoinedStringUnmapperFor=function(e){return function(t){if("string"!=typeof t)throw Error("Unsupported type");const r=[];for(const n of(0,nb.safeSplit)(t," "))if(e.canShrinkWithoutContext(n))(0,nb.safePush)(r,n);else{if(!e.canShrinkWithoutContext(n+","))throw Error("Unsupported word");(0,nb.safePush)(r,n+",")}return r}},rb.wordsToSentenceMapper=function(e){let t=(0,nb.safeJoin)(e," ");return","===t[t.length-1]&&(t=(0,nb.safeSubstring)(t,0,t.length-1)),(0,nb.safeToUpperCase)(t[0])+(0,nb.safeSubstring)(t,1)+"."},rb.wordsToSentenceUnmapperFor=function(e){return function(t){if("string"!=typeof t)throw Error("Unsupported type");if(t.length<2||"."!==t[t.length-1]||","===t[t.length-2]||(0,nb.safeToUpperCase)((0,nb.safeToLowerCase)(t[0]))!==t[0])throw Error("Unsupported value");const r=(0,nb.safeToLowerCase)(t[0])+(0,nb.safeSubstring)(t,1,t.length-1),n=[],i=(0,nb.safeSplit)(r," ");for(let t=0;t!==i.length;++t){const r=i[t];if(e.canShrinkWithoutContext(r))(0,nb.safePush)(n,r);else{if(t!==i.length-1||!e.canShrinkWithoutContext(r+","))throw Error("Unsupported word");(0,nb.safePush)(n,r+",")}}return n}},rb.sentencesToParagraphMapper=function(e){return(0,nb.safeJoin)(e," ")},rb.sentencesToParagraphUnmapper=function(e){if("string"!=typeof e)throw Error("Unsupported type");const t=(0,nb.safeSplit)(e,". ");for(let e=0;e<t.length-1;++e)t[e]+=".";return t};const nb=so;Object.defineProperty(tb,"__esModule",{value:!0}),tb.lorem=function(e={}){const{maxCount:t,mode:r="words",size:n}=e;if(void 0!==t&&t<1)throw Error("lorem has to produce at least one word/sentence");const i=(0,ob.oneof)(h("non",6),h("adipiscing",5),h("ligula",5),h("enim",5),h("pellentesque",5),h("in",5),h("augue",5),h("et",5),h("nulla",5),h("lorem",4),h("sit",4),h("sed",4),h("diam",4),h("fermentum",4),h("ut",4),h("eu",4),h("aliquam",4),h("mauris",4),h("vitae",4),h("felis",4),h("ipsum",3),h("dolor",3),h("amet,",3),h("elit",3),h("euismod",3),h("mi",3),h("orci",3),h("erat",3),h("praesent",3),h("egestas",3),h("leo",3),h("vel",3),h("sapien",3),h("integer",3),h("curabitur",3),h("convallis",3),h("purus",3),h("risus",2),h("suspendisse",2),h("lectus",2),h("nec,",2),h("ultricies",2),h("sed,",2),h("cras",2),h("elementum",2),h("ultrices",2),h("maecenas",2),h("massa,",2),h("varius",2),h("a,",2),h("semper",2),h("proin",2),h("nec",2),h("nisl",2),h("amet",2),h("duis",2),h("congue",2),h("libero",2),h("vestibulum",2),h("pede",2),h("blandit",2),h("sodales",2),h("ante",2),h("nibh",2),h("ac",2),h("aenean",2),h("massa",2),h("suscipit",2),h("sollicitudin",2),h("fusce",2),h("tempus",2),h("aliquam,",2),h("nunc",2),h("ullamcorper",2),h("rhoncus",2),h("metus",2),h("faucibus,",2),h("justo",2),h("magna",2),h("at",2),h("tincidunt",2),h("consectetur",1),h("tortor,",1),h("dignissim",1),h("congue,",1),h("non,",1),h("porttitor,",1),h("nonummy",1),h("molestie,",1),h("est",1),h("eleifend",1),h("mi,",1),h("arcu",1),h("scelerisque",1),h("vitae,",1),h("consequat",1),h("in,",1),h("pretium",1),h("volutpat",1),h("pharetra",1),h("tempor",1),h("bibendum",1),h("odio",1),h("dui",1),h("primis",1),h("faucibus",1),h("luctus",1),h("posuere",1),h("cubilia",1),h("curae,",1),h("hendrerit",1),h("velit",1),h("mauris,",1),h("gravida",1),h("ornare",1),h("ut,",1),h("pulvinar",1),h("varius,",1),h("turpis",1),h("nibh,",1),h("eros",1),h("id",1),h("aliquet",1),h("quis",1),h("lobortis",1),h("consectetuer",1),h("morbi",1),h("vehicula",1),h("tortor",1),h("tellus,",1),h("id,",1),h("eu,",1),h("quam",1),h("feugiat,",1),h("posuere,",1),h("iaculis",1),h("lectus,",1),h("tristique",1),h("mollis,",1),h("nisl,",1),h("vulputate",1),h("sem",1),h("vivamus",1),h("placerat",1),h("imperdiet",1),h("cursus",1),h("rutrum",1),h("iaculis,",1),h("augue,",1),h("lacus",1));if("sentences"===r){const e=(0,ib.array)(i,{minLength:1,size:"small"}).map(ab.wordsToSentenceMapper,(0,ab.wordsToSentenceUnmapperFor)(i));return(0,ib.array)(e,{minLength:1,maxLength:t,size:n}).map(ab.sentencesToParagraphMapper,ab.sentencesToParagraphUnmapper)}return(0,ib.array)(i,{minLength:1,maxLength:t,size:n}).map(ab.wordsToJoinedStringMapper,(0,ab.wordsToJoinedStringUnmapperFor)(i))};const ib=El,sb=Df,ob=zh,ab=rb,h=(e,t)=>({arbitrary:(0,sb.constant)(e),weight:t});var ub={};Object.defineProperty(ub,"__esModule",{value:!0}),ub.memo=function(e){const t={};return r=>{const n=void 0!==r?r:pb;if(!(0,lb.safeHasOwnProperty)(t,n)){const r=pb;pb=n-1,t[n]=e(n),pb=r}return t[n]}};const lb=so;let pb=10;var fb={},hb={},db={};Object.defineProperty(db,"__esModule",{value:!0}),db.countToggledBits=countToggledBits,db.computeNextFlags=function(e,t){const r=((0,mb.BigInt)(1)<<(0,mb.BigInt)(t))-(0,mb.BigInt)(1),n=e&r;let i=countToggledBits(e-n),s=n;for(let e=(0,mb.BigInt)(1);e<=r&&0!==i;e<<=(0,mb.BigInt)(1))s&e||(s|=e,--i);return s},db.computeTogglePositions=function(e,t){const r=[];for(let n=e.length-1;-1!==n;--n)t(e[n])!==e[n]&&(0,mb.safePush)(r,n);return r},db.computeFlagsFromChars=function(e,t,r){let n=(0,mb.BigInt)(0);for(let i=0,s=(0,mb.BigInt)(1);i!==r.length;++i,s<<=(0,mb.BigInt)(1))e[r[i]]!==t[r[i]]&&(n|=s);return n},db.applyFlagsOnChars=function(e,t,r,n){for(let i=0,s=(0,mb.BigInt)(1);i!==r.length;++i,s<<=(0,mb.BigInt)(1))t&s&&(e[r[i]]=n(e[r[i]]))};const mb=so;function countToggledBits(e){let t=0;for(;e>(0,mb.BigInt)(0);)e&(0,mb.BigInt)(1)&&++t,e>>=(0,mb.BigInt)(1);return t}Object.defineProperty(hb,"__esModule",{value:!0}),hb.MixedCaseArbitrary=void 0;const gb=Vp,yb=zs,bb=Hs,Sb=fa,vb=db,_b=so,wb=so;class MixedCaseArbitrary extends yb.Arbitrary{constructor(e,t,r){super(),this.stringArb=e,this.toggleCase=t,this.untoggleAll=r}buildContextFor(e,t){return{rawString:e.value,rawStringContext:e.context,flags:t.value,flagsContext:t.context}}generate(e,t){const r=this.stringArb.generate(e,t),n=[...r.value],i=(0,vb.computeTogglePositions)(n,this.toggleCase),s=(0,gb.bigUintN)(i.length).generate(e,void 0);return(0,vb.applyFlagsOnChars)(n,s.value,i,this.toggleCase),new bb.Value((0,_b.safeJoin)(n,""),this.buildContextFor(r,s))}canShrinkWithoutContext(e){return"string"==typeof e&&(void 0!==this.untoggleAll?this.stringArb.canShrinkWithoutContext(this.untoggleAll(e)):this.stringArb.canShrinkWithoutContext(e))}shrink(e,t){let r;if(void 0!==t)r=t;else if(void 0!==this.untoggleAll){const t=this.untoggleAll(e),n=[...e],i=[...t],s=(0,vb.computeTogglePositions)(i,this.toggleCase);r={rawString:t,rawStringContext:void 0,flags:(0,vb.computeFlagsFromChars)(i,n,s),flagsContext:void 0}}else r={rawString:e,rawStringContext:void 0,flags:(0,wb.BigInt)(0),flagsContext:void 0};const n=r.rawString,i=r.flags;return this.stringArb.shrink(n,r.rawStringContext).map(e=>{const t=[...e.value],r=(0,vb.computeTogglePositions)(t,this.toggleCase),n=(0,vb.computeNextFlags)(i,r.length);return(0,vb.applyFlagsOnChars)(t,n,r,this.toggleCase),new bb.Value((0,_b.safeJoin)(t,""),this.buildContextFor(e,new bb.Value(n,void 0)))}).join((0,Sb.makeLazy)(()=>{const e=[...n],t=(0,vb.computeTogglePositions)(e,this.toggleCase);return(0,gb.bigUintN)(t.length).shrink(i,r.flagsContext).map(i=>{const s=(0,_b.safeSlice)(e);return(0,vb.applyFlagsOnChars)(s,i.value,t,this.toggleCase),new bb.Value((0,_b.safeJoin)(s,""),this.buildContextFor(new bb.Value(n,r.rawStringContext),i))})}))}}hb.MixedCaseArbitrary=MixedCaseArbitrary,Object.defineProperty(fb,"__esModule",{value:!0}),fb.mixedCase=function(e,t){if(void 0===kb.BigInt)throw new kb.Error("mixedCase requires BigInt support");const r=t&&t.toggleCase||defaultToggleCase,n=t&&t.untoggleAll;return new xb.MixedCaseArbitrary(e,r,n)};const kb=so,xb=hb;function defaultToggleCase(e){const t=(0,kb.safeToUpperCase)(e);return t!==e?t:(0,kb.safeToLowerCase)(e)}var Ib={},Tb={},Ob={};Object.defineProperty(Ob,"__esModule",{value:!0}),Ob.float32Array=function(e={}){return(0,Ab.array)((0,Eb.float)(e),e).map(toTypedMapper$1,fromTypedUnmapper$1)};const Eb=cg,Ab=El,Cb=so;function toTypedMapper$1(e){return Cb.Float32Array.from(e)}function fromTypedUnmapper$1(e){if(!(e instanceof Cb.Float32Array))throw Error("Unexpected type");return[...e]}var Mb={};Object.defineProperty(Mb,"__esModule",{value:!0}),Mb.float64Array=function(e={}){return(0,Pb.array)((0,Fb.double)(e),e).map(toTypedMapper,fromTypedUnmapper)};const Fb=Mm,Pb=El,Nb=so;function toTypedMapper(e){return Nb.Float64Array.from(e)}function fromTypedUnmapper(e){if(!(e instanceof Nb.Float64Array))throw Error("Unexpected type");return[...e]}var jb={},Rb={},Db=e&&e.__rest||function(e,t){var r={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.indexOf(n)<0&&(r[n]=e[n]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var i=0;for(n=Object.getOwnPropertySymbols(e);i<n.length;i++)t.indexOf(n[i])<0&&Object.prototype.propertyIsEnumerable.call(e,n[i])&&(r[n[i]]=e[n[i]])}return r};Object.defineProperty(Rb,"__esModule",{value:!0}),Rb.typedIntArrayArbitraryArbitraryBuilder=function(e,t,r,n,i){const s=n.name,{min:o=t,max:a=r}=e,u=Db(e,["min","max"]);if(o>a)throw Error(`Invalid range passed to ${s}: min must be lower than or equal to max`);if(o<t)throw Error(`Invalid min value passed to ${s}: min must be greater than or equal to ${t}`);if(a>r)throw Error(`Invalid max value passed to ${s}: max must be lower than or equal to ${r}`);return(0,Lb.array)(i({min:o,max:a}),u).map(e=>n.from(e),e=>{if(!(e instanceof n))throw Error("Invalid type");return[...e]})};const Lb=El;Object.defineProperty(jb,"__esModule",{value:!0}),jb.int16Array=function(e={}){return(0,Bb.typedIntArrayArbitraryArbitraryBuilder)(e,-32768,32767,Ub.Int16Array,$b.integer)};const Ub=so,$b=Cl,Bb=Rb;var zb={};Object.defineProperty(zb,"__esModule",{value:!0}),zb.int32Array=function(e={}){return(0,Vb.typedIntArrayArbitraryArbitraryBuilder)(e,-2147483648,2147483647,qb.Int32Array,Wb.integer)};const qb=so,Wb=Cl,Vb=Rb;var Kb={};Object.defineProperty(Kb,"__esModule",{value:!0}),Kb.int8Array=function(e={}){return(0,Hb.typedIntArrayArbitraryArbitraryBuilder)(e,-128,127,Gb.Int8Array,Jb.integer)};const Gb=so,Jb=Cl,Hb=Rb;var Zb={};Object.defineProperty(Zb,"__esModule",{value:!0}),Zb.uint16Array=function(e={}){return(0,Xb.typedIntArrayArbitraryArbitraryBuilder)(e,0,65535,Qb.Uint16Array,Yb.integer)};const Qb=so,Yb=Cl,Xb=Rb;var eS={};Object.defineProperty(eS,"__esModule",{value:!0}),eS.uint32Array=function(e={}){return(0,nS.typedIntArrayArbitraryArbitraryBuilder)(e,0,4294967295,tS.Uint32Array,rS.integer)};const tS=so,rS=Cl,nS=Rb;var iS={};Object.defineProperty(iS,"__esModule",{value:!0}),iS.uint8Array=function(e={}){return(0,aS.typedIntArrayArbitraryArbitraryBuilder)(e,0,255,sS.Uint8Array,oS.integer)};const sS=so,oS=Cl,aS=Rb;var uS={};Object.defineProperty(uS,"__esModule",{value:!0}),uS.uint8ClampedArray=function(e={}){return(0,pS.typedIntArrayArbitraryArbitraryBuilder)(e,0,255,cS.Uint8ClampedArray,lS.integer)};const cS=so,lS=Cl,pS=Rb;var fS={},hS={},dS={};Object.defineProperty(dS,"__esModule",{value:!0}),dS.WithShrinkFromOtherArbitrary=void 0;const mS=zs,gS=Hs;function toGeneratorValue(e){return e.hasToBeCloned?new gS.Value(e.value_,{generatorContext:e.context},()=>e.value):new gS.Value(e.value_,{generatorContext:e.context})}function toShrinkerValue(e){return e.hasToBeCloned?new gS.Value(e.value_,{shrinkerContext:e.context},()=>e.value):new gS.Value(e.value_,{shrinkerContext:e.context})}class WithShrinkFromOtherArbitrary extends mS.Arbitrary{constructor(e,t){super(),this.generatorArbitrary=e,this.shrinkerArbitrary=t}generate(e,t){return toGeneratorValue(this.generatorArbitrary.generate(e,t))}canShrinkWithoutContext(e){return this.shrinkerArbitrary.canShrinkWithoutContext(e)}shrink(e,t){return function(e){return void 0!==e}(t)?"generatorContext"in t?this.generatorArbitrary.shrink(e,t.generatorContext).map(toGeneratorValue):this.shrinkerArbitrary.shrink(e,t.shrinkerContext).map(toShrinkerValue):this.shrinkerArbitrary.shrink(e,void 0).map(toShrinkerValue)}}dS.WithShrinkFromOtherArbitrary=WithShrinkFromOtherArbitrary,Object.defineProperty(hS,"__esModule",{value:!0}),hS.restrictedIntegerArbitraryBuilder=function(e,t,r){const n=(0,yS.integer)({min:e,max:t});if(t===r)return n;const i=(0,yS.integer)({min:e,max:r});return new bS.WithShrinkFromOtherArbitrary(n,i)};const yS=Cl,bS=dS;Object.defineProperty(fS,"__esModule",{value:!0}),fS.sparseArray=function(e,t={}){const{size:r,minNumElements:n=0,maxLength:i=kS.MaxLengthUpperBound,maxNumElements:s=i,noTrailingHole:o,depthIdentifier:a}=t,u=(0,kS.maxGeneratedLengthFromSizeForArbitrary)(r,n,s,void 0!==t.maxNumElements),c=(0,kS.maxGeneratedLengthFromSizeForArbitrary)(r,u,i,void 0!==t.maxLength);if(n>i)throw Error("The minimal number of non-hole elements cannot be higher than the maximal length of the array");if(n>s)throw Error("The minimal number of non-hole elements cannot be higher than the maximal number of non-holes");const l=xS(s,i),p=void 0!==t.maxNumElements||void 0!==r?r:"=",d=IS(c-1,0),m=IS(i-1,0),g=(0,_S.uniqueArray)((0,vS.tuple)((0,wS.restrictedIntegerArbitraryBuilder)(0,d,m),e),{size:p,minLength:n,maxLength:l,selector:e=>e[0],depthIdentifier:a}).map(e=>function(e,t){const r=(0,SS.Array)(e);for(let n=0;n!==t.length;++n){const i=t[n];i[0]<e&&(r[i[0]]=i[1])}return r}(function(e){let t=-1;for(let r=0;r!==e.length;++r)t=IS(t,e[r][0]);return t}(e)+1,e),e=>{if(!TS(e))throw Error("Not supported entry type");if(o&&0!==e.length&&!(e.length-1 in e))throw Error("No trailing hole");return(0,SS.safeMap)(OS(e),e=>[Number(e[0]),e[1]])});return o||i===n?g:(0,vS.tuple)(g,(0,wS.restrictedIntegerArbitraryBuilder)(n,c,i)).map(e=>{const t=e[0],r=e[1];if(t.length>=r)return t;const n=(0,SS.safeSlice)(t);return n.length=r,n},e=>{if(!TS(e))throw Error("Not supported entry type");return[e,e.length]})};const SS=so,vS=no,_S=ch,wS=hS,kS=wp,xS=Math.min,IS=Math.max,TS=SS.Array.isArray,OS=Object.entries;var ES={};Object.defineProperty(ES,"__esModule",{value:!0}),ES.arrayToMapMapper=function(e){return new Map(e)},ES.arrayToMapUnmapper=function(e){if("object"!=typeof e||null===e)throw Error("Incompatible instance received: should be a non-null object");if(!("constructor"in e)||e.constructor!==Map)throw Error("Incompatible instance received: should be of exact type Map");return Array.from(e)};var AS={};Object.defineProperty(AS,"__esModule",{value:!0}),AS.arrayToSetMapper=function(e){return new Set(e)},AS.arrayToSetUnmapper=function(e){if("object"!=typeof e||null===e)throw Error("Incompatible instance received: should be a non-null object");if(!("constructor"in e)||e.constructor!==Set)throw Error("Incompatible instance received: should be of exact type Set");return Array.from(e)},Object.defineProperty(Tb,"__esModule",{value:!0}),Tb.anyArbitraryBuilder=function(e){const t=e.values,r=e.depthSize,n=(0,ZS.createDepthIdentifier)(),i=e.maxDepth,s=e.maxKeys,o=e.size,a=(0,FS.oneof)(...t,...e.withBigInt?[(0,NS.bigInt)()]:[],...e.withDate?[(0,jS.date)()]:[]);return(0,JS.letrec)(t=>({anything:(0,FS.oneof)({maxDepth:i,depthSize:r,depthIdentifier:n},a,t("array"),t("object"),...e.withMap?[t("map")]:[],...e.withSet?[t("set")]:[],...e.withObjectString?[t("anything").map(e=>(0,CS.stringify)(e))]:[],...e.withTypedArray?[typedArray({maxLength:s,size:o})]:[],...e.withSparseArray?[(0,VS.sparseArray)(t("anything"),{maxNumElements:s,size:o,depthIdentifier:n})]:[]),keys:e.withObjectString?(0,FS.oneof)({arbitrary:e.key,weight:10},{arbitrary:t("anything").map(e=>(0,CS.stringify)(e)),weight:1}):e.key,array:(0,MS.array)(t("anything"),{maxLength:s,size:o,depthIdentifier:n}),set:setOf(t("anything"),s,o,n),map:(0,FS.oneof)(mapOf(t("keys"),t("anything"),s,o,n),mapOf(t("anything"),t("anything"),s,o,n)),object:dictOf(t("keys"),t("anything"),s,o,n,e.withNullPrototype)})).anything};const CS=cc,MS=El,FS=zh,PS=no,NS=Ip,jS=zf,RS=Ob,DS=Mb,LS=jb,US=zb,$S=Kb,BS=Zb,zS=eS,qS=iS,WS=uS,VS=fS,KS=ES,GS=AS,JS=Hy,HS=ch,ZS=Ql,QS=uh;function mapOf(e,t,r,n,i){return(0,HS.uniqueArray)((0,PS.tuple)(e,t),{maxLength:r,size:n,comparator:"SameValueZero",selector:e=>e[0],depthIdentifier:i}).map(KS.arrayToMapMapper,KS.arrayToMapUnmapper)}function dictOf(e,t,r,n,i,s){return(0,QS.dictionary)(e,t,{maxKeys:r,noNullPrototype:!s,size:n,depthIdentifier:i})}function setOf(e,t,r,n){return(0,HS.uniqueArray)(e,{maxLength:t,size:r,comparator:"SameValueZero",depthIdentifier:n}).map(GS.arrayToSetMapper,GS.arrayToSetUnmapper)}function typedArray(e){return(0,FS.oneof)((0,$S.int8Array)(e),(0,qS.uint8Array)(e),(0,WS.uint8ClampedArray)(e),(0,LS.int16Array)(e),(0,BS.uint16Array)(e),(0,US.int32Array)(e),(0,zS.uint32Array)(e),(0,RS.float32Array)(e),(0,DS.float64Array)(e))}var YS={},XS={};Object.defineProperty(XS,"__esModule",{value:!0}),XS.fullUnicodeString=function(e={}){const t=(0,tv.fullUnicode)(),r=(0,nv.createSlicesForStringLegacy)(t,rv.codePointsToStringUnmapper),n=iv(iv({},e),{experimentalCustomSlices:r});return(0,ev.array)(t,n).map(rv.codePointsToStringMapper,rv.codePointsToStringUnmapper)};const ev=El,tv=Of,rv=Ny,nv=Pd,iv=Object.assign;var sv={},ov={};Object.defineProperty(ov,"__esModule",{value:!0}),ov.unboxedToBoxedMapper=function(e){switch(typeof e){case"boolean":return new av.Boolean(e);case"number":return new av.Number(e);case"string":return new av.String(e);default:return e}},ov.unboxedToBoxedUnmapper=function(e){return"object"==typeof e&&null!==e&&"constructor"in e&&(e.constructor===av.Boolean||e.constructor===av.Number||e.constructor===av.String)?e.valueOf():e};const av=so;Object.defineProperty(sv,"__esModule",{value:!0}),sv.boxedArbitraryBuilder=function(e){return e.map(uv.unboxedToBoxedMapper,uv.unboxedToBoxedUnmapper)};const uv=ov;Object.defineProperty(YS,"__esModule",{value:!0}),YS.toQualifiedObjectConstraints=function(e={}){function orDefault(e,t){return void 0!==e?e:t}const t="stringUnit"in e?mv.string:e.withUnicodeString?fv.fullUnicodeString:mv.string,r={size:e.size,unit:e.stringUnit};return{key:orDefault(e.key,t(r)),values:(n=orDefault(e.values,defaultValues(r,t)),i=orDefault(e.withBoxedValues,!1),i?boxArbitraries(n).concat(n):n),depthSize:e.depthSize,maxDepth:e.maxDepth,maxKeys:e.maxKeys,size:e.size,withSet:orDefault(e.withSet,!1),withMap:orDefault(e.withMap,!1),withObjectString:orDefault(e.withObjectString,!1),withNullPrototype:orDefault(e.withNullPrototype,!1),withBigInt:orDefault(e.withBigInt,!1),withDate:orDefault(e.withDate,!1),withTypedArray:orDefault(e.withTypedArray,!1),withSparseArray:orDefault(e.withSparseArray,!1)};var n,i};const cv=Jp,lv=Df,pv=Mm,fv=XS,hv=ay,dv=zh,mv=Fd,gv=sv;function defaultValues(e,t){return[(0,cv.boolean)(),(0,hv.maxSafeInteger)(),(0,pv.double)(),t(e),(0,dv.oneof)(t(e),(0,lv.constant)(null),(0,lv.constant)(void 0))]}function boxArbitraries(e){return e.map(e=>(0,gv.boxedArbitraryBuilder)(e))}Object.defineProperty(Ib,"__esModule",{value:!0}),Ib.object=function(e){return function(e){return(0,yv.dictionary)(e.key,(0,bv.anyArbitraryBuilder)(e),{maxKeys:e.maxKeys,noNullPrototype:!e.withNullPrototype,size:e.size})}((0,Sv.toQualifiedObjectConstraints)(e))};const yv=uh,bv=Tb,Sv=YS;var vv={},_v={},wv={};Object.defineProperty(wv,"__esModule",{value:!0}),wv.jsonConstraintsBuilder=function(e,t){const{depthSize:r,maxDepth:n}=t;return{key:e,values:[(0,kv.boolean)(),(0,Iv.double)({noDefaultInfinity:!0,noNaN:!0}),e,(0,xv.constant)(null)],depthSize:r,maxDepth:n}};const kv=Jp,xv=Df,Iv=Mm;var Tv={};Object.defineProperty(Tv,"__esModule",{value:!0}),Tv.anything=function(e){return(0,Ov.anyArbitraryBuilder)((0,Ev.toQualifiedObjectConstraints)(e))};const Ov=Tb,Ev=YS;Object.defineProperty(_v,"__esModule",{value:!0}),_v.jsonValue=function(e={}){const t=void 0===e.noUnicodeString||!0===e.noUnicodeString,r="stringUnit"in e?(0,Av.string)({unit:e.stringUnit}):t?(0,Av.string)():(0,Fv.fullUnicodeString)();return(0,Mv.anything)((0,Cv.jsonConstraintsBuilder)(r,e))};const Av=Fd,Cv=wv,Mv=Tv,Fv=XS;Object.defineProperty(vv,"__esModule",{value:!0}),vv.json=function(e={}){return(0,Pv.jsonValue)(e).map(JSON.stringify)};const Pv=_v;var Nv={},jv={};Object.defineProperty(jv,"__esModule",{value:!0}),jv.unicodeString=function(e={}){const t=(0,Dv.unicode)(),r=(0,Uv.createSlicesForStringLegacy)(t,Lv.codePointsToStringUnmapper),n=$v($v({},e),{experimentalCustomSlices:r});return(0,Rv.array)(t,n).map(Lv.codePointsToStringMapper,Lv.codePointsToStringUnmapper)};const Rv=El,Dv=Pf,Lv=Ny,Uv=Pd,$v=Object.assign;Object.defineProperty(Nv,"__esModule",{value:!0}),Nv.unicodeJsonValue=function(e={}){return(0,qv.anything)((0,zv.jsonConstraintsBuilder)((0,Bv.unicodeString)(),e))};const Bv=jv,zv=wv,qv=Tv;var Wv={};Object.defineProperty(Wv,"__esModule",{value:!0}),Wv.unicodeJson=function(e={}){return(0,Vv.unicodeJsonValue)(e).map(JSON.stringify)};const Vv=Nv;var Kv={},Gv={},Jv={};Object.defineProperty(Jv,"__esModule",{value:!0}),Jv.extractEnumerableKeys=function(e){const t=Hv(e),r=Zv(e);for(let n=0;n!==r.length;++n){const i=r[n],s=Qv(e,i);s&&s.enumerable&&t.push(i)}return t};const Hv=Object.keys,Zv=Object.getOwnPropertySymbols,Qv=Object.getOwnPropertyDescriptor;var Yv={};Object.defineProperty(Yv,"__esModule",{value:!0}),Yv.buildValuesAndSeparateKeysToObjectMapper=function(e,t){return function(r){const n=r[1]?e_(null):{};for(let i=0;i!==e.length;++i){const s=r[0][i];s!==t&&t_(n,e[i],{value:s,configurable:!0,enumerable:!0,writable:!0})}return n}},Yv.buildValuesAndSeparateKeysToObjectUnmapper=function(e,t){return function(r){if("object"!=typeof r||null===r)throw Error("Incompatible instance received: should be a non-null object");const n=null===Object.getPrototypeOf(r),i="constructor"in r&&r.constructor===Object;if(!n&&!i)throw Error("Incompatible instance received: should be of exact type Object");let s=0;const o=[];for(let n=0;n!==e.length;++n){const i=r_(r,e[n]);if(void 0!==i){if(!i.configurable||!i.enumerable||!i.writable)throw Error("Incompatible instance received: should contain only c/e/w properties");if(void 0!==i.get||void 0!==i.set)throw Error("Incompatible instance received: should contain only no get/set properties");++s,(0,Xv.safePush)(o,i.value)}else(0,Xv.safePush)(o,t)}if(s!==n_(r).length+i_(r).length)throw Error("Incompatible instance received: should not contain extra properties");return[o,n]}};const Xv=so,e_=Object.create,t_=Object.defineProperty,r_=Object.getOwnPropertyDescriptor,n_=Object.getOwnPropertyNames,i_=Object.getOwnPropertySymbols;Object.defineProperty(Gv,"__esModule",{value:!0}),Gv.buildPartialRecordArbitrary=function(e,t,r){const n=(0,l_.extractEnumerableKeys)(e),i=[];for(let r=0;r!==n.length;++r){const s=n[r],o=e[s];void 0===t||-1!==(0,s_.safeIndexOf)(t,s)?(0,s_.safePush)(i,o):(0,s_.safePush)(i,(0,u_.option)(o,{nil:f_}))}return(0,c_.tuple)((0,c_.tuple)(...i),r?(0,a_.constant)(!1):(0,o_.boolean)()).map((0,p_.buildValuesAndSeparateKeysToObjectMapper)(n,f_),(0,p_.buildValuesAndSeparateKeysToObjectUnmapper)(n,f_))};const s_=so,o_=Jp,a_=Df,u_=Ed,c_=no,l_=Jv,p_=Yv,f_=Symbol("no-key");Object.defineProperty(Kv,"__esModule",{value:!0}),Kv.record=function(e,t){const r=void 0===t||void 0===t.noNullPrototype||t.noNullPrototype;if(null==t)return(0,h_.buildPartialRecordArbitrary)(e,void 0,r);if("withDeletedKeys"in t&&"requiredKeys"in t)throw Error("requiredKeys and withDeletedKeys cannot be used together in fc.record");if(!("requiredKeys"in t&&void 0!==t.requiredKeys||"withDeletedKeys"in t&&t.withDeletedKeys))return(0,h_.buildPartialRecordArbitrary)(e,void 0,r);const n=("requiredKeys"in t?t.requiredKeys:void 0)||[];for(let t=0;t!==n.length;++t){const r=Object.getOwnPropertyDescriptor(e,n[t]);if(void 0===r)throw Error("requiredKeys cannot reference keys that have not been defined in recordModel");if(!r.enumerable)throw Error("requiredKeys cannot reference keys that have are enumerable in recordModel")}return(0,h_.buildPartialRecordArbitrary)(e,n,r)};const h_=Gv;var d_={},m_={};Object.defineProperty(m_,"__esModule",{value:!0}),m_.StreamArbitrary=void 0;const g_=zs,y_=Hs,b_=Js,S_=qs,v_=so,__=cc,w_=Object.defineProperties;function prettyPrint(e){return`Stream(${(0,v_.safeJoin)(e,",")}\u2026)`}class StreamArbitrary extends g_.Arbitrary{constructor(e){super(),this.arb=e}generate(e,t){const r=void 0!==t&&1===e.nextInt(1,t)?t:void 0,enrichedProducer=()=>{const t=[],n=new S_.Stream(function*(e,n){for(;;){const i=e.generate(n,r).value;(0,v_.safePush)(t,i),yield i}}(this.arb,e.clone()));return w_(n,{toString:{value:()=>prettyPrint(t.map(__.stringify))},[__.toStringMethod]:{value:()=>prettyPrint(t.map(__.stringify))},[__.asyncToStringMethod]:{value:async()=>prettyPrint(await Promise.all(t.map(__.asyncStringify)))},[b_.cloneMethod]:{value:enrichedProducer,enumerable:!0}})};return new y_.Value(enrichedProducer(),void 0)}canShrinkWithoutContext(e){return!1}shrink(e,t){return S_.Stream.nil()}}m_.StreamArbitrary=StreamArbitrary,Object.defineProperty(d_,"__esModule",{value:!0}),d_.infiniteStream=function(e){return new k_.StreamArbitrary(e)};const k_=m_;var x_={};Object.defineProperty(x_,"__esModule",{value:!0}),x_.asciiString=function(e={}){const t=(0,T_.ascii)(),r=(0,E_.createSlicesForStringLegacy)(t,O_.codePointsToStringUnmapper),n=A_(A_({},e),{experimentalCustomSlices:r});return(0,I_.array)(t,n).map(O_.codePointsToStringMapper,O_.codePointsToStringUnmapper)};const I_=El,T_=pf,O_=Ny,E_=Pd,A_=Object.assign;var C_={},M_={};Object.defineProperty(M_,"__esModule",{value:!0}),M_.stringToBase64Mapper=function(e){switch(e.length%4){case 0:return e;case 3:return e+"=";case 2:return e+"==";default:return(0,F_.safeSubstring)(e,1)}},M_.stringToBase64Unmapper=function(e){if("string"!=typeof e||e.length%4!=0)throw Error("Invalid string received");const t=e.indexOf("=");if(-1===t)return e;if(e.length-t>2)throw Error("Cannot unmap the passed value");return(0,F_.safeSubstring)(e,0,t)};const F_=so;Object.defineProperty(C_,"__esModule",{value:!0}),C_.base64String=function(e={}){const{minLength:t=0,maxLength:r=j_.MaxLengthUpperBound,size:n}=e,i=t+3-(t+3)%4,s=r-r%4,o=void 0===e.maxLength&&void 0===n?"=":n;if(i>s)throw Error("Minimal length should be inferior or equal to maximal length");if(i%4!=0)throw Error("Minimal length of base64 strings must be a multiple of 4");if(s%4!=0)throw Error("Maximal length of base64 strings must be a multiple of 4");const a=(0,N_.base64)(),u={minLength:i,maxLength:s,size:o,experimentalCustomSlices:(0,L_.createSlicesForStringLegacy)(a,R_.codePointsToStringUnmapper)};return(0,P_.array)(a,u).map(R_.codePointsToStringMapper,R_.codePointsToStringUnmapper).map(D_.stringToBase64Mapper,D_.stringToBase64Unmapper)};const P_=El,N_=vf,j_=wp,R_=Ny,D_=M_,L_=Pd;var U_={},$_={};Object.defineProperty($_,"__esModule",{value:!0}),$_.charsToStringMapper=function(e){return(0,B_.safeJoin)(e,"")},$_.charsToStringUnmapper=function(e){if("string"!=typeof e)throw Error("Cannot unmap the passed value");return(0,B_.safeSplit)(e,"")};const B_=so;Object.defineProperty(U_,"__esModule",{value:!0}),U_.string16bits=function(e={}){const t=(0,q_.char16bits)(),r=(0,V_.createSlicesForStringLegacy)(t,W_.charsToStringUnmapper),n=K_(K_({},e),{experimentalCustomSlices:r});return(0,z_.array)(t,n).map(W_.charsToStringMapper,W_.charsToStringUnmapper)};const z_=El,q_=xf,W_=$_,V_=Pd,K_=Object.assign;var G_={};Object.defineProperty(G_,"__esModule",{value:!0}),G_.stringOf=function(e,t={}){const r=(0,H_.patternsToStringUnmapperFor)(e,t),n=(0,Z_.createSlicesForStringLegacy)(e,r),i=Q_(Q_({},t),{experimentalCustomSlices:n});return(0,J_.array)(e,i).map(H_.patternsToStringMapper,r)};const J_=El,H_=Nd,Z_=Pd,Q_=Object.assign;var Y_={},X_={},ew={};Object.defineProperty(ew,"__esModule",{value:!0}),ew.isSubarrayOf=function(e,t){const r=new tw.Map;let n=0;for(const t of e)if(rw(t,-0))++n;else{const e=(0,tw.safeMapGet)(r,t)||0;(0,tw.safeMapSet)(r,t,e+1)}for(let e=0;e!==t.length;++e){if(!(e in t))return!1;const i=t[e];if(rw(i,-0)){if(0===n)return!1;--n}else{const e=(0,tw.safeMapGet)(r,i)||0;if(0===e)return!1;(0,tw.safeMapSet)(r,i,e-1)}}return!0};const tw=so,rw=Object.is;Object.defineProperty(X_,"__esModule",{value:!0}),X_.SubarrayArbitrary=void 0;const nw=zs,iw=Hs,sw=fa,ow=qs,aw=so,uw=ew,cw=Ml,lw=Math.floor,pw=Math.log,fw=Array.isArray;class SubarrayArbitrary extends nw.Arbitrary{constructor(e,t,r,n){if(super(),this.originalArray=e,this.isOrdered=t,this.minLength=r,this.maxLength=n,r<0||r>e.length)throw Error("fc.*{s|S}ubarrayOf expects the minimal length to be between 0 and the size of the original array");if(n<0||n>e.length)throw Error("fc.*{s|S}ubarrayOf expects the maximal length to be between 0 and the size of the original array");if(r>n)throw Error("fc.*{s|S}ubarrayOf expects the minimal length to be inferior or equal to the maximal length");this.lengthArb=new cw.IntegerArbitrary(r,n),this.biasedLengthArb=r!==n?new cw.IntegerArbitrary(r,r+lw(pw(n-r)/pw(2))):this.lengthArb}generate(e,t){const r=(void 0!==t&&1===e.nextInt(1,t)?this.biasedLengthArb:this.lengthArb).generate(e,void 0),n=r.value,i=(0,aw.safeMap)(this.originalArray,(e,t)=>t),s=[];for(let t=0;t!==n;++t){const t=e.nextInt(0,i.length-1);(0,aw.safePush)(s,i[t]),(0,aw.safeSplice)(i,t,1)}return this.isOrdered&&(0,aw.safeSort)(s,(e,t)=>e-t),new iw.Value((0,aw.safeMap)(s,e=>this.originalArray[e]),r.context)}canShrinkWithoutContext(e){return!!fw(e)&&!!this.lengthArb.canShrinkWithoutContext(e.length)&&(0,uw.isSubarrayOf)(this.originalArray,e)}shrink(e,t){return 0===e.length?ow.Stream.nil():this.lengthArb.shrink(e.length,t).map(t=>new iw.Value((0,aw.safeSlice)(e,e.length-t.value),t.context)).join(e.length>this.minLength?(0,sw.makeLazy)(()=>this.shrink((0,aw.safeSlice)(e,1),void 0).filter(e=>this.minLength<=e.value.length+1).map(t=>new iw.Value([e[0],...t.value],void 0))):ow.Stream.nil())}}X_.SubarrayArbitrary=SubarrayArbitrary,Object.defineProperty(Y_,"__esModule",{value:!0}),Y_.subarray=function(e,t={}){const{minLength:r=0,maxLength:n=e.length}=t;return new hw.SubarrayArbitrary(e,!0,r,n)};const hw=X_;var dw={};Object.defineProperty(dw,"__esModule",{value:!0}),dw.shuffledSubarray=function(e,t={}){const{minLength:r=0,maxLength:n=e.length}=t;return new mw.SubarrayArbitrary(e,!1,r,n)};const mw=X_;var gw={},yw={};Object.defineProperty(yw,"__esModule",{value:!0}),yw.uintToBase32StringMapper=uintToBase32StringMapper,yw.paddedUintToBase32StringMapper=function(e){return function(t){return uintToBase32StringMapper(t,e)}},yw.uintToBase32StringUnmapper=function(e){if("string"!=typeof e)throw new bw.Error("Unsupported type");let t=0,r=1;for(let n=e.length-1;n>=0;--n){const i=e[n],s=vw[i];if(void 0===s)throw new bw.Error("Unsupported type");t+=s*r,r*=32}return t};const bw=so,Sw={10:"A",11:"B",12:"C",13:"D",14:"E",15:"F",16:"G",17:"H",18:"J",19:"K",20:"M",21:"N",22:"P",23:"Q",24:"R",25:"S",26:"T",27:"V",28:"W",29:"X",30:"Y",31:"Z"},vw={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,A:10,B:11,C:12,D:13,E:14,F:15,G:16,H:17,J:18,K:19,M:20,N:21,P:22,Q:23,R:24,S:25,T:26,V:27,W:28,X:29,Y:30,Z:31};function encodeSymbol$1(e){return e<10?(0,bw.String)(e):Sw[e]}function pad(e,t){let r="";for(;e.length+r.length<t;)r+="0";return r+e}function smallUintToBase32StringMapper(e){let t="";for(let r=e;0!==r;){const e=r>>5;t=encodeSymbol$1(r-(e<<5))+t,r=e}return t}function uintToBase32StringMapper(e,t){const r=1073741823&e;return pad(smallUintToBase32StringMapper(~~(e/1073741824)),t-6)+pad(smallUintToBase32StringMapper(r),6)}Object.defineProperty(gw,"__esModule",{value:!0}),gw.ulid=function(){const e=(0,ww.integer)({min:0,max:0xffffffffffff}),t=(0,ww.integer)({min:0,max:0xffffffffff}),r=(0,ww.integer)({min:0,max:0xffffffffff});return(0,_w.tuple)(e,t,r).map(ulidMapper,ulidUnmapper)};const _w=no,ww=Cl,kw=yw,xw=(0,kw.paddedUintToBase32StringMapper)(10),Iw=(0,kw.paddedUintToBase32StringMapper)(8);function ulidMapper(e){return xw(e[0])+Iw(e[1])+Iw(e[2])}function ulidUnmapper(e){if("string"!=typeof e||26!==e.length)throw Error("Unsupported type");return[(0,kw.uintToBase32StringUnmapper)(e.slice(0,10)),(0,kw.uintToBase32StringUnmapper)(e.slice(10,18)),(0,kw.uintToBase32StringUnmapper)(e.slice(18))]}var Tw={},Ow={},Ew={};Object.defineProperty(Ew,"__esModule",{value:!0}),Ew.numberToPaddedEightMapper=numberToPaddedEightMapper,Ew.numberToPaddedEightUnmapper=function(e){if("string"!=typeof e)throw Error("Unsupported type");if(8!==e.length)throw Error("Unsupported value: invalid length");const t=parseInt(e,16);if(e!==numberToPaddedEightMapper(t))throw Error("Unsupported value: invalid content");return t};const Aw=so;function numberToPaddedEightMapper(e){return(0,Aw.safePadStart)((0,Aw.safeNumberToString)(e,16),8,"0")}Object.defineProperty(Ow,"__esModule",{value:!0}),Ow.buildPaddedNumberArbitrary=function(e,t){return(0,Cw.integer)({min:e,max:t}).map(Mw.numberToPaddedEightMapper,Mw.numberToPaddedEightUnmapper)};const Cw=Cl,Mw=Ew;var Fw={};Object.defineProperty(Fw,"__esModule",{value:!0}),Fw.paddedEightsToUuidMapper=function(e){return`${e[0]}-${(0,Pw.safeSubstring)(e[1],4)}-${(0,Pw.safeSubstring)(e[1],0,4)}-${(0,Pw.safeSubstring)(e[2],0,4)}-${(0,Pw.safeSubstring)(e[2],4)}${e[3]}`},Fw.paddedEightsToUuidUnmapper=function(e){if("string"!=typeof e)throw Error("Unsupported type");const t=Nw.exec(e);if(null===t)throw Error("Unsupported type");return[t[1],t[3]+t[2],t[4]+(0,Pw.safeSubstring)(t[5],0,4),(0,Pw.safeSubstring)(t[5],4)]};const Pw=so,Nw=/^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/;var jw={};Object.defineProperty(jw,"__esModule",{value:!0}),jw.buildVersionsAppliersForUuid=function(e){const t={},r={};for(let n=0;n!==e.length;++n){const i=Dw[n],s=Dw[e[n]];t[i]=s,r[s]=i}return{versionsApplierMapper:function(e){return t[e[0]]+(0,Rw.safeSubstring)(e,1)},versionsApplierUnmapper:function(e){if("string"!=typeof e)throw new Rw.Error("Cannot produce non-string values");const t=r[e[0]];if(void 0===t)throw new Rw.Error("Cannot produce strings not starting by the version in hexa code");return t+(0,Rw.safeSubstring)(e,1)}}};const Rw=so,Dw="0123456789abcdef";Object.defineProperty(Tw,"__esModule",{value:!0}),Tw.uuid=function(e={}){const t=(0,Uw.buildPaddedNumberArbitrary)(0,4294967295),r=void 0!==e.version?"number"==typeof e.version?[e.version]:e.version:[1,2,3,4,5];!function(e){const t={};for(const r of e){if(t[r])throw new Bw.Error(`Version ${r} has been requested at least twice for uuid`);if(t[r]=!0,r<1||r>15)throw new Bw.Error("Version must be a value in [1-15] for uuid, but received "+r);if(~~r!==r)throw new Bw.Error("Version must be an integer value for uuid, but received "+r)}if(0===e.length)throw new Bw.Error("Must provide at least one version for uuid")}(r);const{versionsApplierMapper:n,versionsApplierUnmapper:i}=(0,zw.buildVersionsAppliersForUuid)(r),s=(0,Uw.buildPaddedNumberArbitrary)(0,268435456*r.length-1).map(n,i),o=(0,Uw.buildPaddedNumberArbitrary)(2147483648,3221225471);return(0,Lw.tuple)(t,s,o,t).map($w.paddedEightsToUuidMapper,$w.paddedEightsToUuidUnmapper)};const Lw=no,Uw=Ow,$w=Fw,Bw=so,zw=jw;var qw={};Object.defineProperty(qw,"__esModule",{value:!0}),qw.uuidV=function(e){const t=(0,Vw.buildPaddedNumberArbitrary)(0,4294967295),r=268435456*e,n=(0,Vw.buildPaddedNumberArbitrary)(r,r+268435455),i=(0,Vw.buildPaddedNumberArbitrary)(2147483648,3221225471);return(0,Ww.tuple)(t,n,i,t).map(Kw.paddedEightsToUuidMapper,Kw.paddedEightsToUuidUnmapper)};const Ww=no,Vw=Ow,Kw=Fw;var Gw={};Object.defineProperty(Gw,"__esModule",{value:!0}),Gw.webAuthority=function(e){const t=e||{},r=t.size,n=[(0,Zw.domain)({size:r}),...!0===t.withIPv4?[(0,Qw.ipV4)()]:[],...!0===t.withIPv6?[(0,Xw.ipV6)().map(bracketedMapper,bracketedUnmapper)]:[],...!0===t.withIPv4Extended?[(0,Yw.ipV4Extended)()]:[]];return(0,ik.tuple)(!0===t.withUserInfo?(0,rk.option)(function(e){return(0,nk.string)({unit:(0,Jw.getOrCreateAlphaNumericPercentArbitrary)("-._~!$&'()*+,;=:"),size:e})}(r)):(0,Hw.constant)(null),(0,tk.oneof)(...n),!0===t.withPort?(0,rk.option)((0,ek.nat)(65535)):(0,Hw.constant)(null)).map(userHostPortMapper,userHostPortUnmapper)};const Jw=Bh,Hw=Df,Zw=Od,Qw=dy,Yw=wy,Xw=Fy,ek=od,tk=zh,rk=Ed,nk=Fd,ik=no;function userHostPortMapper([e,t,r]){return(null===e?"":e+"@")+t+(null===r?"":":"+r)}function userHostPortUnmapper(e){if("string"!=typeof e)throw Error("Unsupported");const t=e.indexOf("@"),r=-1!==t?e.substring(0,t):null,n=/:(\d+)$/.exec(e),i=null!==n?Number(n[1]):null;return[r,null!==n?e.substring(t+1,e.length-n[1].length-1):e.substring(t+1),i]}function bracketedMapper(e){return`[${e}]`}function bracketedUnmapper(e){if("string"!=typeof e||"["!==e[0]||"]"!==e[e.length-1])throw Error("Unsupported");return e.substring(1,e.length-1)}var sk={},ok={};Object.defineProperty(ok,"__esModule",{value:!0}),ok.buildUriQueryOrFragmentArbitrary=function(e){return(0,uk.string)({unit:(0,ak.getOrCreateAlphaNumericPercentArbitrary)("-._~!$&'()*+,;=:@/?"),size:e})};const ak=Bh,uk=Fd;Object.defineProperty(sk,"__esModule",{value:!0}),sk.webFragments=function(e={}){return(0,ck.buildUriQueryOrFragmentArbitrary)(e.size)};const ck=ok;var lk={},pk={},fk={};Object.defineProperty(fk,"__esModule",{value:!0}),fk.webSegment=function(e={}){return(0,dk.string)({unit:(0,hk.getOrCreateAlphaNumericPercentArbitrary)("-._~!$&'()*+,;=:@"),size:e.size})};const hk=Bh,dk=Fd;var mk={};Object.defineProperty(mk,"__esModule",{value:!0}),mk.segmentsToPathMapper=function(e){return(0,gk.safeJoin)((0,gk.safeMap)(e,e=>"/"+e),"")},mk.segmentsToPathUnmapper=function(e){if("string"!=typeof e)throw Error("Incompatible value received: type");if(0!==e.length&&"/"!==e[0])throw Error("Incompatible value received: start");return(0,gk.safeSplice)((0,gk.safeSplit)(e,"/"),1)};const gk=so;Object.defineProperty(pk,"__esModule",{value:!0}),pk.buildUriPathArbitrary=function(e){const[t,r]=function(e){switch(e){case"xsmall":return["xsmall","xsmall"];case"small":return["small","xsmall"];case"medium":return["small","small"];case"large":return["medium","small"];case"xlarge":return["medium","medium"]}}(e);return t===r?buildUriPathArbitraryInternal(t,r):(0,vk.oneof)(buildUriPathArbitraryInternal(t,r),buildUriPathArbitraryInternal(r,t))};const yk=fk,bk=El,Sk=mk,vk=zh;function buildUriPathArbitraryInternal(e,t){return(0,bk.array)((0,yk.webSegment)({size:e}),{size:t}).map(Sk.segmentsToPathMapper,Sk.segmentsToPathUnmapper)}Object.defineProperty(lk,"__esModule",{value:!0}),lk.webPath=function(e){const t=e||{},r=(0,_k.resolveSize)(t.size);return(0,wk.buildUriPathArbitrary)(r)};const _k=wp,wk=pk;var kk={};Object.defineProperty(kk,"__esModule",{value:!0}),kk.webQueryParameters=function(e={}){return(0,xk.buildUriQueryOrFragmentArbitrary)(e.size)};const xk=ok;var Ik={},Tk={};Object.defineProperty(Tk,"__esModule",{value:!0}),Tk.partsToUrlMapper=function(e){const[t,r,n]=e;return`${t}://${r}${n}${null===e[3]?"":"?"+e[3]}${null===e[4]?"":"#"+e[4]}`},Tk.partsToUrlUnmapper=function(e){if("string"!=typeof e)throw Error("Incompatible value received: type");const t=Ok.exec(e);if(null===t)throw Error("Incompatible value received");const r=t[1],n=t[2],i=t[3],s=t[4],o=t[5];return[r,n,i,void 0!==s?s.substring(1):null,void 0!==o?o.substring(1):null]};const Ok=/^([[A-Za-z][A-Za-z0-9+.-]*):\/\/([^/?#]*)([^?#]*)(\?[A-Za-z0-9\-._~!$&'()*+,;=:@/?%]*)?(#[A-Za-z0-9\-._~!$&'()*+,;=:@/?%]*)?$/;Object.defineProperty(Ik,"__esModule",{value:!0}),Ik.webUrl=function(e){const t=e||{},r=(0,Rk.resolveSize)(t.size),n=void 0!==t.authoritySettings&&void 0!==t.authoritySettings.size?(0,Rk.relativeSizeToSize)(t.authoritySettings.size,r):r,i=Lk(Lk({},t.authoritySettings),{size:n}),s=t.validSchemes||["http","https"],o=(0,Ek.constantFrom)(...s),a=(0,Nk.webAuthority)(i);return(0,Mk.tuple)(o,a,(0,Dk.webPath)({size:r}),!0===t.withQueryParameters?(0,Ck.option)((0,Fk.webQueryParameters)({size:r})):(0,Ak.constant)(null),!0===t.withFragments?(0,Ck.option)((0,Pk.webFragments)({size:r})):(0,Ak.constant)(null)).map(jk.partsToUrlMapper,jk.partsToUrlUnmapper)};const Ek=Xp,Ak=Df,Ck=Ed,Mk=no,Fk=kk,Pk=sk,Nk=Gw,jk=Tk,Rk=wp,Dk=lk,Lk=Object.assign;var Uk={},$k={},Bk={};Object.defineProperty(Bk,"__esModule",{value:!0}),Bk.CommandsIterable=void 0;const zk=Js;class CommandsIterable{constructor(e,t){this.commands=e,this.metadataForReplay=t}[Symbol.iterator](){return this.commands[Symbol.iterator]()}[zk.cloneMethod](){return new CommandsIterable(this.commands.map(e=>e.clone()),this.metadataForReplay)}toString(){const e=this.commands.filter(e=>e.hasRan).map(e=>e.toString()).join(","),t=this.metadataForReplay();return 0!==t.length?`${e} /*${t}*/`:e}}Bk.CommandsIterable=CommandsIterable;var qk={};Object.defineProperty(qk,"__esModule",{value:!0}),qk.CommandWrapper=void 0;const Wk=cc,Vk=Js;class CommandWrapper{constructor(e){if(this.cmd=e,this.hasRan=!1,(0,Wk.hasToStringMethod)(e)){const t=e[Wk.toStringMethod];this[Wk.toStringMethod]=function(){return t.call(e)}}if((0,Wk.hasAsyncToStringMethod)(e)){const t=e[Wk.asyncToStringMethod];this[Wk.asyncToStringMethod]=function(){return t.call(e)}}}check(e){return this.cmd.check(e)}run(e,t){return this.hasRan=!0,this.cmd.run(e,t)}clone(){return(0,Vk.hasCloneMethod)(this.cmd)?new CommandWrapper(this.cmd[Vk.cloneMethod]()):new CommandWrapper(this.cmd)}toString(){return this.cmd.toString()}}qk.CommandWrapper=CommandWrapper;var Kk={};Object.defineProperty(Kk,"__esModule",{value:!0}),Kk.ReplayPath=void 0,Kk.ReplayPath=class{static parse(e){const[t,r]=e.split(":"),n=this.parseCounts(t),i=this.parseChanges(r);return this.parseOccurences(n,i)}static stringify(e){const t=this.countOccurences(e);return`${this.stringifyCounts(t)}:${this.stringifyChanges(t)}`}static intToB64(e){return String.fromCharCode(e<26?e+65:e<52?e+97-26:e<62?e+48-52:62===e?43:47)}static b64ToInt(e){return e>="a"?e.charCodeAt(0)-97+26:e>="A"?e.charCodeAt(0)-65:e>="0"?e.charCodeAt(0)-48+52:"+"===e?62:63}static countOccurences(e){return e.reduce((e,t)=>(0===e.length||64===e[e.length-1].count||e[e.length-1].value!==t?e.push({value:t,count:1}):e[e.length-1].count+=1,e),[])}static parseOccurences(e,t){const r=[];for(let n=0;n!==e.length;++n){const i=e[n],s=t[n];for(let e=0;e!==i;++e)r.push(s)}return r}static stringifyChanges(e){let t="";for(let r=0;r<e.length;r+=6){const n=e.slice(r,r+6).reduceRight((e,t)=>2*e+(t.value?1:0),0);t+=this.intToB64(n)}return t}static parseChanges(e){const t=e.split("").map(e=>this.b64ToInt(e)),r=[];for(let e=0;e!==t.length;++e){let n=t[e];for(let e=0;6!==e;++e,n>>=1)r.push(n%2==1)}return r}static stringifyCounts(e){return e.map(({count:e})=>this.intToB64(e-1)).join("")}static parseCounts(e){return e.split("").map(e=>this.b64ToInt(e)+1)}},Object.defineProperty($k,"__esModule",{value:!0}),$k.CommandsArbitrary=void 0;const Gk=zs,Jk=Hs,Hk=Bk,Zk=qk,Qk=Kk,Yk=fa,Xk=qs,ex=zh,tx=hS;class CommandsArbitrary extends Gk.Arbitrary{constructor(e,t,r,n,i){super(),this.sourceReplayPath=n,this.disableReplayLog=i,this.oneCommandArb=(0,ex.oneof)(...e).map(e=>new Zk.CommandWrapper(e)),this.lengthArb=(0,tx.restrictedIntegerArbitraryBuilder)(0,t,r),this.replayPath=[],this.replayPathPosition=0}metadataForReplay(){return this.disableReplayLog?"":"replayPath="+JSON.stringify(Qk.ReplayPath.stringify(this.replayPath))}buildValueFor(e,t){const r=e.map(e=>e.value_),n={shrunkOnce:t,items:e};return new Jk.Value(new Hk.CommandsIterable(r,()=>this.metadataForReplay()),n)}generate(e){const t=this.lengthArb.generate(e,void 0).value,r=Array(t);for(let n=0;n!==t;++n){const t=this.oneCommandArb.generate(e,void 0);r[n]=t}return this.replayPathPosition=0,this.buildValueFor(r,!1)}canShrinkWithoutContext(e){return!1}filterOnExecution(e){const t=[];for(const r of e)r.value_.hasRan?(this.replayPath.push(!0),t.push(r)):this.replayPath.push(!1);return t}filterOnReplay(e){return e.filter((e,t)=>{const r=this.replayPath[this.replayPathPosition+t];if(void 0===r)throw Error("Too short replayPath");if(!r&&e.value_.hasRan)throw Error("Mismatch between replayPath and real execution");return r})}filterForShrinkImpl(e){0===this.replayPathPosition&&(this.replayPath=null!==this.sourceReplayPath?Qk.ReplayPath.parse(this.sourceReplayPath):[]);const t=this.replayPathPosition<this.replayPath.length?this.filterOnReplay(e):this.filterOnExecution(e);return this.replayPathPosition+=e.length,t}shrink(e,t){if(void 0===t)return Xk.Stream.nil();const r=t,n=r.shrunkOnce,i=r.items,s=this.filterForShrinkImpl(i);if(0===s.length)return Xk.Stream.nil();const o=n?Xk.Stream.nil():new Xk.Stream([[]][Symbol.iterator]()),a=[];for(let e=0;e!==s.length;++e)a.push((0,Yk.makeLazy)(()=>{const t=s.slice(0,e);return this.lengthArb.shrink(s.length-1-e,void 0).map(e=>t.concat(s.slice(s.length-(e.value+1))))}));for(let e=0;e!==s.length;++e)a.push((0,Yk.makeLazy)(()=>this.oneCommandArb.shrink(s[e].value_,s[e].context).map(t=>s.slice(0,e).concat([t],s.slice(e+1)))));return o.join(...a).map(e=>this.buildValueFor(e.map(e=>new Jk.Value(e.value_.clone(),e.context)),!0))}}$k.CommandsArbitrary=CommandsArbitrary,Object.defineProperty(Uk,"__esModule",{value:!0}),Uk.commands=function(e,t={}){const{size:r,maxCommands:n=nx.MaxLengthUpperBound,disableReplayLog:i=!1,replayPath:s=null}=t,o=void 0!==t.maxCommands,a=(0,nx.maxGeneratedLengthFromSizeForArbitrary)(r,0,n,o);return new rx.CommandsArbitrary(e,a,n,s,i)};const rx=$k,nx=wp;var ix={},sx={};Object.defineProperty(sx,"__esModule",{value:!0}),sx.scheduleCommands=sx.ScheduledCommand=void 0;class ScheduledCommand{constructor(e,t){this.s=e,this.cmd=t}async check(e){let t=null,r=!1;if((await this.s.scheduleSequence([{label:"check@"+this.cmd.toString(),builder:async()=>{try{r=await Promise.resolve(this.cmd.check(e))}catch(e){throw t=e,e}}}]).task).faulty)throw t;return r}async run(e,t){let r=null;if((await this.s.scheduleSequence([{label:"run@"+this.cmd.toString(),builder:async()=>{try{await this.cmd.run(e,t)}catch(e){throw r=e,e}}}]).task).faulty)throw r}}sx.ScheduledCommand=ScheduledCommand,sx.scheduleCommands=function*(e,t){for(const r of t)yield new ScheduledCommand(e,r)},Object.defineProperty(ix,"__esModule",{value:!0}),ix.modelRun=function(e,t){internalModelRun(e,t)},ix.asyncModelRun=async function(e,t){await internalAsyncModelRun(e,t)},ix.scheduledModelRun=async function(e,t,r){const n=(0,ox.scheduleCommands)(e,r),i=internalAsyncModelRun(t,n,e.schedule(Promise.resolve(),"startModel"));await e.waitFor(i),await e.waitAll()};const ox=sx,genericModelRun=(e,t,r,n,i)=>e.then(e=>{const{model:s,real:o}=e;let a=r;for(const e of t)a=i(a,()=>n(e,s,o));return a}),internalModelRun=(e,t)=>genericModelRun({then:t=>{t(e())}},t,void 0,(e,t,r)=>{e.check(t)&&e.run(t,r)},(e,t)=>t()),internalAsyncModelRun=async(e,t,r=Promise.resolve())=>{const n={then:t=>{const r=e();return(e=>"function"==typeof e.then)(r)?r.then(t):t(r)}};return await genericModelRun(n,t,r,async(e,t,r)=>{await e.check(t)&&await e.run(t,r)},(e,t)=>e.then(t))};var ax={},ux={},cx={};Object.defineProperty(cx,"__esModule",{value:!0}),cx.SchedulerImplem=void 0;const lx=Ag,px=Js,fx=cc,defaultSchedulerAct=e=>e();class SchedulerImplem{constructor(e,t){this.act=e,this.taskSelector=t,this.lastTaskId=0,this.sourceTaskSelector=t.clone(),this.scheduledTasks=[],this.triggeredTasks=[],this.scheduledWatchers=[]}static buildLog(e){return`[task\${${e.taskId}}] ${0!==e.label.length?`${e.schedulingType}::${e.label}`:e.schedulingType} ${e.status}${void 0!==e.outputValue?" with value "+(0,lx.escapeForTemplateString)(e.outputValue):""}`}log(e,t,r,n,i,s){this.triggeredTasks.push({status:i,schedulingType:e,taskId:t,label:r,metadata:n,outputValue:void 0!==s?(0,fx.stringify)(s):void 0})}scheduleInternal(e,t,r,n,i,s){let o=null;const a=++this.lastTaskId,u=new Promise((i,u)=>{o=()=>{(s?r.then(()=>s()):r).then(r=>(this.log(e,a,t,n,"resolved",r),i(r)),r=>(this.log(e,a,t,n,"rejected",r),u(r)))}});return this.scheduledTasks.push({original:r,scheduled:u,trigger:o,schedulingType:e,taskId:a,label:t,metadata:n,customAct:i}),0!==this.scheduledWatchers.length&&this.scheduledWatchers[0](),u}schedule(e,t,r,n){return this.scheduleInternal("promise",t||"",e,r,n||defaultSchedulerAct)}scheduleFunction(e,t){return(...r)=>this.scheduleInternal("function",`${e.name}(${r.map(fx.stringify).join(",")})`,e(...r),void 0,t||defaultSchedulerAct)}scheduleSequence(e,t){const r={done:!1,faulty:!1},n={then:e=>e()};let resolveSequenceTask=()=>{};const i=new Promise(e=>resolveSequenceTask=e);return e.reduce((e,i)=>{const[s,o,a]="function"==typeof i?[i,i.name,void 0]:[i.builder,i.label,i.metadata];return e.then(()=>{const e=this.scheduleInternal("sequence",o,n,a,t||defaultSchedulerAct,()=>s());return e.catch(()=>{r.faulty=!0,resolveSequenceTask()}),e})},n).then(()=>{r.done=!0,resolveSequenceTask()},()=>{}),Object.assign(r,{task:Promise.resolve(i).then(()=>({done:r.done,faulty:r.faulty}))})}count(){return this.scheduledTasks.length}internalWaitOne(){if(0===this.scheduledTasks.length)throw Error("No task scheduled");const e=this.taskSelector.nextTaskIndex(this.scheduledTasks),[t]=this.scheduledTasks.splice(e,1);return t.customAct(async()=>{t.trigger();try{await t.scheduled}catch(e){}})}async waitOne(e){const t=e||defaultSchedulerAct;await this.act(()=>t(async()=>await this.internalWaitOne()))}async waitAll(e){for(;this.scheduledTasks.length>0;)await this.waitOne(e)}async waitFor(e,t){let r=!1,n=null;const awaiter=async()=>{for(;!r&&this.scheduledTasks.length>0;)await this.waitOne(t);n=null},handleNotified=()=>{null===n&&(n=Promise.resolve().then(awaiter))},clearAndReplaceWatcher=()=>{const e=this.scheduledWatchers.indexOf(handleNotified);-1!==e&&this.scheduledWatchers.splice(e,1),0===e&&0!==this.scheduledWatchers.length&&this.scheduledWatchers[0]()},i=e.then(e=>(r=!0,null===n?(clearAndReplaceWatcher(),e):n.then(()=>(clearAndReplaceWatcher(),e))),e=>{if(r=!0,null===n)throw clearAndReplaceWatcher(),e;return n.then(()=>{throw clearAndReplaceWatcher(),e})});return this.scheduledTasks.length>0&&0===this.scheduledWatchers.length&&handleNotified(),this.scheduledWatchers.push(handleNotified),i}report(){return[...this.triggeredTasks,...this.scheduledTasks.map(e=>({status:"pending",schedulingType:e.schedulingType,taskId:e.taskId,label:e.label,metadata:e.metadata}))]}toString(){return"schedulerFor()`\n"+this.report().map(SchedulerImplem.buildLog).map(e=>"-> "+e).join("\n")+"`"}[px.cloneMethod](){return new SchedulerImplem(this.act,this.sourceTaskSelector)}}cx.SchedulerImplem=SchedulerImplem,Object.defineProperty(ux,"__esModule",{value:!0}),ux.buildSchedulerFor=function(e,t){return new hx.SchedulerImplem(e,buildNextTaskIndex$1(t))};const hx=cx;function buildNextTaskIndex$1(e){let t=0;return{clone:()=>buildNextTaskIndex$1(e),nextTaskIndex:r=>{if(e.length<=t)throw Error("Invalid schedulerFor defined: too many tasks have been scheduled");const n=r.findIndex(r=>r.taskId===e[t]);if(-1===n)throw Error("Invalid schedulerFor defined: unable to find next task");return++t,n}}}var dx={};Object.defineProperty(dx,"__esModule",{value:!0}),dx.SchedulerArbitrary=void 0;const mx=zs,gx=Hs,yx=qs,bx=cx;function buildNextTaskIndex(e){const t=e.clone();return{clone:()=>buildNextTaskIndex(t),nextTaskIndex:t=>e.nextInt(0,t.length-1)}}class SchedulerArbitrary extends mx.Arbitrary{constructor(e){super(),this.act=e}generate(e,t){return new gx.Value(new bx.SchedulerImplem(this.act,buildNextTaskIndex(e.clone())),void 0)}canShrinkWithoutContext(e){return!1}shrink(e,t){return yx.Stream.nil()}}dx.SchedulerArbitrary=SchedulerArbitrary,Object.defineProperty(ax,"__esModule",{value:!0}),ax.scheduler=function(e){const{act:t=e=>e()}=e||{};return new vx.SchedulerArbitrary(t)},ax.schedulerFor=function(e,t){const{act:r=e=>e()}=Array.isArray(e)?t||{}:e||{};return Array.isArray(e)?(0,Sx.buildSchedulerFor)(r,e):function(e,...t){return(0,Sx.buildSchedulerFor)(r,t)}};const Sx=ux,vx=dx;var _x={};Object.defineProperty(_x,"__esModule",{value:!0}),_x.bigInt64Array=function(e={}){return(0,xx.typedIntArrayArbitraryArbitraryBuilder)(e,(0,wx.BigInt)("-9223372036854775808"),(0,wx.BigInt)("9223372036854775807"),wx.BigInt64Array,kx.bigInt)};const wx=so,kx=Ip,xx=Rb;var Ix={};Object.defineProperty(Ix,"__esModule",{value:!0}),Ix.bigUint64Array=function(e={}){return(0,Ex.typedIntArrayArbitraryArbitraryBuilder)(e,(0,Tx.BigInt)(0),(0,Tx.BigInt)("18446744073709551615"),Tx.BigUint64Array,Ox.bigInt)};const Tx=so,Ox=Ip,Ex=Rb;var Ax={},Cx={};Object.defineProperty(Cx,"__esModule",{value:!0}),Cx.addMissingDotStar=function(e){return addMissingDotStarTraversalAddMissing(e,!0,!0)};const Mx=cc;function addMissingDotStarTraversalAddMissing(e,t,r){if(!t&&!r)return e;const n={hasStart:!1,hasEnd:!1},i=addMissingDotStarTraversal(e,t,r,n),s=t&&!n.hasStart,o=r&&!n.hasEnd;if(!s&&!o)return i;const a=[];return s&&(a.push({type:"Assertion",kind:"^"}),a.push({type:"Repetition",quantifier:{type:"Quantifier",kind:"*",greedy:!0},expression:{type:"Char",kind:"meta",symbol:".",value:".",codePoint:NaN}})),a.push(i),o&&(a.push({type:"Repetition",quantifier:{type:"Quantifier",kind:"*",greedy:!0},expression:{type:"Char",kind:"meta",symbol:".",value:".",codePoint:NaN}}),a.push({type:"Assertion",kind:"$"})),{type:"Group",capturing:!1,expression:{type:"Alternative",expressions:a}}}function addMissingDotStarTraversal(e,t,r,n){switch(e.type){case"Char":case"Repetition":case"CharacterClass":case"ClassRange":case"Backreference":return e;case"Quantifier":throw Error("Wrongly defined AST tree, Quantifier nodes not supposed to be scanned!");case"Alternative":return n.hasStart=!0,n.hasEnd=!0,Object.assign(Object.assign({},e),{expressions:e.expressions.map((n,i)=>addMissingDotStarTraversalAddMissing(n,t&&0===i,r&&i===e.expressions.length-1))});case"Group":return Object.assign(Object.assign({},e),{expression:addMissingDotStarTraversal(e.expression,t,r,n)});case"Disjunction":return n.hasStart=!0,n.hasEnd=!0,Object.assign(Object.assign({},e),{left:null!==e.left?addMissingDotStarTraversalAddMissing(e.left,t,r):null,right:null!==e.right?addMissingDotStarTraversalAddMissing(e.right,t,r):null});case"Assertion":if("^"===e.kind||"Lookahead"===e.kind)return n.hasStart=!0,e;if("$"===e.kind||"Lookbehind"===e.kind)return n.hasEnd=!0,e;throw Error(`Assertions of kind ${e.kind} not implemented yet!`);default:throw function(e){return Error("Unsupported AST node! Received: "+(0,Mx.stringify)(e))}(e)}}var Fx,Px={},Nx={};function charSizeAt(e,t){return e[t]>="\ud800"&&e[t]<="\udbff"&&e[t+1]>="\udc00"&&e[t+1]<="\udfff"?2:1}function isHexaDigit(e){return e>="0"&&e<="9"||e>="a"&&e<="f"||e>="A"&&e<="F"}function isDigit$1(e){return e>="0"&&e<="9"}function squaredBracketBlockContentEndFrom(e,t){for(let r=t;r!==e.length;++r){const t=e[r];if("\\"===t)r+=1;else if("]"===t)return r}throw Error("Missing closing ']'")}Object.defineProperty(Nx,"__esModule",{value:!0}),Nx.TokenizerBlockMode=void 0,Nx.readFrom=function(e,t,r,n){const i=function(e,t,r,n){switch(e[t]){case"[":return n===Fx.Character?t+1:squaredBracketBlockContentEndFrom(e,t+1)+1;case"{":{if(n===Fx.Character)return t+1;const r=function(e,t){let r=!1;for(let n=t;n!==e.length;++n){const i=e[n];if(isDigit$1(i));else{if(t===n)return-1;if(","!==i)return"}"===i?n:-1;if(r)return-1;r=!0}}return-1}(e,t+1);return-1===r?t+1:r+1}case"(":return n===Fx.Character?t+1:function(e,t){let r=0;for(let n=t;n!==e.length;++n){const t=e[n];if("\\"===t)n+=1;else if(")"===t){if(0===r)return n;r-=1}else"["===t?n=squaredBracketBlockContentEndFrom(e,n):"("===t&&(r+=1)}throw Error("Missing closing ')'")}(e,t+1)+1;case"]":case"}":case")":return t+1;case"\\":{const n=e[t+1];switch(n){case"x":if(isHexaDigit(e[t+2])&&isHexaDigit(e[t+3]))return t+4;throw Error(`Unexpected token '${e.substring(t,t+4)}' found`);case"u":if("{"===e[t+2]){if(!r)return t+2;if("}"===e[t+4]){if(isHexaDigit(e[t+3]))return t+5;throw Error(`Unexpected token '${e.substring(t,t+5)}' found`)}if("}"===e[t+5]){if(isHexaDigit(e[t+3])&&isHexaDigit(e[t+4]))return t+6;throw Error(`Unexpected token '${e.substring(t,t+6)}' found`)}if("}"===e[t+6]){if(isHexaDigit(e[t+3])&&isHexaDigit(e[t+4])&&isHexaDigit(e[t+5]))return t+7;throw Error(`Unexpected token '${e.substring(t,t+7)}' found`)}if("}"===e[t+7]){if(isHexaDigit(e[t+3])&&isHexaDigit(e[t+4])&&isHexaDigit(e[t+5])&&isHexaDigit(e[t+6]))return t+8;throw Error(`Unexpected token '${e.substring(t,t+8)}' found`)}if("}"===e[t+8]&&isHexaDigit(e[t+3])&&isHexaDigit(e[t+4])&&isHexaDigit(e[t+5])&&isHexaDigit(e[t+6])&&isHexaDigit(e[t+7]))return t+9;throw Error(`Unexpected token '${e.substring(t,t+9)}' found`)}if(isHexaDigit(e[t+2])&&isHexaDigit(e[t+3])&&isHexaDigit(e[t+4])&&isHexaDigit(e[t+5]))return t+6;throw Error(`Unexpected token '${e.substring(t,t+6)}' found`);case"p":case"P":{if(!r)return t+2;let n=t+2;for(;n<e.length&&"}"!==e[n];n+="\\"===e[n]?2:1);if("}"!==e[n])throw Error("Invalid \\P definition");return n+1}case"k":{let n=t+2;for(;n<e.length&&">"!==e[n];++n);if(">"!==e[n]){if(!r)return t+2;throw Error("Invalid \\k definition")}return n+1}default:if(isDigit$1(n)){const n=r?e.length:Math.min(t+4,e.length);let i=t+2;for(;i<n&&isDigit$1(e[i]);++i);return i}return t+(r?charSizeAt(e,t+1):1)+1}}default:return t+(r?charSizeAt(e,t):1)}}(e,t,r,n);return e.substring(t,i)},function(e){e[e.Full=0]="Full",e[e.Character=1]="Character"}(Fx||(Nx.TokenizerBlockMode=Fx={})),Object.defineProperty(Px,"__esModule",{value:!0}),Px.tokenizeRegex=function(e){const t=-1!==(0,jx.safeIndexOf)([...e.flags],"u"),r=[];return pushTokens(r,e.source,t,{lastIndex:0,named:new Map}),toSingleToken(r)};const jx=so,Rx=Nx,Dx=String.fromCodePoint;function safePop(e){const t=e.pop();if(void 0===t)throw Error("Unable to extract token preceeding the currently parsed one");return t}function isDigit(e){return e>="0"&&e<="9"}function simpleChar(e,t){return{type:"Char",kind:"simple",symbol:e,value:e,codePoint:e.codePointAt(0)||-1,escaped:t}}function metaEscapedChar(e,t){return{type:"Char",kind:"meta",symbol:t,value:e,codePoint:t.codePointAt(0)||-1}}function toSingleToken(e,t){if(e.length>1)return{type:"Alternative",expressions:e};if(!t&&0===e.length)throw Error("Unsupported no token");return e[0]}function blockToCharToken(e){if("\\"===e[0]){const t=e[1];switch(t){case"x":{const t=e.substring(2),r=Number.parseInt(t,16);return{type:"Char",kind:"hex",symbol:Dx(r),value:e,codePoint:r}}case"u":{if("\\u"===e)return simpleChar("u",!0);const t="{"===e[2]?e.substring(3,e.length-1):e.substring(2),r=Number.parseInt(t,16);return{type:"Char",kind:"unicode",symbol:Dx(r),value:e,codePoint:r}}case"0":return metaEscapedChar(e,"\0");case"n":return metaEscapedChar(e,"\n");case"f":return metaEscapedChar(e,"\f");case"r":return metaEscapedChar(e,"\r");case"t":return metaEscapedChar(e,"\t");case"v":return metaEscapedChar(e,"\v");case"w":case"W":case"d":case"D":case"s":case"S":case"b":case"B":return{type:"Char",kind:"meta",symbol:void 0,value:e,codePoint:NaN};default:if(isDigit(t)){const t=e.substring(1),r=Number(t);return{type:"Char",kind:"decimal",symbol:Dx(r),value:e,codePoint:r}}if(e.length>2&&("p"===t||"P"===t))throw Error("UnicodeProperty not implemented yet!");return simpleChar(e.substring(1),!0)}}return simpleChar(e)}function pushTokens(e,t,r,n){let i=null;for(let s=0,o=(0,Rx.readFrom)(t,s,r,Rx.TokenizerBlockMode.Full);s!==t.length;s+=o.length,o=(0,Rx.readFrom)(t,s,r,Rx.TokenizerBlockMode.Full)){const t=o[0];switch(t){case"|":null===i&&(i=[]),i.push(toSingleToken(e.splice(0),!0)||null);break;case".":e.push({type:"Char",kind:"meta",symbol:o,value:o,codePoint:NaN});break;case"*":case"+":{const r=safePop(e);e.push({type:"Repetition",expression:r,quantifier:{type:"Quantifier",kind:t,greedy:!0}});break}case"?":{const r=safePop(e);"Repetition"===r.type?(r.quantifier.greedy=!1,e.push(r)):e.push({type:"Repetition",expression:r,quantifier:{type:"Quantifier",kind:t,greedy:!0}});break}case"{":{if("{"===o){e.push(simpleChar(o));break}const t=safePop(e),r=o.substring(1,o.length-1).split(","),n=Number(r[0]),i=1===r.length?n:0!==r[1].length?Number(r[1]):void 0;e.push({type:"Repetition",expression:t,quantifier:{type:"Quantifier",kind:"Range",greedy:!0,from:n,to:i}});break}case"[":{const t=o.substring(1,o.length-1),n=[];let i,s=!1;for(let e=0,o=(0,Rx.readFrom)(t,e,r,Rx.TokenizerBlockMode.Character);e!==t.length;e+=o.length,o=(0,Rx.readFrom)(t,e,r,Rx.TokenizerBlockMode.Character)){if(0===e&&"^"===o){i=!0;continue}const t=blockToCharToken(o);if("-"===o)n.push(t),s=!0;else{const e=n.length>=2?n[n.length-2]:void 0;s&&void 0!==e&&"Char"===e.type?(n.pop(),n.pop(),n.push({type:"ClassRange",from:e,to:t})):n.push(t),s=!1}}e.push({type:"CharacterClass",expressions:n,negative:i});break}case"(":{const t=o.substring(1,o.length-1),i=[];if("?"===t[0])if(":"===t[1])pushTokens(i,t.substring(2),r,n),e.push({type:"Group",capturing:!1,expression:toSingleToken(i)});else if("="===t[1]||"!"===t[1])pushTokens(i,t.substring(2),r,n),e.push({type:"Assertion",kind:"Lookahead",negative:"!"===t[1]||void 0,assertion:toSingleToken(i)});else if("<"!==t[1]||"="!==t[2]&&"!"!==t[2]){const s=t.split(">");if(s.length<2||"<"!==s[0][1])throw Error("Unsupported regex content found at "+JSON.stringify(o));const a=++n.lastIndex,u=s[0].substring(2);n.named.set(u,a),pushTokens(i,s.slice(1).join(">"),r,n),e.push({type:"Group",capturing:!0,nameRaw:u,name:u,number:a,expression:toSingleToken(i)})}else pushTokens(i,t.substring(3),r,n),e.push({type:"Assertion",kind:"Lookbehind",negative:"!"===t[2]||void 0,assertion:toSingleToken(i)});else{const s=++n.lastIndex;pushTokens(i,t,r,n),e.push({type:"Group",capturing:!0,number:s,expression:toSingleToken(i)})}break}default:if("^"===o)e.push({type:"Assertion",kind:o});else if("$"===o)e.push({type:"Assertion",kind:o});else if("\\"===o[0]&&isDigit(o[1])){const t=Number(o.substring(1));r||t<=n.lastIndex?e.push({type:"Backreference",kind:"number",number:t,reference:t}):e.push(blockToCharToken(o))}else if("\\"===o[0]&&"k"===o[1]&&2!==o.length){const t=o.substring(3,o.length-1);e.push({type:"Backreference",kind:"name",number:n.named.get(t)||0,referenceRaw:t,reference:t})}else e.push(blockToCharToken(o))}}if(null!==i){i.push(toSingleToken(e.splice(0),!0)||null);let t={type:"Disjunction",left:i[0],right:i[1]};for(let e=2;e<i.length;++e)t={type:"Disjunction",left:t,right:i[e]};e.push(t)}}Object.defineProperty(Ax,"__esModule",{value:!0}),Ax.stringMatching=function(e,t={}){for(const t of e.flags)if("d"!==t&&"g"!==t&&"m"!==t&&"s"!==t&&"u"!==t)throw new Lx.Error('Unable to use "stringMatching" against a regex using the flag '+t);const r={size:t.size},n={multiline:e.multiline,dotAll:e.dotAll};return toMatchingArbitrary((0,$x.addMissingDotStar)((0,Bx.tokenizeRegex)(e)),r,n)};const Lx=so,Ux=cc,$x=Cx,Bx=Px,zx=wf,qx=Df,Wx=Xp,Vx=Cl,Kx=zh,Gx=G_,Jx=no,Hx=String.fromCodePoint,Zx=[..."abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"],Qx=[..."0123456789"],Yx=[..." \t\r\n\v\f"],Xx=[..."\r\n"],eI=[..."\x1e\x15"],tI=[...Xx,...eI],rI=(0,zx.char)();function raiseUnsupportedASTNode(e){return new Lx.Error("Unsupported AST node! Received: "+(0,Ux.stringify)(e))}function toMatchingArbitrary(e,t,r){switch(e.type){case"Char":if("meta"===e.kind)switch(e.value){case"\\w":return(0,Wx.constantFrom)(...Zx);case"\\W":return rI.filter(e=>-1===(0,Lx.safeIndexOf)(Zx,e));case"\\d":return(0,Wx.constantFrom)(...Qx);case"\\D":return rI.filter(e=>-1===(0,Lx.safeIndexOf)(Qx,e));case"\\s":return(0,Wx.constantFrom)(...Yx);case"\\S":return rI.filter(e=>-1===(0,Lx.safeIndexOf)(Yx,e));case"\\b":case"\\B":throw new Lx.Error(`Meta character ${e.value} not implemented yet!`);case".":{const e=r.dotAll?eI:tI;return rI.filter(t=>-1===(0,Lx.safeIndexOf)(e,t))}}if(void 0===e.symbol)throw new Lx.Error("Unexpected undefined symbol received for non-meta Char! Received: "+(0,Ux.stringify)(e));return(0,qx.constant)(e.symbol);case"Repetition":{const n=toMatchingArbitrary(e.expression,t,r);switch(e.quantifier.kind){case"*":return(0,Gx.stringOf)(n,t);case"+":return(0,Gx.stringOf)(n,Object.assign(Object.assign({},t),{minLength:1}));case"?":return(0,Gx.stringOf)(n,Object.assign(Object.assign({},t),{minLength:0,maxLength:1}));case"Range":return(0,Gx.stringOf)(n,Object.assign(Object.assign({},t),{minLength:e.quantifier.from,maxLength:e.quantifier.to}));default:throw raiseUnsupportedASTNode(e.quantifier)}}case"Quantifier":throw new Lx.Error("Wrongly defined AST tree, Quantifier nodes not supposed to be scanned!");case"Alternative":return(0,Jx.tuple)(...(0,Lx.safeMap)(e.expressions,e=>toMatchingArbitrary(e,t,r))).map(e=>(0,Lx.safeJoin)(e,""));case"CharacterClass":if(e.negative){const n=(0,Lx.safeMap)(e.expressions,e=>toMatchingArbitrary(e,t,r));return rI.filter(e=>(0,Lx.safeEvery)(n,t=>!t.canShrinkWithoutContext(e)))}return(0,Kx.oneof)(...(0,Lx.safeMap)(e.expressions,e=>toMatchingArbitrary(e,t,r)));case"ClassRange":{const t=e.from.codePoint,r=e.to.codePoint;return(0,Vx.integer)({min:t,max:r}).map(e=>Hx(e),e=>{if("string"!=typeof e)throw new Lx.Error("Invalid type");if(1!==[...e].length)throw new Lx.Error("Invalid length");return(0,Lx.safeCharCodeAt)(e,0)})}case"Group":return toMatchingArbitrary(e.expression,t,r);case"Disjunction":{const n=null!==e.left?toMatchingArbitrary(e.left,t,r):(0,qx.constant)(""),i=null!==e.right?toMatchingArbitrary(e.right,t,r):(0,qx.constant)("");return(0,Kx.oneof)(n,i)}case"Assertion":if("^"===e.kind||"$"===e.kind)return r.multiline?"^"===e.kind?(0,Kx.oneof)((0,qx.constant)(""),(0,Jx.tuple)((0,Gx.stringOf)(rI),(0,Wx.constantFrom)(...Xx)).map(e=>`${e[0]}${e[1]}`,e=>{if("string"!=typeof e||0===e.length)throw new Lx.Error("Invalid type");return[(0,Lx.safeSubstring)(e,0,e.length-1),e[e.length-1]]})):(0,Kx.oneof)((0,qx.constant)(""),(0,Jx.tuple)((0,Wx.constantFrom)(...Xx),(0,Gx.stringOf)(rI)).map(e=>`${e[0]}${e[1]}`,e=>{if("string"!=typeof e||0===e.length)throw new Lx.Error("Invalid type");return[e[0],(0,Lx.safeSubstring)(e,1)]})):(0,qx.constant)("");throw new Lx.Error(`Assertions of kind ${e.kind} not implemented yet!`);case"Backreference":throw new Lx.Error("Backreference nodes not implemented yet!");default:throw raiseUnsupportedASTNode(e)}}var nI={},iI={},sI={};function nextZippedValues(e,t){for(let r=0;r!==e.length;++r)t[r]=e[r].next()}function isDoneZippedValues(e){for(let t=0;t!==e.length;++t)if(e[t].done)return!0;return!1}Object.defineProperty(sI,"__esModule",{value:!0}),sI.zipIterableIterators=function*(...e){const t=function(e){const t=[];for(let r=0;r!==e.length;++r)t.push(e[r].next());return t}(e);for(;!isDoneZippedValues(t);)yield t.map(e=>e.value),nextZippedValues(e,t)},Object.defineProperty(iI,"__esModule",{value:!0}),iI.LimitedShrinkArbitrary=void 0;const oI=zs,aI=Hs,uI=qs,cI=sI;class LimitedShrinkArbitrary extends oI.Arbitrary{constructor(e,t){super(),this.arb=e,this.maxShrinks=t}generate(e,t){const r=this.arb.generate(e,t);return this.valueMapper(r,0)}canShrinkWithoutContext(e){return this.arb.canShrinkWithoutContext(e)}shrink(e,t){return this.isSafeContext(t)?this.safeShrink(e,t.originalContext,t.length):this.safeShrink(e,void 0,0)}safeShrink(e,t,r){const n=this.maxShrinks-r;return n<=0?uI.Stream.nil():new uI.Stream((0,cI.zipIterableIterators)(this.arb.shrink(e,t),function*(e){let t=e;for(;;)yield t,++t}(r+1))).take(n).map(e=>this.valueMapper(e[0],e[1]))}valueMapper(e,t){const r={originalContext:e.context,length:t};return new aI.Value(e.value,r)}isSafeContext(e){return null!=e&&"object"==typeof e&&"originalContext"in e&&"length"in e}}iI.LimitedShrinkArbitrary=LimitedShrinkArbitrary,Object.defineProperty(nI,"__esModule",{value:!0}),nI.limitShrink=function(e,t){return new lI.LimitedShrinkArbitrary(e,t)};const lI=iI;!function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.noShrink=e.noBias=e.clone=e.oneof=e.option=e.mapToConstant=e.constantFrom=e.constant=e.lorem=e.limitShrink=e.stringMatching=e.base64String=e.hexaString=e.fullUnicodeString=e.unicodeString=e.stringOf=e.string16bits=e.asciiString=e.string=e.mixedCase=e.base64=e.hexa=e.fullUnicode=e.unicode=e.char16bits=e.ascii=e.char=e.bigUint=e.bigInt=e.bigUintN=e.bigIntN=e.maxSafeNat=e.maxSafeInteger=e.nat=e.integer=e.double=e.float=e.falsy=e.boolean=e.asyncProperty=e.property=e.PreconditionFailure=e.pre=e.assert=e.check=e.statistics=e.sample=e.__commitHash=e.__version=e.__type=void 0,e.modelRun=e.asyncModelRun=e.bigUint64Array=e.bigInt64Array=e.float64Array=e.float32Array=e.uint32Array=e.int32Array=e.uint16Array=e.int16Array=e.uint8ClampedArray=e.uint8Array=e.int8Array=e.uuidV=e.uuid=e.ulid=e.emailAddress=e.webUrl=e.webQueryParameters=e.webPath=e.webFragments=e.webSegment=e.webAuthority=e.domain=e.ipV6=e.ipV4Extended=e.ipV4=e.date=e.gen=e.context=e.func=e.compareFunc=e.compareBooleanFunc=e.memo=e.letrec=e.unicodeJsonValue=e.unicodeJson=e.jsonValue=e.json=e.object=e.anything=e.dictionary=e.record=e.tuple=e.uniqueArray=e.infiniteStream=e.sparseArray=e.array=e.subarray=e.shuffledSubarray=void 0,e.createDepthIdentifier=e.stream=e.Stream=e.Random=e.ExecutionStatus=e.resetConfigureGlobal=e.readConfigureGlobal=e.configureGlobal=e.VerbosityLevel=e.hash=e.asyncDefaultReportMessage=e.defaultReportMessage=e.asyncStringify=e.stringify=e.getDepthContextFor=e.hasAsyncToStringMethod=e.asyncToStringMethod=e.hasToStringMethod=e.toStringMethod=e.hasCloneMethod=e.cloneIfNeeded=e.cloneMethod=e.Value=e.Arbitrary=e.schedulerFor=e.scheduler=e.commands=e.scheduledModelRun=void 0;const t=Ls;Object.defineProperty(e,"pre",{enumerable:!0,get:function(){return t.pre}});const r=Bs;Object.defineProperty(e,"asyncProperty",{enumerable:!0,get:function(){return r.asyncProperty}});const n=qa;Object.defineProperty(e,"property",{enumerable:!0,get:function(){return n.property}});const i=ru;Object.defineProperty(e,"assert",{enumerable:!0,get:function(){return i.assert}}),Object.defineProperty(e,"check",{enumerable:!0,get:function(){return i.check}});const s=el;Object.defineProperty(e,"sample",{enumerable:!0,get:function(){return s.sample}}),Object.defineProperty(e,"statistics",{enumerable:!0,get:function(){return s.statistics}});const o=ul;Object.defineProperty(e,"gen",{enumerable:!0,get:function(){return o.gen}});const a=El;Object.defineProperty(e,"array",{enumerable:!0,get:function(){return a.array}});const u=Ip;Object.defineProperty(e,"bigInt",{enumerable:!0,get:function(){return u.bigInt}});const c=Up;Object.defineProperty(e,"bigIntN",{enumerable:!0,get:function(){return c.bigIntN}});const l=zp;Object.defineProperty(e,"bigUint",{enumerable:!0,get:function(){return l.bigUint}});const p=Vp;Object.defineProperty(e,"bigUintN",{enumerable:!0,get:function(){return p.bigUintN}});const d=Jp;Object.defineProperty(e,"boolean",{enumerable:!0,get:function(){return d.boolean}});const m=Yp;Object.defineProperty(e,"falsy",{enumerable:!0,get:function(){return m.falsy}});const g=pf;Object.defineProperty(e,"ascii",{enumerable:!0,get:function(){return g.ascii}});const y=vf;Object.defineProperty(e,"base64",{enumerable:!0,get:function(){return y.base64}});const b=wf;Object.defineProperty(e,"char",{enumerable:!0,get:function(){return b.char}});const S=xf;Object.defineProperty(e,"char16bits",{enumerable:!0,get:function(){return S.char16bits}});const v=Of;Object.defineProperty(e,"fullUnicode",{enumerable:!0,get:function(){return v.fullUnicode}});const _=Mf;Object.defineProperty(e,"hexa",{enumerable:!0,get:function(){return _.hexa}});const w=Pf;Object.defineProperty(e,"unicode",{enumerable:!0,get:function(){return w.unicode}});const k=Df;Object.defineProperty(e,"constant",{enumerable:!0,get:function(){return k.constant}});const x=Xp;Object.defineProperty(e,"constantFrom",{enumerable:!0,get:function(){return x.constantFrom}});const I=Uf;Object.defineProperty(e,"context",{enumerable:!0,get:function(){return I.context}});const T=zf;Object.defineProperty(e,"date",{enumerable:!0,get:function(){return T.date}});const O=Qf;Object.defineProperty(e,"clone",{enumerable:!0,get:function(){return O.clone}});const E=uh;Object.defineProperty(e,"dictionary",{enumerable:!0,get:function(){return E.dictionary}});const A=$h;Object.defineProperty(e,"emailAddress",{enumerable:!0,get:function(){return A.emailAddress}});const C=Mm;Object.defineProperty(e,"double",{enumerable:!0,get:function(){return C.double}});const M=cg;Object.defineProperty(e,"float",{enumerable:!0,get:function(){return M.float}});const F=Og;Object.defineProperty(e,"compareBooleanFunc",{enumerable:!0,get:function(){return F.compareBooleanFunc}});const P=Kg;Object.defineProperty(e,"compareFunc",{enumerable:!0,get:function(){return P.compareFunc}});const N=Hg;Object.defineProperty(e,"func",{enumerable:!0,get:function(){return N.func}});const j=Od;Object.defineProperty(e,"domain",{enumerable:!0,get:function(){return j.domain}});const R=Cl;Object.defineProperty(e,"integer",{enumerable:!0,get:function(){return R.integer}});const D=ay;Object.defineProperty(e,"maxSafeInteger",{enumerable:!0,get:function(){return D.maxSafeInteger}});const L=py;Object.defineProperty(e,"maxSafeNat",{enumerable:!0,get:function(){return L.maxSafeNat}});const U=od;Object.defineProperty(e,"nat",{enumerable:!0,get:function(){return U.nat}});const $=dy;Object.defineProperty(e,"ipV4",{enumerable:!0,get:function(){return $.ipV4}});const B=wy;Object.defineProperty(e,"ipV4Extended",{enumerable:!0,get:function(){return B.ipV4Extended}});const z=Fy;Object.defineProperty(e,"ipV6",{enumerable:!0,get:function(){return z.ipV6}});const q=Hy;Object.defineProperty(e,"letrec",{enumerable:!0,get:function(){return q.letrec}});const W=tb;Object.defineProperty(e,"lorem",{enumerable:!0,get:function(){return W.lorem}});const V=sd;Object.defineProperty(e,"mapToConstant",{enumerable:!0,get:function(){return V.mapToConstant}});const K=ub;Object.defineProperty(e,"memo",{enumerable:!0,get:function(){return K.memo}});const G=fb;Object.defineProperty(e,"mixedCase",{enumerable:!0,get:function(){return G.mixedCase}});const J=Ib;Object.defineProperty(e,"object",{enumerable:!0,get:function(){return J.object}});const H=vv;Object.defineProperty(e,"json",{enumerable:!0,get:function(){return H.json}});const Z=Tv;Object.defineProperty(e,"anything",{enumerable:!0,get:function(){return Z.anything}});const Q=Nv;Object.defineProperty(e,"unicodeJsonValue",{enumerable:!0,get:function(){return Q.unicodeJsonValue}});const Y=_v;Object.defineProperty(e,"jsonValue",{enumerable:!0,get:function(){return Y.jsonValue}});const X=Wv;Object.defineProperty(e,"unicodeJson",{enumerable:!0,get:function(){return X.unicodeJson}});const ee=zh;Object.defineProperty(e,"oneof",{enumerable:!0,get:function(){return ee.oneof}});const te=Ed;Object.defineProperty(e,"option",{enumerable:!0,get:function(){return te.option}});const re=Kv;Object.defineProperty(e,"record",{enumerable:!0,get:function(){return re.record}});const ne=ch;Object.defineProperty(e,"uniqueArray",{enumerable:!0,get:function(){return ne.uniqueArray}});const ie=d_;Object.defineProperty(e,"infiniteStream",{enumerable:!0,get:function(){return ie.infiniteStream}});const se=x_;Object.defineProperty(e,"asciiString",{enumerable:!0,get:function(){return se.asciiString}});const oe=C_;Object.defineProperty(e,"base64String",{enumerable:!0,get:function(){return oe.base64String}});const ae=XS;Object.defineProperty(e,"fullUnicodeString",{enumerable:!0,get:function(){return ae.fullUnicodeString}});const ue=Py;Object.defineProperty(e,"hexaString",{enumerable:!0,get:function(){return ue.hexaString}});const ce=Fd;Object.defineProperty(e,"string",{enumerable:!0,get:function(){return ce.string}});const le=U_;Object.defineProperty(e,"string16bits",{enumerable:!0,get:function(){return le.string16bits}});const pe=G_;Object.defineProperty(e,"stringOf",{enumerable:!0,get:function(){return pe.stringOf}});const fe=jv;Object.defineProperty(e,"unicodeString",{enumerable:!0,get:function(){return fe.unicodeString}});const he=Y_;Object.defineProperty(e,"subarray",{enumerable:!0,get:function(){return he.subarray}});const de=dw;Object.defineProperty(e,"shuffledSubarray",{enumerable:!0,get:function(){return de.shuffledSubarray}});const me=no;Object.defineProperty(e,"tuple",{enumerable:!0,get:function(){return me.tuple}});const ge=gw;Object.defineProperty(e,"ulid",{enumerable:!0,get:function(){return ge.ulid}});const ye=Tw;Object.defineProperty(e,"uuid",{enumerable:!0,get:function(){return ye.uuid}});const be=qw;Object.defineProperty(e,"uuidV",{enumerable:!0,get:function(){return be.uuidV}});const Se=Gw;Object.defineProperty(e,"webAuthority",{enumerable:!0,get:function(){return Se.webAuthority}});const ve=sk;Object.defineProperty(e,"webFragments",{enumerable:!0,get:function(){return ve.webFragments}});const _e=lk;Object.defineProperty(e,"webPath",{enumerable:!0,get:function(){return _e.webPath}});const we=kk;Object.defineProperty(e,"webQueryParameters",{enumerable:!0,get:function(){return we.webQueryParameters}});const ke=fk;Object.defineProperty(e,"webSegment",{enumerable:!0,get:function(){return ke.webSegment}});const xe=Ik;Object.defineProperty(e,"webUrl",{enumerable:!0,get:function(){return xe.webUrl}});const Ie=Uk;Object.defineProperty(e,"commands",{enumerable:!0,get:function(){return Ie.commands}});const Te=ix;Object.defineProperty(e,"asyncModelRun",{enumerable:!0,get:function(){return Te.asyncModelRun}}),Object.defineProperty(e,"modelRun",{enumerable:!0,get:function(){return Te.modelRun}}),Object.defineProperty(e,"scheduledModelRun",{enumerable:!0,get:function(){return Te.scheduledModelRun}});const Oe=Cc;Object.defineProperty(e,"Random",{enumerable:!0,get:function(){return Oe.Random}});const Ee=Ia;Object.defineProperty(e,"configureGlobal",{enumerable:!0,get:function(){return Ee.configureGlobal}}),Object.defineProperty(e,"readConfigureGlobal",{enumerable:!0,get:function(){return Ee.readConfigureGlobal}}),Object.defineProperty(e,"resetConfigureGlobal",{enumerable:!0,get:function(){return Ee.resetConfigureGlobal}});const Ae=Zu;Object.defineProperty(e,"VerbosityLevel",{enumerable:!0,get:function(){return Ae.VerbosityLevel}});const Ce=wc;Object.defineProperty(e,"ExecutionStatus",{enumerable:!0,get:function(){return Ce.ExecutionStatus}});const Me=Js;Object.defineProperty(e,"cloneMethod",{enumerable:!0,get:function(){return Me.cloneMethod}}),Object.defineProperty(e,"cloneIfNeeded",{enumerable:!0,get:function(){return Me.cloneIfNeeded}}),Object.defineProperty(e,"hasCloneMethod",{enumerable:!0,get:function(){return Me.hasCloneMethod}});const Fe=qs;Object.defineProperty(e,"Stream",{enumerable:!0,get:function(){return Fe.Stream}}),Object.defineProperty(e,"stream",{enumerable:!0,get:function(){return Fe.stream}});const Pe=Cg;Object.defineProperty(e,"hash",{enumerable:!0,get:function(){return Pe.hash}});const Ne=cc;Object.defineProperty(e,"stringify",{enumerable:!0,get:function(){return Ne.stringify}}),Object.defineProperty(e,"asyncStringify",{enumerable:!0,get:function(){return Ne.asyncStringify}}),Object.defineProperty(e,"toStringMethod",{enumerable:!0,get:function(){return Ne.toStringMethod}}),Object.defineProperty(e,"hasToStringMethod",{enumerable:!0,get:function(){return Ne.hasToStringMethod}}),Object.defineProperty(e,"asyncToStringMethod",{enumerable:!0,get:function(){return Ne.asyncToStringMethod}}),Object.defineProperty(e,"hasAsyncToStringMethod",{enumerable:!0,get:function(){return Ne.hasAsyncToStringMethod}});const je=ax;Object.defineProperty(e,"scheduler",{enumerable:!0,get:function(){return je.scheduler}}),Object.defineProperty(e,"schedulerFor",{enumerable:!0,get:function(){return je.schedulerFor}});const Re=Lc;Object.defineProperty(e,"defaultReportMessage",{enumerable:!0,get:function(){return Re.defaultReportMessage}}),Object.defineProperty(e,"asyncDefaultReportMessage",{enumerable:!0,get:function(){return Re.asyncDefaultReportMessage}});const De=Us;Object.defineProperty(e,"PreconditionFailure",{enumerable:!0,get:function(){return De.PreconditionFailure}});const Le=Kb;Object.defineProperty(e,"int8Array",{enumerable:!0,get:function(){return Le.int8Array}});const Ue=jb;Object.defineProperty(e,"int16Array",{enumerable:!0,get:function(){return Ue.int16Array}});const $e=zb;Object.defineProperty(e,"int32Array",{enumerable:!0,get:function(){return $e.int32Array}});const Be=iS;Object.defineProperty(e,"uint8Array",{enumerable:!0,get:function(){return Be.uint8Array}});const ze=uS;Object.defineProperty(e,"uint8ClampedArray",{enumerable:!0,get:function(){return ze.uint8ClampedArray}});const qe=Zb;Object.defineProperty(e,"uint16Array",{enumerable:!0,get:function(){return qe.uint16Array}});const We=eS;Object.defineProperty(e,"uint32Array",{enumerable:!0,get:function(){return We.uint32Array}});const Ve=Ob;Object.defineProperty(e,"float32Array",{enumerable:!0,get:function(){return Ve.float32Array}});const Ke=Mb;Object.defineProperty(e,"float64Array",{enumerable:!0,get:function(){return Ke.float64Array}});const Ge=fS;Object.defineProperty(e,"sparseArray",{enumerable:!0,get:function(){return Ge.sparseArray}});const Je=zs;Object.defineProperty(e,"Arbitrary",{enumerable:!0,get:function(){return Je.Arbitrary}});const He=Hs;Object.defineProperty(e,"Value",{enumerable:!0,get:function(){return He.Value}});const Ze=Ql;Object.defineProperty(e,"createDepthIdentifier",{enumerable:!0,get:function(){return Ze.createDepthIdentifier}}),Object.defineProperty(e,"getDepthContextFor",{enumerable:!0,get:function(){return Ze.getDepthContextFor}});const Qe=_x;Object.defineProperty(e,"bigInt64Array",{enumerable:!0,get:function(){return Qe.bigInt64Array}});const Ye=Ix;Object.defineProperty(e,"bigUint64Array",{enumerable:!0,get:function(){return Ye.bigUint64Array}});const Xe=Ax;Object.defineProperty(e,"stringMatching",{enumerable:!0,get:function(){return Xe.stringMatching}});const et=Pg;Object.defineProperty(e,"noShrink",{enumerable:!0,get:function(){return et.noShrink}});const tt=Hp;Object.defineProperty(e,"noBias",{enumerable:!0,get:function(){return tt.noBias}});const rt=nI;Object.defineProperty(e,"limitShrink",{enumerable:!0,get:function(){return rt.limitShrink}}),e.__type="commonjs",e.__version="3.23.2",e.__commitHash="a4a600eaa08c833707067a877db144289a724b91"}(Ds),function(t){var r=e&&e.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),n=e&&e.__exportStar||function(e,t){for(var n in e)"default"===n||Object.prototype.hasOwnProperty.call(t,n)||r(t,e,n)};Object.defineProperty(t,"__esModule",{value:!0});const i=Ds;t.default=i,n(Ds,t)}(Rs);var pI=_mergeNamespaces({__proto__:null},[Rs]);const getKeysForIndexSignature=(e,t)=>{switch(t._tag){case"StringKeyword":case"TemplateLiteral":return Object.keys(e);case"SymbolKeyword":return Object.getOwnPropertySymbols(e);case"Refinement":return getKeysForIndexSignature(e,t.from)}},memoizeThunk=e=>{let t,r=!1;return()=>(r||(t=e(),r=!0),t)},formatDate=e=>{try{return e.toISOString()}catch{return e+""}},fI="[Circular]";function formatUnknown$1(e,t=0){const r=new WeakSet,n=t?"number"==typeof t?" ".repeat(t):t:"",ind=e=>n.repeat(e),wrap=(e,t)=>{const r=e?.constructor;return r&&r!==Object.prototype.constructor&&r.name?`${r.name}(${t})`:t};return function go(e,t=0){if(Array.isArray(e)){if(r.has(e))return fI;if(r.add(e),!n||e.length<=1)return`[${e.map(e=>go(e,t)).join(",")}]`;const i=e.map(e=>go(e,t+1)).join(",\n"+ind(t+1));return`[\n${ind(t+1)}${i}\n${ind(t)}]`}if(isDate(e))return formatDate(e);if(C(e,"toString")&&A(e.toString)&&e.toString!==Object.prototype.toString)return(e=>{try{const t=e.toString();return"string"==typeof t?t:t+""}catch{return"[toString threw]"}})(e);if(isString$1(e))return JSON.stringify(e);if(isNumber$1(e)||null==e||isBoolean$1(e)||isSymbol$1(e))return e+"";if(isBigInt$1(e))return e+"n";if(e instanceof Set||e instanceof Map)return r.has(e)?fI:(r.add(e),`${e.constructor.name}(${go(Array.from(e),t)})`);if(isObject(e)){if(r.has(e))return fI;r.add(e);const i=(e=>{try{return Reflect.ownKeys(e)}catch{return["[ownKeys threw]"]}})(e);if(!n||i.length<=1){const r=`{${i.map(r=>`${formatPropertyKey$1(r)}:${go(e[r],t)}`).join(",")}}`;return wrap(e,r)}const s=`{\n${i.map(r=>`${ind(t+1)}${formatPropertyKey$1(r)}: ${go(e[r],t+1)}`).join(",\n")}\n${ind(t)}}`;return wrap(e,s)}return e+""}(e,0)}function formatPropertyKey$1(name){return isString$1(name)?JSON.stringify(name):name+""}const isNonEmpty$9=e=>Array.isArray(e),formatPathKey=e=>`[${formatPropertyKey$1(e)}]`,formatPath=e=>isNonEmpty$9(e)?e.map(formatPathKey).join(""):formatPathKey(e),getErrorMessage$1=(e,t,r,n)=>{let i=e;return r&&ci(r)&&(i+="\nat path: "+formatPath(r)),void 0!==t&&(i+="\ndetails: "+t),n&&(i+=`\nschema (${n._tag}): ${n}`),i},getInvalidArgumentErrorMessage=e=>getErrorMessage$1("Invalid Argument",e),getUnsupportedSchemaErrorMessage=(e,t,r)=>getErrorMessage$1("Unsupported schema",e,t,r),getMissingAnnotationErrorMessage=(e,t,r)=>getErrorMessage$1("Missing annotation",e,t,r),getJSONSchemaMissingAnnotationErrorMessage=(e,t)=>getMissingAnnotationErrorMessage('Generating a JSON Schema for this schema requires a "jsonSchema" annotation',e,t),getJSONSchemaUnsupportedKeyErrorMessage=(e,t)=>getErrorMessage$1("Unsupported key",`Cannot encode ${formatPropertyKey$1(e)} key to JSON Schema`,t),getSchemaExtendErrorMessage=(e,t,r)=>getErrorMessage$1("Unsupported schema or overlapping types",`cannot extend ${e} with ${t}`,r),getASTUnsupportedSchemaErrorMessage=e=>getUnsupportedSchemaErrorMessage(void 0,void 0,e),getASTDuplicateIndexSignatureErrorMessage=e=>getErrorMessage$1("Duplicate index signature",e+" index signature"),hI=getErrorMessage$1("Unsupported index signature parameter","An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types"),dI=getErrorMessage$1("Invalid element","A required element cannot follow an optional element. ts(1257)"),getASTDuplicatePropertySignatureTransformationErrorMessage=e=>getErrorMessage$1("Duplicate property signature transformation","Duplicate key "+formatUnknown$1(e)),getASTDuplicatePropertySignatureErrorMessage=e=>getErrorMessage$1("Duplicate property signature","Duplicate key "+formatUnknown$1(e)),mI=Symbol.for("effect/SchemaId/DateFromSelf"),gI=Symbol.for("effect/SchemaId/GreaterThan"),yI=Symbol.for("effect/SchemaId/GreaterThanOrEqualTo"),bI=Symbol.for("effect/SchemaId/LessThan"),SI=Symbol.for("effect/SchemaId/LessThanOrEqualTo"),vI=Symbol.for("effect/SchemaId/Int"),_I=Symbol.for("effect/SchemaId/NonNaN"),wI=Symbol.for("effect/SchemaId/Finite"),kI=Symbol.for("effect/SchemaId/JsonNumber"),xI=Symbol.for("effect/SchemaId/Between"),II=Symbol.for("effect/SchemaId/GreaterThanBigint"),TI=Symbol.for("effect/SchemaId/GreaterThanOrEqualToBigint"),OI=Symbol.for("effect/SchemaId/LessThanBigint"),EI=Symbol.for("effect/SchemaId/LessThanOrEqualToBigint"),AI=Symbol.for("effect/SchemaId/BetweenBigint"),CI=Symbol.for("effect/SchemaId/MinLength"),MI=Symbol.for("effect/SchemaId/MaxLength"),FI=Symbol.for("effect/SchemaId/Length"),PI=Symbol.for("effect/SchemaId/MinItems"),NI=Symbol.for("effect/SchemaId/MaxItems"),jI=Symbol.for("effect/SchemaId/ItemsCount"),RI=isNumber$1,DI=dual(2,(e,t)=>e+t),LI=dual(2,(e,t)=>e-t),UI=dual(2,(e,t)=>e*t),$I=dual(2,(e,t)=>0===t?$e:some$k(e/t)),BI=dual(2,(e,t)=>e/t),zI=p,qI=Et,WI=lessThan$e(qI),VI=lessThanOrEqualTo$7(qI),KI=greaterThan$a(qI),GI=greaterThanOrEqualTo$7(qI),JI=between$7(qI),HI=clamp$8(qI),ZI=min$9(qI),QI=max$b(qI),sign$2=e=>qI(e,0),YI=dual(2,(e,t)=>{const r=(e.toString().split(".")[1]||"").length,n=(t.toString().split(".")[1]||"").length,i=r>n?r:n;return parseInt(e.toFixed(i).replace(".",""))%parseInt(t.toFixed(i).replace(".",""))/Math.pow(10,i)}),nextPow2=e=>Math.max(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))),2),parse$1=e=>{if("NaN"===e)return some$k(NaN);if("Infinity"===e)return some$k(1/0);if("-Infinity"===e)return some$k(-1/0);if(""===e.trim())return $e;const t=Number(e);return Number.isNaN(t)?$e:some$k(t)};var XI=Object.freeze({__proto__:null,Equivalence:zI,Order:qI,between:JI,clamp:HI,decrement:e=>LI(e,1),divide:$I,greaterThan:KI,greaterThanOrEqualTo:GI,increment:e=>DI(e,1),isNumber:RI,lessThan:WI,lessThanOrEqualTo:VI,max:QI,min:ZI,multiply:UI,multiplyAll:e=>{let t=1;for(const r of e){if(0===r)return 0;t*=r}return t},negate:e=>UI(e,-1),nextPow2,parse:parse$1,remainder:YI,round:dual(2,(e,t)=>{const r=Math.pow(10,t);return Math.round(e*r)/r}),sign:sign$2,subtract:LI,sum:DI,sumAll:e=>pn(e,0,DI),unsafeDivide:BI});const escape=e=>e.replace(/[/\\^$*+?.()|[\]{}]/g,"\\$&");var eT=Object.freeze({__proto__:null,escape,isRegExp:isRegExp$1});const tT=Symbol.for("effect/annotation/Brand"),rT=Symbol.for("effect/annotation/SchemaId"),nT=Symbol.for("effect/annotation/Message"),iT=Symbol.for("effect/annotation/MissingMessage"),sT=Symbol.for("effect/annotation/Identifier"),oT=Symbol.for("effect/annotation/Title"),aT=Symbol.for("effect/annotation/AutoTitle"),uT=Symbol.for("effect/annotation/Description"),cT=Symbol.for("effect/annotation/Examples"),lT=Symbol.for("effect/annotation/Default"),pT=Symbol.for("effect/annotation/JSONSchema"),fT=Symbol.for("effect/annotation/Arbitrary"),hT=Symbol.for("effect/annotation/Pretty"),dT=Symbol.for("effect/annotation/Equivalence"),mT=Symbol.for("effect/annotation/Documentation"),gT=Symbol.for("effect/annotation/Concurrency"),yT=Symbol.for("effect/annotation/Batching"),bT=Symbol.for("effect/annotation/ParseIssueTitle"),ST=Symbol.for("effect/annotation/ParseOptions"),vT=Symbol.for("effect/annotation/DecodingFallback"),_T=Symbol.for("effect/annotation/Surrogate"),wT=Symbol.for("effect/annotation/StableFilter"),kT=dual(2,(e,t)=>Object.prototype.hasOwnProperty.call(e.annotations,t)?Ut(e.annotations[t]):none$c()),xT=kT(tT),IT=kT(rT),TT=kT(nT),OT=kT(iT),ET=kT(oT),AT=kT(aT),CT=kT(sT),MT=kT(uT),FT=kT(cT),PT=kT(lT),NT=kT(pT),jT=kT(mT),RT=kT(gT),DT=kT(yT),LT=kT(bT),UT=kT(ST),$T=kT(vT),BT=kT(_T),zT=kT(wT),hasStableFilter=e=>vr(zT(e),e=>!0===e),qT=Symbol.for("effect/annotation/JSONIdentifier"),WT=kT(qT),getJSONIdentifier=e=>Gt(WT(e),()=>CT(e)),VT=Symbol.for("effect/schema/ParseJson");class Declaration{typeParameters;decodeUnknown;encodeUnknown;annotations;_tag="Declaration";constructor(e,t,r,n={}){this.typeParameters=e,this.decodeUnknown=t,this.encodeUnknown=r,this.annotations=n}toString(){return Kt(getExpected(this),()=>"<declaration schema>")}toJSON(){return{_tag:this._tag,typeParameters:this.typeParameters.map(e=>e.toJSON()),annotations:toJSONAnnotations(this.annotations)}}}const createASTGuard=e=>t=>t._tag===e,KT=createASTGuard("Declaration");let GT=class{literal;annotations;_tag="Literal";constructor(e,t={}){this.literal=e,this.annotations=t}toString(){return Kt(getExpected(this),()=>formatUnknown$1(this.literal))}toJSON(){return{_tag:this._tag,literal:isBigInt$1(this.literal)?this.literal+"":this.literal,annotations:toJSONAnnotations(this.annotations)}}};const JT=createASTGuard("Literal"),HT=new GT(null);class UniqueSymbol{symbol;annotations;_tag="UniqueSymbol";constructor(e,t={}){this.symbol=e,this.annotations=t}toString(){return Kt(getExpected(this),()=>formatUnknown$1(this.symbol))}toJSON(){return{_tag:this._tag,symbol:this.symbol+"",annotations:toJSONAnnotations(this.annotations)}}}const ZT=createASTGuard("UniqueSymbol");class UndefinedKeyword{annotations;_tag="UndefinedKeyword";constructor(e={}){this.annotations=e}toString(){return formatKeyword(this)}toJSON(){return{_tag:this._tag,annotations:toJSONAnnotations(this.annotations)}}}const QT=new UndefinedKeyword({[oT]:"undefined"}),YT=createASTGuard("UndefinedKeyword");class VoidKeyword{annotations;_tag="VoidKeyword";constructor(e={}){this.annotations=e}toString(){return formatKeyword(this)}toJSON(){return{_tag:this._tag,annotations:toJSONAnnotations(this.annotations)}}}const XT=new VoidKeyword({[oT]:"void"}),eO=createASTGuard("VoidKeyword");class NeverKeyword{annotations;_tag="NeverKeyword";constructor(e={}){this.annotations=e}toString(){return formatKeyword(this)}toJSON(){return{_tag:this._tag,annotations:toJSONAnnotations(this.annotations)}}}const tO=new NeverKeyword({[oT]:"never"}),rO=createASTGuard("NeverKeyword");class UnknownKeyword{annotations;_tag="UnknownKeyword";constructor(e={}){this.annotations=e}toString(){return formatKeyword(this)}toJSON(){return{_tag:this._tag,annotations:toJSONAnnotations(this.annotations)}}}const nO=new UnknownKeyword({[oT]:"unknown"}),iO=createASTGuard("UnknownKeyword");class AnyKeyword{annotations;_tag="AnyKeyword";constructor(e={}){this.annotations=e}toString(){return formatKeyword(this)}toJSON(){return{_tag:this._tag,annotations:toJSONAnnotations(this.annotations)}}}const sO=new AnyKeyword({[oT]:"any"}),oO=createASTGuard("AnyKeyword");class StringKeyword{annotations;_tag="StringKeyword";constructor(e={}){this.annotations=e}toString(){return formatKeyword(this)}toJSON(){return{_tag:this._tag,annotations:toJSONAnnotations(this.annotations)}}}const aO=new StringKeyword({[oT]:"string",[uT]:"a string"}),uO=createASTGuard("StringKeyword");class NumberKeyword{annotations;_tag="NumberKeyword";constructor(e={}){this.annotations=e}toString(){return formatKeyword(this)}toJSON(){return{_tag:this._tag,annotations:toJSONAnnotations(this.annotations)}}}const cO=new NumberKeyword({[oT]:"number",[uT]:"a number"}),lO=createASTGuard("NumberKeyword");class BooleanKeyword{annotations;_tag="BooleanKeyword";constructor(e={}){this.annotations=e}toString(){return formatKeyword(this)}toJSON(){return{_tag:this._tag,annotations:toJSONAnnotations(this.annotations)}}}const pO=new BooleanKeyword({[oT]:"boolean",[uT]:"a boolean"}),fO=createASTGuard("BooleanKeyword");class BigIntKeyword{annotations;_tag="BigIntKeyword";constructor(e={}){this.annotations=e}toString(){return formatKeyword(this)}toJSON(){return{_tag:this._tag,annotations:toJSONAnnotations(this.annotations)}}}const hO=new BigIntKeyword({[oT]:"bigint",[uT]:"a bigint"}),dO=createASTGuard("BigIntKeyword");class SymbolKeyword{annotations;_tag="SymbolKeyword";constructor(e={}){this.annotations=e}toString(){return formatKeyword(this)}toJSON(){return{_tag:this._tag,annotations:toJSONAnnotations(this.annotations)}}}const mO=new SymbolKeyword({[oT]:"symbol",[uT]:"a symbol"}),gO=createASTGuard("SymbolKeyword");class ObjectKeyword{annotations;_tag="ObjectKeyword";constructor(e={}){this.annotations=e}toString(){return formatKeyword(this)}toJSON(){return{_tag:this._tag,annotations:toJSONAnnotations(this.annotations)}}}const yO=new ObjectKeyword({[oT]:"object",[uT]:"an object in the TypeScript meaning, i.e. the `object` type"}),bO=createASTGuard("ObjectKeyword");let SO=class{enums;annotations;_tag="Enums";constructor(e,t={}){this.enums=e,this.annotations=t}toString(){return Kt(getExpected(this),()=>`<enum ${this.enums.length} value(s): ${this.enums.map(([e,t])=>JSON.stringify(t)).join(" | ")}>`)}toJSON(){return{_tag:this._tag,enums:this.enums,annotations:toJSONAnnotations(this.annotations)}}};const vO=createASTGuard("Enums"),isTemplateLiteralSpanType=e=>{switch(e._tag){case"Literal":case"NumberKeyword":case"StringKeyword":case"TemplateLiteral":return!0;case"Union":return e.types.every(isTemplateLiteralSpanType)}return!1},templateLiteralSpanUnionTypeToString=e=>{switch(e._tag){case"Literal":return JSON.stringify(e.literal+"");case"StringKeyword":return"string";case"NumberKeyword":return"number";case"TemplateLiteral":return e+"";case"Union":return e.types.map(templateLiteralSpanUnionTypeToString).join(" | ")}};class TemplateLiteralSpan{literal;type;constructor(e,t){if(this.literal=t,!isTemplateLiteralSpanType(e))throw Error(getErrorMessage$1("Unsupported template literal span",void 0,void 0,e));this.type=e}toString(){return(e=>{switch(e._tag){case"Literal":return e.literal+"";case"StringKeyword":return"${string}";case"NumberKeyword":return"${number}";case"TemplateLiteral":return"${"+e+"}";case"Union":return"${"+e.types.map(templateLiteralSpanUnionTypeToString).join(" | ")+"}"}})(this.type)+this.literal}toJSON(){return{type:this.type.toJSON(),literal:this.literal}}}let _O=class{head;spans;annotations;_tag="TemplateLiteral";constructor(e,t,r={}){this.head=e,this.spans=t,this.annotations=r}toString(){return Kt(getExpected(this),()=>formatTemplateLiteral(this))}toJSON(){return{_tag:this._tag,head:this.head,spans:this.spans.map(e=>e.toJSON()),annotations:toJSONAnnotations(this.annotations)}}};const formatTemplateLiteral=e=>"`"+e.head+e.spans.map(String).join("")+"`",wO=createASTGuard("TemplateLiteral");let kO=class{type;annotations;constructor(e,t={}){this.type=e,this.annotations=t}toJSON(){return{type:this.type.toJSON(),annotations:toJSONAnnotations(this.annotations)}}toString(){return this.type+""}};class OptionalType extends kO{isOptional;constructor(e,t,r={}){super(e,r),this.isOptional=t}toJSON(){return{type:this.type.toJSON(),isOptional:this.isOptional,annotations:toJSONAnnotations(this.annotations)}}toString(){return this.type+""+(this.isOptional?"?":"")}}const getRestASTs=e=>e.map(e=>e.type);class TupleType{elements;rest;isReadonly;annotations;_tag="TupleType";constructor(e,t,r,n={}){this.elements=e,this.rest=t,this.isReadonly=r,this.annotations=n;let i=!1,s=!1;for(const t of e)if(t.isOptional)i=!0;else if(i){s=!0;break}if(s||i&&t.length>1)throw Error(dI)}toString(){return Kt(getExpected(this),()=>formatTuple(this))}toJSON(){return{_tag:this._tag,elements:this.elements.map(e=>e.toJSON()),rest:this.rest.map(e=>e.toJSON()),isReadonly:this.isReadonly,annotations:toJSONAnnotations(this.annotations)}}}const formatTuple=e=>{const t=e.elements.map(String).join(", ");return Yn(e.rest,{onEmpty:()=>`readonly [${t}]`,onNonEmpty:(r,n)=>{const i=r+"",s=i.includes(" | ")?`(${i})`:i;if(n.length>0){const r=n.map(String).join(", ");return e.elements.length>0?`readonly [${t}, ...${s}[], ${r}]`:`readonly [...${s}[], ${r}]`}return e.elements.length>0?`readonly [${t}, ...${s}[]]`:`ReadonlyArray<${i}>`}})},xO=createASTGuard("TupleType");class PropertySignature extends OptionalType{name;isReadonly;constructor(name,e,t,r,n){super(e,t,n),this.name=name,this.isReadonly=r}toString(){return(this.isReadonly?"readonly ":"")+this.name+(this.isOptional?"?":"")+": "+this.type}toJSON(){return{name:this.name+"",type:this.type.toJSON(),isOptional:this.isOptional,isReadonly:this.isReadonly,annotations:toJSONAnnotations(this.annotations)}}}const isParameter=e=>{switch(e._tag){case"StringKeyword":case"SymbolKeyword":case"TemplateLiteral":return!0;case"Refinement":return isParameter(e.from)}return!1};class IndexSignature{type;isReadonly;parameter;constructor(e,t,r){if(this.type=t,this.isReadonly=r,!isParameter(e))throw Error(hI);this.parameter=e}toString(){return(this.isReadonly?"readonly ":"")+`[x: ${this.parameter}]: ${this.type}`}toJSON(){return{parameter:this.parameter.toJSON(),type:this.type.toJSON(),isReadonly:this.isReadonly}}}class TypeLiteral{annotations;_tag="TypeLiteral";propertySignatures;indexSignatures;constructor(e,t,r={}){this.annotations=r;const n={};for(let t=0;t<e.length;t++){const name=e[t].name;if(Object.prototype.hasOwnProperty.call(n,name))throw Error(getASTDuplicatePropertySignatureErrorMessage(name));n[name]=null}const parameters={string:!1,symbol:!1};for(let e=0;e<t.length;e++){const r=getEncodedParameter(t[e].parameter);if(uO(r)){if(parameters.string)throw Error(getASTDuplicateIndexSignatureErrorMessage("string"));parameters.string=!0}else if(gO(r)){if(parameters.symbol)throw Error(getASTDuplicateIndexSignatureErrorMessage("symbol"));parameters.symbol=!0}}this.propertySignatures=e,this.indexSignatures=t}toString(){return Kt(getExpected(this),()=>formatTypeLiteral(this))}toJSON(){return{_tag:this._tag,propertySignatures:this.propertySignatures.map(e=>e.toJSON()),indexSignatures:this.indexSignatures.map(e=>e.toJSON()),annotations:toJSONAnnotations(this.annotations)}}}const formatIndexSignatures=e=>e.map(String).join("; "),formatTypeLiteral=e=>{if(e.propertySignatures.length>0){const t=e.propertySignatures.map(String).join("; ");return e.indexSignatures.length>0?`{ ${t}; ${formatIndexSignatures(e.indexSignatures)} }`:`{ ${t} }`}return e.indexSignatures.length>0?`{ ${formatIndexSignatures(e.indexSignatures)} }`:"{}"},IO=createASTGuard("TypeLiteral"),TO=Ni(Pt(qI,e=>{switch(e._tag){case"AnyKeyword":return 0;case"UnknownKeyword":return 1;case"ObjectKeyword":return 2;case"StringKeyword":case"NumberKeyword":case"BooleanKeyword":case"BigIntKeyword":case"SymbolKeyword":return 3}return 4})),OO={string:"StringKeyword",number:"NumberKeyword",boolean:"BooleanKeyword",bigint:"BigIntKeyword"},flatten$g=e=>us(e,e=>AO(e)?flatten$g(e.types):[e]),unify$1=e=>{const t=TO(e),r=[],n={},i=[];for(const e of t)switch(e._tag){case"NeverKeyword":break;case"AnyKeyword":return[sO];case"UnknownKeyword":return[nO];case"ObjectKeyword":case"UndefinedKeyword":case"VoidKeyword":case"StringKeyword":case"NumberKeyword":case"BooleanKeyword":case"BigIntKeyword":case"SymbolKeyword":n[e._tag]||(n[e._tag]=e,r.push(e));break;case"Literal":{const t=typeof e.literal;switch(t){case"string":case"number":case"bigint":case"boolean":n[OO[t]]||i.includes(e.literal)||(i.push(e.literal),r.push(e));break;case"object":i.includes(e.literal)||(i.push(e.literal),r.push(e))}break}case"UniqueSymbol":n.SymbolKeyword||i.includes(e.symbol)||(i.push(e.symbol),r.push(e));break;case"TupleType":n.ObjectKeyword||r.push(e);break;case"TypeLiteral":0===e.propertySignatures.length&&0===e.indexSignatures.length?n["{}"]||(n["{}"]=e,r.push(e)):n.ObjectKeyword||r.push(e);break;default:r.push(e)}return r};let EO=class Union{types;annotations;static make=(e,t)=>isMembers(e)?new Union(e,t):1===e.length?e[0]:tO;static unify=(e,t)=>Union.make(unify$1(flatten$g(e)),t);_tag="Union";constructor(e,t={}){this.types=e,this.annotations=t}toString(){return Kt(getExpected(this),()=>this.types.map(String).join(" | "))}toJSON(){return{_tag:this._tag,types:this.types.map(e=>e.toJSON()),annotations:toJSONAnnotations(this.annotations)}}};const mapMembers=(e,t)=>e.map(t),isMembers=e=>e.length>1,AO=createASTGuard("Union"),CO=globalValue(Symbol.for("effect/Schema/AST/toJSONMemoMap"),()=>new WeakMap);class Suspend{f;annotations;_tag="Suspend";constructor(e,t={}){this.f=e,this.annotations=t,this.f=memoizeThunk(e)}toString(){return getExpected(this).pipe(Gt(()=>ir(liftThrowable(this.f)(),e=>getExpected(e))),Kt(()=>"<suspended schema>"))}toJSON(){const e=this.f();let t=CO.get(e);return t||(CO.set(e,{_tag:this._tag}),t={_tag:this._tag,ast:e.toJSON(),annotations:toJSONAnnotations(this.annotations)},CO.set(e,t),t)}}const MO=createASTGuard("Suspend");let FO=class{from;filter;annotations;_tag="Refinement";constructor(e,t,r={}){this.from=e,this.filter=t,this.annotations=r}toString(){return CT(this).pipe(Kt(()=>qt(getOrElseExpected(this),{onNone:()=>`{ ${this.from} | filter }`,onSome:e=>PO(this.from)?this.from+" & "+e:e})))}toJSON(){return{_tag:this._tag,from:this.from.toJSON(),annotations:toJSONAnnotations(this.annotations)}}};const PO=createASTGuard("Refinement"),NO={};let jO=class{from;to;transformation;annotations;_tag="Transformation";constructor(e,t,r,n={}){this.from=e,this.to=t,this.transformation=r,this.annotations=n}toString(){return Kt(getExpected(this),()=>`(${this.from+""} <-> ${this.to+""})`)}toJSON(){return{_tag:this._tag,from:this.from.toJSON(),to:this.to.toJSON(),annotations:toJSONAnnotations(this.annotations)}}};const RO=createASTGuard("Transformation");class FinalTransformation{decode;encode;_tag="FinalTransformation";constructor(e,t){this.decode=e,this.encode=t}}const createTransformationGuard=e=>t=>t._tag===e,DO=createTransformationGuard("FinalTransformation");class ComposeTransformation{_tag="ComposeTransformation"}const LO=new ComposeTransformation,UO=createTransformationGuard("ComposeTransformation");let $O=class{from;to;decode;encode;constructor(e,t,r,n){this.from=e,this.to=t,this.decode=r,this.encode=n}};const isRenamingPropertySignatureTransformation=e=>e.decode===identity$5&&e.encode===identity$5;class TypeLiteralTransformation{propertySignatureTransformations;_tag="TypeLiteralTransformation";constructor(e){this.propertySignatureTransformations=e;const t={},r={};for(const n of e){const e=n.from;if(t[e])throw Error(getASTDuplicatePropertySignatureTransformationErrorMessage(e));t[e]=!0;const i=n.to;if(r[i])throw Error(getASTDuplicatePropertySignatureTransformationErrorMessage(i));r[i]=!0}}}const BO=createTransformationGuard("TypeLiteralTransformation"),annotations$2=(e,t)=>{const r=Object.getOwnPropertyDescriptors(e),n={...e.annotations};delete n[sT];const i={...n,...t},s=BT(e);return zt(s)&&(i[_T]=annotations$2(s.value,t)),r.annotations.value=i,Object.create(Object.getPrototypeOf(e),r)},keyof$1=e=>EO.unify(_keyof(e)),getTemplateLiteralSpanTypePattern=(e,t)=>{switch(e._tag){case"Literal":return escape(e.literal+"");case"StringKeyword":return"[\\s\\S]*?";case"NumberKeyword":return"[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";case"TemplateLiteral":return getTemplateLiteralPattern(e,t,!1);case"Union":return e.types.map(e=>getTemplateLiteralSpanTypePattern(e,t)).join("|")}},handleTemplateLiteralSpanTypeParens=(e,t,r,n)=>{if(AO(e)){if(r&&!n)return`(?:${t})`}else if(!r||!n)return t;return`(${t})`},getTemplateLiteralPattern=(e,t,r)=>{let n="";if(""!==e.head){const i=escape(e.head);n+=t&&r?`(${i})`:i}for(const i of e.spans){const e=getTemplateLiteralSpanTypePattern(i.type,t);if(n+=handleTemplateLiteralSpanTypeParens(i.type,e,t,r),""!==i.literal){const e=escape(i.literal);n+=t&&r?`(${e})`:e}}return n},getTemplateLiteralRegExp=e=>RegExp(`^${getTemplateLiteralPattern(e,!1,!0)}$`),getTemplateLiteralCapturingRegExp=e=>RegExp(`^${getTemplateLiteralPattern(e,!0,!0)}$`),getPropertySignatures=e=>{const t=BT(e);if(zt(t))return getPropertySignatures(t.value);switch(e._tag){case"TypeLiteral":return e.propertySignatures.slice();case"Suspend":return getPropertySignatures(e.f());case"Refinement":return getPropertySignatures(e.from)}return getPropertyKeys(e).map(name=>getPropertyKeyIndexedAccess(e,name))},getIndexSignatures=e=>{const t=BT(e);if(zt(t))return getIndexSignatures(t.value);switch(e._tag){case"TypeLiteral":return e.indexSignatures.slice();case"Suspend":return getIndexSignatures(e.f());case"Refinement":return getIndexSignatures(e.from)}return[]},getNumberIndexedAccess$1=e=>{switch(e._tag){case"TupleType":{let t=!1,r=[];for(const n of e.elements)n.isOptional&&(t=!0),r.push(n.type);return t&&r.push(QT),r=r.concat(getRestASTs(e.rest)),EO.make(r)}case"Refinement":return getNumberIndexedAccess$1(e.from);case"Union":return EO.make(e.types.map(getNumberIndexedAccess$1));case"Suspend":return getNumberIndexedAccess$1(e.f())}throw Error(getASTUnsupportedSchemaErrorMessage(e))},getTypeLiteralPropertySignature=(e,name)=>{const t=ki(e.propertySignatures,e=>e.name===name);if(zt(t))return t.value;if(isString$1(name)){let t;for(const r of e.indexSignatures){const e=getEncodedParameter(r.parameter);switch(e._tag){case"TemplateLiteral":if(getTemplateLiteralRegExp(e).test(name))return new PropertySignature(name,r.type,!1,!0);break;case"StringKeyword":void 0===t&&(t=new PropertySignature(name,r.type,!1,!0))}}if(t)return t}else if(isSymbol$1(name))for(const t of e.indexSignatures){const e=getEncodedParameter(t.parameter);if(gO(e))return new PropertySignature(name,t.type,!1,!0)}},getPropertyKeyIndexedAccess=(e,name)=>{const t=BT(e);if(zt(t))return getPropertyKeyIndexedAccess(t.value,name);switch(e._tag){case"TypeLiteral":{const t=getTypeLiteralPropertySignature(e,name);if(t)return t;break}case"Union":return new PropertySignature(name,EO.make(e.types.map(e=>getPropertyKeyIndexedAccess(e,name).type)),!1,!0);case"Suspend":return getPropertyKeyIndexedAccess(e.f(),name);case"Refinement":return getPropertyKeyIndexedAccess(e.from,name)}throw Error(getASTUnsupportedSchemaErrorMessage(e))},getPropertyKeys=e=>{const t=BT(e);if(zt(t))return getPropertyKeys(t.value);switch(e._tag){case"TypeLiteral":return e.propertySignatures.map(e=>e.name);case"Union":return e.types.slice(1).reduce((e,t)=>ss(e,getPropertyKeys(t)),getPropertyKeys(e.types[0]));case"Suspend":return getPropertyKeys(e.f());case"Refinement":return getPropertyKeys(e.from);case"Transformation":return getPropertyKeys(e.to)}return[]},record$1=(e,t)=>{const r=[],n=[],go=e=>{switch(e._tag){case"NeverKeyword":break;case"StringKeyword":case"SymbolKeyword":case"TemplateLiteral":case"Refinement":n.push(new IndexSignature(e,t,!0));break;case"Literal":if(!isString$1(e.literal)&&!isNumber$1(e.literal))throw Error((e=>getErrorMessage$1("Unsupported literal","literal value: "+formatUnknown$1(e)))(e.literal));r.push(new PropertySignature(e.literal,t,!1,!0));break;case"Enums":for(const[n,name]of e.enums)r.push(new PropertySignature(name,t,!1,!0));break;case"UniqueSymbol":r.push(new PropertySignature(e.symbol,t,!1,!0));break;case"Union":e.types.forEach(go);break;default:throw Error(getErrorMessage$1("Unsupported key schema",void 0,void 0,e))}};return go(e),{propertySignatures:r,indexSignatures:n}},pick$4=(e,t)=>{const r=BT(e);if(zt(r))return pick$4(r.value,t);switch(e._tag){case"TypeLiteral":{const r=[],n={};for(const i of e.propertySignatures)n[i.name]=null,t.includes(i.name)&&r.push(i);for(const i of t)if(!(i in n)){const t=getTypeLiteralPropertySignature(e,i);t&&r.push(t)}return new TypeLiteral(r,[])}case"Union":return new TypeLiteral(t.map(name=>getPropertyKeyIndexedAccess(e,name)),[]);case"Suspend":return pick$4(e.f(),t);case"Refinement":return pick$4(e.from,t);case"Transformation":switch(e.transformation._tag){case"ComposeTransformation":return new jO(pick$4(e.from,t),pick$4(e.to,t),LO);case"TypeLiteralTransformation":{const r=[],n=[];for(const i of t){const t=e.transformation.propertySignatureTransformations.find(e=>e.to===i);t?(r.push(t),n.push(t.from)):n.push(i)}return ci(r)?new jO(pick$4(e.from,n),pick$4(e.to,t),new TypeLiteralTransformation(r)):pick$4(e.from,n)}}}throw Error(getASTUnsupportedSchemaErrorMessage(e))},omit$4=(e,t)=>{let r=getIndexSignatures(e);return r.length>0?(r.some(e=>uO(getEncodedParameter(e.parameter)))&&(r=r.filter(e=>!wO(getEncodedParameter(e.parameter)))),new TypeLiteral([],r)):pick$4(e,getPropertyKeys(e).filter(name=>!t.includes(name)))},orUndefined=e=>EO.make([e,QT]),partial$1=(e,t)=>{const r=!0===t?.exact;switch(e._tag){case"TupleType":return new TupleType(e.elements.map(e=>new OptionalType(r?e.type:orUndefined(e.type),!0)),Qn(e.rest,{onEmpty:()=>e.rest,onNonEmpty:e=>[new kO(EO.make([...getRestASTs(e),QT]))]}),e.isReadonly);case"TypeLiteral":return new TypeLiteral(e.propertySignatures.map(e=>new PropertySignature(e.name,r?e.type:orUndefined(e.type),!0,e.isReadonly,e.annotations)),e.indexSignatures.map(e=>new IndexSignature(e.parameter,orUndefined(e.type),e.isReadonly)));case"Union":return EO.make(e.types.map(e=>partial$1(e,t)));case"Suspend":return new Suspend(()=>partial$1(e.f(),t));case"Declaration":case"Refinement":throw Error(getASTUnsupportedSchemaErrorMessage(e));case"Transformation":if(BO(e.transformation)&&e.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation))return new jO(partial$1(e.from,t),partial$1(e.to,t),e.transformation);throw Error(getASTUnsupportedSchemaErrorMessage(e))}return e},required$1=e=>{switch(e._tag){case"TupleType":return new TupleType(e.elements.map(e=>new OptionalType(e.type,!1)),e.rest,e.isReadonly);case"TypeLiteral":return new TypeLiteral(e.propertySignatures.map(e=>new PropertySignature(e.name,e.type,!1,e.isReadonly,e.annotations)),e.indexSignatures);case"Union":return EO.make(e.types.map(e=>required$1(e)));case"Suspend":return new Suspend(()=>required$1(e.f()));case"Declaration":case"Refinement":throw Error(getASTUnsupportedSchemaErrorMessage(e));case"Transformation":if(BO(e.transformation)&&e.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation))return new jO(required$1(e.from),required$1(e.to),e.transformation);throw Error(getASTUnsupportedSchemaErrorMessage(e))}return e},mutable$1=e=>{switch(e._tag){case"TupleType":return!1===e.isReadonly?e:new TupleType(e.elements,e.rest,!1,e.annotations);case"TypeLiteral":{const t=changeMap(e.propertySignatures,e=>!1===e.isReadonly?e:new PropertySignature(e.name,e.type,e.isOptional,!1,e.annotations)),r=changeMap(e.indexSignatures,e=>!1===e.isReadonly?e:new IndexSignature(e.parameter,e.type,!1));return t===e.propertySignatures&&r===e.indexSignatures?e:new TypeLiteral(t,r,e.annotations)}case"Union":{const t=changeMap(e.types,mutable$1);return t===e.types?e:EO.make(t,e.annotations)}case"Suspend":return new Suspend(()=>mutable$1(e.f()),e.annotations);case"Refinement":{const t=mutable$1(e.from);return t===e.from?e:new FO(t,e.filter,e.annotations)}case"Transformation":{const t=mutable$1(e.from),r=mutable$1(e.to);return t===e.from&&r===e.to?e:new jO(t,r,e.transformation,e.annotations)}}return e},getCompiler=e=>{const compile=(t,r)=>e[t._tag](t,compile,r);return compile},pickAnnotations=e=>t=>{let r;for(const n of e)Object.prototype.hasOwnProperty.call(t.annotations,n)&&(void 0===r&&(r={}),r[n]=t.annotations[n]);return r},omitAnnotations=e=>t=>{const r={...t.annotations};for(const t of e)delete r[t];return r},zO=pickAnnotations([cT,lT,pT,fT,hT,dT]),typeAST=e=>{switch(e._tag){case"Declaration":{const t=changeMap(e.typeParameters,typeAST);return t===e.typeParameters?e:new Declaration(t,e.decodeUnknown,e.encodeUnknown,e.annotations)}case"TupleType":{const t=changeMap(e.elements,e=>{const t=typeAST(e.type);return t===e.type?e:new OptionalType(t,e.isOptional)}),r=getRestASTs(e.rest),n=changeMap(r,typeAST);return t===e.elements&&n===r?e:new TupleType(t,n.map(e=>new kO(e)),e.isReadonly,e.annotations)}case"TypeLiteral":{const t=changeMap(e.propertySignatures,e=>{const t=typeAST(e.type);return t===e.type?e:new PropertySignature(e.name,t,e.isOptional,e.isReadonly)}),r=changeMap(e.indexSignatures,e=>{const t=typeAST(e.type);return t===e.type?e:new IndexSignature(e.parameter,t,e.isReadonly)});return t===e.propertySignatures&&r===e.indexSignatures?e:new TypeLiteral(t,r,e.annotations)}case"Union":{const t=changeMap(e.types,typeAST);return t===e.types?e:EO.make(t,e.annotations)}case"Suspend":return new Suspend(()=>typeAST(e.f()),e.annotations);case"Refinement":{const t=typeAST(e.from);return t===e.from?e:new FO(t,e.filter,e.annotations)}case"Transformation":{const t=zO(e);return typeAST(void 0!==t?annotations$2(e.to,t):e.to)}}return e};function changeMap(e,t){let r=!1;const n=allocate$1(e.length);for(let i=0;i<e.length;i++){const s=e[i],o=t(s);o!==s&&(r=!0),n[i]=o}return r?n:e}const getTransformationFrom=e=>{switch(e._tag){case"Transformation":return e.from;case"Refinement":return getTransformationFrom(e.from);case"Suspend":return getTransformationFrom(e.f())}},encodedAST_=(e,t)=>{switch(e._tag){case"Declaration":{const r=changeMap(e.typeParameters,e=>encodedAST_(e,t));return r===e.typeParameters?e:new Declaration(r,e.decodeUnknown,e.encodeUnknown)}case"TupleType":{const r=changeMap(e.elements,e=>{const r=encodedAST_(e.type,t);return r===e.type?e:new OptionalType(r,e.isOptional)}),n=getRestASTs(e.rest),i=changeMap(n,e=>encodedAST_(e,t));return r===e.elements&&i===n?e:new TupleType(r,i.map(e=>new kO(e)),e.isReadonly)}case"TypeLiteral":{const r=changeMap(e.propertySignatures,e=>{const r=encodedAST_(e.type,t);return r===e.type?e:new PropertySignature(e.name,r,e.isOptional,e.isReadonly)}),n=changeMap(e.indexSignatures,e=>{const r=encodedAST_(e.type,t);return r===e.type?e:new IndexSignature(e.parameter,r,e.isReadonly)});return r===e.propertySignatures&&n===e.indexSignatures?e:new TypeLiteral(r,n)}case"Union":{const r=changeMap(e.types,e=>encodedAST_(e,t));return r===e.types?e:EO.make(r)}case"Suspend":{let r;const n=getJSONIdentifier(e);if(zt(n)){const e=t?"Bound":"";r={[qT]:`${n.value}Encoded${e}`}}return new Suspend(()=>encodedAST_(e.f(),t),r)}case"Refinement":{const r=encodedAST_(e.from,t);return t?r===e.from?e:void 0===getTransformationFrom(e.from)&&hasStableFilter(e)?new FO(r,e.filter,e.annotations):r:r}case"Transformation":return encodedAST_(e.from,t)}return e},encodedAST=e=>encodedAST_(e,!1),encodedBoundAST=e=>encodedAST_(e,!0),toJSONAnnotations=e=>{const t={};for(const r of Object.getOwnPropertySymbols(e))t[r+""]=e[r];return t},getEncodedParameter=e=>{switch(e._tag){case"StringKeyword":case"SymbolKeyword":case"TemplateLiteral":return e;case"Refinement":return getEncodedParameter(e.from)}},equals$3=(e,t)=>{switch(e._tag){case"Literal":return JT(t)&&t.literal===e.literal;case"UniqueSymbol":return ZT(t)&&t.symbol===e.symbol;case"UndefinedKeyword":case"VoidKeyword":case"NeverKeyword":case"UnknownKeyword":case"AnyKeyword":case"StringKeyword":case"NumberKeyword":case"BooleanKeyword":case"BigIntKeyword":case"SymbolKeyword":case"ObjectKeyword":return t._tag===e._tag;case"TemplateLiteral":return wO(t)&&t.head===e.head&&qO(t.spans,e.spans);case"Enums":return vO(t)&&WO(t.enums,e.enums);case"Union":return AO(t)&&VO(e.types,t.types);case"Refinement":case"TupleType":case"TypeLiteral":case"Suspend":case"Transformation":case"Declaration":return e===t}},qO=Ts((e,t)=>e.literal===t.literal&&equals$3(e.type,t.type)),WO=Ts((e,t)=>t[0]===e[0]&&t[1]===e[1]),VO=Ts(equals$3),KO=intersectionWith(equals$3),_keyof=e=>{switch(e._tag){case"Declaration":{const t=BT(e);if(zt(t))return _keyof(t.value);break}case"TypeLiteral":return e.propertySignatures.map(e=>isSymbol$1(e.name)?new UniqueSymbol(e.name):new GT(e.name)).concat(e.indexSignatures.map(e=>getEncodedParameter(e.parameter)));case"Suspend":return _keyof(e.f());case"Union":return e.types.slice(1).reduce((e,t)=>KO(e,_keyof(t)),_keyof(e.types[0]));case"Transformation":return _keyof(e.to)}throw Error(getASTUnsupportedSchemaErrorMessage(e))},compose$4=(e,t)=>new jO(e,t,LO),rename$1=(e,t)=>{switch(e._tag){case"TypeLiteral":{const r=[];for(const e of Reflect.ownKeys(t)){const name=t[e];void 0!==name&&r.push(new $O(e,name,identity$5,identity$5))}return 0===r.length?e:new jO(e,new TypeLiteral(e.propertySignatures.map(e=>{const name=t[e.name];return new PropertySignature(void 0===name?e.name:name,typeAST(e.type),e.isOptional,e.isReadonly,e.annotations)}),e.indexSignatures),new TypeLiteralTransformation(r))}case"Union":return EO.make(e.types.map(e=>rename$1(e,t)));case"Suspend":return new Suspend(()=>rename$1(e.f(),t));case"Transformation":return compose$4(e,rename$1(typeAST(e),t))}throw Error((e=>getUnsupportedSchemaErrorMessage(void 0,void 0,e))(e))},formatKeyword=e=>Kt(getExpected(e),()=>e._tag),getOrElseExpected=e=>ET(e).pipe(Gt(()=>MT(e)),Gt(()=>AT(e)),er(t=>t+function(e){return qt(xT(e),{onNone:()=>"",onSome:e=>e.map(e=>` & Brand<${formatUnknown$1(e)}>`).join("")})}(e))),getExpected=e=>Gt(CT(e),()=>getOrElseExpected(e)),pruneUndefined$2=(e,t,r)=>{switch(e._tag){case"UndefinedKeyword":return tO;case"Union":{const r=[];let n=!1;for(const i of e.types){const e=t(i);e?(n=!0,rO(e)||r.push(e)):r.push(i)}if(n)return EO.make(r);break}case"Suspend":return t(e.f());case"Transformation":return r(e)}};var GO=Object.freeze({__proto__:null,AnyKeyword,ArbitraryAnnotationId:fT,AutoTitleAnnotationId:aT,BatchingAnnotationId:yT,BigIntKeyword,BooleanKeyword,BrandAnnotationId:tT,ComposeTransformation,ConcurrencyAnnotationId:gT,Declaration,DecodingFallbackAnnotationId:vT,DefaultAnnotationId:lT,DescriptionAnnotationId:uT,DocumentationAnnotationId:mT,Enums:SO,EquivalenceAnnotationId:dT,ExamplesAnnotationId:cT,FinalTransformation,IdentifierAnnotationId:sT,IndexSignature,JSONIdentifierAnnotationId:qT,JSONSchemaAnnotationId:pT,Literal:GT,MessageAnnotationId:nT,MissingMessageAnnotationId:iT,NeverKeyword,NumberKeyword,ObjectKeyword,OptionalType,ParseIssueTitleAnnotationId:bT,ParseJsonSchemaId:VT,ParseOptionsAnnotationId:ST,PrettyAnnotationId:hT,PropertySignature,PropertySignatureTransformation:$O,Refinement:FO,SchemaIdAnnotationId:rT,StableFilterAnnotationId:wT,StringKeyword,SurrogateAnnotationId:_T,Suspend,SymbolKeyword,TemplateLiteral:_O,TemplateLiteralSpan,TitleAnnotationId:oT,Transformation:jO,TupleType,Type:kO,TypeLiteral,TypeLiteralTransformation,UndefinedKeyword,Union:EO,UniqueSymbol,UnknownKeyword,VoidKeyword,annotations:annotations$2,anyKeyword:sO,bigIntKeyword:hO,booleanKeyword:pO,compose:compose$4,composeTransformation:LO,defaultParseOption:NO,encodedAST,encodedBoundAST,equals:equals$3,flatten:flatten$g,getAnnotation:kT,getAutoTitleAnnotation:AT,getBatchingAnnotation:DT,getBrandAnnotation:xT,getCompiler,getConcurrencyAnnotation:RT,getDecodingFallbackAnnotation:$T,getDefaultAnnotation:PT,getDescriptionAnnotation:MT,getDocumentationAnnotation:jT,getEncodedParameter,getExamplesAnnotation:FT,getIdentifierAnnotation:CT,getJSONIdentifier,getJSONIdentifierAnnotation:WT,getJSONSchemaAnnotation:NT,getMessageAnnotation:TT,getMissingMessageAnnotation:OT,getNumberIndexedAccess:getNumberIndexedAccess$1,getParseIssueTitleAnnotation:LT,getParseOptionsAnnotation:UT,getPropertyKeyIndexedAccess,getPropertySignatures,getSchemaIdAnnotation:IT,getSurrogateAnnotation:BT,getTemplateLiteralCapturingRegExp,getTemplateLiteralRegExp,getTitleAnnotation:ET,getTransformationFrom,hasStableFilter,isAnyKeyword:oO,isBigIntKeyword:dO,isBooleanKeyword:fO,isComposeTransformation:UO,isDeclaration:KT,isEnums:vO,isFinalTransformation:DO,isLiteral:JT,isMembers,isNeverKeyword:rO,isNumberKeyword:lO,isObjectKeyword:bO,isParameter,isRefinement:PO,isStringKeyword:uO,isSuspend:MO,isSymbolKeyword:gO,isTemplateLiteral:wO,isTransformation:RO,isTupleType:xO,isTypeLiteral:IO,isTypeLiteralTransformation:BO,isUndefinedKeyword:YT,isUnion:AO,isUniqueSymbol:ZT,isUnknownKeyword:iO,isVoidKeyword:eO,keyof:keyof$1,mapMembers,mutable:mutable$1,neverKeyword:tO,null:HT,numberKeyword:cO,objectKeyword:yO,omit:omit$4,omitAnnotations,orUndefined,partial:partial$1,pick:pick$4,pickAnnotations,pruneUndefined:pruneUndefined$2,record:record$1,rename:rename$1,required:required$1,stringKeyword:aO,symbolKeyword:mO,typeAST,undefinedKeyword:QT,unify:unify$1,unknownKeyword:nO,voidKeyword:XT});const makeLazy=e=>{const description=QO(e.ast,[]);return eE(description,{maxDepth:2})},makeStringConstraints=e=>{const t={_tag:"StringConstraints",constraints:{}};return isNumber$1(e.minLength)&&(t.constraints.minLength=e.minLength),isNumber$1(e.maxLength)&&(t.constraints.maxLength=e.maxLength),isString$1(e.pattern)&&(t.pattern=e.pattern),t},makeNumberConstraints=e=>{const t={_tag:"NumberConstraints",constraints:{},isInteger:e.isInteger??!1};return isNumber$1(e.min)&&(t.constraints.min=Math.fround(e.min)),isBoolean$1(e.minExcluded)&&(t.constraints.minExcluded=e.minExcluded),isNumber$1(e.max)&&(t.constraints.max=Math.fround(e.max)),isBoolean$1(e.maxExcluded)&&(t.constraints.maxExcluded=e.maxExcluded),isBoolean$1(e.noNaN)&&(t.constraints.noNaN=e.noNaN),isBoolean$1(e.noDefaultInfinity)&&(t.constraints.noDefaultInfinity=e.noDefaultInfinity),t},makeBigIntConstraints=e=>{const t={_tag:"BigIntConstraints",constraints:{}};return isBigInt$1(e.min)&&(t.constraints.min=e.min),isBigInt$1(e.max)&&(t.constraints.max=e.max),t},makeArrayConstraints=e=>{const t={_tag:"ArrayConstraints",constraints:{}};return isNumber$1(e.minLength)&&(t.constraints.minLength=e.minLength),isNumber$1(e.maxLength)&&(t.constraints.maxLength=e.maxLength),t},makeDateConstraints=e=>{const t={_tag:"DateConstraints",constraints:{}};return isDate(e.min)&&(t.constraints.min=e.min),isDate(e.max)&&(t.constraints.max=e.max),isBoolean$1(e.noInvalidDate)&&(t.constraints.noInvalidDate=e.noInvalidDate),t},JO=kT(fT),HO=globalValue(Symbol.for("effect/Arbitrary/IdMemoMap"),()=>new Map);let ZO=0;function wrapGetDescription(e,t){return(r,n)=>e(r,t(r,n))}const QO=wrapGetDescription((e,description)=>{const t=JO(e);return zt(t)?{...description,annotations:[...description.annotations,t.value]}:description},(e,t)=>{const[r,n]=function(e){const t=NT(e).pipe(yr(F),Qt),r=Kt(IT(e),()=>{});return[r,{...fromNullable$3(r).pipe(er(t=>e.annotations[t]),yr(F),Qt),...t}]}(e);switch(e._tag){case"Refinement":{const i=QO(e.from,t);switch(i._tag){case"StringKeyword":return{...i,constraints:[...i.constraints,makeStringConstraints(n)],refinements:[...i.refinements,e]};case"NumberKeyword":{const t=makeNumberConstraints(r===_I?{noNaN:!0}:r===wI||r===kI?{noDefaultInfinity:!0,noNaN:!0}:{isInteger:"type"in n&&"integer"===n.type,noNaN:void 0,noDefaultInfinity:void 0,min:n.exclusiveMinimum??n.minimum,minExcluded:"exclusiveMinimum"in n||void 0,max:n.exclusiveMaximum??n.maximum,maxExcluded:"exclusiveMaximum"in n||void 0});return{...i,constraints:[...i.constraints,t],refinements:[...i.refinements,e]}}case"BigIntKeyword":{const t=(e=>{const t=e.annotations[rT];if(isPropertyKey(t)){const r=e.annotations[t];if(F(r))return r}})(e);return{...i,constraints:void 0!==t?[...i.constraints,makeBigIntConstraints(t)]:i.constraints,refinements:[...i.refinements,e]}}case"TupleType":return{...i,constraints:[...i.constraints,makeArrayConstraints({minLength:n.minItems,maxLength:n.maxItems})],refinements:[...i.refinements,e]};case"DateFromSelf":return{...i,constraints:[...i.constraints,makeDateConstraints(n)],refinements:[...i.refinements,e]};default:return{...i,refinements:[...i.refinements,e]}}}case"Declaration":return r===mI?{_tag:"DateFromSelf",constraints:[makeDateConstraints(n)],path:t,refinements:[],annotations:[]}:{_tag:"Declaration",typeParameters:e.typeParameters.map(e=>QO(e,t)),path:t,refinements:[],annotations:[],ast:e};case"Literal":return{_tag:"Literal",literal:e.literal,path:t,refinements:[],annotations:[]};case"UniqueSymbol":return{_tag:"UniqueSymbol",symbol:e.symbol,path:t,refinements:[],annotations:[]};case"Enums":return{_tag:"Enums",enums:e.enums,path:t,refinements:[],annotations:[],ast:e};case"TemplateLiteral":return{_tag:"TemplateLiteral",head:e.head,spans:e.spans.map(e=>({description:QO(e.type,t),literal:e.literal})),path:t,refinements:[],annotations:[]};case"StringKeyword":return{_tag:"StringKeyword",constraints:[],path:t,refinements:[],annotations:[]};case"NumberKeyword":return{_tag:"NumberKeyword",constraints:[],path:t,refinements:[],annotations:[]};case"BigIntKeyword":return{_tag:"BigIntKeyword",constraints:[],path:t,refinements:[],annotations:[]};case"TupleType":return{_tag:"TupleType",constraints:[],elements:e.elements.map((e,r)=>({isOptional:e.isOptional,description:QO(e.type,[...t,r])})),rest:e.rest.map((e,r)=>QO(e.type,[...t,r])),path:t,refinements:[],annotations:[]};case"TypeLiteral":return{_tag:"TypeLiteral",propertySignatures:e.propertySignatures.map(e=>({isOptional:e.isOptional,name:e.name,value:QO(e.type,[...t,e.name])})),indexSignatures:e.indexSignatures.map(e=>({parameter:QO(e.parameter,t),value:QO(e.type,t)})),path:t,refinements:[],annotations:[]};case"Union":return{_tag:"Union",members:e.types.map((e,r)=>QO(e,[...t,r])),path:t,refinements:[],annotations:[]};case"Suspend":{const r=HO.get(e);if(void 0!==r)return{_tag:"Ref",id:r,ast:e,path:t,refinements:[],annotations:[]};ZO++;const n=`__id-${ZO}__`;return HO.set(e,n),{_tag:"Suspend",id:n,ast:e,description:()=>QO(e.f(),t),path:t,refinements:[],annotations:[]}}case"Transformation":return QO(e.to,t);case"NeverKeyword":return{_tag:"NeverKeyword",path:t,refinements:[],annotations:[],ast:e};default:return{_tag:"Keyword",value:e._tag,path:t,refinements:[],annotations:[]}}});function getMax(e,t){return void 0===e?t:void 0===t?e:e<=t?t:e}function getMin(e,t){return void 0===e?t:void 0===t||e<=t?e:t}const getOr=(e,t)=>void 0===e?t:void 0===t?e:e||t;function mergeStringConstraints(e,t){return makeStringConstraints({minLength:getMax(e.constraints.minLength,t.constraints.minLength),maxLength:getMin(e.constraints.maxLength,t.constraints.maxLength),pattern:(r=e.pattern,n=t.pattern,void 0===r?n:void 0===n?r:`(?:${r})|(?:${n})`)});var r,n}function buildStringConstraints(description){return 0===description.constraints.length?void 0:description.constraints.reduce(mergeStringConstraints)}function mergeNumberConstraints(e,t){return makeNumberConstraints({isInteger:e.isInteger||t.isInteger,min:getMax(e.constraints.min,t.constraints.min),minExcluded:getOr(e.constraints.minExcluded,t.constraints.minExcluded),max:getMin(e.constraints.max,t.constraints.max),maxExcluded:getOr(e.constraints.maxExcluded,t.constraints.maxExcluded),noNaN:getOr(e.constraints.noNaN,t.constraints.noNaN),noDefaultInfinity:getOr(e.constraints.noDefaultInfinity,t.constraints.noDefaultInfinity)})}function buildNumberConstraints(description){return 0===description.constraints.length?void 0:description.constraints.reduce(mergeNumberConstraints)}function mergeBigIntConstraints(e,t){return makeBigIntConstraints({min:getMax(e.constraints.min,t.constraints.min),max:getMin(e.constraints.max,t.constraints.max)})}function buildBigIntConstraints(description){return 0===description.constraints.length?void 0:description.constraints.reduce(mergeBigIntConstraints)}function mergeDateConstraints(e,t){return makeDateConstraints({min:getMax(e.constraints.min,t.constraints.min),max:getMin(e.constraints.max,t.constraints.max),noInvalidDate:getOr(e.constraints.noInvalidDate,t.constraints.noInvalidDate)})}function buildDateConstraints(description){return 0===description.constraints.length?void 0:description.constraints.reduce(mergeDateConstraints)}const YO=makeArrayConstraints({});function mergeArrayConstraints(e,t){return makeArrayConstraints({minLength:getMax(e.constraints.minLength,t.constraints.minLength),maxLength:getMin(e.constraints.maxLength,t.constraints.maxLength)})}function buildArrayConstraints(description){return 0===description.constraints.length?void 0:description.constraints.reduce(mergeArrayConstraints)}const XO=globalValue(Symbol.for("effect/Arbitrary/arbitraryMemoMap"),()=>new WeakMap);function applyFilters(e,t){return r=>e.reduce((e,t)=>e.filter(t),t(r))}function wrapGo(e,t){return(description,r)=>e(description,r,t(description,r))}const eE=wrapGo((description,e,t)=>{const r=description.annotations[description.annotations.length-1];if(void 0===r)switch(description._tag){case"Declaration":case"NeverKeyword":throw Error((n=description.path,i=description.ast,getMissingAnnotationErrorMessage('Generating an Arbitrary for this schema requires an "arbitrary" annotation',n,i)));case"Enums":if(0===description.enums.length)throw Error((e=>getErrorMessage$1("Empty Enums schema","Generating an Arbitrary for this schema requires at least one enum",e))(description.path))}var n,i;const s=description.refinements.map(e=>t=>Bt(e.filter(t,NO,e)));if(void 0===r)return applyFilters(s,t);const o=function(description){switch(description._tag){case"StringKeyword":return buildStringConstraints(description);case"NumberKeyword":return buildNumberConstraints(description);case"BigIntKeyword":return buildBigIntConstraints(description);case"DateFromSelf":return buildDateConstraints(description);case"TupleType":return buildArrayConstraints(description)}}(description);return void 0!==o&&(e={...e,constraints:o}),"Declaration"===description._tag?applyFilters(s,r(...description.typeParameters.map(t=>eE(t,e)),e)):description.refinements.length>0?applyFilters(s,r(t,e)):r(e)},(description,e)=>{switch(description._tag){case"DateFromSelf":{const e=buildDateConstraints(description);return t=>t.date(e?.constraints)}case"Declaration":case"NeverKeyword":return t="BUG: cannot generate an arbitrary for "+description._tag,()=>{throw Error(t)};case"Literal":return e=>e.constant(description.literal);case"UniqueSymbol":return e=>e.constant(description.symbol);case"Keyword":switch(description.value){case"UndefinedKeyword":return e=>e.constant(void 0);case"VoidKeyword":case"UnknownKeyword":case"AnyKeyword":return e=>e.anything();case"BooleanKeyword":return e=>e.boolean();case"SymbolKeyword":return e=>e.string().map(e=>Symbol.for(e));case"ObjectKeyword":return e=>e.oneof(e.object(),e.array(e.anything()))}case"Enums":return e=>e.oneof(...description.enums.map(([t,r])=>e.constant(r)));case"TemplateLiteral":return e=>{const t=e.string({maxLength:5}),r=e.float({noDefaultInfinity:!0,noNaN:!0}),getTemplateLiteralArb=description=>{const n=""!==description.head?[e.constant(description.head)]:[],getTemplateLiteralSpanTypeArb=description=>{switch(description._tag){case"StringKeyword":return t;case"NumberKeyword":return r;case"Literal":return e.constant(description.literal+"");case"Union":return e.oneof(...description.members.map(getTemplateLiteralSpanTypeArb));case"TemplateLiteral":return getTemplateLiteralArb(description);default:return e.constant("")}};return description.spans.forEach(t=>{n.push(getTemplateLiteralSpanTypeArb(t.description)),""!==t.literal&&n.push(e.constant(t.literal))}),e.tuple(...n).map(e=>e.join(""))};return getTemplateLiteralArb(description)};case"StringKeyword":{const e=buildStringConstraints(description),t=e?.pattern;return void 0!==t?e=>e.stringMatching(RegExp(t)):t=>t.string(e?.constraints)}case"NumberKeyword":{const e=buildNumberConstraints(description);return e?.isInteger?t=>t.integer(e.constraints):t=>t.float(e?.constraints)}case"BigIntKeyword":{const e=buildBigIntConstraints(description);return t=>t.bigInt(e?.constraints??{})}case"TupleType":{const t=[];let r=!1;for(const n of description.elements)t.push(eE(n.description,e)),n.isOptional&&(r=!0);const n=description.rest.map(t=>eE(t,e));return i=>{let s=i.tuple(...t.map(e=>e(i)));if(r){const e=i.tuple(...description.elements.map(e=>e.isOptional?i.boolean():i.constant(!0)));s=s.chain(t=>e.map(e=>{for(const[r,n]of e.reverse().entries())n||t.splice(e.length-r,1);return t}))}if(ci(n)){const t=buildArrayConstraints(description)??YO,[r,...o]=n,a=r(i);s=s.chain(r=>{const n=r.length,s=function(e,t){if(0===t||void 0===e.minLength&&void 0===e.maxLength)return e;const r={...e};return void 0!==r.minLength&&(r.minLength=Math.max(r.minLength-t,0)),void 0!==r.maxLength&&(r.maxLength=Math.max(r.maxLength-t,0)),r}(t.constraints,n);if(0===s.maxLength)return i.constant(r);const o=void 0!==e.depthIdentifier?getSuspendedArray(i,e.depthIdentifier,e.maxDepth,a,s):i.array(a,s);return 0===n?o:o.map(e=>[...r,...e])});for(let e=0;e<o.length;e++)s=s.chain(t=>o[e](i).map(e=>[...t,e]))}return s}}case"TypeLiteral":{const t=[],r=[];for(const n of description.propertySignatures)n.isOptional||r.push(n.name),t.push(eE(n.value,e));const n=description.indexSignatures.map(t=>[eE(t.parameter,e),eE(t.value,e)]);return i=>{const s={};for(let e=0;e<t.length;e++)s[description.propertySignatures[e].name]=t[e](i);let o=i.record(s,{requiredKeys:r});for(let t=0;t<n.length;t++){const r=n[t][0](i),s=n[t][1](i);o=o.chain(t=>{const n=i.tuple(r,s);return(void 0!==e.depthIdentifier?getSuspendedArray(i,e.depthIdentifier,e.maxDepth,n,{maxLength:2}):i.array(n)).map(e=>({...Object.fromEntries(e),...t}))})}return o}}case"Union":{const t=description.members.map(t=>eE(t,e));return e=>e.oneof(...t.map(t=>t(e)))}case"Suspend":{const t=XO.get(description.ast);if(t)return t;void 0===e.depthIdentifier&&(e={...e,depthIdentifier:description.id});const r=memoizeThunk(()=>eE(description.description(),e)),out=e=>e.constant(null).chain(()=>r()(e));return XO.set(description.ast,out),out}case"Ref":{const e=XO.get(description.ast);if(e)return e;throw Error(`BUG: Ref ${JSON.stringify(description.id)} not found`)}}var t}),getSuspendedArray=(e,t,r,n,i)=>{const s=Math.max(2,i.minLength??0);return void 0!==i.maxLength&&i.maxLength>s&&(i={...i,maxLength:s}),e.oneof({maxDepth:r,depthIdentifier:t},e.constant([]),e.array(n,i))};var tE=Object.freeze({__proto__:null,getDescription:QO,make:e=>makeLazy(e)(pI),makeArrayConstraints,makeBigIntConstraints,makeDateConstraints,makeLazy,makeNumberConstraints,makeStringConstraints});const rE=/^[+-]?\d+$/,nE=Symbol.for("effect/BigDecimal"),iE={[nE]:nE,[Z](){const e=normalize$1(this);return pipe(hash$3(e.value),combine$h(number$4(e.scale)),cached$2(this))},[Y](e){return isBigDecimal(e)&&OE(this,e)},toString(){return`BigDecimal(${format$5(this)})`},toJSON(){return{_id:"BigDecimal",value:this.value+"",scale:this.scale}},[ee](){return this.toJSON()},pipe(){return pipeArguments(this,arguments)}},isBigDecimal=e=>C(e,nE),make$2g=(e,t)=>{const r=Object.create(iE);return r.value=e,r.scale=t,r},unsafeMakeNormalized=(e,t)=>{if(e!==sE&&e%aE===sE)throw new RangeError("Value must be normalized");const r=make$2g(e,t);return r.normalized=r,r},sE=BigInt(0),oE=BigInt(1),aE=BigInt(10),uE=unsafeMakeNormalized(sE,0),normalize$1=e=>{if(void 0===e.normalized)if(e.value===sE)e.normalized=uE;else{const t=""+e.value;let r=0;for(let e=t.length-1;e>=0&&"0"===t[e];e--)r++;0===r&&(e.normalized=e);const n=BigInt(t.substring(0,t.length-r)),i=e.scale-r;e.normalized=unsafeMakeNormalized(n,i)}return e.normalized},cE=dual(2,(e,t)=>t>e.scale?make$2g(e.value*aE**BigInt(t-e.scale),t):t<e.scale?make$2g(e.value/aE**BigInt(e.scale-t),t):e),lE=dual(2,(e,t)=>t.value===sE?e:e.value===sE?t:e.scale>t.scale?make$2g(cE(t,e.scale).value+e.value,e.scale):e.scale<t.scale?make$2g(cE(e,t.scale).value+t.value,t.scale):make$2g(e.value+t.value,e.scale)),pE=dual(2,(e,t)=>t.value===sE||e.value===sE?uE:make$2g(e.value*t.value,e.scale+t.scale)),fE=dual(2,(e,t)=>t.value===sE?e:e.value===sE?make$2g(-t.value,t.scale):e.scale>t.scale?make$2g(e.value-cE(t,e.scale).value,e.scale):e.scale<t.scale?make$2g(cE(e,t.scale).value-t.value,t.scale):make$2g(e.value-t.value,e.scale)),divideWithPrecision=(e,t,r,n)=>{const i=e<sE,s=t<sE,o=i!==s;for(e=i?-e:e,t=s?-t:t;e<t;)e*=aE,r++;let a=e/t,u=e%t;if(u===sE)return make$2g(o?-a:a,r);let c=(""+a).length;for(u*=aE;u!==sE&&c<n;)a=a*aE+u/t,u=u%t*aE,c++,r++;return u!==sE&&(a+=roundTerminal(u/t)),make$2g(o?-a:a,r)},roundTerminal=e=>Number((""+e)[e>=sE?0:1])<5?sE:oE,hE=dual(2,(e,t)=>{if(t.value===sE)return none$c();if(e.value===sE)return Ut(uE);const r=e.scale-t.scale;return e.value===t.value?Ut(make$2g(oE,r)):Ut(divideWithPrecision(e.value,t.value,r,100))}),dE=dual(2,(e,t)=>{if(t.value===sE)throw new RangeError("Division by zero");if(e.value===sE)return uE;const r=e.scale-t.scale;return e.value===t.value?make$2g(oE,r):divideWithPrecision(e.value,t.value,r,100)}),mE=make$2k((e,t)=>{const r=Et(sign$1(e),sign$1(t));return 0!==r?r:e.scale>t.scale?Ct(e.value,cE(t,e.scale).value):e.scale<t.scale?Ct(cE(e,t.scale).value,t.value):Ct(e.value,t.value)}),gE=lessThan$e(mE),yE=lessThanOrEqualTo$7(mE),bE=greaterThan$a(mE),SE=greaterThanOrEqualTo$7(mE),vE=between$7(mE),_E=clamp$8(mE),wE=min$9(mE),kE=max$b(mE),sign$1=e=>e.value===sE?0:e.value<sE?-1:1,abs$1=e=>e.value<sE?make$2g(-e.value,e.scale):e,xE=dual(2,(e,t)=>{if(t.value===sE)return none$c();const r=Math.max(e.scale,t.scale);return Ut(make$2g(cE(e,r).value%cE(t,r).value,r))}),IE=dual(2,(e,t)=>{if(t.value===sE)throw new RangeError("Division by zero");const r=Math.max(e.scale,t.scale);return make$2g(cE(e,r).value%cE(t,r).value,r)}),TE=make$2l((e,t)=>e.scale>t.scale?cE(t,e.scale).value===e.value:e.scale<t.scale?cE(e,t.scale).value===t.value:e.value===t.value),OE=dual(2,(e,t)=>TE(e,t)),unsafeFromNumber=e=>Yt(safeFromNumber(e),()=>new RangeError("Number must be finite, got "+e)),EE=unsafeFromNumber,safeFromNumber=e=>{if(!Number.isFinite(e))return none$c();const t=""+e;if(t.includes("e"))return fromString$3(t);const[r,n=""]=t.split(".");return Ut(make$2g(BigInt(`${r}${n}`),n.length))},fromString$3=e=>{if(""===e)return Ut(uE);let t,r;const n=e.search(/[eE]/);if(-1!==n){const i=e.slice(n+1);if(t=e.slice(0,n),r=Number(i),""===t||!Number.isSafeInteger(r)||!rE.test(i))return none$c()}else t=e,r=0;let i,s;const o=t.search(/\./);if(-1!==o){const e=t.slice(0,o),r=t.slice(o+1);i=`${e}${r}`,s=r.length}else i=t,s=0;if(!rE.test(i))return none$c();const a=s-r;return Number.isSafeInteger(a)?Ut(make$2g(BigInt(i),a)):none$c()},format$5=e=>{const t=normalize$1(e);if(Math.abs(t.scale)>=16)return toExponential(t);const r=t.value<sE,n=r?(""+t.value).substring(1):""+t.value;let i,s;if(t.scale>=n.length)i="0",s="0".repeat(t.scale-n.length)+n;else{const e=n.length-t.scale;if(e>n.length){const t=e-n.length;i=`${n}${"0".repeat(t)}`,s=""}else s=n.slice(e),i=n.slice(0,e)}const o=""===s?i:`${i}.${s}`;return r?"-"+o:o},toExponential=e=>{if(isZero$1(e))return"0e+0";const t=normalize$1(e),r=""+abs$1(t).value,n=r.slice(0,1),i=r.slice(1);let s=`${isNegative(t)?"-":""}${n}`;""!==i&&(s+="."+i);const o=i.length-t.scale;return`${s}e${o>=0?"+":""}${o}`},unsafeToNumber=e=>Number(format$5(e)),isZero$1=e=>e.value===sE,isNegative=e=>e.value<sE,isPositive=e=>e.value>sE,isBigDecimalArgs=e=>isBigDecimal(e[0]),AE=dual(isBigDecimalArgs,(e,t=0)=>{const r=ME(e,t);return isPositive(e)&&gE(r,e)?lE(r,make$2g(1n,t)):r}),CE=dual(isBigDecimalArgs,(e,t=0)=>{const r=ME(e,t);return isNegative(e)&&bE(r,e)?lE(r,make$2g(-1n,t)):r}),ME=dual(isBigDecimalArgs,(e,t=0)=>e.scale<=t?e:make$2g(e.value/10n**BigInt(e.scale-t),t)),FE=dual(2,(e,t)=>e.scale<t?0n:e.value/10n**BigInt(e.scale-t)%10n),PE=dual(isBigDecimalArgs,(e,t)=>{const r=t?.mode??"half-from-zero",n=t?.scale??0;switch(r){case"ceil":return AE(e,n);case"floor":return CE(e,n);case"to-zero":return ME(e,n);case"from-zero":return isPositive(e)?AE(e,n):CE(e,n);case"half-ceil":return CE(lE(e,make$2g(5n,n+1)),n);case"half-floor":return AE(lE(e,make$2g(-5n,n+1)),n);case"half-to-zero":return isNegative(e)?CE(lE(e,make$2g(5n,n+1)),n):AE(lE(e,make$2g(-5n,n+1)),n);case"half-from-zero":return isNegative(e)?AE(lE(e,make$2g(-5n,n+1)),n):CE(lE(e,make$2g(5n,n+1)),n)}const i=CE(lE(e,make$2g(5n,n+1)),n),s=AE(lE(e,make$2g(-5n,n+1)),n),o=FE(i,n);switch(r){case"half-even":return OE(i,s)||o%2n==0n?i:s;case"half-odd":return OE(i,s)?i:o%2n==0n?s:i}});var NE=Object.freeze({__proto__:null,Equivalence:TE,Order:mE,TypeId:nE,abs:abs$1,between:vE,ceil:AE,clamp:_E,digitAt:FE,divide:hE,equals:OE,floor:CE,format:format$5,fromBigInt:e=>make$2g(e,0),fromNumber:EE,fromString:fromString$3,greaterThan:bE,greaterThanOrEqualTo:SE,isBigDecimal,isInteger:e=>normalize$1(e).scale<=0,isNegative,isPositive,isZero:isZero$1,lessThan:gE,lessThanOrEqualTo:yE,make:make$2g,max:kE,min:wE,multiply:pE,negate:e=>make$2g(-e.value,e.scale),normalize:normalize$1,remainder:xE,round:PE,roundTerminal,safeFromNumber,scale:cE,sign:sign$1,subtract:fE,sum:lE,sumAll:e=>{let t=uE;for(const r of e)t=lE(t,r);return t},toExponential,truncate:ME,unsafeDivide:dE,unsafeFromNumber,unsafeFromString:e=>Yt(fromString$3(e),()=>Error("Invalid numerical string")),unsafeMakeNormalized,unsafeRemainder:IE,unsafeToNumber});const jE=BigInt(0),RE=BigInt(1),DE=BigInt(2),LE=isBigInt$1,UE=dual(2,(e,t)=>e+t),$E=dual(2,(e,t)=>e*t),BE=dual(2,(e,t)=>e-t),zE=dual(2,(e,t)=>t===jE?none$c():Ut(e/t)),qE=dual(2,(e,t)=>e/t),WE=m,VE=Ct,KE=lessThan$e(VE),GE=lessThanOrEqualTo$7(VE),JE=greaterThan$a(VE),HE=greaterThanOrEqualTo$7(VE),ZE=between$7(VE),QE=clamp$8(VE),YE=min$9(VE),XE=max$b(VE),eA=dual(2,(e,t)=>{for(;t!==jE;){const r=t;t=e%t,e=r}return e}),tA=dual(2,(e,t)=>e*t/eA(e,t)),unsafeSqrt=e=>{if(e<jE)throw new RangeError("Cannot take the square root of a negative number");if(e<DE)return e;let t=e/DE;for(;t*t>e;)t=(e/t+t)/DE;return t},toNumber=e=>e>BigInt(Number.MAX_SAFE_INTEGER)||e<BigInt(Number.MIN_SAFE_INTEGER)?none$c():Ut(Number(e)),fromString$2=e=>{try{return""===e.trim()?none$c():Ut(BigInt(e))}catch{return none$c()}},fromNumber=e=>{if(e>Number.MAX_SAFE_INTEGER||e<Number.MIN_SAFE_INTEGER)return none$c();try{return Ut(BigInt(e))}catch{return none$c()}};var rA=Object.freeze({__proto__:null,Equivalence:WE,Order:VE,abs:e=>e<jE?-e:e,between:ZE,clamp:QE,decrement:e=>e-RE,divide:zE,fromNumber,fromString:fromString$2,gcd:eA,greaterThan:JE,greaterThanOrEqualTo:HE,increment:e=>e+RE,isBigInt:LE,lcm:tA,lessThan:KE,lessThanOrEqualTo:GE,max:XE,min:YE,multiply:$E,multiplyAll:e=>{let t=RE;for(const r of e){if(r===jE)return jE;t*=r}return t},sign:e=>VE(e,jE),sqrt:e=>HE(e,jE)?Ut(unsafeSqrt(e)):none$c(),subtract:BE,sum:UE,sumAll:e=>{let t=jE;for(const r of e)t+=r;return t},toNumber,unsafeDivide:qE,unsafeSqrt});const nA=isBoolean$1,iA=dual(2,(e,t)=>e?t.onTrue():t.onFalse()),sA=d,oA=At,not$2=e=>!e,aA=dual(2,(e,t)=>e&&t),uA=dual(2,(e,t)=>!(e&&t)),cA=dual(2,(e,t)=>e||t),lA=dual(2,(e,t)=>!(e||t)),pA=dual(2,(e,t)=>!e&&t||e&&!t);var fA=Object.freeze({__proto__:null,Equivalence:sA,Order:oA,and:aA,eqv:dual(2,(e,t)=>!pA(e,t)),every:e=>{for(const t of e)if(!t)return!1;return!0},implies:dual(2,(e,t)=>!e||t),isBoolean:nA,match:iA,nand:uA,nor:lA,not:not$2,or:cA,some:e=>{for(const t of e)if(t)return!0;return!1},xor:pA});const hA=Symbol.for("effect/Brand"),dA=Symbol.for("effect/Brand/Refined");var mA=Object.freeze({__proto__:null,BrandTypeId:hA,RefinedConstructorsTypeId:dA,all:(...e)=>{const either=t=>{let r=Ge(t);for(const n of e){const e=n.either(t);r=Xe(r)&&Xe(e)?He([...r.left,...e.left]):Xe(r)?r:e}return r};return Object.assign(e=>ot(either(e),{onLeft:e=>{throw e},onRight:identity$5}),{[dA]:dA,option:e=>Wt(either(e)),either,is:e=>et(either(e))})},error:(e,t)=>[{message:e,meta:t}],errors:(...e)=>cs(e),nominal:()=>Object.assign(e=>e,{[dA]:dA,option:e=>Ut(e),either:e=>Ge(e),is:e=>!0}),refined:function(...e){const t=2===e.length?t=>e[0](t)?Ge(t):He(e[1](t)):t=>qt(e[0](t),{onNone:()=>Ge(t),onSome:He});return Object.assign(e=>ht(t(e),identity$5),{[dA]:dA,option:e=>Wt(t(e)),either:t,is:e=>et(t(e))})},unbranded:t});const gA=Symbol.for("effect/Context/Tag"),yA=Symbol.for("effect/Context/Reference"),bA=Symbol.for("effect/STM"),SA={...Ae,_op:"Tag",[bA]:Ee,[gA]:{_Service:e=>e,_Identifier:e=>e},toString(){return format$6(this.toJSON())},toJSON(){return{_id:"Tag",key:this.key,stack:this.stack}},[ee](){return this.toJSON()},of:e=>e,context(e){return make$2f(this,e)}},vA={...SA,[yA]:yA},_A=Symbol.for("effect/Context"),wA={[_A]:{_Services:e=>e},[Y](e){if(isContext$1(e)&&this.unsafeMap.size===e.unsafeMap.size){for(const t of this.unsafeMap.keys())if(!e.unsafeMap.has(t)||!equals$4(this.unsafeMap.get(t),e.unsafeMap.get(t)))return!1;return!0}return!1},[Z](){return cached$2(this,number$4(this.unsafeMap.size))},pipe(){return pipeArguments(this,arguments)},toString(){return format$6(this.toJSON())},toJSON(){return{_id:"Context",services:Array.from(this.unsafeMap).map(toJSON)}},[ee](){return this.toJSON()}},makeContext$1=e=>{const t=Object.create(wA);return t.unsafeMap=e,t},isContext$1=e=>C(e,_A),isReference$1=e=>C(e,yA),kA=makeContext$1(new Map),make$2f=(e,t)=>makeContext$1(new Map([[e.key,t]])),xA=dual(3,(e,t,r)=>{const n=new Map(e.unsafeMap);return n.set(t.key,r),makeContext$1(n)}),IA=globalValue("effect/Context/defaultValueCache",()=>new Map),getDefaultValue=e=>{if(IA.has(e.key))return IA.get(e.key);const t=e.defaultValue();return IA.set(e.key,t),t},TA=dual(2,(e,t)=>{if(!e.unsafeMap.has(t.key)){if(yA in t)return getDefaultValue(t);throw(e=>{const t=Error("Service not found"+(e.key?": "+e.key:""));if(e.stack){const r=e.stack.split("\n");if(r.length>2){const e=r[2].match(/at (.*)/);e&&(t.message=t.message+` (defined at ${e[1]})`)}}if(t.stack){const e=t.stack.split("\n");e.splice(1,3),t.stack=e.join("\n")}return t})(t)}return e.unsafeMap.get(t.key)}),OA=TA,EA=dual(3,(e,t,r)=>e.unsafeMap.has(t.key)?e.unsafeMap.get(t.key):isReference$1(t)?getDefaultValue(t):r()),AA=dual(2,(e,t)=>e.unsafeMap.has(t.key)?some$k(e.unsafeMap.get(t.key)):isReference$1(t)?some$k(getDefaultValue(t)):$e),CA=dual(2,(e,t)=>{const r=new Map(e.unsafeMap);for(const[e,n]of t.unsafeMap)r.set(e,n);return makeContext$1(r)}),GenericTag=e=>{const t=Error.stackTraceLimit;Error.stackTraceLimit=2;const r=Error();Error.stackTraceLimit=t;const n=Object.create(SA);return Object.defineProperty(n,"stack",{get:()=>r.stack}),n.key=e,n},MA=makeContext$1,FA=isContext$1,isTag=e=>C(e,gA),empty$S=()=>kA,PA=make$2f,NA=xA,jA=OA,RA=TA,DA=AA,LA=CA,pick$2=(...e)=>t=>{const r=new Set(e.map(e=>e.key)),n=new Map;for(const[e,i]of t.unsafeMap.entries())r.has(e)&&n.set(e,i);return makeContext$1(n)},Tag$3=e=>()=>{const t=Error.stackTraceLimit;Error.stackTraceLimit=2;const r=Error();function TagClass(){}return Error.stackTraceLimit=t,Object.setPrototypeOf(TagClass,SA),TagClass.key=e,Object.defineProperty(TagClass,"stack",{get:()=>r.stack}),TagClass},Reference=()=>(e,t)=>{const r=Error.stackTraceLimit;Error.stackTraceLimit=2;const n=Error();function ReferenceClass(){}return Error.stackTraceLimit=r,Object.setPrototypeOf(ReferenceClass,vA),ReferenceClass.key=e,ReferenceClass.defaultValue=t.defaultValue,Object.defineProperty(ReferenceClass,"stack",{get:()=>n.stack}),ReferenceClass};var UA=Object.freeze({__proto__:null,GenericTag,Reference,ReferenceTypeId:yA,Tag:Tag$3,TagTypeId:gA,add:NA,empty:empty$S,get:jA,getOption:DA,getOrElse:EA,isContext:FA,isReference:isReference$1,isTag,make:PA,merge:LA,mergeAll:(...e)=>{const t=new Map;for(const r of e)for(const[e,n]of r.unsafeMap)t.set(e,n);return makeContext$1(t)},omit:(...e)=>t=>{const r=new Map(t.unsafeMap);for(const t of e)r.delete(t.key);return makeContext$1(r)},pick:pick$2,unsafeGet:RA,unsafeMake:MA});const $A=Symbol.for("effect/Chunk"),BA=[],getEquivalence$4=e=>make$2l((t,r)=>t.length===r.length&&toReadonlyArray$1(t).every((t,n)=>e(t,KA(r,n)))),zA=getEquivalence$4(equals$4),qA={[$A]:{_A:e=>e},toString(){return format$6(this.toJSON())},toJSON(){return{_id:"Chunk",values:toReadonlyArray$1(this).map(toJSON)}},[ee](){return this.toJSON()},[Y](e){return isChunk(e)&&zA(this,e)},[Z](){return cached$2(this,array$6(toReadonlyArray$1(this)))},[Symbol.iterator](){switch(this.backing._tag){case"IArray":return this.backing.array[Symbol.iterator]();case"IEmpty":return BA[Symbol.iterator]();default:return toReadonlyArray$1(this)[Symbol.iterator]()}},pipe(){return pipeArguments(this,arguments)}},makeChunk=e=>{const t=Object.create(qA);switch(t.backing=e,e._tag){case"IEmpty":t.length=0,t.depth=0,t.left=t,t.right=t;break;case"IConcat":t.length=e.left.length+e.right.length,t.depth=1+Math.max(e.left.depth,e.right.depth),t.left=e.left,t.right=e.right;break;case"IArray":t.length=e.array.length,t.depth=0,t.left=WA,t.right=WA;break;case"ISingleton":t.length=1,t.depth=0,t.left=WA,t.right=WA;break;case"ISlice":t.length=e.length,t.depth=e.chunk.depth+1,t.left=WA,t.right=WA}return t},isChunk=e=>C(e,$A),WA=makeChunk({_tag:"IEmpty"}),empty$R=()=>WA,make$2d=(...e)=>unsafeFromNonEmptyArray(e),of$5=e=>makeChunk({_tag:"ISingleton",a:e}),fromIterable$u=e=>isChunk(e)?e:unsafeFromArray(fromIterable$v(e)),copyToArray=(e,t,r)=>{switch(e.backing._tag){case"IArray":!function(e,t,r,n,i){for(let t=0;t<Math.min(e.length,0+i);t++)r[n+t-0]=e[t]}(e.backing.array,0,t,r,e.length);break;case"IConcat":copyToArray(e.left,t,r),copyToArray(e.right,t,r+e.left.length);break;case"ISingleton":t[r]=e.backing.a;break;case"ISlice":{let n=0,i=r;for(;n<e.length;)t[i]=KA(e,n),n+=1,i+=1;break}}},toArray$9=e=>toReadonlyArray$1(e).slice(),toReadonlyArray$1=e=>{switch(e.backing._tag){case"IEmpty":return BA;case"IArray":return e.backing.array;default:{const t=Array(e.length);return copyToArray(e,t,0),e.backing={_tag:"IArray",array:t},e.left=WA,e.right=WA,e.depth=0,t}}},reverse$3=e=>{switch(e.backing._tag){case"IEmpty":case"ISingleton":return e;case"IArray":return makeChunk({_tag:"IArray",array:reverse$4(e.backing.array)});case"IConcat":return makeChunk({_tag:"IConcat",left:reverse$3(e.backing.right),right:reverse$3(e.backing.left)});case"ISlice":return unsafeFromArray(reverse$4(toReadonlyArray$1(e)))}},VA=dual(2,(e,t)=>t<0||t>=e.length?none$c():Ut(KA(e,t))),unsafeFromArray=e=>0===e.length?empty$R():1===e.length?of$5(e[0]):makeChunk({_tag:"IArray",array:e}),unsafeFromNonEmptyArray=e=>unsafeFromArray(e),KA=dual(2,(e,t)=>{switch(e.backing._tag){case"IEmpty":throw Error("Index out of bounds");case"ISingleton":if(0!==t)throw Error("Index out of bounds");return e.backing.a;case"IArray":if(t>=e.length||t<0)throw Error("Index out of bounds");return e.backing.array[t];case"IConcat":return t<e.left.length?KA(e.left,t):KA(e.right,t-e.left.length);case"ISlice":return KA(e.backing.chunk,t+e.backing.offset)}}),GA=dual(2,(e,t)=>eC(e,of$5(t))),JA=dual(2,(e,t)=>eC(of$5(t),e)),HA=dual(2,(e,t)=>{if(t<=0)return WA;if(t>=e.length)return e;switch(e.backing._tag){case"ISlice":return makeChunk({_tag:"ISlice",chunk:e.backing.chunk,length:t,offset:e.backing.offset});case"IConcat":return t>e.left.length?makeChunk({_tag:"IConcat",left:e.left,right:HA(e.right,t-e.left.length)}):HA(e.left,t);default:return makeChunk({_tag:"ISlice",chunk:e,offset:0,length:t})}}),ZA=dual(2,(e,t)=>{if(t<=0)return e;if(t>=e.length)return WA;switch(e.backing._tag){case"ISlice":return makeChunk({_tag:"ISlice",chunk:e.backing.chunk,offset:e.backing.offset+t,length:e.backing.length-t});case"IConcat":return t>e.left.length?ZA(e.right,t-e.left.length):makeChunk({_tag:"IConcat",left:ZA(e.left,t),right:e.right});default:return makeChunk({_tag:"ISlice",chunk:e,offset:t,length:e.length-t})}}),QA=dual(2,(e,t)=>HA(e,Math.max(0,e.length-t))),YA=dual(2,(e,t)=>{const r=toReadonlyArray$1(e),n=r.length;let i=0;for(;i<n&&t(r[i]);)i++;return ZA(e,i)}),XA=dual(2,(e,t)=>eC(t,e)),eC=dual(2,(e,t)=>{if("IEmpty"===e.backing._tag)return t;if("IEmpty"===t.backing._tag)return e;const r=t.depth-e.depth;if(Math.abs(r)<=1)return makeChunk({_tag:"IConcat",left:e,right:t});if(r<-1){if(e.left.depth>=e.right.depth){const r=eC(e.right,t);return makeChunk({_tag:"IConcat",left:e.left,right:r})}{const r=eC(e.right.right,t);if(r.depth===e.depth-3){const t=makeChunk({_tag:"IConcat",left:e.right.left,right:r});return makeChunk({_tag:"IConcat",left:e.left,right:t})}{const t=makeChunk({_tag:"IConcat",left:e.left,right:e.right.left});return makeChunk({_tag:"IConcat",left:t,right:r})}}}if(t.right.depth>=t.left.depth){const r=eC(e,t.left);return makeChunk({_tag:"IConcat",left:r,right:t.right})}{const r=eC(e,t.left.left);if(r.depth===t.depth-3){const e=makeChunk({_tag:"IConcat",left:r,right:t.left.right});return makeChunk({_tag:"IConcat",left:e,right:t.right})}{const e=makeChunk({_tag:"IConcat",left:t.left.right,right:t.right});return makeChunk({_tag:"IConcat",left:r,right:e})}}}),tC=dual(2,(e,t)=>unsafeFromArray(ls(e,t))),rC=dual(2,(e,t)=>unsafeFromArray(ds(e,t))),nC=dual(2,(e,t)=>unsafeFromArray(ps(e,t))),iC=dual(2,(e,t)=>{if("ISingleton"===e.backing._tag)return t(e.backing.a,0);let r=WA,n=0;for(const i of e)r=eC(r,t(i,n++));return r}),sC=dual(2,(e,t)=>toReadonlyArray$1(e).forEach(t)),oC=iC(identity$5),aC=dual(2,(e,t)=>{const r=[];let n=[];return toReadonlyArray$1(e).forEach(e=>{n.push(e),n.length>=t&&(r.push(unsafeFromArray(n)),n=[])}),n.length>0&&r.push(unsafeFromArray(n)),unsafeFromArray(r)}),uC=dual(2,(e,t)=>unsafeFromArray(ss(toReadonlyArray$1(e),toReadonlyArray$1(t)))),isEmpty$t=e=>0===e.length,isNonEmpty$8=e=>e.length>0,cC=VA(0),unsafeHead$1=e=>KA(e,0),lC=unsafeHead$1,last$5=e=>VA(e,e.length-1),unsafeLast$1=e=>KA(e,e.length-1),pC=unsafeLast$1,fC=dual(2,(e,t)=>"ISingleton"===e.backing._tag?of$5(t(e.backing.a,0)):unsafeFromArray(pipe(toReadonlyArray$1(e),as((e,r)=>t(e,r))))),hC=dual(3,(e,t,r)=>{const[n,i]=Fs(e,t,r);return[n,unsafeFromArray(i)]}),dC=dual(2,(e,t)=>pipe(ms(toReadonlyArray$1(e),t),([e,t])=>[unsafeFromArray(e),unsafeFromArray(t)])),mC=dual(2,(e,t)=>pipe(fs(toReadonlyArray$1(e),t),([e,t])=>[unsafeFromArray(e),unsafeFromArray(t)])),gC=dual(2,(e,t)=>unsafeFromArray(Ni(toReadonlyArray$1(e),t))),yC=dual(3,(e,t,r)=>gC(e,Pt(r,t))),bC=dual(2,(e,t)=>[HA(e,t),ZA(e,t)]),SC=dual(2,(e,t)=>{const r=Math.max(1,Math.floor(t));return r>=e.length?[e,empty$R()]:[HA(e,r),ZA(e,r)]}),vC=dual(2,(e,t)=>aC(e,Math.ceil(e.length/Math.floor(t)))),_C=dual(2,(e,t)=>{let r=0;for(const n of toReadonlyArray$1(e)){if(t(n))break;r++}return bC(e,r)}),tailNonEmpty=e=>ZA(e,1),wC=dual(2,(e,t)=>ZA(e,e.length-t)),kC=dual(2,(e,t)=>{const r=[];for(const n of toReadonlyArray$1(e)){if(!t(n))break;r.push(n)}return unsafeFromArray(r)}),xC=dual(2,(e,t)=>unsafeFromArray(is(toReadonlyArray$1(e),toReadonlyArray$1(t)))),IC=dual(3,(e,t,r)=>unsafeFromArray(Di(e,t,r))),TC=dual(2,(e,t)=>IC(e,t,(e,t)=>[e,t])),OC=dual(2,(e,t)=>t<0||t>=e.length?e:unsafeFromArray(Fi(toReadonlyArray$1(e),t))),EC=dual(2,(e,t)=>t<0||t>=e.length?none$c():Ut(unsafeFromArray(Fi(toReadonlyArray$1(e),t)))),AC=dual(3,(e,t,r)=>t<0||t>=e.length?none$c():Ut(unsafeFromArray(Ci(toReadonlyArray$1(e),t,r)))),CC=dual(3,(e,t,r)=>Kt(AC(e,t,r),()=>e)),MC=dual(3,(e,t,r)=>CC(e,t,()=>r)),FC=dual(3,(e,t,r)=>AC(e,t,()=>r)),PC=dual(2,(e,t)=>fromIterable$u(Gn(e,t))),range$2=(start,e)=>start<=e?PC(e-start+1,e=>start+e):of$5(start),NC=Vi,jC=containsWith$1,RC=ki,DC=_i,LC=xi,UC=wi,$C=dual(2,(e,t)=>fromIterable$v(e).every(t)),BC=dual(2,(e,t)=>fromIterable$v(e).some(t)),zC=Ms,qC=ys,WC=bs;var VC=Object.freeze({__proto__:null,append:GA,appendAll:eC,chunksOf:aC,compact:e=>tC(e,identity$5),contains:NC,containsWith:jC,dedupe:e=>unsafeFromArray(dedupe$1(toReadonlyArray$1(e))),dedupeAdjacent:e=>unsafeFromArray(Cs(e)),difference:dual(2,(e,t)=>unsafeFromArray(os(t,e))),differenceWith:e=>dual(2,(t,r)=>unsafeFromArray(differenceWith$1(e)(r,t))),drop:ZA,dropRight:QA,dropWhile:YA,empty:empty$R,every:$C,filter:rC,filterMap:tC,filterMapWhile:nC,findFirst:RC,findFirstIndex:DC,findLast:LC,findLastIndex:UC,flatMap:iC,flatten:oC,forEach:sC,fromIterable:fromIterable$u,get:VA,getEquivalence:getEquivalence$4,head:cC,headNonEmpty:lC,intersection:uC,isChunk,isEmpty:isEmpty$t,isNonEmpty:isNonEmpty$8,join:zC,last:last$5,lastNonEmpty:pC,make:make$2d,makeBy:PC,map:fC,mapAccum:hC,modify:CC,modifyOption:AC,of:of$5,partition:dC,partitionMap:mC,prepend:JA,prependAll:XA,range:range$2,reduce:qC,reduceRight:WC,remove:OC,removeOption:EC,replace:MC,replaceOption:FC,reverse:reverse$3,separate:e=>pipe(gs(toReadonlyArray$1(e)),([e,t])=>[unsafeFromArray(e),unsafeFromArray(t)]),size:e=>e.length,some:BC,sort:gC,sortWith:yC,split:vC,splitAt:bC,splitNonEmptyAt:SC,splitWhere:_C,tail:e=>e.length>0?Ut(ZA(e,1)):none$c(),tailNonEmpty,take:HA,takeRight:wC,takeWhile:kC,toArray:toArray$9,toReadonlyArray:toReadonlyArray$1,union:xC,unsafeFromArray,unsafeFromNonEmptyArray,unsafeGet:KA,unsafeHead:unsafeHead$1,unsafeLast:unsafeLast$1,unzip:e=>{const[t,r]=unzip$1(e);return[unsafeFromArray(t),unsafeFromArray(r)]},zip:TC,zipWith:IC});const KC=Symbol.for("effect/Duration"),GC=BigInt(0),JC=BigInt(24),HC=BigInt(60),ZC=BigInt(1e3),QC=BigInt(1e6),YC=BigInt(1e9),XC=/^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/,decode$5=e=>{if(isDuration(e))return e;if(isNumber$1(e))return millis(e);if(isBigInt$1(e))return nanos(e);if(Array.isArray(e)&&2===e.length&&e.every(isNumber$1))return e[0]===-1/0||e[1]===-1/0||Number.isNaN(e[0])||Number.isNaN(e[1])?iM:e[0]===1/0||e[1]===1/0?sM:nanos(BigInt(Math.round(1e9*e[0]))+BigInt(Math.round(e[1])));if(isString$1(e)){const t=XC.exec(e);if(t){const[e,r,n]=t,i=Number(r);switch(n){case"nano":case"nanos":return nanos(BigInt(r));case"micro":case"micros":return micros(BigInt(r));case"milli":case"millis":return millis(i);case"second":case"seconds":return seconds(i);case"minute":case"minutes":return minutes(i);case"hour":case"hours":return hours(i);case"day":case"days":return days(i);case"week":case"weeks":return weeks(i)}}}throw Error("Invalid DurationInput")},eM=liftThrowable(decode$5),tM={_tag:"Millis",millis:0},rM={_tag:"Infinity"},nM={[KC]:KC,[Z](){return cached$2(this,structure(this.value))},[Y](e){return isDuration(e)&&IM(this,e)},toString(){return`Duration(${format$4(this)})`},toJSON(){switch(this.value._tag){case"Millis":return{_id:"Duration",_tag:"Millis",millis:this.value.millis};case"Nanos":return{_id:"Duration",_tag:"Nanos",hrtime:toHrTime(this)};case"Infinity":return{_id:"Duration",_tag:"Infinity"}}},[ee](){return this.toJSON()},pipe(){return pipeArguments(this,arguments)}},make$2c=e=>{const t=Object.create(nM);return isNumber$1(e)?isNaN(e)||e<=0?t.value=tM:Number.isFinite(e)?Number.isInteger(e)?t.value={_tag:"Millis",millis:e}:t.value={_tag:"Nanos",nanos:BigInt(Math.round(1e6*e))}:t.value=rM:t.value=e<=GC?tM:{_tag:"Nanos",nanos:e},t},isDuration=e=>C(e,KC),isFinite=e=>"Infinity"!==e.value._tag,isZero=e=>{switch(e.value._tag){case"Millis":return 0===e.value.millis;case"Nanos":return e.value.nanos===GC;case"Infinity":return!1}},iM=make$2c(0),sM=make$2c(1/0),nanos=e=>make$2c(e),micros=e=>make$2c(e*ZC),millis=e=>make$2c(e),seconds=e=>make$2c(1e3*e),minutes=e=>make$2c(6e4*e),hours=e=>make$2c(36e5*e),days=e=>make$2c(864e5*e),weeks=e=>make$2c(6048e5*e),toMillis=e=>oM(e,{onMillis:e=>e,onNanos:e=>Number(e)/1e6}),toNanos=e=>{const t=decode$5(e);switch(t.value._tag){case"Infinity":return none$c();case"Nanos":return Ut(t.value.nanos);case"Millis":return Ut(BigInt(Math.round(1e6*t.value.millis)))}},unsafeToNanos=e=>{const t=decode$5(e);switch(t.value._tag){case"Infinity":throw Error("Cannot convert infinite duration to nanos");case"Nanos":return t.value.nanos;case"Millis":return BigInt(Math.round(1e6*t.value.millis))}},toHrTime=e=>{const t=decode$5(e);switch(t.value._tag){case"Infinity":return[1/0,0];case"Nanos":return[Number(t.value.nanos/YC),Number(t.value.nanos%YC)];case"Millis":return[Math.floor(t.value.millis/1e3),Math.round(t.value.millis%1e3*1e6)]}},oM=dual(2,(e,t)=>{const r=decode$5(e);switch(r.value._tag){case"Nanos":return t.onNanos(r.value.nanos);case"Infinity":return t.onMillis(1/0);case"Millis":return t.onMillis(r.value.millis)}}),aM=dual(3,(e,t,r)=>{const n=decode$5(e),i=decode$5(t);if("Infinity"===n.value._tag||"Infinity"===i.value._tag)return r.onMillis(toMillis(n),toMillis(i));if("Nanos"===n.value._tag||"Nanos"===i.value._tag){const e="Nanos"===n.value._tag?n.value.nanos:BigInt(Math.round(1e6*n.value.millis)),t="Nanos"===i.value._tag?i.value.nanos:BigInt(Math.round(1e6*i.value.millis));return r.onNanos(e,t)}return r.onMillis(n.value.millis,i.value.millis)}),uM=make$2k((e,t)=>aM(e,t,{onMillis:(e,t)=>e<t?-1:e>t?1:0,onNanos:(e,t)=>e<t?-1:e>t?1:0})),cM=between$7(Pt(uM,decode$5)),Equivalence$5=(e,t)=>aM(e,t,{onMillis:(e,t)=>e===t,onNanos:(e,t)=>e===t}),lM=min$9(uM),pM=dual(2,(e,t)=>lM(decode$5(e),decode$5(t))),fM=max$b(uM),hM=dual(2,(e,t)=>fM(decode$5(e),decode$5(t))),dM=clamp$8(uM),mM=dual(2,(e,t)=>dM(decode$5(e),{minimum:decode$5(t.minimum),maximum:decode$5(t.maximum)})),gM=dual(2,(e,t)=>oM(e,{onMillis:e=>0===t||isNaN(t)||!Number.isFinite(t)?none$c():Ut(make$2c(e/t)),onNanos:e=>{if(isNaN(t)||t<=0||!Number.isFinite(t))return none$c();try{return Ut(make$2c(e/BigInt(t)))}catch{return none$c()}}})),yM=dual(2,(e,t)=>oM(e,{onMillis:e=>make$2c(e/t),onNanos:e=>isNaN(t)||t<0||Object.is(t,-0)?iM:Object.is(t,0)||!Number.isFinite(t)?sM:make$2c(e/BigInt(t))})),bM=dual(2,(e,t)=>oM(e,{onMillis:e=>make$2c(e*t),onNanos:e=>make$2c(e*BigInt(t))})),SM=dual(2,(e,t)=>aM(e,t,{onMillis:(e,t)=>make$2c(e-t),onNanos:(e,t)=>make$2c(e-t)})),vM=dual(2,(e,t)=>aM(e,t,{onMillis:(e,t)=>make$2c(e+t),onNanos:(e,t)=>make$2c(e+t)})),_M=dual(2,(e,t)=>aM(e,t,{onMillis:(e,t)=>e<t,onNanos:(e,t)=>e<t})),wM=dual(2,(e,t)=>aM(e,t,{onMillis:(e,t)=>e<=t,onNanos:(e,t)=>e<=t})),kM=dual(2,(e,t)=>aM(e,t,{onMillis:(e,t)=>e>t,onNanos:(e,t)=>e>t})),xM=dual(2,(e,t)=>aM(e,t,{onMillis:(e,t)=>e>=t,onNanos:(e,t)=>e>=t})),IM=dual(2,(e,t)=>Equivalence$5(decode$5(e),decode$5(t))),parts=e=>{const t=decode$5(e);if("Infinity"===t.value._tag)return{days:1/0,hours:1/0,minutes:1/0,seconds:1/0,millis:1/0,nanos:1/0};const r=unsafeToNanos(t),n=r/QC,i=n/ZC,s=i/HC,o=s/HC;return{days:Number(o/JC),hours:Number(o%JC),minutes:Number(s%HC),seconds:Number(i%HC),millis:Number(n%ZC),nanos:Number(r%QC)}},format$4=e=>{const t=decode$5(e);if("Infinity"===t.value._tag)return"Infinity";if(isZero(t))return"0";const r=parts(t),n=[];return 0!==r.days&&n.push(r.days+"d"),0!==r.hours&&n.push(r.hours+"h"),0!==r.minutes&&n.push(r.minutes+"m"),0!==r.seconds&&n.push(r.seconds+"s"),0!==r.millis&&n.push(r.millis+"ms"),0!==r.nanos&&n.push(r.nanos+"ns"),n.join(" ")},unsafeFormatIso=e=>{const t=decode$5(e);if(!isFinite(t))throw new RangeError("Cannot format infinite duration");const r=[],{days:n,hours:i,millis:s,minutes:o,nanos:a,seconds:u}=parts(t);let c=n;if(c>=365){const e=Math.floor(c/365);c%=365,r.push(e+"Y")}if(c>=30){const e=Math.floor(c/30);c%=30,r.push(e+"M")}if(c>=7){const e=Math.floor(c/7);c%=7,r.push(e+"W")}if(c>0&&r.push(c+"D"),(0!==i||0!==o||0!==u||0!==s||0!==a)&&(r.push("T"),0!==i&&r.push(i+"H"),0!==o&&r.push(o+"M"),0!==u||0!==s||0!==a)){const e=BigInt(u)*YC+BigInt(s)*QC+BigInt(a),t=(Number(e)/1e9).toFixed(9).replace(/\.?0+$/,"");r.push(t+"S")}return"P"+(r.join("")||"T0S")},TM=/^P(?!$)(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?(?:T(?!$)(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/;var OM=Object.freeze({__proto__:null,Equivalence:Equivalence$5,Order:uM,between:cM,clamp:mM,days,decode:decode$5,decodeUnknown:eM,divide:gM,equals:IM,format:format$4,formatIso:e=>{const t=decode$5(e);return isFinite(t)?Ut(unsafeFormatIso(t)):none$c()},fromIso:e=>{const t=TM.exec(e);if(null==t)return none$c();const[r,n,i,s,o,a,u]=t.slice(1,8).map(e=>e?Number(e):0);return Ut(seconds(365*r*24*60*60+30*n*24*60*60+7*i*24*60*60+24*s*60*60+60*o*60+60*a+u))},greaterThan:kM,greaterThanOrEqualTo:xM,hours,infinity:sM,isDuration,isFinite,isZero,lessThan:_M,lessThanOrEqualTo:wM,match:oM,matchWith:aM,max:hM,micros,millis,min:pM,minutes,nanos,parts,seconds,subtract:SM,sum:vM,times:bM,toDays:e=>oM(e,{onMillis:e=>e/864e5,onNanos:e=>Number(e)/864e11}),toHours:e=>oM(e,{onMillis:e=>e/36e5,onNanos:e=>Number(e)/36e11}),toHrTime,toMillis,toMinutes:e=>oM(e,{onMillis:e=>e/6e4,onNanos:e=>Number(e)/6e10}),toNanos,toSeconds:e=>oM(e,{onMillis:e=>e/1e3,onNanos:e=>Number(e)/1e9}),toWeeks:e=>oM(e,{onMillis:e=>e/6048e5,onNanos:e=>Number(e)/6048e11}),unsafeDivide:yM,unsafeFormatIso,unsafeToNanos,weeks,zero:iM});function hashFragment(e,t){return t>>>e&31}function toBitmap(e){return 1<<e}function fromBitmap(e,t){return r=e&t-1,r=(r=(858993459&(r-=r>>1&1431655765))+(r>>2&858993459))+(r>>4)&252645135,127&(r+=r>>8)+(r>>16);var r}const make$2b=(e,t)=>({value:e,previous:t});function arrayUpdate(e,t,r,n){let i=n;if(!e){const e=n.length;i=Array(e);for(let t=0;t<e;++t)i[t]=n[t]}return i[t]=r,i}function arraySpliceOut(e,t,r){const n=r.length-1;let i=0,s=0,o=r;if(e)i=s=t;else for(o=Array(n);i<t;)o[s++]=r[i++];for(++i;i<=n;)o[s++]=r[i++];return e&&(o.length=n),o}class EmptyNode{_tag="EmptyNode";modify(e,t,r,n,i,s){const o=r(none$c());return Bt(o)?new EmptyNode:(++s.value,new LeafNode(e,n,i,o))}}function isEmptyNode(e){return M(e,"EmptyNode")}function canEditNode(e,t){return!isEmptyNode(e)&&t===e.edit}class LeafNode{edit;hash;key;value;_tag="LeafNode";constructor(e,t,r,n){this.edit=e,this.hash=t,this.key=r,this.value=n}modify(e,t,r,n,i,s){if(equals$4(i,this.key)){const t=r(this.value);return t===this.value?this:Bt(t)?(--s.value,new EmptyNode):canEditNode(this,e)?(this.value=t,this):new LeafNode(e,n,i,t)}const o=r(none$c());return Bt(o)?this:(++s.value,mergeLeaves(e,t,this.hash,this,n,new LeafNode(e,n,i,o)))}}class CollisionNode{edit;hash;children;_tag="CollisionNode";constructor(e,t,r){this.edit=e,this.hash=t,this.children=r}modify(e,t,r,n,i,s){if(n===this.hash){const t=canEditNode(this,e),n=this.updateCollisionList(t,e,this.hash,this.children,r,i,s);return n===this.children?this:n.length>1?new CollisionNode(e,this.hash,n):n[0]}const o=r(none$c());return Bt(o)?this:(++s.value,mergeLeaves(e,t,this.hash,this,n,new LeafNode(e,n,i,o)))}updateCollisionList(e,t,r,n,i,s,o){const a=n.length;for(let u=0;u<a;++u){const a=n[u];if("key"in a&&equals$4(s,a.key)){const c=a.value,l=i(c);return l===c?n:Bt(l)?(--o.value,arraySpliceOut(e,u,n)):arrayUpdate(e,u,new LeafNode(t,r,s,l),n)}}const u=i(none$c());return Bt(u)?n:(++o.value,arrayUpdate(e,a,new LeafNode(t,r,s,u),n))}}class IndexedNode{edit;mask;children;_tag="IndexedNode";constructor(e,t,r){this.edit=e,this.mask=t,this.children=r}modify(e,t,r,n,i,s){const o=this.mask,a=this.children,u=hashFragment(t,n),c=toBitmap(u),l=fromBitmap(o,c),p=o&c,d=canEditNode(this,e);if(!p){const p=(new EmptyNode).modify(e,t+5,r,n,i,s);return p?a.length>=16?function(e,t,r,n,i){const s=[];let o=n,a=0;for(let e=0;o;++e)1&o&&(s[e]=i[a++]),o>>>=1;return s[t]=r,new ArrayNode(e,a+1,s)}(e,u,p,o,a):new IndexedNode(e,o|c,function(e,t,r,n){const i=n.length;if(e){let e=i;for(;e>=t;)n[e--]=n[e];return n[t]=r,n}let s=0,o=0;const a=Array(i+1);for(;s<t;)a[o++]=n[s++];for(a[t]=r;s<i;)a[++o]=n[s++];return a}(d,l,p,a)):this}const m=a[l],g=m.modify(e,t+5,r,n,i,s);if(m===g)return this;let y,b=o;if(isEmptyNode(g)){if(b&=~c,!b)return new EmptyNode;if(a.length<=2&&(isEmptyNode(S=a[1^l])||"LeafNode"===S._tag||"CollisionNode"===S._tag))return a[1^l];y=arraySpliceOut(d,l,a)}else y=arrayUpdate(d,l,g,a);var S;return d?(this.mask=b,this.children=y,this):new IndexedNode(e,b,y)}}class ArrayNode{edit;size;children;_tag="ArrayNode";constructor(e,t,r){this.edit=e,this.size=t,this.children=r}modify(e,t,r,n,i,s){let o=this.size;const a=this.children,u=hashFragment(t,n),c=a[u],l=(c||new EmptyNode).modify(e,t+5,r,n,i,s);if(c===l)return this;const p=canEditNode(this,e);let d;if(isEmptyNode(c)&&!isEmptyNode(l))++o,d=arrayUpdate(p,u,l,a);else if(!isEmptyNode(c)&&isEmptyNode(l)){if(--o,o<=8)return function(e,t,r,n){const i=Array(t-1);let s=0,o=0;for(let e=0,t=n.length;e<t;++e)if(e!==r){const t=n[e];t&&!isEmptyNode(t)&&(i[s++]=t,o|=1<<e)}return new IndexedNode(e,o,i)}(e,o,u,a);d=arrayUpdate(p,u,new EmptyNode,a)}else d=arrayUpdate(p,u,l,a);return p?(this.size=o,this.children=d,this):new ArrayNode(e,o,d)}}function mergeLeavesInner(e,t,r,n,i,s){if(r===i)return new CollisionNode(e,r,[s,n]);const o=hashFragment(t,r),a=hashFragment(t,i);if(o===a)return t=>new IndexedNode(e,toBitmap(o)|toBitmap(a),[t]);{const t=o<a?[n,s]:[s,n];return new IndexedNode(e,toBitmap(o)|toBitmap(a),t)}}function mergeLeaves(e,t,r,n,i,s){let o,a=t;for(;;){const t=mergeLeavesInner(e,a,r,n,i,s);if("function"!=typeof t){let e=t;for(;null!=o;)e=o.value(e),o=o.previous;return e}o=make$2b(t,o),a+=5}}const EM="effect/HashMap",AM=Symbol.for(EM),CM={[AM]:AM,[Symbol.iterator](){return new HashMapIterator(this,(e,t)=>[e,t])},[Z](){let e=hash$3(EM);for(const t of this)e^=pipe(hash$3(t[0]),combine$h(hash$3(t[1])));return cached$2(this,e)},[Y](e){if(isHashMap$1(e)){if(e._size!==this._size)return!1;for(const t of this){const r=pipe(e,PM(t[0],hash$3(t[0])));if(Bt(r))return!1;if(!equals$4(t[1],r.value))return!1}return!0}return!1},toString(){return format$6(this.toJSON())},toJSON(){return{_id:"HashMap",values:Array.from(this).map(toJSON)}},[ee](){return this.toJSON()},pipe(){return pipeArguments(this,arguments)}},makeImpl$5=(e,t,r,n)=>{const i=Object.create(CM);return i._editable=e,i._edit=t,i._root=r,i._size=n,i};class HashMapIterator{map;f;v;constructor(e,t){this.map=e,this.f=t,this.v=visitLazy(this.map._root,this.f,void 0)}next(){if(Bt(this.v))return{done:!0,value:void 0};const e=this.v.value;return this.v=applyCont(e.cont),{done:!1,value:e.value}}[Symbol.iterator](){return new HashMapIterator(this.map,this.f)}}const applyCont=e=>e?visitLazyChildren(e[0],e[1],e[2],e[3],e[4]):none$c(),visitLazy=(e,t,r=void 0)=>{switch(e._tag){case"LeafNode":return zt(e.value)?Ut({value:t(e.key,e.value.value),cont:r}):applyCont(r);case"CollisionNode":case"ArrayNode":case"IndexedNode":{const n=e.children;return visitLazyChildren(n.length,n,0,t,r)}default:return applyCont(r)}},visitLazyChildren=(e,t,r,n,i)=>{for(;r<e;){const s=t[r++];if(s&&!isEmptyNode(s))return visitLazy(s,n,[e,t,r,n,i])}return applyCont(i)},MM=makeImpl$5(!1,0,new EmptyNode,0),empty$Q=()=>MM,fromIterable$t=e=>{const t=beginMutation$4(empty$Q());for(const r of e)LM(t,r[0],r[1]);return endMutation$4(t)},isHashMap$1=e=>C(e,AM),FM=dual(2,(e,t)=>PM(e,t,hash$3(t))),PM=dual(3,(e,t,r)=>{let n=e._root,i=0;for(;;)switch(n._tag){case"LeafNode":return equals$4(t,n.key)?n.value:none$c();case"CollisionNode":if(r===n.hash){const e=n.children;for(let r=0,n=e.length;r<n;++r){const n=e[r];if("key"in n&&equals$4(t,n.key))return n.value}}return none$c();case"IndexedNode":{const e=toBitmap(hashFragment(i,r));if(n.mask&e){n=n.children[fromBitmap(n.mask,e)],i+=5;break}return none$c()}case"ArrayNode":if(n=n.children[hashFragment(i,r)],n){i+=5;break}return none$c();default:return none$c()}}),NM=dual(2,(e,t)=>{const r=PM(e,t,hash$3(t));if(Bt(r))throw Error("Expected map to contain key");return r.value}),jM=dual(2,(e,t)=>zt(PM(e,t,hash$3(t)))),RM=dual(3,(e,t,r)=>zt(PM(e,t,r))),DM=dual(2,(e,t)=>zt(eF(e,t))),LM=dual(3,(e,t,r)=>zM(e,t,()=>Ut(r))),UM=dual(3,(e,t,r)=>e._editable?(e._root=t,e._size=r,e):t===e._root?e:makeImpl$5(e._editable,e._edit,t,r)),keys$c=e=>new HashMapIterator(e,e=>e),size$z=e=>e._size,$M=dual(2,(e,t)=>{let r=0;for(const[n,i]of e)t(i,n)&&r++;return r}),beginMutation$4=e=>makeImpl$5(!0,e._edit+1,e._root,e._size),endMutation$4=e=>(e._editable=!1,e),BM=dual(2,(e,t)=>{const r=beginMutation$4(e);return t(r),endMutation$4(r)}),zM=dual(3,(e,t,r)=>qM(e,t,hash$3(t),r)),qM=dual(4,(e,t,r,n)=>{const i={value:e._size},s=e._root.modify(e._editable?e._edit:NaN,0,n,r,t,i);return pipe(e,UM(s,i.value))}),WM=dual(3,(e,t,r)=>zM(e,t,er(r))),VM=dual(2,(e,t)=>{const r=beginMutation$4(e);return ZM(t,(e,t)=>LM(r,t,e)),endMutation$4(r)}),KM=dual(2,(e,t)=>zM(e,t,none$c)),GM=dual(2,(e,t)=>BM(e,e=>{for(const r of t)KM(r)(e)})),JM=dual(2,(e,t)=>QM(e,empty$Q(),(e,r,n)=>LM(e,n,t(r,n)))),HM=dual(2,(e,t)=>QM(e,empty$Q(),(e,r,n)=>BM(e,e=>ZM(t(r,n),(t,r)=>LM(e,r,t))))),ZM=dual(2,(e,t)=>QM(e,void 0,(e,r,n)=>t(r,n))),QM=dual(3,(e,t,r)=>{const n=e._root;if("LeafNode"===n._tag)return zt(n.value)?r(t,n.value.value,n.key):t;if("EmptyNode"===n._tag)return t;const i=[n.children];let s;for(;s=i.pop();)for(let e=0,n=s.length;e<n;){const n=s[e++];n&&!isEmptyNode(n)&&("LeafNode"===n._tag?zt(n.value)&&(t=r(t,n.value.value,n.key)):i.push(n.children))}return t}),YM=dual(2,(e,t)=>BM(empty$Q(),r=>{for(const[n,i]of e)t(i,n)&&LM(r,n,i)})),XM=dual(2,(e,t)=>BM(empty$Q(),r=>{for(const[n,i]of e){const e=t(i,n);zt(e)&&LM(r,n,e.value)}})),eF=dual(2,(e,t)=>{for(const r of e)if(t(r[1],r[0]))return Ut(r);return none$c()}),tF=dual(2,(e,t)=>{for(const r of e)if(t(r[1],r[0]))return!0;return!1}),rF=dual(2,(e,t)=>!tF(e,(e,r)=>!t(e,r))),nF="effect/HashSet",iF=Symbol.for(nF),sF={[iF]:iF,[Symbol.iterator](){return keys$c(this._keyMap)},[Z](){return cached$2(this,combine$h(hash$3(this._keyMap))(hash$3(nF)))},[Y](e){return!!isHashSet$1(e)&&size$z(this._keyMap)===size$z(e._keyMap)&&equals$4(this._keyMap,e._keyMap)},toString(){return format$6(this.toJSON())},toJSON(){return{_id:"HashSet",values:Array.from(this).map(toJSON)}},[ee](){return this.toJSON()},pipe(){return pipeArguments(this,arguments)}},makeImpl$4=e=>{const t=Object.create(sF);return t._keyMap=e,t},isHashSet$1=e=>C(e,iF),oF=makeImpl$4(empty$Q()),empty$P=()=>oF,aF=dual(2,(e,t)=>jM(e._keyMap,t)),uF=dual(2,(e,t)=>{let r=!1;for(const n of e)if(r=t(n),r)break;return r}),cF=dual(2,(e,t)=>!uF(e,e=>!t(e))),lF=dual(2,(e,t)=>cF(e,e=>aF(t,e))),values$c=e=>keys$c(e._keyMap),beginMutation$3=e=>makeImpl$4(beginMutation$4(e._keyMap)),endMutation$3=e=>(e._keyMap._editable=!1,e),pF=dual(2,(e,t)=>{const r=beginMutation$3(e);return t(r),endMutation$3(r)}),fF=dual(2,(e,t)=>e._keyMap._editable?(LM(t,!0)(e._keyMap),e):makeImpl$4(LM(t,!0)(e._keyMap))),hF=dual(2,(e,t)=>e._keyMap._editable?(KM(t)(e._keyMap),e):makeImpl$4(KM(t)(e._keyMap))),dF=dual(2,(e,t)=>pF(e,e=>{for(const r of t)hF(e,r)})),mF=dual(2,(e,t)=>pF(empty$P(),r=>{for(const n of t)aF(n)(e)&&fF(n)(r)})),gF=dual(2,(e,t)=>pF(empty$P(),r=>{vF(e,e=>fF(r,e));for(const e of t)fF(r,e)})),yF=dual(2,(e,t)=>aF(e,t)?hF(e,t):fF(e,t)),bF=dual(2,(e,t)=>pF(empty$P(),r=>{vF(e,e=>{const n=t(e);aF(r,n)||fF(r,n)})})),SF=dual(2,(e,t)=>pF(empty$P(),r=>{vF(e,e=>{for(const n of t(e))aF(r,n)||fF(r,n)})})),vF=dual(2,(e,t)=>ZM(e._keyMap,(e,r)=>t(r))),_F=dual(3,(e,t,r)=>QM(e._keyMap,t,(e,t,n)=>r(e,n))),wF=dual(2,(e,t)=>pF(empty$P(),r=>{const n=values$c(e);let i;for(;!(i=n.next()).done;){const e=i.value;t(e)&&fF(r,e)}})),kF=dual(2,(e,t)=>{const r=values$c(e);let n;const i=beginMutation$3(empty$P()),s=beginMutation$3(empty$P());for(;!(n=r.next()).done;){const e=n.value;t(e)?fF(i,e):fF(s,e)}return[endMutation$3(s),endMutation$3(i)]}),xF=isHashSet$1,IF=empty$P,fromIterable$r=e=>{const t=beginMutation$3(empty$P());for(const r of e)fF(t,r);return endMutation$3(t)},make$28=(...e)=>{const t=beginMutation$3(empty$P());for(const r of e)fF(t,r);return endMutation$3(t)},TF=aF,OF=cF,EF=values$c,size$x=e=>size$z(e._keyMap),AF=fF,CF=hF,MF=dF,FF=gF,PF=bF,NF=SF,jF=vF,RF=_F;var DF=Object.freeze({__proto__:null,add:AF,beginMutation:beginMutation$3,difference:MF,empty:IF,endMutation:endMutation$3,every:OF,filter:wF,flatMap:NF,forEach:jF,fromIterable:fromIterable$r,has:TF,intersection:mF,isHashSet:xF,isSubset:lF,make:make$28,map:PF,mutate:pF,partition:kF,reduce:RF,remove:CF,size:size$x,some:uF,toValues:e=>Array.from(EF(e)),toggle:yF,union:FF,values:EF});const LF=Symbol.for("effect/MutableRef"),UF={[LF]:LF,toString(){return format$6(this.toJSON())},toJSON(){return{_id:"MutableRef",current:toJSON(this.current)}},[ee](){return this.toJSON()},pipe(){return pipeArguments(this,arguments)}},make$27=e=>{const t=Object.create(UF);return t.current=e,t},$F=dual(3,(e,t,r)=>!!equals$4(t,e.current)&&(e.current=r,!0)),decrementAndGet=e=>KF(e,e=>e-1),get$E=e=>e.current,BF=dual(2,(e,t)=>{const r=e.current;return e.current=t,r}),zF=dual(2,(e,t)=>BF(e,t(get$E(e)))),incrementAndGet=e=>KF(e,e=>e+1),qF=dual(2,(e,t)=>(e.current=t,e)),WF=dual(2,(e,t)=>(e.current=t,e.current)),VF=dual(2,(e,t)=>qF(e,t(get$E(e)))),KF=dual(2,(e,t)=>WF(e,t(get$E(e))));var GF=Object.freeze({__proto__:null,compareAndSet:$F,decrement:e=>VF(e,e=>e-1),decrementAndGet,get:get$E,getAndDecrement:e=>zF(e,e=>e-1),getAndIncrement:e=>zF(e,e=>e+1),getAndSet:BF,getAndUpdate:zF,increment:e=>VF(e,e=>e+1),incrementAndGet,make:make$27,set:qF,setAndGet:WF,toggle:e=>VF(e,e=>!e),update:VF,updateAndGet:KF});const JF="effect/FiberId",HF=Symbol.for(JF),ZF="None",QF="Runtime",YF="Composite",XF=string$6(`${JF}-${ZF}`);let eP=class{[HF]=HF;_tag=ZF;id=-1;startTimeMillis=-1;[Z](){return XF}[Y](e){return isFiberId$1(e)&&e._tag===ZF}toString(){return format$6(this.toJSON())}toJSON(){return{_id:"FiberId",_tag:this._tag}}[ee](){return this.toJSON()}},tP=class{id;startTimeMillis;[HF]=HF;_tag=QF;constructor(e,t){this.id=e,this.startTimeMillis=t}[Z](){return cached$2(this,string$6(`${JF}-${this._tag}-${this.id}-${this.startTimeMillis}`))}[Y](e){return isFiberId$1(e)&&e._tag===QF&&this.id===e.id&&this.startTimeMillis===e.startTimeMillis}toString(){return format$6(this.toJSON())}toJSON(){return{_id:"FiberId",_tag:this._tag,id:this.id,startTimeMillis:this.startTimeMillis}}[ee](){return this.toJSON()}},rP=class{left;right;[HF]=HF;_tag=YF;constructor(e,t){this.left=e,this.right=t}_hash;[Z](){return pipe(string$6(`${JF}-${this._tag}`),combine$h(hash$3(this.left)),combine$h(hash$3(this.right)),cached$2(this))}[Y](e){return isFiberId$1(e)&&e._tag===YF&&equals$4(this.left,e.left)&&equals$4(this.right,e.right)}toString(){return format$6(this.toJSON())}toJSON(){return{_id:"FiberId",_tag:this._tag,left:toJSON(this.left),right:toJSON(this.right)}}[ee](){return this.toJSON()}};const nP=new eP,isFiberId$1=e=>C(e,HF),isNone$1=e=>e._tag===ZF||pipe(toSet$4(e),OF(e=>isNone$1(e))),iP=dual(2,(e,t)=>e._tag===ZF?t:t._tag===ZF?e:new rP(e,t)),sP=dual(2,(e,t)=>isNone$1(e)?t:e),ids$1=e=>{switch(e._tag){case ZF:return IF();case QF:return make$28(e.id);case YF:return pipe(ids$1(e.left),FF(ids$1(e.right)))}},oP=globalValue(Symbol.for("effect/Fiber/Id/_fiberCounter"),()=>make$27(0)),threadName$1=e=>Array.from(ids$1(e)).map(e=>"#"+e).join(","),toSet$4=e=>{switch(e._tag){case ZF:return IF();case QF:return make$28(e);case YF:return pipe(toSet$4(e.left),FF(toSet$4(e.right)))}},aP=nP,runtime$5=(e,t)=>new tP(e,t),composite=(e,t)=>new rP(e,t),uP=isFiberId$1,cP=iP,combineAll$1=e=>pipe(e,RF(nP,(e,t)=>iP(t)(e))),lP=sP,pP=ids$1,make$25=(e,t)=>new tP(e,t),fP=threadName$1,unsafeMake$h=()=>{const e=get$E(oP);return pipe(oP,qF(e+1)),new tP(e,Date.now())};var hP=Object.freeze({__proto__:null,FiberIdTypeId:HF,combine:cP,combineAll:combineAll$1,composite,getOrElse:lP,ids:pP,isComposite:e=>e._tag===YF,isFiberId:uP,isNone:isNone$1,isRuntime:e=>e._tag===QF,make:make$25,none:aP,runtime:runtime$5,threadName:fP,toOption:e=>{const t=toSet$4(e);if(0===size$x(t))return none$c();let r,n=!0;for(const e of t)n?(r=e,n=!1):r=pipe(r,iP(e));return Ut(r)},toSet:toSet$4,unsafeMake:unsafeMake$h});const dP=isHashMap$1,mP=empty$Q,make$24=(...e)=>fromIterable$t(e),gP=fromIterable$t,isEmpty$r=e=>e&&isEmptyNode(e._root),yP=FM,bP=NM,SP=jM,vP=LM,_P=keys$c,values$a=e=>new HashMapIterator(e,(e,t)=>t),toValues=e=>Array.from(values$a(e)),entries$5=e=>new HashMapIterator(e,(e,t)=>[e,t]),wP=size$z,kP=BM,xP=zM,IP=KM,TP=JM,OP=ZM,EP=QM;var AP=Object.freeze({__proto__:null,beginMutation:beginMutation$4,compact:e=>XM(e,identity$5),countBy:$M,empty:mP,endMutation:endMutation$4,entries:entries$5,every:rF,filter:YM,filterMap:XM,findFirst:eF,flatMap:HM,forEach:OP,fromIterable:gP,get:yP,getHash:PM,has:SP,hasBy:DM,hasHash:RM,isEmpty:isEmpty$r,isHashMap:dP,keySet:function(e){return makeImpl$4(e)},keys:_P,make:make$24,map:TP,modify:WM,modifyAt:xP,modifyHash:qM,mutate:kP,reduce:EP,remove:IP,removeMany:GM,set:vP,size:wP,some:tF,toEntries:e=>Array.from(entries$5(e)),toValues,union:VM,unsafeGet:bP,values:values$a});const CP=Symbol.for("effect/List"),toArray$8=e=>fromIterable$v(e),getEquivalence$3=e=>S(Ts(e),toArray$8),MP=getEquivalence$3(equals$4),FP={[CP]:CP,_tag:"Cons",toString(){return format$6(this.toJSON())},toJSON(){return{_id:"List",_tag:"Cons",values:toArray$8(this).map(toJSON)}},[ee](){return this.toJSON()},[Y](e){return isList(e)&&this._tag===e._tag&&MP(this,e)},[Z](){return cached$2(this,array$6(toArray$8(this)))},[Symbol.iterator](){let e=!1,t=this;return{next(){if(e)return this.return();if("Nil"===t._tag)return e=!0,this.return();const r=t.head;return t=t.tail,{done:e,value:r}},return:t=>(e||(e=!0),{done:!0,value:t})}},pipe(){return pipeArguments(this,arguments)}},makeCons=(e,t)=>{const r=Object.create(FP);return r.head=e,r.tail=t,r},PP=string$6("Nil"),NP={[CP]:CP,_tag:"Nil",toString(){return format$6(this.toJSON())},toJSON:()=>({_id:"List",_tag:"Nil"}),[ee](){return this.toJSON()},[Z]:()=>PP,[Y](e){return isList(e)&&this._tag===e._tag},[Symbol.iterator]:()=>({next:()=>({done:!0,value:void 0})}),pipe(){return pipeArguments(this,arguments)}},jP=Object.create(NP),isList=e=>C(e,CP),isNil=e=>"Nil"===e._tag,isCons=e=>"Cons"===e._tag,size$v=e=>{let t=e,r=0;for(;!isNil(t);)r+=1,t=t.tail;return r},nil=()=>jP,cons=(e,t)=>makeCons(e,t),RP=nil,of$4=e=>makeCons(e,jP),fromIterable$p=e=>{const t=e[Symbol.iterator]();let r;if((r=t.next())&&!r.done){const e=makeCons(r.value,jP);let n=e;for(;(r=t.next())&&!r.done;){const e=makeCons(r.value,jP);n.tail=e,n=e}return e}return jP},make$23=(...e)=>fromIterable$p(e),DP=dual(2,(e,t)=>LP(e,of$4(t))),LP=dual(2,(e,t)=>$P(t,e)),UP=dual(2,(e,t)=>cons(t,e)),$P=dual(2,(e,t)=>{if(isNil(e))return t;if(isNil(t))return e;{const r=makeCons(t.head,e);let n=r,i=t.tail;for(;!isNil(i);){const t=makeCons(i.head,e);n.tail=t,n=t,i=i.tail}return r}}),BP=dual(2,(e,t)=>{let r=e,n=t;for(;isCons(n);)r=makeCons(n.head,r),n=n.tail;return r}),zP=dual(2,(e,t)=>{if(t<=0)return e;if(t>=size$v(e))return jP;let r=e,n=0;for(;!isNil(r)&&n<t;)r=r.tail,n+=1;return r}),qP=dual(2,(e,t)=>{for(const r of e)if(!t(r))return!1;return!0}),WP=dual(2,(e,t)=>{let r=e;for(;!isNil(r);){if(t(r.head))return!0;r=r.tail}return!1}),VP=dual(2,(e,t)=>noneIn(e,t,!1)),noneIn=(e,t,r)=>{for(;;){if(isNil(e))return jP;if(t(e.head)!==r)return allIn(e,e.tail,t,r);e=e.tail}},allIn=(start,e,t,r)=>{for(;;){if(isNil(e))return start;if(t(e.head)===r)return partialFill(start,e,t,r);e=e.tail}},partialFill=(e,r,n,i)=>{const s=makeCons(unsafeHead(e),jP);let o=unsafeTail(e),a=s;for(;o!==r;){const e=makeCons(unsafeHead(o),jP);a.tail=e,a=t(e),o=t(o.tail)}let u=r.tail,c=t(u);for(;!isNil(u);)if(n(unsafeHead(u))!==i)u=u.tail;else{for(;c!==u;){const e=makeCons(unsafeHead(c),jP);a.tail=e,a=e,c=t(c.tail)}c=t(u.tail),u=u.tail}return isNil(c)||(a.tail=c),s},KP=dual(2,(e,t)=>{const r=[];for(const n of e){const e=t(n);zt(e)&&r.push(e.value)}return fromIterable$p(r)}),GP=dual(2,(e,t)=>{let r=e;for(;!isNil(r);){if(t(r.head))return Ut(r.head);r=r.tail}return none$c()}),JP=dual(2,(e,t)=>{let r,n,i=e;for(;!isNil(i);){let e=t(i.head);for(;!isNil(e);){const t=makeCons(e.head,jP);void 0===n?r=t:n.tail=t,n=t,e=e.tail}i=i.tail}return void 0===r?jP:r}),HP=dual(2,(e,t)=>{let r=e;for(;!isNil(r);)t(r.head),r=r.tail}),ZP=dual(2,(e,t)=>{if(isNil(e))return e;{let r=0;const n=makeCons(t(e.head,r++),jP);let i=n,s=e.tail;for(;!isNil(s);){const e=makeCons(t(s.head,r++),jP);i.tail=e,i=e,s=s.tail}return n}}),QP=dual(2,(e,t)=>{const r=[],n=[];for(const i of e)t(i)?n.push(i):r.push(i);return[fromIterable$p(r),fromIterable$p(n)]}),YP=dual(2,(e,t)=>{const r=[],n=[];for(const i of e){const e=t(i);Xe(e)?r.push(e.left):n.push(e.right)}return[fromIterable$p(r),fromIterable$p(n)]}),XP=dual(3,(e,t,r)=>{let n=t,i=e;for(;!isNil(i);)n=r(n,i.head),i=i.tail;return n}),eN=dual(3,(e,t,r)=>{let n=t,i=reverse$2(e);for(;!isNil(i);)n=r(n,i.head),i=i.tail;return n}),reverse$2=e=>{let t=RP(),r=e;for(;!isNil(r);)t=UP(t,r.head),r=r.tail;return t},tN=dual(2,(e,t)=>[rN(e,t),zP(e,t)]),rN=dual(2,(e,t)=>{if(t<=0)return jP;if(t>=size$v(e))return e;let r=make$23(unsafeHead(e)),n=unsafeTail(e);for(let e=1;e<t;e++)r=makeCons(unsafeHead(n),r),n=unsafeTail(n);return reverse$2(r)}),nN="Expected List to be non-empty",unsafeHead=e=>{if(isNil(e))throw Error(nN);return e.head},unsafeLast=e=>{if(isNil(e))throw Error(nN);let t=e,r=e.tail;for(;!isNil(r);)t=r,r=r.tail;return t.head},unsafeTail=e=>{if(isNil(e))throw Error(nN);return e.tail};var iN=Object.freeze({__proto__:null,TypeId:CP,append:DP,appendAll:LP,compact:e=>KP(e,identity$5),cons,drop:zP,empty:RP,every:qP,filter:VP,filterMap:KP,findFirst:GP,flatMap:JP,forEach:HP,fromIterable:fromIterable$p,getEquivalence:getEquivalence$3,head:e=>isNil(e)?none$c():Ut(e.head),isCons,isList,isNil,last:e=>isNil(e)?none$c():Ut(unsafeLast(e)),make:make$23,map:ZP,nil,of:of$4,partition:QP,partitionMap:YP,prepend:UP,prependAll:$P,prependAllReversed:BP,reduce:XP,reduceRight:eN,reverse:reverse$2,size:size$v,some:WP,splitAt:tN,tail:e=>isNil(e)?none$c():Ut(e.tail),take:rN,toArray:toArray$8,toChunk:e=>fromIterable$u(e),unsafeHead,unsafeLast,unsafeTail});const sN=Object.assign(Object.create(Array.prototype),{[Z](){return cached$2(this,array$6(this))},[Y](e){return!(!Array.isArray(e)||this.length!==e.length)&&this.every((t,r)=>equals$4(t,e[r]))}}),oN=function(){function Structural(e){e&&Object.assign(this,e)}return Structural.prototype=Ce,Structural}(),struct$2=e=>Object.assign(Object.create(Ce),e),aN=Symbol.for("effect/DifferChunkPatch");function variance$a(e){return e}const uN={...oN.prototype,[aN]:{_Value:variance$a,_Patch:variance$a}},cN=Object.create(Object.assign(Object.create(uN),{_tag:"Empty"})),empty$L=()=>cN,lN=Object.assign(Object.create(uN),{_tag:"AndThen"}),pN=Object.assign(Object.create(uN),{_tag:"Append"}),fN=Object.assign(Object.create(uN),{_tag:"Slice"}),hN=Object.assign(Object.create(uN),{_tag:"Update"}),makeUpdate$2=(e,t)=>{const r=Object.create(hN);return r.index=e,r.patch=t,r},dN=dual(2,(e,t)=>((e,t)=>{const r=Object.create(lN);return r.first=e,r.second=t,r})(e,t)),mN=dual(3,(e,t,r)=>{if("Empty"===e._tag)return t;let n=t,i=of$5(e);for(;isNonEmpty$8(i);){const e=lC(i),t=tailNonEmpty(i);switch(e._tag){case"Empty":i=t;break;case"AndThen":i=JA(e.first)(JA(e.second)(t));break;case"Append":n=eC(e.values)(n),i=t;break;case"Slice":{const r=toReadonlyArray$1(n);n=unsafeFromArray(r.slice(e.from,e.until)),i=t;break}case"Update":{const s=toReadonlyArray$1(n);s[e.index]=r.patch(e.patch,s[e.index]),n=unsafeFromArray(s),i=t;break}}}return n}),gN=Symbol.for("effect/DifferContextPatch");function variance$9(e){return e}const yN={...oN.prototype,[gN]:{_Value:variance$9,_Patch:variance$9}},bN=Object.create(Object.assign(Object.create(yN),{_tag:"Empty"})),empty$K=()=>bN,SN=Object.assign(Object.create(yN),{_tag:"AndThen"}),vN=Object.assign(Object.create(yN),{_tag:"AddService"}),makeAddService=(e,t)=>{const r=Object.create(vN);return r.key=e,r.service=t,r},_N=Object.assign(Object.create(yN),{_tag:"RemoveService"}),makeRemoveService=e=>{const t=Object.create(_N);return t.key=e,t},wN=Object.assign(Object.create(yN),{_tag:"UpdateService"}),makeUpdateService=(e,t)=>{const r=Object.create(wN);return r.key=e,r.update=t,r},kN=dual(2,(e,t)=>((e,t)=>{const r=Object.create(SN);return r.first=e,r.second=t,r})(e,t)),xN=dual(2,(e,t)=>{if("Empty"===e._tag)return t;let r=!1,n=of$5(e);const i=new Map(t.unsafeMap);for(;isNonEmpty$8(n);){const e=lC(n),t=tailNonEmpty(n);switch(e._tag){case"Empty":n=t;break;case"AddService":i.set(e.key,e.service),n=t;break;case"AndThen":n=JA(JA(t,e.second),e.first);break;case"RemoveService":i.delete(e.key),n=t;break;case"UpdateService":i.set(e.key,e.update(i.get(e.key))),r=!0,n=t}}if(!r)return makeContext$1(i);const s=new Map;for(const[e]of t.unsafeMap)i.has(e)&&(s.set(e,i.get(e)),i.delete(e));for(const[e,t]of i)s.set(e,t);return makeContext$1(s)}),IN=Symbol.for("effect/DifferHashMapPatch");function variance$8(e){return e}const TN={...oN.prototype,[IN]:{_Value:variance$8,_Key:variance$8,_Patch:variance$8}},ON=Object.create(Object.assign(Object.create(TN),{_tag:"Empty"})),empty$J=()=>ON,EN=Object.assign(Object.create(TN),{_tag:"AndThen"}),AN=Object.assign(Object.create(TN),{_tag:"Add"}),makeAdd$1=(e,t)=>{const r=Object.create(AN);return r.key=e,r.value=t,r},CN=Object.assign(Object.create(TN),{_tag:"Remove"}),MN=Object.assign(Object.create(TN),{_tag:"Update"}),makeUpdate$1=(e,t)=>{const r=Object.create(MN);return r.key=e,r.patch=t,r},FN=dual(2,(e,t)=>((e,t)=>{const r=Object.create(EN);return r.first=e,r.second=t,r})(e,t)),PN=dual(3,(e,t,r)=>{if("Empty"===e._tag)return t;let n=t,i=of$5(e);for(;isNonEmpty$8(i);){const e=lC(i),t=tailNonEmpty(i);switch(e._tag){case"Empty":i=t;break;case"AndThen":i=JA(e.first)(JA(e.second)(t));break;case"Add":n=vP(e.key,e.value)(n),i=t;break;case"Remove":n=IP(e.key)(n),i=t;break;case"Update":{const s=yP(e.key)(n);"Some"===s._tag&&(n=vP(e.key,r.patch(e.patch,s.value))(n)),i=t;break}}}return n}),NN=Symbol.for("effect/DifferHashSetPatch");function variance$7(e){return e}const jN={...oN.prototype,[NN]:{_Value:variance$7,_Key:variance$7,_Patch:variance$7}},RN=Object.create(Object.assign(Object.create(jN),{_tag:"Empty"})),empty$I=()=>RN,DN=Object.assign(Object.create(jN),{_tag:"AndThen"}),LN=Object.assign(Object.create(jN),{_tag:"Add"}),makeAdd=e=>{const t=Object.create(LN);return t.value=e,t},UN=Object.assign(Object.create(jN),{_tag:"Remove"}),$N=dual(2,(e,t)=>((e,t)=>{const r=Object.create(DN);return r.first=e,r.second=t,r})(e,t)),BN=dual(2,(e,t)=>{if("Empty"===e._tag)return t;let r=t,n=of$5(e);for(;isNonEmpty$8(n);){const e=lC(n),t=tailNonEmpty(n);switch(e._tag){case"Empty":n=t;break;case"AndThen":n=JA(e.first)(JA(e.second)(t));break;case"Add":r=AF(e.value)(r),n=t;break;case"Remove":r=CF(e.value)(r),n=t}}return r}),zN=Symbol.for("effect/DifferOrPatch");function variance$6(e){return e}const qN={...oN.prototype,[zN]:{_Value:variance$6,_Key:variance$6,_Patch:variance$6}},WN=Object.create(Object.assign(Object.create(qN),{_tag:"Empty"})),empty$H=()=>WN,VN=Object.assign(Object.create(qN),{_tag:"AndThen"}),KN=Object.assign(Object.create(qN),{_tag:"SetLeft"}),GN=Object.assign(Object.create(qN),{_tag:"SetRight"}),JN=Object.assign(Object.create(qN),{_tag:"UpdateLeft"}),HN=Object.assign(Object.create(qN),{_tag:"UpdateRight"}),ZN=dual(2,(e,t)=>((e,t)=>{const r=Object.create(VN);return r.first=e,r.second=t,r})(e,t)),QN=dual(2,(e,{left:t,oldValue:r,right:n})=>{if("Empty"===e._tag)return r;let i=of$5(e),s=r;for(;isNonEmpty$8(i);){const e=lC(i),r=tailNonEmpty(i);switch(e._tag){case"Empty":i=r;break;case"AndThen":i=JA(e.first)(JA(e.second)(r));break;case"UpdateLeft":"Left"===s._tag&&(s=He(t.patch(e.patch,s.left))),i=r;break;case"UpdateRight":"Right"===s._tag&&(s=Ge(n.patch(e.patch,s.right))),i=r;break;case"SetLeft":s=He(e.value),i=r;break;case"SetRight":s=Ge(e.value),i=r}}return s}),YN=Symbol.for("effect/DifferReadonlyArrayPatch");function variance$5(e){return e}const XN={...oN.prototype,[YN]:{_Value:variance$5,_Patch:variance$5}},ej=Object.create(Object.assign(Object.create(XN),{_tag:"Empty"})),empty$G=()=>ej,tj=Object.assign(Object.create(XN),{_tag:"AndThen"}),rj=Object.assign(Object.create(XN),{_tag:"Append"}),nj=Object.assign(Object.create(XN),{_tag:"Slice"}),ij=Object.assign(Object.create(XN),{_tag:"Update"}),makeUpdate=(e,t)=>{const r=Object.create(ij);return r.index=e,r.patch=t,r},sj=dual(2,(e,t)=>((e,t)=>{const r=Object.create(tj);return r.first=e,r.second=t,r})(e,t)),oj=dual(3,(e,t,r)=>{if("Empty"===e._tag)return t;let n=t.slice(),i=of$6(e);for(;ui(i);){const e=hi(i),t=tailNonEmpty$1(i);switch(e._tag){case"Empty":i=t;break;case"AndThen":t.unshift(e.first,e.second),i=t;break;case"Append":for(const t of e.values)n.push(t);i=t;break;case"Slice":n=n.slice(e.from,e.until),i=t;break;case"Update":n[e.index]=r.patch(e.patch,n[e.index]),i=t}}return n}),aj=Symbol.for("effect/Differ"),uj={[aj]:{_P:identity$5,_V:identity$5},pipe(){return pipeArguments(this,arguments)}},make$22=e=>{const t=Object.create(uj);return t.empty=e.empty,t.diff=e.diff,t.combine=e.combine,t.patch=e.patch,t},environment$1=()=>make$22({empty:empty$K(),combine:(e,t)=>kN(t)(e),diff:(e,t)=>((e,t)=>{const r=new Map(e.unsafeMap);let n=empty$K();for(const[e,i]of t.unsafeMap.entries())if(r.has(e)){const t=r.get(e);r.delete(e),equals$4(t,i)||(n=kN(makeUpdateService(e,()=>i))(n))}else r.delete(e),n=kN(makeAddService(e,i))(n);for(const[e]of r.entries())n=kN(makeRemoveService(e))(n);return n})(e,t),patch:(e,t)=>xN(t)(e)}),hashSet$3=()=>make$22({empty:empty$I(),combine:(e,t)=>$N(t)(e),diff:(e,t)=>((e,t)=>{const[r,n]=RF([e,empty$I()],([e,t],r)=>TF(r)(e)?[CF(r)(e),t]:[e,$N(makeAdd(r))(t)])(t);return RF(n,(e,t)=>$N((e=>{const t=Object.create(UN);return t.value=e,t})(t))(e))(r)})(e,t),patch:(e,t)=>BN(t)(e)}),cj=dual(2,(e,t)=>make$22({empty:empty$H(),combine:(e,t)=>ZN(e,t),diff:(r,n)=>(e=>{switch(e.oldValue._tag){case"Left":switch(e.newValue._tag){case"Left":{const t=e.left.diff(e.oldValue.left,e.newValue.left);return equals$4(t,e.left.empty)?empty$H():(e=>{const t=Object.create(JN);return t.patch=e,t})(t)}case"Right":return(e=>{const t=Object.create(GN);return t.value=e,t})(e.newValue.right)}case"Right":switch(e.newValue._tag){case"Left":return(e=>{const t=Object.create(KN);return t.value=e,t})(e.newValue.left);case"Right":{const t=e.right.diff(e.oldValue.right,e.newValue.right);return equals$4(t,e.right.empty)?empty$H():(e=>{const t=Object.create(HN);return t.patch=e,t})(t)}}}})({oldValue:r,newValue:n,left:e,right:t}),patch:(r,n)=>QN(r,{oldValue:n,left:e,right:t})})),readonlyArray$1=e=>make$22({empty:empty$G(),combine:(e,t)=>sj(e,t),diff:(t,r)=>(e=>{let t=0,r=empty$G();for(;t<e.oldValue.length&&t<e.newValue.length;){const n=e.oldValue[t],i=e.newValue[t],s=e.differ.diff(n,i);equals$4(s,e.differ.empty)||(r=sj(r,makeUpdate(t,s))),t+=1}return t<e.oldValue.length&&(r=sj(r,((e,t)=>{const r=Object.create(nj);return r.from=0,r.until=t,r})(0,t))),t<e.newValue.length&&(r=sj(r,(e=>{const t=Object.create(rj);return t.values=e,t})(bi(t)(e.newValue)))),r})({oldValue:t,newValue:r,differ:e}),patch:(t,r)=>oj(t,r,e)}),lj=dual(2,(e,{toNew:t,toOld:r})=>make$22({empty:e.empty,combine:(t,r)=>e.combine(t,r),diff:(t,n)=>e.diff(r(t),r(n)),patch:(n,i)=>t(e.patch(n,r(i)))})),update$f=()=>updateWith$3((e,t)=>t),updateWith$3=e=>make$22({empty:identity$5,combine:(e,t)=>e===identity$5?t:t===identity$5?e:r=>t(e(r)),diff:(e,t)=>equals$4(e,t)?identity$5:constant$2(t),patch:(t,r)=>e(r,t(r))}),pj=dual(2,(e,t)=>make$22({empty:[e.empty,t.empty],combine:(r,n)=>[e.combine(r[0],n[0]),t.combine(r[1],n[1])],diff:(r,n)=>[e.diff(r[0],n[0]),t.diff(r[1],n[1])],patch:(r,n)=>[e.patch(r[0],n[0]),t.patch(r[1],n[1])]})),fj=255,active=e=>e&fj,enabled=e=>e>>8&fj,make$21=(e,t)=>(e&fj)+((t&e&fj)<<8),hj=make$21(0,0),enable$3=e=>make$21(e,e),disable$3=e=>make$21(e,0),dj=dual(2,(e,t)=>0!==(active(e)&t)),mj=dual(2,(e,t)=>0!==(enabled(e)&t)),gj=dual(2,(e,t)=>0!==(active(e)&t)&&0===(enabled(e)&t)),yj=dual(2,(e,t)=>make$21(active(e)&~t,enabled(e))),bj=dual(2,(e,t)=>make$21(active(e)|active(t),enabled(e)&enabled(t))),Sj=dual(2,(e,t)=>make$21(active(e)|active(t),enabled(e)|enabled(t))),vj=dual(2,(e,t)=>e|t),invert=e=>~e>>>0&fj,_j=16,wj=32,kj=[0,1,2,4,_j,wj],print=e=>{switch(e){case wj:return"CooperativeYielding";case _j:return"WindDown";case 4:return"RuntimeMetrics";case 2:return"OpSupervision";case 1:return"Interruption";case 0:return"None"}},cooperativeYielding$1=e=>Aj(e,wj),xj=dual(2,(e,t)=>e&~t),Ij=dual(2,(e,t)=>e&~t),Tj=dual(2,(e,t)=>e|t),Oj=dual(2,(e,t)=>e|t),interruptible$4=e=>interruption$1(e)&&!windDown$1(e),interruption$1=e=>Aj(e,1),Ej=dual(2,(e,t)=>!Aj(e,t)),Aj=dual(2,(e,t)=>0!==(e&t)),make$20=(...e)=>e.reduce((e,t)=>e|t,0),Cj=make$20(0),runtimeMetrics$1=e=>Aj(e,4),toSet$2=e=>new Set(kj.filter(t=>Aj(e,t))),windDown$1=e=>Aj(e,_j),enabledSet$1=e=>toSet$2(active(e)&enabled(e)),disabledSet$1=e=>toSet$2(active(e)&~enabled(e)),Mj=dual(2,(e,t)=>make$21(e^t,t)),Fj=dual(2,(e,t)=>e&(invert(active(t))|enabled(t))|active(t)&enabled(t)),Pj=make$22({empty:hj,diff:(e,t)=>Mj(e,t),combine:(e,t)=>vj(t)(e),patch:(e,t)=>Fj(t,e)}),Nj=hj,jj=enable$3,Rj=disable$3,Dj=yj;var Lj=Object.freeze({__proto__:null,andThen:vj,both:bj,disable:Rj,disabledSet:disabledSet$1,either:Sj,empty:Nj,enable:jj,enabledSet:enabledSet$1,exclude:Dj,includes:dj,inverse:e=>make$21(enabled(e),invert(active(e))),isActive:dj,isDisabled:gj,isEmpty:e=>0===e,isEnabled:mj,make:make$21,render:e=>`RuntimeFlagsPatch(enabled = (${Array.from(enabledSet$1(e)).map(e=>print(e)).join(", ")}), disabled = (${Array.from(disabledSet$1(e)).map(e=>print(e)).join(", ")}))`});const Uj={_tag:"Empty"},par=(e,t)=>({_tag:"Par",left:e,right:t}),seq=(e,t)=>({_tag:"Seq",left:e,right:t}),single$1=(e,t)=>({_tag:"Single",dataSource:e,blockedRequest:t}),reduce$k=(e,t)=>{let r=of$4(e),n=RP();for(;isCons(r);){const e=r.head;switch(e._tag){case"Empty":n=cons(Ge(t.emptyCase()),n),r=r.tail;break;case"Par":n=cons(He({_tag:"ParCase"}),n),r=cons(e.left,cons(e.right,r.tail));break;case"Seq":n=cons(He({_tag:"SeqCase"}),n),r=cons(e.left,cons(e.right,r.tail));break;case"Single":{const i=t.singleCase(e.dataSource,e.blockedRequest);n=cons(Ge(i),n),r=r.tail;break}}}const i=XP(n,RP(),(e,r)=>{switch(r._tag){case"Left":{const n=unsafeHead(e),i=unsafeHead(unsafeTail(e)),s=unsafeTail(unsafeTail(e));switch(r.left._tag){case"ParCase":return cons(t.parCase(n,i),s);case"SeqCase":return cons(t.seqCase(n,i),s)}}case"Right":return cons(r.right,e)}});if(isNil(i))throw Error("BUG: BlockedRequests.reduce - please report an issue at https://github.com/Effect-TS/effect/issues");return i.head},step$2=e=>{let t=e,r=parallelCollectionEmpty(),n=RP(),i=RP();for(;;)switch(t._tag){case"Empty":if(isNil(n))return[r,i];t=n.head,n=n.tail;break;case"Par":n=cons(t.right,n),t=t.left;break;case"Seq":{const e=t.left,r=t.right;switch(e._tag){case"Empty":t=r;break;case"Par":{const n=e.left,i=e.right;t=par(seq(n,r),seq(i,r));break}case"Seq":{const n=e.left,i=e.right;t=seq(n,seq(i,r));break}case"Single":t=e,i=cons(r,i)}break}case"Single":if(r=parallelCollectionAdd(r,t),isNil(n))return[r,i];t=n.head,n=n.tail}throw Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues")},merge$b=(e,t)=>{if(isNil(e))return of$4(parallelCollectionToSequentialCollection(t));if(parallelCollectionIsEmpty(t))return e;const r=sequentialCollectionKeys(e.head),n=parallelCollectionKeys(t);return 1===r.length&&1===n.length&&equals$4(r[0],n[0])?cons(sequentialCollectionCombine(e.head,parallelCollectionToSequentialCollection(t)),e.tail):cons(parallelCollectionToSequentialCollection(t),e)},$j=Symbol.for("effect/RequestBlock/Entry");class EntryImpl{request;result;listeners;ownerId;state;[$j]=Bj;constructor(e,t,r,n,i){this.request=e,this.result=t,this.listeners=r,this.ownerId=n,this.state=i}}const Bj={_R:e=>e},makeEntry$1=e=>new EntryImpl(e.request,e.result,e.listeners,e.ownerId,e.state),zj=Symbol.for("effect/RequestBlock/RequestBlockParallel"),qj={_R:e=>e};class ParallelImpl{map;[zj]=qj;constructor(e){this.map=e}}const parallelCollectionEmpty=()=>new ParallelImpl(mP()),parallelCollectionAdd=(e,t)=>new ParallelImpl(xP(e.map,t.dataSource,e=>Jt(er(e,GA(t.blockedRequest)),()=>of$5(t.blockedRequest)))),parallelCollectionCombine=(e,t)=>new ParallelImpl(EP(e.map,t.map,(e,t,r)=>vP(e,r,qt(yP(e,r),{onNone:()=>t,onSome:e=>eC(t,e)})))),parallelCollectionIsEmpty=e=>isEmpty$r(e.map),parallelCollectionKeys=e=>Array.from(_P(e.map)),parallelCollectionToSequentialCollection=e=>sequentialCollectionMake(TP(e.map,e=>of$5(e))),Wj=Symbol.for("effect/RequestBlock/RequestBlockSequential"),Vj={_R:e=>e};class SequentialImpl{map;[Wj]=Vj;constructor(e){this.map=e}}const sequentialCollectionMake=e=>new SequentialImpl(e),sequentialCollectionCombine=(e,t)=>new SequentialImpl(EP(t.map,e.map,(e,t,r)=>vP(e,r,qt(yP(e,r),{onNone:()=>empty$R(),onSome:e=>eC(e,t)})))),sequentialCollectionKeys=e=>Array.from(_P(e.map)),Kj="Die",Gj="Empty",Jj="Fail",Hj="Interrupt",Zj="Parallel",Qj="Sequential",Yj="effect/Cause",Xj=Symbol.for(Yj),eR={[Xj]:{_E:e=>e},[Z](){return pipe(hash$3(Yj),combine$h(hash$3(flattenCause(this))),cached$2(this))},[Y](e){return isCause$1(e)&&causeEquals(this,e)},pipe(){return pipeArguments(this,arguments)},toJSON(){switch(this._tag){case"Empty":return{_id:"Cause",_tag:this._tag};case"Die":return{_id:"Cause",_tag:this._tag,defect:toJSON(this.defect)};case"Interrupt":return{_id:"Cause",_tag:this._tag,fiberId:this.fiberId.toJSON()};case"Fail":return{_id:"Cause",_tag:this._tag,failure:toJSON(this.error)};case"Sequential":case"Parallel":return{_id:"Cause",_tag:this._tag,left:toJSON(this.left),right:toJSON(this.right)}}},toString(){return pretty$4(this)},[ee](){return this.toJSON()}},tR=(()=>{const e=Object.create(eR);return e._tag=Gj,e})(),fail$s=e=>{const t=Object.create(eR);return t._tag=Jj,t.error=e,t},die$h=e=>{const t=Object.create(eR);return t._tag=Kj,t.defect=e,t},interrupt$a=e=>{const t=Object.create(eR);return t._tag=Hj,t.fiberId=e,t},parallel$4=(e,t)=>{const r=Object.create(eR);return r._tag=Zj,r.left=e,r.right=t,r},sequential$4=(e,t)=>{const r=Object.create(eR);return r._tag=Qj,r.left=e,r.right=t,r},isCause$1=e=>C(e,Xj),isEmptyType$1=e=>e._tag===Gj,isDieType$1=e=>e._tag===Kj,isEmpty$o=e=>e._tag===Gj||mR(e,!0,(e,t)=>{switch(t._tag){case Gj:return Ut(e);case Kj:case Jj:case Hj:return Ut(!1);default:return none$c()}}),isInterrupted$2=e=>zt(interruptOption$1(e)),isInterruptedOnly$1=e=>gR(void 0,pR)(e),failures$1=e=>reverse$3(mR(e,empty$R(),(e,t)=>t._tag===Jj?Ut(pipe(e,JA(t.error))):none$c())),defects$1=e=>reverse$3(mR(e,empty$R(),(e,t)=>t._tag===Kj?Ut(pipe(e,JA(t.defect))):none$c())),interruptors$1=e=>mR(e,IF(),(e,t)=>t._tag===Hj?Ut(pipe(e,AF(t.fiberId))):none$c()),failureOption$1=e=>uR(e,e=>e._tag===Jj?Ut(e.error):none$c()),failureOrCause$1=e=>{const t=failureOption$1(e);switch(t._tag){case"None":return Ge(e);case"Some":return He(t.value)}},dieOption$1=e=>uR(e,e=>e._tag===Kj?Ut(e.defect):none$c()),interruptOption$1=e=>uR(e,e=>e._tag===Hj?Ut(e.fiberId):none$c()),keepDefects$1=e=>dR(e,{onEmpty:none$c(),onFail:()=>none$c(),onDie:e=>Ut(die$h(e)),onInterrupt:()=>none$c(),onSequential:mergeWith$4(sequential$4),onParallel:mergeWith$4(parallel$4)}),stripFailures$1=e=>dR(e,{onEmpty:tR,onFail:()=>tR,onDie:die$h,onInterrupt:interrupt$a,onSequential:sequential$4,onParallel:parallel$4}),rR=dual(2,(e,t)=>dR(e,{onEmpty:Ut(tR),onFail:e=>Ut(fail$s(e)),onDie:e=>{const r=t(e);return zt(r)?none$c():Ut(die$h(e))},onInterrupt:e=>Ut(interrupt$a(e)),onSequential:mergeWith$4(sequential$4),onParallel:mergeWith$4(parallel$4)})),nR=dual(2,(e,t)=>iR(e,()=>t)),iR=dual(2,(e,t)=>sR(e,e=>fail$s(t(e)))),sR=dual(2,(e,t)=>dR(e,{onEmpty:tR,onFail:e=>t(e),onDie:e=>die$h(e),onInterrupt:e=>interrupt$a(e),onSequential:(e,t)=>sequential$4(e,t),onParallel:(e,t)=>parallel$4(e,t)})),flatten$d=e=>sR(e,identity$5),oR=dual(2,(e,t)=>A(t)?sR(e,t):sR(e,()=>t)),aR=dual(2,(e,t)=>t._tag===Gj||e===t||mR(e,!1,(e,r)=>Ut(e||causeEquals(r,t)))),causeEquals=(e,t)=>{let r=of$5(e),n=of$5(t);for(;isNonEmpty$8(r)&&isNonEmpty$8(n);){const[e,t]=pipe(lC(r),mR([IF(),empty$R()],([e,t],r)=>{const[n,i]=evaluateCause(r);return Ut([pipe(e,FF(n)),pipe(t,eC(i))])})),[i,s]=pipe(lC(n),mR([IF(),empty$R()],([e,t],r)=>{const[n,i]=evaluateCause(r);return Ut([pipe(e,FF(n)),pipe(t,eC(i))])}));if(!equals$4(e,i))return!1;r=t,n=s}return!0},flattenCause=e=>flattenCauseLoop(of$5(e),empty$R()),flattenCauseLoop=(e,t)=>{for(;;){const[r,n]=pipe(e,ys([IF(),empty$R()],([e,t],r)=>{const[n,i]=evaluateCause(r);return[pipe(e,FF(n)),pipe(t,eC(i))]})),i=size$x(r)>0?pipe(t,JA(r)):t;if(isEmpty$t(n))return reverse$3(i);e=n,t=i}throw Error(getBugErrorMessage("Cause.flattenCauseLoop"))},uR=dual(2,(e,t)=>{const r=[e];for(;r.length>0;){const e=r.pop(),n=t(e);switch(n._tag){case"None":switch(e._tag){case Qj:case Zj:r.push(e.right),r.push(e.left)}break;case"Some":return n}}return none$c()}),cR=dual(2,(e,t)=>gR(e,void 0,FilterCauseReducer(t))),evaluateCause=e=>{let t=e;const r=[];let n=IF(),i=empty$R();for(;void 0!==t;)switch(t._tag){case Gj:if(0===r.length)return[n,i];t=r.pop();break;case Jj:if(n=AF(n,make$2d(t._tag,t.error)),0===r.length)return[n,i];t=r.pop();break;case Kj:if(n=AF(n,make$2d(t._tag,t.defect)),0===r.length)return[n,i];t=r.pop();break;case Hj:if(n=AF(n,make$2d(t._tag,t.fiberId)),0===r.length)return[n,i];t=r.pop();break;case Qj:switch(t.left._tag){case Gj:t=t.right;break;case Qj:t=sequential$4(t.left.left,sequential$4(t.left.right,t.right));break;case Zj:t=parallel$4(sequential$4(t.left.left,t.right),sequential$4(t.left.right,t.right));break;default:i=JA(i,t.right),t=t.left}break;case Zj:r.push(t.right),t=t.left}throw Error(getBugErrorMessage("Cause.evaluateCauseLoop"))},lR={emptyCase:()=>0,failCase:()=>1,dieCase:()=>1,interruptCase:()=>1,sequentialCase:(e,t,r)=>t+r,parallelCase:(e,t,r)=>t+r},pR={emptyCase:r,failCase:n,dieCase:n,interruptCase:r,sequentialCase:(e,t,r)=>t&&r,parallelCase:(e,t,r)=>t&&r},FilterCauseReducer=e=>({emptyCase:()=>tR,failCase:(e,t)=>fail$s(t),dieCase:(e,t)=>die$h(t),interruptCase:(e,t)=>interrupt$a(t),sequentialCase:(t,r,n)=>e(r)?e(n)?sequential$4(r,n):r:e(n)?n:tR,parallelCase:(t,r,n)=>e(r)?e(n)?parallel$4(r,n):r:e(n)?n:tR}),fR="SequentialCase",hR="ParallelCase",dR=dual(2,(e,{onDie:t,onEmpty:r,onFail:n,onInterrupt:i,onParallel:s,onSequential:o})=>gR(e,void 0,{emptyCase:()=>r,failCase:(e,t)=>n(t),dieCase:(e,r)=>t(r),interruptCase:(e,t)=>i(t),sequentialCase:(e,t,r)=>o(t,r),parallelCase:(e,t,r)=>s(t,r)})),mR=dual(3,(e,t,r)=>{let n=t,i=e;const s=[];for(;void 0!==i;){const e=r(n,i);switch(n=zt(e)?e.value:n,i._tag){case Qj:case Zj:s.push(i.right),i=i.left;break;default:i=void 0}void 0===i&&s.length>0&&(i=s.pop())}return n}),gR=dual(3,(e,t,r)=>{const n=[e],i=[];for(;n.length>0;){const e=n.pop();switch(e._tag){case Gj:i.push(Ge(r.emptyCase(t)));break;case Jj:i.push(Ge(r.failCase(t,e.error)));break;case Kj:i.push(Ge(r.dieCase(t,e.defect)));break;case Hj:i.push(Ge(r.interruptCase(t,e.fiberId)));break;case Qj:n.push(e.right),n.push(e.left),i.push(He({_tag:fR}));break;case Zj:n.push(e.right),n.push(e.left),i.push(He({_tag:hR}))}}const s=[];for(;i.length>0;){const e=i.pop();switch(e._tag){case"Left":switch(e.left._tag){case fR:{const e=s.pop(),n=s.pop(),i=r.sequentialCase(t,e,n);s.push(i);break}case hR:{const e=s.pop(),n=s.pop(),i=r.parallelCase(t,e,n);s.push(i);break}}break;case"Right":s.push(e.right)}}if(0===s.length)throw Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");return s.pop()}),pretty$4=(e,t)=>isInterruptedOnly$1(e)?"All fibers interrupted without errors.":prettyErrors$1(e).map(function(e){return!0!==t?.renderErrorCause||void 0===e.cause?e.stack:`${e.stack} {\n${renderErrorCause(e.cause,"  ")}\n}`}).join("\n"),renderErrorCause=(e,t)=>{const r=e.stack.split("\n");let n=`${t}[cause]: ${r[0]}`;for(let e=1,i=r.length;e<i;e++)n+=`\n${t}${r[e]}`;return e.cause&&(n+=` {\n${renderErrorCause(e.cause,t+"  ")}\n${t}}`),n};class PrettyError extends globalThis.Error{span=void 0;constructor(e){const t="object"==typeof e&&null!==e,r=Error.stackTraceLimit;Error.stackTraceLimit=1,super(prettyErrorMessage(e),t&&"cause"in e&&void 0!==e.cause?{cause:new PrettyError(e.cause)}:void 0),""===this.message&&(this.message="An error has occurred"),Error.stackTraceLimit=r,this.name=e instanceof Error?e.name:"Error",t&&(SR in e&&(this.span=e[SR]),Object.keys(e).forEach(t=>{t in this||(this[t]=e[t])})),this.stack=prettyErrorStack(`${this.name}: ${this.message}`,e instanceof Error&&e.stack?e.stack:"",this.span)}}const prettyErrorMessage=e=>{if("string"==typeof e)return e;if("object"==typeof e&&null!==e&&e instanceof Error)return e.message;try{if(C(e,"toString")&&A(e.toString)&&e.toString!==Object.prototype.toString&&e.toString!==globalThis.Array.prototype.toString)return e.toString()}catch{}return stringifyCircular(e)},yR=/\((.*)\)/g,bR=globalValue("effect/Tracer/spanToTrace",()=>new WeakMap),prettyErrorStack=(e,t,r)=>{const n=[e],i=t.startsWith(e)?t.slice(e.length).split("\n"):t.split("\n");for(let e=1;e<i.length;e++)if(i[e].includes(" at new BaseEffectError")||i[e].includes(" at new YieldableError"))e++;else{if(i[e].includes("Generator.next"))break;if(i[e].includes("effect_internal_function"))break;n.push(i[e].replace(/at .*effect_instruction_i.*\((.*)\)/,"at $1").replace(/EffectPrimitive\.\w+/,"<anonymous>"))}if(r){let e=r,t=0;for(;e&&"Span"===e._tag&&t<10;){const r=bR.get(e);if("function"==typeof r){const t=r();if("string"==typeof t){const r=t.matchAll(yR);let i=!1;for(const[,t]of r)i=!0,n.push(`    at ${e.name} (${t})`);i||n.push(`    at ${e.name} (${t.replace(/^at /,"")})`)}else n.push("    at "+e.name)}else n.push("    at "+e.name);e=Qt(e.parent),t++}}return n.join("\n")},SR=Symbol.for("effect/SpanAnnotation"),prettyErrors$1=e=>gR(e,void 0,{emptyCase:()=>[],dieCase:(e,t)=>[new PrettyError(t)],failCase:(e,t)=>[new PrettyError(t)],interruptCase:()=>[],parallelCase:(e,t,r)=>[...t,...r],sequentialCase:(e,t,r)=>[...t,...r]}),vR="Pending",_R="Done",wR=Symbol.for("effect/Deferred"),kR={_E:e=>e,_A:e=>e},done$f=e=>({_tag:_R,effect:e});class SingleShotGen{self;called=!1;constructor(e){this.self=e}next(e){return this.called?{value:e,done:!0}:(this.called=!0,{value:this.self,done:!1})}return(e){return{value:e,done:!0}}throw(e){throw e}[Symbol.iterator](){return new SingleShotGen(this.self)}}const blocked$1=(e,t)=>{const r=new EffectPrimitive("Blocked");return r.effect_instruction_i0=e,r.effect_instruction_i1=t,r},runRequestBlock$1=e=>{const t=new EffectPrimitive("RunBlocked");return t.effect_instruction_i0=e,t},xR=Symbol.for("effect/Effect");class RevertFlags{patch;op;_op=we;constructor(e,t){this.patch=e,this.op=t}}class EffectPrimitive{_op;effect_instruction_i0=void 0;effect_instruction_i1=void 0;effect_instruction_i2=void 0;trace=void 0;[xR]=Ee;constructor(e){this._op=e}[Y](e){return this===e}[Z](){return cached$2(this,random$2(this))}pipe(){return pipeArguments(this,arguments)}toJSON(){return{_id:"Effect",_op:this._op,effect_instruction_i0:toJSON(this.effect_instruction_i0),effect_instruction_i1:toJSON(this.effect_instruction_i1),effect_instruction_i2:toJSON(this.effect_instruction_i2)}}toString(){return format$6(this.toJSON())}[ee](){return this.toJSON()}[Symbol.iterator](){return new SingleShotGen(new YieldWrap(this))}}class EffectPrimitiveFailure{_op;effect_instruction_i0=void 0;effect_instruction_i1=void 0;effect_instruction_i2=void 0;trace=void 0;[xR]=Ee;constructor(e){this._op=e,this._tag=e}[Y](e){return exitIsExit(e)&&"Failure"===e._op&&equals$4(this.effect_instruction_i0,e.effect_instruction_i0)}[Z](){return pipe(string$6(this._tag),combine$h(hash$3(this.effect_instruction_i0)),cached$2(this))}get cause(){return this.effect_instruction_i0}pipe(){return pipeArguments(this,arguments)}toJSON(){return{_id:"Exit",_tag:this._op,cause:this.cause.toJSON()}}toString(){return format$6(this.toJSON())}[ee](){return this.toJSON()}[Symbol.iterator](){return new SingleShotGen(new YieldWrap(this))}}class EffectPrimitiveSuccess{_op;effect_instruction_i0=void 0;effect_instruction_i1=void 0;effect_instruction_i2=void 0;trace=void 0;[xR]=Ee;constructor(e){this._op=e,this._tag=e}[Y](e){return exitIsExit(e)&&"Success"===e._op&&equals$4(this.effect_instruction_i0,e.effect_instruction_i0)}[Z](){return pipe(string$6(this._tag),combine$h(hash$3(this.effect_instruction_i0)),cached$2(this))}get value(){return this.effect_instruction_i0}pipe(){return pipeArguments(this,arguments)}toJSON(){return{_id:"Exit",_tag:this._op,value:toJSON(this.value)}}toString(){return format$6(this.toJSON())}[ee](){return this.toJSON()}[Symbol.iterator](){return new SingleShotGen(new YieldWrap(this))}}const isEffect$1=e=>C(e,xR),withFiberRuntime$1=e=>{const t=new EffectPrimitive(ve);return t.effect_instruction_i0=e,t},IR=dual(3,(e,t,r)=>uninterruptibleMask$2(n=>PR(e,e=>PR(exit$2(suspend$g(()=>n(t(e)))),t=>suspend$g(()=>r(e,t)).pipe(RR({onFailure:e=>{switch(t._tag){case le:return failCause$j(sequential$4(t.effect_instruction_i0,e));case de:return failCause$j(e)}},onSuccess:()=>t})))))),TR=dual(2,(e,t)=>PR(e,()=>succeed$u(t))),asVoid$9=e=>TR(e,void 0),custom$1=function(){const e=new EffectPrimitive(ce);switch(arguments.length){case 2:e.effect_instruction_i0=arguments[0],e.commit=arguments[1];break;case 3:e.effect_instruction_i0=arguments[0],e.effect_instruction_i1=arguments[1],e.commit=arguments[2];break;case 4:e.effect_instruction_i0=arguments[0],e.effect_instruction_i1=arguments[1],e.effect_instruction_i2=arguments[2],e.commit=arguments[3];break;default:throw Error(getBugErrorMessage("you're not supposed to end up here"))}return e},unsafeAsync=(e,t=aP)=>{const r=new EffectPrimitive(ue);let n;return r.effect_instruction_i0=t=>{n=e(t)},r.effect_instruction_i1=t,JR(r,e=>isEffect$1(n)?n:tD)},asyncInterrupt=(e,t=aP)=>suspend$g(()=>unsafeAsync(e,t)),async_=(e,t=aP)=>custom$1(e,function(){let e,r;function proxyResume(t){e?e(t):void 0===r&&(r=t)}const n=new EffectPrimitive(ue);let i,s;return n.effect_instruction_i0=t=>{e=t,r&&t(r)},n.effect_instruction_i1=t,1!==this.effect_instruction_i0.length?(s=new AbortController,i=K(()=>this.effect_instruction_i0(proxyResume,s.signal))):i=K(()=>this.effect_instruction_i0(proxyResume)),i||s?JR(n,e=>(s&&s.abort(),i??tD)):n}),OR=dual(2,(e,t)=>{const r=new EffectPrimitive(pe);return r.effect_instruction_i0=e,r.effect_instruction_i1=t,r}),ER=dual(2,(e,t)=>DR(e,{onFailure:t,onSuccess:succeed$u})),AR=dual(3,(e,t,r)=>OR(e,e=>{const n=failureOrCause$1(e);switch(n._tag){case"Left":return t(n.left)?r(n.left):failCause$j(e);case"Right":return failCause$j(n.right)}})),CR=dual(2,(e,t)=>OR(e,e=>{const r=failureOrCause$1(e);switch(r._tag){case"Left":return pipe(t(r.left),Kt(()=>failCause$j(e)));case"Right":return failCause$j(r.right)}})),MR=Symbol.for("effect/OriginalAnnotation"),capture=(e,t)=>zt(t)?new Proxy(e,{has:(e,t)=>t===SR||t===MR||t in e,get:(r,n)=>n===SR?t.value:n===MR?e:r[n]}):e,die$g=e=>isObject(e)&&!(SR in e)?withFiberRuntime$1(t=>failCause$j(die$h(capture(e,currentSpanFromFiber(t))))):failCause$j(die$h(e)),dieMessage$9=e=>failCauseSync$b(()=>die$h(new fL(e))),dieSync$a=e=>PR(sync$l(e),die$g),either$a=e=>DR(e,{onFailure:e=>succeed$u(He(e)),onSuccess:e=>succeed$u(Ge(e))}),exit$2=e=>jR(e,{onFailure:exitFailCause$1,onSuccess:exitSucceed$1}),fail$r=e=>isObject(e)&&!(SR in e)?withFiberRuntime$1(t=>failCause$j(fail$s(capture(e,currentSpanFromFiber(t))))):failCause$j(fail$s(e)),failSync$d=e=>PR(sync$l(e),fail$r),failCause$j=e=>{const t=new EffectPrimitiveFailure(le);return t.effect_instruction_i0=e,t},failCauseSync$b=e=>PR(sync$l(e),failCause$j),FR=withFiberRuntime$1(e=>succeed$u(e.id())),fiberIdWith$1=e=>withFiberRuntime$1(t=>e(t.id())),PR=dual(2,(e,t)=>{const r=new EffectPrimitive(fe);return r.effect_instruction_i0=e,r.effect_instruction_i1=t,r}),NR=dual(2,(e,t)=>PR(e,e=>{const r="function"==typeof t?t(e):t;return isEffect$1(r)?r:isPromiseLike(r)?unsafeAsync(e=>{r.then(t=>e(succeed$u(t)),t=>e(fail$r(new TL(t,"An unknown error occurred in Effect.andThen"))))}):succeed$u(r)})),step$1=e=>{const t=new EffectPrimitive("OnStep");return t.effect_instruction_i0=e,t},flatten$c=e=>PR(e,identity$5),flip$4=e=>DR(e,{onFailure:succeed$u,onSuccess:fail$r}),jR=dual(2,(e,t)=>RR(e,{onFailure:e=>succeed$u(t.onFailure(e)),onSuccess:e=>succeed$u(t.onSuccess(e))})),RR=dual(2,(e,t)=>{const r=new EffectPrimitive(he);return r.effect_instruction_i0=e,r.effect_instruction_i1=t.onFailure,r.effect_instruction_i2=t.onSuccess,r}),DR=dual(2,(e,t)=>RR(e,{onFailure:e=>{if(defects$1(e).length>0)return failCause$j((e=>dR(e,{onEmpty:tR,onFail:die$h,onDie:die$h,onInterrupt:interrupt$a,onSequential:sequential$4,onParallel:parallel$4}))(e));const r=failures$1(e);return r.length>0?t.onFailure(unsafeHead$1(r)):failCause$j(e)},onSuccess:t.onSuccess})),LR=dual(2,(e,t)=>suspend$g(()=>{const r=fromIterable$v(e),n=allocate$1(r.length);let i=0;return TR(whileLoop$2({while:()=>i<r.length,body:()=>t(r[i],i),step:e=>{n[i++]=e}}),n)})),UR=dual(2,(e,t)=>suspend$g(()=>{const r=fromIterable$v(e);let n=0;return whileLoop$2({while:()=>n<r.length,body:()=>t(r[n],n),step:()=>{n++}})})),$R=dual(e=>"boolean"==typeof e[0]||isEffect$1(e[0]),(e,t)=>isEffect$1(e)?PR(e,e=>e?t.onTrue():t.onFalse()):e?t.onTrue():t.onFalse()),BR=PR(FR,e=>interruptWith$2(e)),interruptWith$2=e=>failCause$j(interrupt$a(e)),interruptible$3=e=>{const t=new EffectPrimitive(ye);return t.effect_instruction_i0=jj(1),t.effect_instruction_i1=()=>e,t},interruptibleMask$1=e=>custom$1(e,function(){const e=new EffectPrimitive(ye);return e.effect_instruction_i0=jj(1),e.effect_instruction_i1=e=>interruption$1(e)?K(()=>this.effect_instruction_i0(interruptible$3)):K(()=>this.effect_instruction_i0(uninterruptible$2)),e}),zR=dual(2,(e,t)=>uninterruptibleMask$2(r=>PR(exit$2(r(e)),e=>HL(t,e)))),qR=dual(2,(e,t)=>PR(e,e=>sync$l(()=>t(e)))),WR=dual(2,(e,t)=>DR(e,{onFailure:e=>failSync$d(()=>t.onFailure(e)),onSuccess:e=>sync$l(()=>t.onSuccess(e))})),VR=dual(2,(e,t)=>RR(e,{onFailure:e=>{const r=failureOrCause$1(e);switch(r._tag){case"Left":return failSync$d(()=>t(r.left));case"Right":return failCause$j(r.right)}},onSuccess:succeed$u})),KR=dual(2,(e,t)=>GR(e,e=>exitIsSuccess$1(e)?tD:t(e.effect_instruction_i0))),GR=dual(2,(e,t)=>uninterruptibleMask$2(r=>RR(r(e),{onFailure:e=>{const r=exitFailCause$1(e);return RR(t(r),{onFailure:t=>exitFailCause$1(sequential$4(e,t)),onSuccess:()=>r})},onSuccess:e=>{const r=exitSucceed$1(e);return lD(t(r),r)}}))),JR=dual(2,(e,t)=>GR(e,DL({onFailure:e=>isInterruptedOnly$1(e)?asVoid$9(t(interruptors$1(e))):tD,onSuccess:()=>tD}))),HR=dual(2,(e,t)=>eD(e,t,succeed$u)),orDie$a=e=>ZR(e,identity$5),ZR=dual(2,(e,t)=>DR(e,{onFailure:e=>die$g(t(e)),onSuccess:succeed$u})),QR=fs,YR=withFiberRuntime$1((e,t)=>succeed$u(t.runtimeFlags)),succeed$u=e=>{const t=new EffectPrimitiveSuccess(de);return t.effect_instruction_i0=e,t},suspend$g=e=>{const t=new EffectPrimitive(ce);return t.commit=e,t},sync$l=e=>{const t=new EffectPrimitive(me);return t.effect_instruction_i0=e,t},XR=dual(e=>3===e.length||2===e.length&&!(isObject(e[1])&&"onlyEffect"in e[1]),(e,t)=>PR(e,e=>{const r="function"==typeof t?t(e):t;return isEffect$1(r)?TR(r,e):isPromiseLike(r)?unsafeAsync(t=>{r.then(r=>t(succeed$u(e)),e=>t(fail$r(new TL(e,"An unknown error occurred in Effect.tap"))))}):succeed$u(e)})),transplant$1=e=>withFiberRuntime$1(t=>{const r=pipe(t.getFiberRef(tL),Kt(()=>t.scope()));return e(LD(tL,Ut(r)))}),eD=dual(3,(e,t,r)=>RR(e,{onFailure:e=>defects$1(e).length>0?failCause$j(Xt((e=>dR(e,{onEmpty:none$c(),onFail:e=>Ut(die$h(e)),onDie:e=>Ut(die$h(e)),onInterrupt:()=>none$c(),onSequential:mergeWith$4(sequential$4),onParallel:mergeWith$4(parallel$4)}))(e))):t(),onSuccess:r})),uninterruptible$2=e=>{const t=new EffectPrimitive(ye);return t.effect_instruction_i0=Rj(1),t.effect_instruction_i1=()=>e,t},uninterruptibleMask$2=e=>custom$1(e,function(){const e=new EffectPrimitive(ye);return e.effect_instruction_i0=Rj(1),e.effect_instruction_i1=e=>interruption$1(e)?K(()=>this.effect_instruction_i0(interruptible$3)):K(()=>this.effect_instruction_i0(uninterruptible$2)),e}),tD=succeed$u(void 0),updateRuntimeFlags$2=e=>{const t=new EffectPrimitive(ye);return t.effect_instruction_i0=e,t.effect_instruction_i1=void 0,t},rD=dual(2,(e,t)=>PR(t,t=>t?pipe(e,qR(Ut)):succeed$u(none$c()))),whileLoop$2=e=>{const t=new EffectPrimitive(be);return t.effect_instruction_i0=e.while,t.effect_instruction_i1=e.body,t.effect_instruction_i2=e.step,t},fromIterator$1=e=>suspend$g(()=>{const t=new EffectPrimitive(Se);return t.effect_instruction_i0=e(),t}),gen$4=function(){const e=1===arguments.length?arguments[0]:arguments[1].bind(arguments[0]);return fromIterator$1(()=>e(pipe))},fnUntraced$1=(e,...t)=>Object.defineProperty(0===t.length?function(...t){return fromIterator$1(()=>e.apply(this,t))}:function(...r){let n=fromIterator$1(()=>e.apply(this,r));for(const e of t)n=e(n,...r);return n},"length",{value:e.length,configurable:!0}),nD=dual(2,(e,t)=>LD(e,JD,t)),iD=dual(2,(e,t)=>LD(e,HD,t)),sD=dual(2,(e,t)=>{const r=new EffectPrimitive(ye);return r.effect_instruction_i0=t,r.effect_instruction_i1=()=>e,r}),oD=dual(2,(e,t)=>LD(e,nL,t)),aD=dual(2,(e,t)=>LD(e,iL,t)),yieldNow$3=e=>{const t=new EffectPrimitive(_e);return void 0!==e?.priority?KD(t,e.priority):t},uD=dual(2,(e,t)=>PR(e,e=>qR(t,t=>[e,t]))),cD=dual(2,(e,t)=>PR(e,e=>TR(t,e))),lD=dual(2,(e,t)=>PR(e,()=>t)),pD=dual(3,(e,t,r)=>PR(e,e=>qR(t,t=>r(e,t)))),fD=asyncInterrupt(()=>{const e=setInterval(()=>{},2**31-1);return sync$l(()=>clearInterval(e))}),interruptFiber=e=>PR(FR,t=>pipe(e,hD(t))),hD=dual(2,(e,t)=>PR(e.interruptAsFork(t),()=>e.await)),dD={_tag:"All",syslog:0,label:"ALL",ordinal:Number.MIN_SAFE_INTEGER,pipe(){return pipeArguments(this,arguments)}},mD={_tag:"Fatal",syslog:2,label:"FATAL",ordinal:5e4,pipe(){return pipeArguments(this,arguments)}},gD={_tag:"Error",syslog:3,label:"ERROR",ordinal:4e4,pipe(){return pipeArguments(this,arguments)}},yD={_tag:"Warning",syslog:4,label:"WARN",ordinal:3e4,pipe(){return pipeArguments(this,arguments)}},bD={_tag:"Info",syslog:6,label:"INFO",ordinal:2e4,pipe(){return pipeArguments(this,arguments)}},SD={_tag:"Debug",syslog:7,label:"DEBUG",ordinal:1e4,pipe(){return pipeArguments(this,arguments)}},vD={_tag:"Trace",syslog:7,label:"TRACE",ordinal:0,pipe(){return pipeArguments(this,arguments)}},_D={_tag:"None",syslog:7,label:"OFF",ordinal:Number.MAX_SAFE_INTEGER,pipe(){return pipeArguments(this,arguments)}},wD=[dD,vD,SD,bD,yD,gD,mD,_D],kD=Symbol.for("effect/FiberRef"),xD={_A:e=>e},fiberRefGet=e=>withFiberRuntime$1(t=>exitSucceed$1(t.getFiberRef(e))),ID=dual(2,(e,t)=>CD(e,e=>[e,t])),TD=dual(2,(e,t)=>CD(e,e=>[e,t(e)])),OD=dual(2,(e,t)=>CD(e,e=>[e,Kt(t(e),()=>e)])),ED=dual(2,(e,t)=>PR(fiberRefGet(e),t)),AD=dual(2,(e,t)=>CD(e,()=>[void 0,t])),fiberRefDelete=e=>withFiberRuntime$1(t=>(t.unsafeDeleteFiberRef(e),tD)),CD=dual(2,(e,t)=>withFiberRuntime$1(r=>{const[n,i]=t(r.getFiberRef(e));return r.setFiberRef(e,i),succeed$u(n)})),MD=dual(2,(e,t)=>CD(e,e=>[void 0,t(e)])),FD=dual(2,(e,t)=>CD(e,e=>[void 0,Kt(t(e),()=>e)])),PD=dual(2,(e,t)=>CD(e,e=>{const r=t(e);return[r,r]})),ND=dual(2,(e,t)=>CD(e,e=>{const r=Kt(t(e),()=>e);return[r,r]})),jD=Symbol.for("effect/RequestResolver"),RD={_A:e=>e,_R:e=>e};class RequestResolverImpl{runAll;target;[jD]=RD;constructor(e,t){this.runAll=e,this.target=t}[Z](){return cached$2(this,this.target?hash$3(this.target):random$2(this))}[Y](e){return this.target?isRequestResolver$1(e)&&equals$4(this.target,e.target):this===e}identified(...e){return new RequestResolverImpl(this.runAll,fromIterable$u(e))}pipe(){return pipeArguments(this,arguments)}}const isRequestResolver$1=e=>C(e,jD),DD=dual(3,(e,t,r)=>new RequestResolverImpl(n=>LD(e.runAll(n),t,r),make$2d("Locally",e,t,r))),LD=dual(3,(e,t,r)=>IR(cD(fiberRefGet(t),AD(t,r)),()=>e,e=>AD(t,e))),UD=dual(3,(e,t,r)=>ED(t,n=>LD(e,t,r(n)))),fiberRefUnsafeMake=(e,t)=>fiberRefUnsafeMakePatch(e,{differ:update$f(),fork:t?.fork??identity$5,join:t?.join}),fiberRefUnsafeMakeHashSet=e=>{const t=hashSet$3();return fiberRefUnsafeMakePatch(e,{differ:t,fork:t.empty})},fiberRefUnsafeMakeContext=e=>{const t=environment$1();return fiberRefUnsafeMakePatch(e,{differ:t,fork:t.empty})},fiberRefUnsafeMakePatch=(e,t)=>({...Me,[kD]:xD,initial:e,commit(){return fiberRefGet(this)},diff:(e,r)=>t.differ.diff(e,r),combine:(e,r)=>t.differ.combine(e,r),patch:e=>r=>t.differ.patch(e,r),fork:t.fork,join:t.join??((e,t)=>t)}),fiberRefUnsafeMakeRuntimeFlags=e=>fiberRefUnsafeMakePatch(e,{differ:Pj,fork:Pj.empty}),$D=globalValue(Symbol.for("effect/FiberRef/currentContext"),()=>fiberRefUnsafeMakeContext(empty$S())),BD=globalValue(Symbol.for("effect/FiberRef/currentSchedulingPriority"),()=>fiberRefUnsafeMake(0)),zD=globalValue(Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"),()=>fiberRefUnsafeMake(2048)),qD=globalValue(Symbol.for("effect/FiberRef/currentLogAnnotation"),()=>fiberRefUnsafeMake(mP())),WD=globalValue(Symbol.for("effect/FiberRef/currentLogLevel"),()=>fiberRefUnsafeMake(bD)),VD=globalValue(Symbol.for("effect/FiberRef/currentLogSpan"),()=>fiberRefUnsafeMake(RP())),KD=dual(2,(e,t)=>LD(e,BD,t)),GD=dual(2,(e,t)=>LD(e,zD,t)),JD=globalValue(Symbol.for("effect/FiberRef/currentConcurrency"),()=>fiberRefUnsafeMake("unbounded")),HD=globalValue(Symbol.for("effect/FiberRef/currentRequestBatching"),()=>fiberRefUnsafeMake(!0)),ZD=globalValue(Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"),()=>fiberRefUnsafeMake(Ut(SD))),QD=globalValue(Symbol.for("effect/FiberRef/versionMismatchErrorLogLevel"),()=>fiberRefUnsafeMake(Ut(yD))),YD=dual(2,(e,t)=>LD(e,ZD,t)),XD=globalValue(Symbol.for("effect/FiberRef/currentMetricLabels"),()=>(()=>{const e=readonlyArray$1(update$f());return fiberRefUnsafeMakePatch([],{differ:e,fork:e.empty})})()),eL=fiberRefGet(XD),tL=globalValue(Symbol.for("effect/FiberRef/currentForkScopeOverride"),()=>fiberRefUnsafeMake(none$c(),{fork:()=>none$c(),join:(e,t)=>e})),rL=globalValue(Symbol.for("effect/FiberRef/currentInterruptedCause"),()=>fiberRefUnsafeMake(tR,{fork:()=>tR,join:(e,t)=>e})),nL=globalValue(Symbol.for("effect/FiberRef/currentTracerEnabled"),()=>fiberRefUnsafeMake(!0)),iL=globalValue(Symbol.for("effect/FiberRef/currentTracerTiming"),()=>fiberRefUnsafeMake(!0)),sL=globalValue(Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"),()=>fiberRefUnsafeMake(mP())),oL=globalValue(Symbol.for("effect/FiberRef/currentTracerSpanLinks"),()=>fiberRefUnsafeMake(empty$R())),aL=Symbol.for("effect/Scope"),uL=Symbol.for("effect/CloseableScope"),scopeAddFinalizer=(e,t)=>e.addFinalizer(()=>asVoid$9(t)),scopeAddFinalizerExit=(e,t)=>e.addFinalizer(t),scopeClose=(e,t)=>e.close(t),scopeFork=(e,t)=>e.fork(t),cL=dual(2,(e,t)=>{const r=pipe(e,failureOption$1,er(t));switch(r._tag){case"None":return pipe(defects$1(e),cC,qt({onNone:()=>{const t=fromIterable$v(interruptors$1(e)).flatMap(e=>fromIterable$v(pP(e)).map(e=>"#"+e));return new dL(t?"Interrupted by fibers: "+t.join(", "):void 0)},onSome:identity$5}));case"Some":return r.value}}),lL=function(){class YieldableError extends globalThis.Error{commit(){return fail$r(this)}toJSON(){const e={...this};return this.message&&(e.message=this.message),this.cause&&(e.cause=this.cause),e}[ee](){return this.toString!==globalThis.Error.prototype.toString?this.stack?`${this.toString()}\n${this.stack.split("\n").slice(1).join("\n")}`:this.toString():"Bun"in globalThis?pretty$4(fail$s(this),{renderErrorCause:!0}):this}}return Object.assign(YieldableError.prototype,Fe),YieldableError}(),makeException=(e,t)=>{class Base extends lL{_tag=t}return Object.assign(Base.prototype,e),Base.prototype.name=t,Base},pL=Symbol.for("effect/Cause/errors/RuntimeException"),fL=makeException({[pL]:pL},"RuntimeException"),hL=Symbol.for("effect/Cause/errors/InterruptedException"),dL=makeException({[hL]:hL},"InterruptedException"),isInterruptedException$1=e=>C(e,hL),mL=Symbol.for("effect/Cause/errors/IllegalArgument"),gL=makeException({[mL]:mL},"IllegalArgumentException"),yL=Symbol.for("effect/Cause/errors/NoSuchElement"),bL=makeException({[yL]:yL},"NoSuchElementException"),isNoSuchElementException$1=e=>C(e,yL),SL=Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException"),vL=makeException({[SL]:SL},"InvalidPubSubCapacityException"),_L=Symbol.for("effect/Cause/errors/ExceededCapacityException"),wL=makeException({[_L]:_L},"ExceededCapacityException"),kL=Symbol.for("effect/Cause/errors/Timeout"),xL=makeException({[kL]:kL},"TimeoutException"),IL=Symbol.for("effect/Cause/errors/UnknownException"),TL=function(){class UnknownException extends lL{_tag="UnknownException";error;constructor(e,t){super(t??"An unknown error occurred",{cause:e}),this.error=e}}return Object.assign(UnknownException.prototype,{[IL]:IL,name:"UnknownException"}),UnknownException}(),exitIsExit=e=>isEffect$1(e)&&"_tag"in e&&("Success"===e._tag||"Failure"===e._tag),exitIsFailure$1=e=>"Failure"===e._tag,exitIsSuccess$1=e=>"Success"===e._tag,OL=dual(2,(e,t)=>{switch(e._tag){case le:return exitFailCause$1(e.effect_instruction_i0);case de:return exitSucceed$1(t)}}),exitAsVoid=e=>OL(e,void 0),exitCollectAll=(e,t)=>exitCollectAllInternal(e,t?.parallel?parallel$4:sequential$4),exitDie$1=e=>exitFailCause$1(die$h(e)),EL=dual(2,(e,t)=>{switch(e._tag){case le:return!1;case de:return t(e.effect_instruction_i0)}}),exitFail$1=e=>exitFailCause$1(fail$s(e)),exitFailCause$1=e=>{const t=new EffectPrimitiveFailure(le);return t.effect_instruction_i0=e,t},AL=dual(2,(e,t)=>{switch(e._tag){case le:return exitFailCause$1(e.effect_instruction_i0);case de:return t(e.effect_instruction_i0)}}),CL=dual(2,(e,t)=>{switch(e._tag){case le:return succeed$u(exitFailCause$1(e.effect_instruction_i0));case de:return t(e.effect_instruction_i0)}}),ML=dual(2,(e,t)=>{switch(e._tag){case le:return succeed$u(exitFailCause$1(e.effect_instruction_i0));case de:return exit$2(t(e.effect_instruction_i0))}}),FL=dual(2,(e,t)=>{switch(e._tag){case le:return t(e.effect_instruction_i0);case de:return e.effect_instruction_i0}}),exitInterrupt$1=e=>exitFailCause$1(interrupt$a(e)),PL=dual(2,(e,t)=>{switch(e._tag){case le:return exitFailCause$1(e.effect_instruction_i0);case de:return exitSucceed$1(t(e.effect_instruction_i0))}}),NL=dual(2,(e,{onFailure:t,onSuccess:r})=>{switch(e._tag){case le:return exitFailCause$1(pipe(e.effect_instruction_i0,iR(t)));case de:return exitSucceed$1(r(e.effect_instruction_i0))}}),jL=dual(2,(e,t)=>{switch(e._tag){case le:return exitFailCause$1(pipe(e.effect_instruction_i0,iR(t)));case de:return exitSucceed$1(e.effect_instruction_i0)}}),RL=dual(2,(e,t)=>{switch(e._tag){case le:return exitFailCause$1(t(e.effect_instruction_i0));case de:return exitSucceed$1(e.effect_instruction_i0)}}),DL=dual(2,(e,{onFailure:t,onSuccess:r})=>{switch(e._tag){case le:return t(e.effect_instruction_i0);case de:return r(e.effect_instruction_i0)}}),LL=dual(2,(e,{onFailure:t,onSuccess:r})=>{switch(e._tag){case le:return t(e.effect_instruction_i0);case de:return r(e.effect_instruction_i0)}}),exitSucceed$1=e=>{const t=new EffectPrimitiveSuccess(de);return t.effect_instruction_i0=e,t},UL=exitSucceed$1(void 0),$L=dual(2,(e,t)=>KL(e,t,{onSuccess:(e,t)=>[e,t],onFailure:sequential$4})),BL=dual(2,(e,t)=>KL(e,t,{onSuccess:(e,t)=>e,onFailure:sequential$4})),zL=dual(2,(e,t)=>KL(e,t,{onSuccess:(e,t)=>t,onFailure:sequential$4})),qL=dual(2,(e,t)=>KL(e,t,{onSuccess:(e,t)=>[e,t],onFailure:parallel$4})),WL=dual(2,(e,t)=>KL(e,t,{onSuccess:(e,t)=>e,onFailure:parallel$4})),VL=dual(2,(e,t)=>KL(e,t,{onSuccess:(e,t)=>t,onFailure:parallel$4})),KL=dual(3,(e,t,{onFailure:r,onSuccess:n})=>{switch(e._tag){case le:switch(t._tag){case de:return exitFailCause$1(e.effect_instruction_i0);case le:return exitFailCause$1(r(e.effect_instruction_i0,t.effect_instruction_i0))}case de:switch(t._tag){case de:return exitSucceed$1(n(e.effect_instruction_i0,t.effect_instruction_i0));case le:return exitFailCause$1(t.effect_instruction_i0)}}}),exitCollectAllInternal=(e,t)=>{const r=fromIterable$u(e);return isNonEmpty$8(r)?pipe(tailNonEmpty(r),ys(pipe(lC(r),PL(of$5)),(e,r)=>pipe(e,KL(r,{onSuccess:(e,t)=>pipe(e,JA(t)),onFailure:t}))),PL(reverse$3),PL(e=>toReadonlyArray$1(e)),Ut):none$c()},deferredUnsafeMake=e=>{var t;return{...Me,[wR]:kR,state:make$27((t=[],{_tag:vR,joiners:t})),commit(){return deferredAwait(this)},blockingOn:e}},deferredMake=()=>PR(FR,e=>deferredMakeAs(e)),deferredMakeAs=e=>sync$l(()=>deferredUnsafeMake(e)),deferredAwait=e=>asyncInterrupt(t=>{const r=get$E(e.state);switch(r._tag){case _R:return t(r.effect);case vR:return r.joiners.push(t),deferredInterruptJoiner(e,t)}},e.blockingOn),GL=dual(2,(e,t)=>zR(t,e)),JL=dual(2,(e,t)=>sync$l(()=>{const r=get$E(e.state);switch(r._tag){case _R:return!1;case vR:qF(e.state,done$f(t));for(let e=0,n=r.joiners.length;e<n;e++)r.joiners[e](t);return!0}})),HL=dual(2,(e,t)=>JL(e,t)),ZL=dual(2,(e,t)=>JL(e,fail$r(t))),QL=dual(2,(e,t)=>JL(e,failSync$d(t))),YL=dual(2,(e,t)=>JL(e,failCause$j(t))),XL=dual(2,(e,t)=>JL(e,failCauseSync$b(t))),eU=dual(2,(e,t)=>JL(e,die$g(t))),tU=dual(2,(e,t)=>JL(e,dieSync$a(t))),rU=dual(2,(e,t)=>JL(e,interruptWith$2(t))),nU=dual(2,(e,t)=>JL(e,succeed$u(t))),iU=dual(2,(e,t)=>JL(e,sync$l(t))),deferredUnsafeDone=(e,t)=>{const r=get$E(e.state);if(r._tag===vR){qF(e.state,done$f(t));for(let e=0,n=r.joiners.length;e<n;e++)r.joiners[e](t)}},deferredInterruptJoiner=(e,t)=>sync$l(()=>{const r=get$E(e.state);if(r._tag===vR){const e=r.joiners.indexOf(t);e>=0&&r.joiners.splice(e,1)}}),sU=withFiberRuntime$1(e=>exitSucceed$1(e.currentContext)),context$c=()=>sU,contextWithEffect$7=e=>PR(context$c(),e),oU=dual(2,(e,t)=>LD($D,t)(e)),aU=dual(2,(e,t)=>UD($D,e=>LA(e,t))(e)),uU=dual(2,(e,t)=>contextWithEffect$7(r=>oU(e,t(r)))),cU=dual(2,(e,t)=>PR(e,e=>PR(t.predicate(e),r=>r?succeed$u(e):t.orElse(e)))),lU=dual(2,(e,t)=>cU(e,{predicate:t.predicate,orElse:e=>fail$r(t.orFailWith(e))})),currentSpanFromFiber=e=>{const t=e.currentSpan;return void 0!==t&&"Span"===t._tag?Ut(t):none$c()},pU={_tag:"Span",spanId:"noop",traceId:"noop",sampled:!1,status:{_tag:"Ended",startTime:BigInt(0),endTime:BigInt(0),exit:UL},attributes:new Map,links:[],kind:"internal",attribute(){},event(){},end(){},addLinks(){}},fU=deferredMake,hU=deferredAwait,dU=HL,mU=ZL,gU=YL,interrupt$8=e=>PR(FR,t=>JL(e,interruptWith$2(t))),isDone$7=e=>sync$l(()=>get$E(e.state)._tag===_R),poll$b=e=>sync$l(()=>{const t=get$E(e.state);switch(t._tag){case _R:return Ut(t.effect);case vR:return none$c()}}),yU=nU,bU=deferredUnsafeMake,SU=deferredUnsafeDone;var vU=Object.freeze({__proto__:null,DeferredTypeId:wR,await:hU,complete:GL,completeWith:JL,die:eU,dieSync:tU,done:dU,fail:mU,failCause:gU,failCauseSync:XL,failSync:QL,interrupt:interrupt$8,interruptWith:rU,isDone:isDone$7,make:fU,makeAs:deferredMakeAs,poll:poll$b,succeed:yU,sync:iU,unsafeDone:SU,unsafeMake:bU});const _U=exitIsExit,wU=exitIsFailure$1,kU=exitIsSuccess$1,xU=exitCollectAll,IU=exitDie$1,TU=exitFail$1,OU=exitFailCause$1,flatten$b=e=>pipe(e,AL(identity$5)),EU=ML,AU=exitInterrupt$1,CU=PL,MU=NL,FU=DL,PU=LL,NU=exitSucceed$1,jU=UL,RU=$L,DU=zL,LU=KL;var UU=Object.freeze({__proto__:null,all:xU,as:OL,asVoid:exitAsVoid,causeOption:e=>{switch(e._tag){case le:return Ut(e.effect_instruction_i0);case de:return none$c()}},die:IU,exists:EL,fail:TU,failCause:OU,flatMap:AL,flatMapEffect:CL,flatten:flatten$b,forEachEffect:EU,fromEither:e=>{switch(e._tag){case"Left":return exitFail$1(e.left);case"Right":return exitSucceed$1(e.right)}},fromOption:e=>{switch(e._tag){case"None":return exitFail$1(void 0);case"Some":return exitSucceed$1(e.value)}},getOrElse:FL,interrupt:AU,isExit:_U,isFailure:wU,isInterrupted:e=>{switch(e._tag){case le:return isInterrupted$2(e.effect_instruction_i0);case de:return!1}},isSuccess:kU,map:CU,mapBoth:MU,mapError:jL,mapErrorCause:RL,match:FU,matchEffect:PU,succeed:NU,void:jU,zip:RU,zipLeft:BL,zipPar:qL,zipParLeft:WL,zipParRight:VL,zipRight:DU,zipWith:LU});const $U=Symbol.for("effect/MutableHashMap"),BU={[$U]:$U,[Symbol.iterator](){return new MutableHashMapIterator(this)},toString(){return format$6(this.toJSON())},toJSON(){return{_id:"MutableHashMap",values:Array.from(this).map(toJSON)}},[ee](){return this.toJSON()},pipe(){return pipeArguments(this,arguments)}};class MutableHashMapIterator{self;referentialIterator;bucketIterator;constructor(e){this.self=e,this.referentialIterator=e.referential[Symbol.iterator]()}next(){if(void 0!==this.bucketIterator)return this.bucketIterator.next();const e=this.referentialIterator.next();return e.done?(this.bucketIterator=new BucketIterator(this.self.buckets.values()),this.next()):e}[Symbol.iterator](){return new MutableHashMapIterator(this.self)}}class BucketIterator{backing;constructor(e){this.backing=e}currentBucket;next(){if(void 0===this.currentBucket){const e=this.backing.next();if(e.done)return e;this.currentBucket=e.value[Symbol.iterator]()}const e=this.currentBucket.next();return e.done?(this.currentBucket=void 0,this.next()):e}}const empty$B=()=>{const e=Object.create(BU);return e.referential=new Map,e.buckets=new Map,e.bucketsSize=0,e},fromIterable$o=e=>{const t=empty$B();for(const[r,n]of e)WU(t,r,n);return t},zU=dual(2,(e,t)=>{if(!1===isEqual(t))return e.referential.has(t)?Ut(e.referential.get(t)):none$c();const r=t[Z](),n=e.buckets.get(r);return void 0===n?none$c():getFromBucket(e,n,t)}),keys$a=e=>{const t=Array.from(e.referential.keys());for(const r of e.buckets.values())for(let e=0,n=r.length;e<n;e++)t.push(r[e][0]);return t},getFromBucket=(e,t,r,n=!1)=>{for(let i=0,s=t.length;i<s;i++)if(r[Y](t[i][0])){const r=t[i][1];return n&&(t.splice(i,1),e.bucketsSize--),Ut(r)}return none$c()},qU=dual(2,(e,t)=>zt(zU(e,t))),WU=dual(3,(e,t,r)=>{if(!1===isEqual(t))return e.referential.set(t,r),e;const n=t[Z](),i=e.buckets.get(n);return void 0===i?(e.buckets.set(n,[[t,r]]),e.bucketsSize++,e):(removeFromBucket(e,i,t),i.push([t,r]),e.bucketsSize++,e)}),removeFromBucket=(e,t,r)=>{for(let n=0,i=t.length;n<i;n++)if(r[Y](t[n][0]))return t.splice(n,1),void e.bucketsSize--},VU=dual(3,(e,t,r)=>{if(!1===isEqual(t))return e.referential.has(t)&&e.referential.set(t,r(e.referential.get(t))),e;const n=t[Z](),i=e.buckets.get(n);if(void 0===i)return e;const s=getFromBucket(e,i,t,!0);return Bt(s)||(i.push([t,r(s.value)]),e.bucketsSize++),e}),KU=dual(3,(e,t,r)=>{if(!1===isEqual(t)){const n=r(zU(e,t));return zt(n)?WU(e,t,n.value):GU(e,t),e}const n=t[Z](),i=e.buckets.get(n);if(void 0===i){const n=r(none$c());return zt(n)?WU(e,t,n.value):e}const s=r(getFromBucket(e,i,t,!0));return Bt(s)?(0===i.length&&e.buckets.delete(n),e):(i.push([t,s.value]),e.bucketsSize++,e)}),GU=dual(2,(e,t)=>{if(!1===isEqual(t))return e.referential.delete(t),e;const r=t[Z](),n=e.buckets.get(r);return void 0===n||(removeFromBucket(e,n,t),0===n.length&&e.buckets.delete(r)),e}),clear$6=e=>(e.referential.clear(),e.buckets.clear(),e.bucketsSize=0,e),size$t=e=>e.referential.size+e.bucketsSize;var JU=Object.freeze({__proto__:null,clear:clear$6,empty:empty$B,forEach:dual(2,(e,t)=>{e.referential.forEach(t);for(const r of e.buckets.values())for(const[e,n]of r)t(n,e)}),fromIterable:fromIterable$o,get:zU,has:qU,isEmpty:e=>0===size$t(e),keys:keys$a,make:(...e)=>fromIterable$o(e),modify:VU,modifyAt:KU,remove:GU,set:WU,size:size$t,values:e=>{const t=Array.from(e.referential.values());for(const r of e.buckets.values())for(let e=0,n=r.length;e<n;e++)t.push(r[e][1]);return t}});const HU=Symbol.for("effect/MutableList"),ZU={[HU]:HU,[Symbol.iterator](){let e=!1,t=this.head;return{next(){if(e)return this.return();if(null==t)return e=!0,this.return();const r=t.value;return t=t.next,{done:e,value:r}},return:t=>(e||(e=!0),{done:!0,value:t})}},toString(){return format$6(this.toJSON())},toJSON(){return{_id:"MutableList",values:Array.from(this).map(toJSON)}},[ee](){return this.toJSON()},pipe(){return pipeArguments(this,arguments)}},makeNode$1=e=>({value:e,removed:!1,prev:void 0,next:void 0}),empty$A=()=>{const e=Object.create(ZU);return e.head=void 0,e.tail=void 0,e._length=0,e},fromIterable$n=e=>{const t=empty$A();for(const r of e)YU(t,r);return t},isEmpty$m=e=>0===length$3(e),length$3=e=>e._length,QU=dual(2,(e,t)=>{let r=e.head;for(;void 0!==r;)t(r.value),r=r.next}),YU=dual(2,(e,t)=>{const r=makeNode$1(t);return void 0===e.head&&(e.head=r),void 0===e.tail||(e.tail.next=r,r.prev=e.tail),e.tail=r,e._length+=1,e}),shift=e=>{const t=e.head;if(void 0!==t)return remove$b(e,t),t.value},remove$b=(e,t)=>{t.removed||(t.removed=!0,void 0!==t.prev&&void 0!==t.next?(t.prev.next=t.next,t.next.prev=t.prev):void 0!==t.prev?(e.tail=t.prev,t.prev.next=void 0):void 0!==t.next?(e.head=t.next,t.next.prev=void 0):(e.tail=void 0,e.head=void 0),e._length>0&&(e._length-=1))};var XU=Object.freeze({__proto__:null,append:YU,empty:empty$A,forEach:QU,fromIterable:fromIterable$n,head:e=>void 0===e.head?void 0:e.head.value,isEmpty:isEmpty$m,length:length$3,make:(...e)=>fromIterable$n(e),pop:e=>{const t=e.tail;if(void 0!==t)return remove$b(e,t),t.value},prepend:dual(2,(e,t)=>{const r=makeNode$1(t);return r.next=e.head,void 0!==e.head&&(e.head.prev=r),e.head=r,void 0===e.tail&&(e.tail=r),e._length+=1,e}),reset:e=>(e._length=0,e.head=void 0,e.tail=void 0,e),shift,tail:e=>void 0===e.tail?void 0:e.tail.value});const e$=Symbol.for("effect/MutableQueue"),t$=Symbol.for("effect/mutable/MutableQueue/Empty"),r$={[e$]:e$,[Symbol.iterator](){return Array.from(this.queue)[Symbol.iterator]()},toString(){return format$6(this.toJSON())},toJSON(){return{_id:"MutableQueue",values:Array.from(this).map(toJSON)}},[ee](){return this.toJSON()},pipe(){return pipeArguments(this,arguments)}},make$1X=e=>{const t=Object.create(r$);return t.queue=empty$A(),t.capacity=e,t},bounded$8=e=>make$1X(e),unbounded$8=()=>make$1X(void 0),length$2=e=>length$3(e.queue),isEmpty$l=e=>isEmpty$m(e.queue),capacity$8=e=>void 0===e.capacity?1/0:e.capacity,n$=dual(2,(e,t)=>{const r=length$3(e.queue);return(void 0===e.capacity||r!==e.capacity)&&(YU(t)(e.queue),!0)}),i$=dual(2,(e,t)=>{const r=t[Symbol.iterator]();let n,i=empty$R(),s=!0;for(;s&&(n=r.next())&&!n.done;)s=n$(n.value)(e);for(;null!=n&&!n.done;)i=JA(n.value)(i),n=r.next();return reverse$3(i)}),s$=dual(2,(e,t)=>isEmpty$m(e.queue)?t:shift(e.queue)),o$=dual(2,(e,t)=>{let r=empty$R(),n=0;for(;n<t;){const t=s$(t$)(e);if(t===t$)break;r=JA(t)(r),n+=1}return reverse$3(r)});var a$=Object.freeze({__proto__:null,EmptyMutableQueue:t$,bounded:bounded$8,capacity:capacity$8,isEmpty:isEmpty$l,isFull:e=>void 0!==e.capacity&&length$3(e.queue)===e.capacity,length:length$2,offer:n$,offerAll:i$,poll:s$,pollUpTo:o$,unbounded:unbounded$8});const u$=Symbol.for("effect/Clock"),c$=GenericTag("effect/Clock"),l$={unsafeSchedule(e,t){const r=toMillis(t);if(r>2147483647)return n;let i=!1;const s=setTimeout(()=>{i=!0,e()},r);return()=>(clearTimeout(s),!i)}},p$=function(){const e=BigInt(1e6);if("undefined"==typeof performance)return()=>BigInt(Date.now())*e;let t;return()=>(void 0===t&&(t=BigInt(Date.now())*e-BigInt(Math.round(1e6*performance.now()))),t+BigInt(Math.round(1e6*performance.now())))}(),f$=function(){const e="object"==typeof process&&"hrtime"in process&&"function"==typeof process.hrtime.bigint?process.hrtime:void 0;if(!e)return p$;const t=p$()-e.bigint();return()=>t+e.bigint()}();class ClockImpl{[u$]=u$;unsafeCurrentTimeMillis(){return Date.now()}unsafeCurrentTimeNanos(){return f$()}currentTimeMillis=sync$l(()=>this.unsafeCurrentTimeMillis());currentTimeNanos=sync$l(()=>this.unsafeCurrentTimeNanos());scheduler(){return succeed$u(l$)}sleep(e){return async_(t=>{const r=l$.unsafeSchedule(()=>t(tD),e);return asVoid$9(sync$l(r))})}}const make$1W=()=>new ClockImpl,h$="And",d$="Or",m$="InvalidData",g$="MissingData",y$="SourceUnavailable",b$="Unsupported",S$=Symbol.for("effect/ConfigError"),v$={_tag:"ConfigError",[S$]:S$},And$1=(e,t)=>{const r=Object.create(v$);return r._op=h$,r.left=e,r.right=t,Object.defineProperty(r,"toString",{enumerable:!1,value(){return`${this.left} and ${this.right}`}}),Object.defineProperty(r,"message",{enumerable:!1,get(){return this.toString()}}),r},Or$1=(e,t)=>{const r=Object.create(v$);return r._op=d$,r.left=e,r.right=t,Object.defineProperty(r,"toString",{enumerable:!1,value(){return`${this.left} or ${this.right}`}}),Object.defineProperty(r,"message",{enumerable:!1,get(){return this.toString()}}),r},InvalidData$1=(e,t,r={pathDelim:"."})=>{const n=Object.create(v$);return n._op=m$,n.path=e,n.message=t,Object.defineProperty(n,"toString",{enumerable:!1,value(){return`(Invalid data at ${pipe(this.path,Ms(r.pathDelim))}: "${this.message}")`}}),n},MissingData$1=(e,t,r={pathDelim:"."})=>{const n=Object.create(v$);return n._op=g$,n.path=e,n.message=t,Object.defineProperty(n,"toString",{enumerable:!1,value(){return`(Missing data at ${pipe(this.path,Ms(r.pathDelim))}: "${this.message}")`}}),n},SourceUnavailable$1=(e,t,r,n={pathDelim:"."})=>{const i=Object.create(v$);return i._op=y$,i.path=e,i.message=t,i.cause=r,Object.defineProperty(i,"toString",{enumerable:!1,value(){return`(Source unavailable at ${pipe(this.path,Ms(n.pathDelim))}: "${this.message}")`}}),i},Unsupported$1=(e,t,r={pathDelim:"."})=>{const n=Object.create(v$);return n._op=b$,n.path=e,n.message=t,Object.defineProperty(n,"toString",{enumerable:!1,value(){return`(Unsupported operation at ${pipe(this.path,Ms(r.pathDelim))}: "${this.message}")`}}),n},_$=dual(2,(e,t)=>{switch(e._op){case h$:return And$1(_$(e.left,t),_$(e.right,t));case d$:return Or$1(_$(e.left,t),_$(e.right,t));case m$:return InvalidData$1([...t,...e.path],e.message);case g$:return MissingData$1([...t,...e.path],e.message);case y$:return SourceUnavailable$1([...t,...e.path],e.message,e.cause);case b$:return Unsupported$1([...t,...e.path],e.message)}}),w$={andCase:(e,t,r)=>t&&r,orCase:(e,t,r)=>t&&r,invalidDataCase:n,missingDataCase:r,sourceUnavailableCase:n,unsupportedCase:n},k$=dual(3,(e,t,r)=>{const n=[e],i=[];for(;n.length>0;){const e=n.pop();switch(e._op){case h$:n.push(e.right),n.push(e.left),i.push(He({_op:"AndCase"}));break;case d$:n.push(e.right),n.push(e.left),i.push(He({_op:"OrCase"}));break;case m$:i.push(Ge(r.invalidDataCase(t,e.path,e.message)));break;case g$:i.push(Ge(r.missingDataCase(t,e.path,e.message)));break;case y$:i.push(Ge(r.sourceUnavailableCase(t,e.path,e.message,e.cause)));break;case b$:i.push(Ge(r.unsupportedCase(t,e.path,e.message)))}}const s=[];for(;i.length>0;){const e=i.pop();switch(e._op){case"Left":switch(e.left._op){case"AndCase":{const e=s.pop(),n=s.pop(),i=r.andCase(t,e,n);s.push(i);break}case"OrCase":{const e=s.pop(),n=s.pop(),i=r.orCase(t,e,n);s.push(i);break}}break;case"Right":s.push(e.right)}}if(0===s.length)throw Error("BUG: ConfigError.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");return s.pop()}),x$={_tag:"Empty"},I$=dual(2,(e,t)=>({_tag:"AndThen",first:e,second:t})),T$=dual(2,(e,t)=>I$(e,{_tag:"MapName",f:t})),O$=dual(2,(e,name)=>I$(e,{_tag:"Nested",name})),E$=dual(2,(e,name)=>I$(e,{_tag:"Unnested",name})),A$=dual(2,(e,t)=>{let r=of$4(t),n=e;for(;isCons(r);){const e=r.head;switch(e._tag){case"Empty":r=r.tail;break;case"AndThen":r=cons(e.first,cons(e.second,r.tail));break;case"MapName":n=as(n,e.f),r=r.tail;break;case"Nested":n=ei(n,e.name),r=r.tail;break;case"Unnested":if(!pipe(fi(n),Sr(e.name)))return He(MissingData$1(n,`Expected ${e.name} to be in path in ConfigProvider#unnested`));n=tailNonEmpty$1(n),r=r.tail}}return Ge(n)}),C$="Constant",M$="Fail",F$="Fallback",P$="Described",N$="Lazy",j$="MapOrFail",R$="Nested",D$="Primitive",L$="Sequence",U$="HashMap",$$="ZipWith",lowerCase$2=e=>e.toLowerCase(),upperCase$2=e=>e.toUpperCase(),replace$2=(e,t,r)=>t instanceof RegExp?e.replace(t,r):t.reduce((e,t)=>e.replace(t,r),e),B$=[/([a-z0-9])([A-Z])/g,/([A-Z])([A-Z][a-z])/g],z$=/[^A-Z0-9]+/gi,noCase=(e,t={})=>{const{delimiter:r=" ",splitRegexp:n=B$,stripRegexp:i=z$,transform:s=lowerCase$2}=t,o=replace$2(replace$2(e,n,"$1\0$2"),i,"\0");let start=0,a=o.length;for(;"\0"===o.charAt(start);)start++;for(;"\0"===o.charAt(a-1);)a--;return o.slice(start,a).split("\0").map(s).join(r)},constantCase$2=(e,t)=>noCase(e,{delimiter:"_",transform:upperCase$2,...t}),kebabCase$2=(e,t)=>noCase(e,{delimiter:"-",...t}),snakeCase$2=(e,t)=>noCase(e,{delimiter:"_",...t}),concat$3=(e,t)=>[...e,...t],q$=Symbol.for("effect/ConfigProvider"),W$=GenericTag("effect/ConfigProvider"),V$=Symbol.for("effect/ConfigProviderFlat"),make$1V=e=>({[q$]:q$,pipe(){return pipeArguments(this,arguments)},...e}),makeFlat$1=e=>({[V$]:V$,patch:e.patch,load:(t,r,n=!0)=>e.load(t,r,n),enumerateChildren:e.enumerateChildren}),fromFlat$1=e=>make$1V({load:t=>PR(fromFlatLoop(e,[],t,!1),e=>qt(fi(e),{onNone:()=>fail$r(MissingData$1([],"Expected a single value having structure: "+t)),onSome:succeed$u})),flattened:e}),fromEnv$1=e=>{const{pathDelim:t,seqDelim:r}=Object.assign({},{pathDelim:"_",seqDelim:","},e),getEnv=()=>"undefined"!=typeof process&&"env"in process&&"object"==typeof process.env?process.env:{};return fromFlat$1(makeFlat$1({load:(e,n,i=!0)=>{const s=(e=>pipe(e,Ms(t)))(e),o=getEnv();return pipe(s in o?Ut(o[s]):none$c(),VR(()=>MissingData$1(e,`Expected ${s} to exist in the process context`)),PR(t=>parsePrimitive(t,e,n,r,i)))},enumerateChildren:e=>sync$l(()=>{const r=getEnv(),n=Object.keys(r).map(e=>e.toUpperCase().split(t)).filter(t=>{for(let r=0;r<e.length;r++){const n=pipe(e,pi(r)),i=t[r];if(void 0===i||n!==i)return!1}return!0}).flatMap(t=>t.slice(e.length,e.length+1));return fromIterable$r(n)}),patch:x$}))},fromMap$1=(e,t)=>{const{pathDelim:r,seqDelim:n}=Object.assign({seqDelim:",",pathDelim:"."},t),makePathString=e=>pipe(e,Ms(r)),unmakePathString=e=>e.split(r),i=splitIndexInKeys(e,e=>unmakePathString(e),makePathString);return fromFlat$1(makeFlat$1({load:(e,t,r=!0)=>{const s=makePathString(e);return pipe(i.has(s)?Ut(i.get(s)):none$c(),VR(()=>MissingData$1(e,`Expected ${s} to exist in the provided map`)),PR(i=>parsePrimitive(i,e,t,n,r)))},enumerateChildren:e=>sync$l(()=>{const t=fromIterable$v(i.keys()).map(unmakePathString).filter(t=>{for(let r=0;r<e.length;r++){const n=pipe(e,pi(r)),i=t[r];if(void 0===i||n!==i)return!1}return!0}).flatMap(t=>t.slice(e.length,e.length+1));return fromIterable$r(t)}),patch:x$}))},fromFlatLoop=(e,t,r,n)=>{const i=r;switch(i._tag){case C$:return succeed$u(of$6(i.value));case P$:return suspend$g(()=>fromFlatLoop(e,t,i.config,n));case M$:return fail$r(MissingData$1(t,i.message));case F$:return pipe(suspend$g(()=>fromFlatLoop(e,t,i.first,n)),ER(r=>i.condition(r)?pipe(fromFlatLoop(e,t,i.second,n),ER(e=>fail$r(Or$1(r,e)))):fail$r(r)));case N$:return suspend$g(()=>fromFlatLoop(e,t,i.config(),n));case j$:return suspend$g(()=>pipe(fromFlatLoop(e,t,i.original,n),PR(LR(e=>pipe(i.mapOrFail(e),VR(_$(((e,t)=>{let r=t;if("Nested"===r._tag){const t=e.slice();for(;"Nested"===r._tag;)t.push(r.name),r=r.config;return t}return e})(t,i.original))))))));case R$:return suspend$g(()=>fromFlatLoop(e,concat$3(t,of$6(i.name)),i.config,n));case D$:return pipe(A$(t,e.patch),PR(t=>pipe(e.load(t,i,n),PR(e=>{if(0===e.length){const name=pipe(last$6(t),Kt(()=>"<n/a>"));return fail$r(MissingData$1([],`Expected ${i.description} with name ${name}`))}return succeed$u(e)}))));case L$:return pipe(A$(t,e.patch),PR(r=>pipe(e.enumerateChildren(r),PR(indicesFrom),PR(r=>0===r.length?suspend$g(()=>qR(fromFlatLoop(e,t,i.config,!0),of$6)):pipe(LR(r,r=>fromFlatLoop(e,ri(t,`[${r}]`),i.config,!0)),qR(e=>{const t=cs(e);return 0===t.length?of$6([]):of$6(t)}))))));case U$:return suspend$g(()=>pipe(A$(t,e.patch),PR(t=>pipe(e.enumerateChildren(t),PR(r=>pipe(r,LR(r=>fromFlatLoop(e,concat$3(t,of$6(r)),i.valueConfig,n)),qR(e=>0===e.length?of$6(mP()):pipe(transpose(e),as(e=>gP(Ri(fromIterable$v(r),e)))))))))));case $$:return suspend$g(()=>pipe(fromFlatLoop(e,t,i.left,n),either$a,PR(r=>pipe(fromFlatLoop(e,t,i.right,n),either$a,PR(e=>{if(Xe(r)&&Xe(e))return fail$r(And$1(r.left,e.left));if(Xe(r)&&et(e))return fail$r(r.left);if(et(r)&&Xe(e))return fail$r(e.left);if(et(r)&&et(e)){const n=pipe(t,Ms(".")),s=fromFlatLoopFail(t,n),[o,a]=((e,t,r,n)=>{const i=unfold$4(r.length,t=>t>=n.length?none$c():Ut([e(t),t+1])),s=unfold$4(n.length,e=>e>=r.length?none$c():Ut([t(e),e+1]));return[concat$3(r,i),concat$3(n,s)]})(s,s,pipe(r.right,as(Ge)),pipe(e.right,as(Ge)));return pipe(o,Ri(a),LR(([e,t])=>pipe(uD(e,t),qR(([e,t])=>i.zip(e,t)))))}throw Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues")})))))}},fromFlatLoopFail=(e,t)=>r=>He(MissingData$1(e,`The element at index ${r} in a sequence at path "${t}" was missing`)),K$=dual(2,(e,t)=>fromFlat$1(mapInputPathFlat(e.flattened,t))),mapInputPathFlat=(e,t)=>makeFlat$1({load:(t,r,n=!0)=>e.load(t,r,n),enumerateChildren:t=>e.enumerateChildren(t),patch:T$(e.patch,t)}),G$=dual(2,(e,name)=>fromFlat$1(makeFlat$1({load:(t,r)=>e.flattened.load(t,r,!0),enumerateChildren:t=>e.flattened.enumerateChildren(t),patch:O$(e.flattened.patch,name)}))),J$=dual(2,(e,name)=>fromFlat$1(makeFlat$1({load:(t,r)=>e.flattened.load(t,r,!0),enumerateChildren:t=>e.flattened.enumerateChildren(t),patch:E$(e.flattened.patch,name)}))),H$=dual(2,(e,t)=>fromFlat$1(orElseFlat(e.flattened,()=>t().flattened))),orElseFlat=(e,t)=>makeFlat$1({load:(r,n,i)=>pipe(A$(r,e.patch),PR(t=>e.load(t,n,i)),ER(e=>pipe(sync$l(t),PR(t=>pipe(A$(r,t.patch),PR(e=>t.load(e,n,i)),ER(t=>fail$r(Or$1(e,t)))))))),enumerateChildren:r=>pipe(A$(r,e.patch),PR(t=>e.enumerateChildren(t)),either$a,PR(e=>pipe(sync$l(t),PR(t=>pipe(A$(r,t.patch),PR(e=>t.enumerateChildren(e)),either$a,PR(t=>{if(Xe(e)&&Xe(t))return fail$r(And$1(e.left,t.left));if(Xe(e)&&et(t))return succeed$u(t.right);if(et(e)&&Xe(t))return succeed$u(e.right);if(et(e)&&et(t))return succeed$u(pipe(e.right,FF(t.right)));throw Error("BUG: ConfigProvider.orElseFlat - please report an issue at https://github.com/Effect-TS/effect/issues")})))))),patch:x$}),Z$=dual(3,(e,t,r)=>{const n=ys(t,e,(e,name)=>J$(e,name)),i=bs(t,r(n),(e,name)=>G$(e,name));return H$(i,()=>e)}),parsePrimitive=(e,t,r,n,i)=>i?pipe(((e,t)=>e.split(RegExp(`\\s*${escape(t)}\\s*`)))(e,n),LR(e=>r.parse(e.trim())),VR(_$(t))):pipe(r.parse(e),WR({onFailure:_$(t),onSuccess:of$6})),transpose=e=>Object.keys(e[0]).map(t=>e.map(e=>e[t])),indicesFrom=e=>pipe(LR(e,parseQuotedIndex),WR({onFailure:()=>[],onSuccess:Ni(qI)}),either$a,qR(ct)),Q$=/(^.+)(\[(\d+)\])$/,Y$=/^(\[(\d+)\])$/,parseQuotedIndex=e=>{const t=e.match(Y$);if(null!==t){const e=t[2];return pipe(void 0!==e&&e.length>0?Ut(e):none$c(),ir(parseInteger))}return none$c()},splitIndexInKeys=(e,t,r)=>{const n=new Map;for(const[i,s]of e){const e=pipe(t(i),us(e=>qt(splitIndexFrom(e),{onNone:()=>of$6(e),onSome:([e,t])=>make$2i(e,`[${t}]`)})));n.set(r(e),s)}return n},splitIndexFrom=e=>{const t=e.match(Q$);if(null!==t){const e=t[1],r=t[3],n=void 0!==e&&e.length>0?Ut(e):none$c(),i=pipe(void 0!==r&&r.length>0?Ut(r):none$c(),ir(parseInteger));return all$a([n,i])}return none$c()},parseInteger=e=>{const t=Number.parseInt(e);return Number.isNaN(t)?none$c():Ut(t)},configPathToString=e=>{const t=[];let r=0;for(;r<e.length;){const n=e[r];if("KeyName"===n._tag)if(r+1<e.length){const i=e[r+1];"KeyIndex"===i._tag?(t.push(`${n.name}[${i.index}]`),r+=2):(t.push(n.name),r+=1)}else t.push(n.name),r+=1}return t},X$=Symbol.for("effect/Console"),eB=GenericTag("effect/Console"),tB={[X$]:X$,assert:(e,...t)=>sync$l(()=>{console.assert(e,...t)}),clear:sync$l(()=>{console.clear()}),count:e=>sync$l(()=>{console.count(e)}),countReset:e=>sync$l(()=>{console.countReset(e)}),debug:(...e)=>sync$l(()=>{}),dir:(e,t)=>sync$l(()=>{console.dir(e,t)}),dirxml:(...e)=>sync$l(()=>{console.dirxml(...e)}),error:(...e)=>sync$l(()=>{console.error(...e)}),group:e=>sync$l(e?.collapsed?()=>console.groupCollapsed(e?.label):()=>console.group(e?.label)),groupEnd:sync$l(()=>{console.groupEnd()}),info:(...e)=>sync$l(()=>{console.info(...e)}),log:(...e)=>sync$l(()=>{console.log(...e)}),table:(e,t)=>sync$l(()=>{console.table(e,t)}),time:e=>sync$l(()=>console.time(e)),timeEnd:e=>sync$l(()=>console.timeEnd(e)),timeLog:(e,...t)=>sync$l(()=>{console.timeLog(e,...t)}),trace:(...e)=>sync$l(()=>{}),warn:(...e)=>sync$l(()=>{console.warn(...e)}),unsafe:console},rB=Symbol.for("effect/Random"),nB=GenericTag("effect/Random");class RandomImpl{seed;[rB]=rB;PRNG;constructor(e){this.seed=e,this.PRNG=new PCGRandom(e)}get next(){return sync$l(()=>this.PRNG.number())}get nextBoolean(){return qR(this.next,e=>e>.5)}get nextInt(){return sync$l(()=>this.PRNG.integer(Number.MAX_SAFE_INTEGER))}nextRange(e,t){return qR(this.next,r=>(t-e)*r+e)}nextIntBetween(e,t){return sync$l(()=>this.PRNG.integer(t-e)+e)}shuffle(e){return shuffleWith$1(e,e=>this.nextIntBetween(0,e))}}const shuffleWith$1=(e,t)=>suspend$g(()=>pipe(sync$l(()=>Array.from(e)),PR(e=>{const r=[];for(let t=e.length;t>=2;t-=1)r.push(t);return pipe(r,UR(r=>pipe(t(r),qR(t=>swap$1(e,r-1,t)))),TR(fromIterable$u(e)))}))),swap$1=(e,t,r)=>{const n=e[t];return e[t]=e[r],e[r]=n,e},make$1U=e=>new RandomImpl(hash$3(e));class FixedRandomImpl{values;[rB]=rB;index=0;constructor(e){if(this.values=e,0===e.length)throw Error("Requires at least one value")}getNextValue(){const e=this.values[this.index];return this.index=(this.index+1)%this.values.length,e}get next(){return sync$l(()=>{const e=this.getNextValue();return"number"==typeof e?Math.max(0,Math.min(1,e)):hash$3(e)/2147483647})}get nextBoolean(){return sync$l(()=>{const e=this.getNextValue();return"boolean"==typeof e?e:hash$3(e)%2==0})}get nextInt(){return sync$l(()=>{const e=this.getNextValue();return"number"==typeof e&&Number.isFinite(e)?Math.round(e):Math.abs(hash$3(e))})}nextRange(e,t){return qR(this.next,r=>(t-e)*r+e)}nextIntBetween(e,t){return sync$l(()=>{const r=this.getNextValue();if("number"==typeof r&&Number.isFinite(r))return Math.max(e,Math.min(t-1,Math.round(r)));const n=Math.abs(hash$3(r));return e+n%(t-e)})}shuffle(e){return shuffleWith$1(e,e=>this.nextIntBetween(0,e))}}const iB=Symbol.for("effect/Tracer"),make$1T=e=>({[iB]:iB,...e}),sB=GenericTag("effect/Tracer"),oB=GenericTag("effect/ParentSpan"),aB=function(){return function(e){let t="";for(let r=0;r<e;r++)t+="abcdef0123456789".charAt(Math.floor(16*Math.random()));return t}}();class NativeSpan{name;parent;context;startTime;kind;_tag="Span";spanId;traceId="native";sampled=!0;status;attributes;events=[];links;constructor(name,e,t,r,n,i){this.name=name,this.parent=e,this.context=t,this.startTime=n,this.kind=i,this.status={_tag:"Started",startTime:n},this.attributes=new Map,this.traceId="Some"===e._tag?e.value.traceId:aB(32),this.spanId=aB(16),this.links=Array.from(r)}end(e,t){this.status={_tag:"Ended",endTime:e,exit:t,startTime:this.status.startTime}}attribute(e,t){this.attributes.set(e,t)}event(name,e,t){this.events.push([name,e,t??{}])}addLinks(e){this.links.push(...e)}}const uB=make$1T({span:(name,e,t,r,n,i)=>new NativeSpan(name,e,t,r,n,i),context:e=>e()}),addSpanStackTrace=e=>{if(!1===e?.captureStackTrace)return e;if(void 0!==e?.captureStackTrace&&"boolean"!=typeof e.captureStackTrace)return e;const t=Error.stackTraceLimit;Error.stackTraceLimit=3;const r=Error();Error.stackTraceLimit=t;let n=!1;return{...e,captureStackTrace:()=>{if(!1!==n)return n;if(void 0!==r.stack){const e=r.stack.split("\n");if(void 0!==e[3])return n=e[3].trim(),n}}}},cB=Reference()("effect/Tracer/DisablePropagation",{defaultValue:n}),lB=pipe(empty$S(),NA(c$,make$1W()),NA(eB,tB),NA(nB,make$1U(Math.random())),NA(W$,fromEnv$1()),NA(sB,uB)),pB=globalValue(Symbol.for("effect/DefaultServices/currentServices"),()=>fiberRefUnsafeMakeContext(lB)),defaultServicesWith=e=>withFiberRuntime$1(t=>e(t.currentDefaultServices)),clockWith$3=e=>defaultServicesWith(t=>e(t.unsafeMap.get(c$.key))),fB=clockWith$3(e=>e.currentTimeMillis),hB=clockWith$3(e=>e.currentTimeNanos),dB=dual(2,(e,t)=>UD(pB,NA(c$,t))(e)),mB=dual(2,(e,t)=>UD(pB,NA(W$,t))(e)),configProviderWith$1=e=>defaultServicesWith(t=>e(t.unsafeMap.get(W$.key))),randomWith$2=e=>defaultServicesWith(t=>e(t.unsafeMap.get(nB.key))),gB=dual(2,(e,t)=>UD(pB,NA(nB,t))(e)),yB=randomWith$2(e=>e.next),bB=randomWith$2(e=>e.nextInt),SB=randomWith$2(e=>e.nextBoolean),tracerWith$3=e=>defaultServicesWith(t=>e(t.unsafeMap.get(sB.key))),vB=dual(2,(e,t)=>UD(pB,NA(sB,t))(e)),sleep$4=e=>{const t=decode$5(e);return clockWith$3(e=>e.sleep(t))},_B=fB,wB=hB,kB=clockWith$3,xB=c$;var IB=Object.freeze({__proto__:null,Clock:xB,ClockTypeId:u$,clockWith:kB,currentTimeMillis:_B,currentTimeNanos:wB,make:make$1W,sleep:sleep$4});function unsafeMake$f(e){return new FiberRefsImpl(e)}function empty$y(){return unsafeMake$f(new Map)}const TB=Symbol.for("effect/FiberRefs");class FiberRefsImpl{locals;[TB]=TB;constructor(e){this.locals=e}pipe(){return pipeArguments(this,arguments)}}const OB=dual(3,(e,t,r)=>{const n=new Map(e.locals);return r.locals.forEach((e,r)=>{const i=e[0][1];if(!e[0][0][Y](t)){if(!n.has(r)){if(equals$4(i,r.initial))return;return void n.set(r,[[t,r.join(r.initial,i)]])}const s=n.get(r),[o,a]=((e,t,r,n=!1)=>{const i=e;let s,o=t,a=r,u=n;for(;void 0===s;)if(ci(o)&&ci(a)){const e=hi(o)[0],t=tailNonEmpty$1(o),r=hi(a)[0],n=hi(a)[1],i=tailNonEmpty$1(a);e.startTimeMillis<r.startTimeMillis?(a=i,u=!0):e.startTimeMillis>r.startTimeMillis?o=t:e.id<r.id?(a=i,u=!0):e.id>r.id?o=t:s=[n,u]}else s=[i.initial,!0];return s})(r,s,e);if(a){const e=r.diff(o,i),a=s[0][1],u=r.join(a,r.patch(e)(a));if(!equals$4(a,u)){let e;const i=s[0][0];e=i[Y](t)?[[i,u],...s.slice(1)]:[[t,u],...s],n.set(r,e)}}}}),new FiberRefsImpl(n)}),EB=dual(2,(e,t)=>{const r=new Map;return unsafeForkAs(e,r,t),new FiberRefsImpl(r)}),unsafeForkAs=(e,t,r)=>{e.locals.forEach((e,n)=>{const i=e[0][1],s=n.patch(n.fork)(i);equals$4(i,s)?t.set(n,e):t.set(n,[[r,s],...e])})},fiberRefs$2=e=>fromIterable$r(e.locals.keys()),AB=dual(2,(e,t)=>{const r=new Map(e.locals);return r.delete(t),new FiberRefsImpl(r)}),CB=dual(2,(e,t)=>e.locals.has(t)?Ut(hi(e.locals.get(t))[1]):none$c()),MB=dual(2,(e,t)=>pipe(CB(e,t),Kt(()=>t.initial))),FB=dual(2,(e,{fiberId:t,fiberRef:r,value:n})=>{if(0===e.locals.size)return new FiberRefsImpl(new Map([[r,[[t,n]]]]));const i=new Map(e.locals);return unsafeUpdateAs(i,t,r,n),new FiberRefsImpl(i)}),unsafeUpdateAs=(e,t,r,n)=>{const i=e.get(r)??[];let s;if(ci(i)){const[e,r]=hi(i);if(e[Y](t)){if(equals$4(r,n))return;s=[[t,n],...i.slice(1)]}else s=[[t,n],...i]}else s=[[t,n]];e.set(r,s)},PB=dual(2,(e,{entries:t,forkAs:r})=>{if(0===e.locals.size)return new FiberRefsImpl(new Map(t));const n=new Map(e.locals);return void 0!==r&&unsafeForkAs(e,n,r),t.forEach(([e,t])=>{1===t.length?unsafeUpdateAs(n,t[0][0],e,t[0][1]):t.forEach(([t,r])=>{unsafeUpdateAs(n,t,e,r)})}),new FiberRefsImpl(n)}),NB=AB,jB=CB,RB=MB,DB=OB,setAll=e=>UR(fiberRefs$2(e),t=>AD(t,MB(e,t))),LB=FB,UB=PB,$B=empty$y;var BB=Object.freeze({__proto__:null,FiberRefsSym:TB,delete:NB,empty:$B,fiberRefs:fiberRefs$2,forkAs:EB,get:jB,getOrDefault:RB,joinAs:DB,setAll,unsafeMake:unsafeMake$f,updateAs:LB,updateManyAs:UB});const zB=dD,qB=mD,WB=gD,VB=yD,KB=bD,GB=SD,JB=vD,HB=_D,ZB=wD,QB=dual(2,(e,t)=>LD(e,WD,t)),YB=pipe(qI,Pt(e=>e.ordinal)),XB=lessThan$e(YB),ez=lessThanOrEqualTo$7(YB),tz=greaterThan$a(YB),fromLiteral=e=>{switch(e){case"All":return zB;case"Debug":return GB;case"Error":return WB;case"Fatal":return qB;case"Info":return KB;case"Trace":return JB;case"None":return HB;case"Warning":return VB}};var rz=Object.freeze({__proto__:null,All:zB,Debug:GB,Error:WB,Fatal:qB,Info:KB,None:HB,Order:YB,Trace:JB,Warning:VB,allLevels:ZB,fromLiteral,greaterThan:tz,greaterThanEqual:greaterThanOrEqualTo$7(YB),lessThan:XB,lessThanEqual:ez,locally:QB});const formatLabel=e=>e.replace(/[\s="]/g,"_"),render$2=e=>t=>`${formatLabel(t.label)}=${e-t.startTime}ms`,make$1Q=(e,t)=>({label:e,startTime:t});var nz=Object.freeze({__proto__:null,make:make$1Q,render:render$2});const iz=xe,sz=Ie,oz=Te,az=Oe,uz=Ae,cz=Me,lz=Fe,pz=Pe,fz=Ne;let hz=class extends pz{};var dz=Object.freeze({__proto__:null,ChannelTypeId:az,Class:hz,CommitPrototype:cz,EffectPrototype:uz,EffectTypeId:iz,SinkTypeId:oz,StreamTypeId:sz,StructuralClass:class extends fz{},StructuralCommitPrototype:lz});const mz=Symbol.for("effect/Readable"),gz={[mz]:mz,pipe(){return pipeArguments(this,arguments)}},make$1P=e=>{const t=Object.create(gz);return t.get=e,t},yz=dual(2,(e,t)=>make$1P(qR(e.get,t))),bz=dual(2,(e,t)=>make$1P(PR(e.get,t)));var Sz=Object.freeze({__proto__:null,TypeId:mz,isReadable:e=>C(e,mz),make:make$1P,map:yz,mapEffect:bz,unwrap:e=>make$1P(PR(e,e=>e.get))});const vz=Symbol.for("effect/Ref"),_z={_A:e=>e};class RefImpl extends hz{ref;commit(){return this.get}[vz]=_z;[mz]=mz;constructor(e){super(),this.ref=e,this.get=sync$l(()=>get$E(this.ref))}get;modify(e){return sync$l(()=>{const t=get$E(this.ref),[r,n]=e(t);return t!==n&&qF(n)(this.ref),r})}}const unsafeMake$d=e=>new RefImpl(make$27(e)),make$1O=e=>sync$l(()=>unsafeMake$d(e)),get$z=e=>e.get,wz=dual(2,(e,t)=>e.modify(()=>[void 0,t])),kz=dual(2,(e,t)=>e.modify(e=>[e,t])),xz=dual(2,(e,t)=>e.modify(e=>[e,t(e)])),Iz=dual(2,(e,t)=>e.modify(e=>{const r=t(e);switch(r._tag){case"None":return[e,e];case"Some":return[e,r.value]}})),Tz=dual(2,(e,t)=>e.modify(()=>[t,t])),Oz=dual(2,(e,t)=>e.modify(t)),Ez=dual(3,(e,t,r)=>e.modify(e=>{const n=r(e);switch(n._tag){case"None":return[t,e];case"Some":return n.value}})),Az=dual(2,(e,t)=>e.modify(e=>[void 0,t(e)])),Cz=dual(2,(e,t)=>e.modify(e=>{const r=t(e);return[r,r]})),Mz=dual(2,(e,t)=>e.modify(e=>[void 0,qt(t(e),{onNone:()=>e,onSome:e=>e})])),Fz=dual(2,(e,t)=>e.modify(e=>{const r=t(e);switch(r._tag){case"None":return[e,e];case"Some":return[r.value,r.value]}})),unsafeGet$6=e=>get$E(e.ref),Pz=vz,Nz=make$1O,jz=get$z,Rz=kz,Dz=xz,Lz=Iz,Uz=Oz,$z=Ez,Bz=wz,zz=Tz,qz=Az,Wz=Cz,Vz=Mz,Kz=Fz;var Gz=Object.freeze({__proto__:null,RefTypeId:Pz,get:jz,getAndSet:Rz,getAndUpdate:Dz,getAndUpdateSome:Lz,make:Nz,modify:Uz,modifySome:$z,set:Bz,setAndGet:zz,unsafeMake:unsafeMake$d,update:qz,updateAndGet:Wz,updateSome:Vz,updateSomeAndGet:Kz});const Jz=tracerWith$3;var Hz=Object.freeze({__proto__:null,DisablePropagation:cB,ParentSpan:oB,Tracer:sB,TracerTypeId:iB,externalSpan:e=>({_tag:"ExternalSpan",spanId:e.spanId,traceId:e.traceId,sampled:e.sampled??!0,context:e.context??empty$S()}),make:make$1T,tracerWith:Jz});const Zz="Empty",Qz="Remove",Yz="Update",Xz="AndThen",eq={_tag:Zz},diff$4=(e,t)=>{const r=new Map(e.locals);let n=eq;for(const[e,i]of t.locals.entries()){const t=hi(i)[1],s=r.get(e);if(void 0!==s){const r=hi(s)[1];equals$4(r,t)||(n=tq({_tag:Yz,fiberRef:e,patch:e.diff(r,t)})(n))}else n=tq({_tag:"Add",fiberRef:e,value:t})(n);r.delete(e)}for(const[e]of r.entries())n=tq({_tag:Qz,fiberRef:e})(n);return n},tq=dual(2,(e,t)=>({_tag:Xz,first:e,second:t})),rq=dual(3,(e,t,r)=>{let n=r,i=of$6(e);for(;ci(i);){const e=hi(i),r=tailNonEmpty$1(i);switch(e._tag){case Zz:i=r;break;case"Add":n=FB(n,{fiberId:t,fiberRef:e.fiberRef,value:e.value}),i=r;break;case Qz:n=AB(n,e.fiberRef),i=r;break;case Yz:{const s=MB(n,e.fiberRef);n=FB(n,{fiberId:t,fiberRef:e.fiberRef,value:e.fiberRef.patch(e.patch)(s)}),i=r;break}case Xz:i=ei(e.first)(ei(e.second)(r))}}return n}),nq="effect/MetricLabel",iq=Symbol.for(nq);class MetricLabelImpl{key;value;[iq]=iq;_hash;constructor(e,t){this.key=e,this.value=t,this._hash=string$6(nq+this.key+this.value)}[Z](){return this._hash}[Y](e){return isMetricLabel$1(e)&&this.key===e.key&&this.value===e.value}pipe(){return pipeArguments(this,arguments)}}const make$1L=(e,t)=>new MetricLabelImpl(e,t),isMetricLabel$1=e=>C(e,iq),sq=dual(e=>isEffect$1(e[0]),function(){const e=arguments;return UD(e[0],qD,"string"==typeof e[1]?vP(e[1],e[2]):t=>Object.entries(e[1]).reduce((e,[t,r])=>vP(e,t,r),t))}),asSome$4=e=>qR(e,Ut),try_$4=e=>{let t,r;return"function"==typeof e?t=e:(t=e.try,r=e.catch),suspend$g(()=>{try{return succeed$u(K(t))}catch(e){return fail$r(r?K(()=>r(e)):new TL(e,"An unknown error occurred in Effect.try"))}})},oq=dual(3,(e,t,r)=>ER(e,e=>C(e,t)&&e[t]===r.failure?r.onFailure(e):fail$r(e))),aq=dual(2,(e,t)=>OR(e,e=>{const r=uR(e,e=>isDieType$1(e)?Ut(e):none$c());switch(r._tag){case"None":return failCause$j(e);case"Some":return t(r.value.defect)}})),uq=dual(2,(e,t)=>RR(e,{onFailure:e=>{const r=t(e);switch(r._tag){case"None":return failCause$j(e);case"Some":return r.value}},onSuccess:succeed$u})),cq=dual(2,(e,t)=>OR(e,e=>{const r=uR(e,e=>isDieType$1(e)?Ut(e):none$c());switch(r._tag){case"None":return failCause$j(e);case"Some":{const n=t(r.value.defect);return"Some"===n._tag?n.value:failCause$j(e)}}})),lq=dual(e=>isEffect$1(e[0]),(e,...t)=>{const r=t[t.length-1];let n;return n=2===t.length?M(t[0]):e=>{const r=C(e,"_tag")?e._tag:void 0;if(!r)return!1;for(let e=0;e<t.length-1;e++)if(t[e]===r)return!0;return!1},AR(e,n,r)}),pq=dual(2,(e,t)=>{let r;return AR(e,e=>(r??=Object.keys(t),C(e,"_tag")&&isString$1(e._tag)&&r.includes(e._tag)),e=>t[e._tag](e))}),fq=kB,hq=fq(succeed$u),dq=dual(2,(e,t)=>lD(sleep$4(t),e)),descriptorWith$1=e=>withFiberRuntime$1((t,r)=>e({id:t.id(),status:r,interruptors:interruptors$1(t.getFiberRef(rL))})),mq=descriptorWith$1(e=>size$x(e.interruptors)>0?BR:tD),gq=descriptorWith$1(succeed$u),diffFiberRefs$1=e=>rW(e,Pq,diff$4),yq=succeed$u({}),bq=bind$a(qR,PR),Sq=bindTo$a(qR),vq=let_$a(qR),_q=dual(2,(e,t)=>suspend$g(()=>{const r=e[Symbol.iterator](),n=[];let i,s=succeed$u(!1),o=0;for(;(i=r.next())&&!i.done;){const e=i.value,r=o++;s=PR(s,i=>i?(n.push(e),succeed$u(!0)):t(e,r))}return qR(s,()=>n)})),wq=dual(2,(e,t)=>suspend$g(()=>{const r=e[Symbol.iterator](),n=[];let i,s=succeed$u(!0),o=0;for(;(i=r.next())&&!i.done;){const e=i.value,r=o++;s=PR(s,i=>qR(i?t(e,r):succeed$u(!1),t=>(t||n.push(e),t)))}return qR(s,()=>n)})),eventually$3=e=>HR(e,()=>PR(yieldNow$3(),()=>eventually$3(e))),kq=dual(2,(e,t)=>qR(LR(e,identity$5),ls(t))),xq=dual(3,(e,t,r)=>Tq(e,t,e=>dieSync$a(()=>r(e)))),Iq=dual(3,(e,t,r)=>Tq(e,t,()=>dieMessage$9(r))),Tq=dual(3,(e,t,r)=>PR(e,e=>t(e)?succeed$u(e):r(e))),Oq=dual(3,(e,t,r)=>suspend$g(()=>t(e)?succeed$u(e):fail$r(r(e)))),Eq=dual(e=>isEffect$1(e[0]),(e,t,r)=>Tq(e,t,e=>void 0===r?fail$r(new bL):failSync$d(()=>r(e)))),Aq=dual(2,(e,t)=>suspend$g(()=>{const r=e[Symbol.iterator](),n=r.next();return n.done?succeed$u(none$c()):findLoop(r,0,t,n.value)})),findLoop=(e,t,r,n)=>PR(r(n,t),i=>{if(i)return succeed$u(Ut(n));const s=e.next();return s.done?succeed$u(none$c()):findLoop(e,t+1,r,s.value)}),Cq=dual(2,(e,t)=>flip$4(t(flip$4(e)))),Mq=dual(2,(e,t)=>DR(e,{onFailure:e=>succeed$u(t.onFailure(e)),onSuccess:e=>succeed$u(t.onSuccess(e))})),Fq=dual(2,(e,t)=>suspend$g(()=>forAllLoop(e[Symbol.iterator](),0,t))),forAllLoop=(e,t,r)=>{const n=e.next();return n.done?succeed$u(!0):PR(r(n.value,t),n=>n?forAllLoop(e,t+1,r):succeed$u(n))},forever$6=e=>{const t=PR(PR(e,()=>yieldNow$3()),()=>t);return t},Pq=withFiberRuntime$1(e=>succeed$u(e.getFiberRefs())),ignore$4=e=>Mq(e,{onFailure:o,onSuccess:o}),ignoreLogged$2=e=>RR(e,{onFailure:e=>Rq(e,"An error was silently ignored because it is not anticipated to be useful"),onSuccess:()=>tD}),iterate$5=(e,t)=>suspend$g(()=>t.while(e)?PR(t.body(e),e=>iterate$5(e,t)):succeed$u(e)),logWithLevel$1=e=>(...t)=>{const r=fromNullable$3(e);let n;for(let e=0,r=t.length;e<r;e++){const r=t[e];isCause$1(r)&&(n=void 0!==n?sequential$4(n,r):r,t=[...t.slice(0,e),...t.slice(e+1)],e--)}return void 0===n&&(n=tR),withFiberRuntime$1(e=>(e.log(t,n,r),tD))},Nq=logWithLevel$1(),jq=logWithLevel$1(JB),Rq=logWithLevel$1(GB),Dq=logWithLevel$1(KB),Lq=logWithLevel$1(VB),Uq=logWithLevel$1(WB),$q=logWithLevel$1(qB),Bq=dual(2,(e,t)=>PR(_B,r=>UD(e,VD,UP(make$1Q(t,r))))),zq=fiberRefGet(qD),loopInternal=(e,t,r,n)=>suspend$g(()=>t(e)?PR(n(e),i=>qR(loopInternal(r(e),t,r,n),UP(i))):sync$l(()=>RP())),loopDiscard=(e,t,r,n)=>suspend$g(()=>t(e)?PR(n(e),()=>loopDiscard(r(e),t,r,n)):tD),qq=dual(3,(e,t,r)=>suspend$g(()=>{const n=e[Symbol.iterator](),i=[];let s,o=succeed$u(t),a=0;for(;!(s=n.next()).done;){const e=a++,t=s.value;o=PR(o,n=>qR(r(n,t,e),([e,t])=>(i.push(t),e)))}return qR(o,e=>[e,i])})),Wq=dual(2,(e,t)=>RR(e,{onFailure:e=>failCauseSync$b(()=>t(e)),onSuccess:succeed$u})),memoize$2=e=>pipe(deferredMake(),PR(t=>pipe((e=>rW(e,uD(Pq,YR),([e,t],[r,n])=>[diff$4(e,r),Mj(t,n)]))(e),zR(t),once$3,qR(e=>lD(e,pipe(deferredAwait(t),PR(([e,t])=>TR(uD(patchFiberRefs$1(e[0]),updateRuntimeFlags$2(e[1])),t)))))))),negate$3=e=>qR(e,e=>!e),once$3=e=>qR(Nz(!0),t=>asVoid$9(rD(e,Rz(t,!1)))),Vq=dual(2,(e,t)=>HR(e,()=>failSync$d(t))),Kq=dual(2,(e,t)=>HR(e,()=>sync$l(t))),patchFiberRefs$1=e=>updateFiberRefs$3((t,r)=>pipe(e,rq(t,r))),Gq=dual(3,(e,t,r)=>contextWithEffect$7(n=>oU(e,NA(n,t,r)))),Jq=dual(3,(e,t,r)=>contextWithEffect$7(n=>PR(r,r=>oU(e,pipe(n,NA(t,r)))))),Hq=randomWith$2(succeed$u),Zq=dual(3,(e,t,r)=>fromIterable$v(e).reduce((e,t,n)=>PR(e,e=>r(e,t,n)),succeed$u(t))),Qq=dual(3,(e,t,r)=>fromIterable$v(e).reduceRight((e,t,n)=>PR(e,e=>r(t,e,n)),succeed$u(t))),Yq=dual(3,(e,t,r)=>PR(sync$l(()=>e[Symbol.iterator]()),e=>reduceWhileLoop(e,0,t,r.while,r.body))),reduceWhileLoop=(e,t,r,n,i)=>{const s=e.next();return!s.done&&n(r)?PR(i(r,s.value,t),r=>reduceWhileLoop(e,t+1,r,n,i)):succeed$u(r)},Xq=dual(2,(e,t)=>suspend$g(()=>repeatNLoop(e,t))),repeatNLoop=(e,t)=>PR(e,r=>t<=0?succeed$u(r):lD(yieldNow$3(),repeatNLoop(e,t-1))),eW=sleep$4,tW=succeed$u(none$c()),rW=dual(3,(e,t,r)=>PR(t,start=>PR(e,e=>qR(t,t=>[r(start,t),e])))),nW=dual(e=>isEffect$1(e[0]),function(){return iW(arguments[0],"string"==typeof arguments[1]?[make$1L(arguments[1],arguments[2])]:Object.entries(arguments[1]).map(([e,t])=>make$1L(e,t)))}),iW=dual(2,(e,t)=>UD(e,XD,e=>is(e,t))),sW=dual(2,(e,t)=>suspend$g(()=>{const r=e[Symbol.iterator](),n=[];let i,s=succeed$u(!1),o=0;for(;(i=r.next())&&!i.done;){const e=i.value,r=o++;s=PR(s,i=>i?succeed$u(!0):(n.push(e),t(e,r)))}return qR(s,()=>n)})),oW=dual(2,(e,t)=>suspend$g(()=>{const r=e[Symbol.iterator](),n=[];let i,s=succeed$u(!0),o=0;for(;(i=r.next())&&!i.done;){const e=i.value,r=o++;s=PR(s,i=>pipe(i?t(e,r):succeed$u(!1),qR(t=>(t&&n.push(e),t))))}return qR(s,()=>n)})),aW=dual(2,(e,{onFailure:t,onSuccess:r})=>RR(e,{onFailure:e=>{const r=failureOrCause$1(e);switch(r._tag){case"Left":return lD(t(r.left),failCause$j(e));case"Right":return failCause$j(e)}},onSuccess:e=>TR(r(e),e)})),uW=dual(2,(e,t)=>OR(e,e=>qt(keepDefects$1(e),{onNone:()=>failCause$j(e),onSome:r=>lD(t(r),failCause$j(e))}))),cW=dual(2,(e,t)=>RR(e,{onFailure:e=>{const r=failureOrCause$1(e);switch(r._tag){case"Left":return lD(t(r.left),failCause$j(e));case"Right":return failCause$j(e)}},onSuccess:succeed$u})),lW=dual(3,(e,t,r)=>cW(e,e=>M(e,t)?r(e):tD)),pW=dual(2,(e,t)=>RR(e,{onFailure:e=>lD(t(e),failCause$j(e)),onSuccess:succeed$u})),fW=dual(2,(e,t)=>rW(e,t,(start,e)=>nanos(e-start))),hW=Jz(succeed$u),tryPromise$2=e=>{let t,r;"function"==typeof e?t=e:(t=e.try,r=e.catch);const fail=e=>r?failSync$d(()=>r(e)):fail$r(new TL(e,"An unknown error occurred in Effect.tryPromise"));return t.length>=1?async_((e,r)=>{try{t(r).then(t=>e(succeed$u(t)),t=>e(fail(t)))}catch(t){e(fail(t))}}):async_(e=>{try{t().then(t=>e(succeed$u(t)),t=>e(fail(t)))}catch(t){e(fail(t))}})},dW=dual(2,(e,t)=>PR(e,e=>try_$4({try:()=>t.try(e),catch:t.catch}))),mW=dual(2,(e,t)=>PR(e,e=>tryPromise$2({try:t.try.length>=1?r=>t.try(e,r):()=>t.try(e),catch:t.catch}))),gW=dual(2,(e,t)=>suspend$g(()=>t()?tW:asSome$4(e))),yW=dual(2,(e,t)=>PR(t,t=>t?tW:asSome$4(e))),updateFiberRefs$3=e=>withFiberRuntime$1(t=>(t.setFiberRefs(e(t.id(),t.getFiberRefs())),tD)),bW=dual(3,(e,t,r)=>uU(e,e=>NA(e,t,r(RA(e,t))))),SW=dual(2,(e,t)=>suspend$g(()=>t()?qR(e,Ut):succeed$u(none$c()))),vW=dual(3,(e,t,r)=>PR(fiberRefGet(t),t=>r(t)?qR(e,e=>[t,Ut(e)]):succeed$u([t,none$c()]))),_W=dual(3,(e,t,r)=>PR(jz(t),t=>r(t)?qR(e,e=>[t,Ut(e)]):succeed$u([t,none$c()]))),wW=dual(2,(e,t)=>t(e)),serviceFunctions$1=e=>new Proxy({},{get:(t,r,n)=>(...t)=>PR(e,e=>e[r](...t))}),serviceConstants$1=e=>new Proxy({},{get:(t,r,n)=>PR(e,e=>isEffect$1(e[r])?e[r]:succeed$u(e[r]))}),serviceOptional$1=e=>PR(context$c(),DA(e)),kW=dual(e=>isEffect$1(e[0]),function(){const e=arguments;return UD(e[0],sL,"string"==typeof e[1]?vP(e[1],e[2]):t=>Object.entries(e[1]).reduce((e,[t,r])=>vP(e,t,r),t))}),xW=serviceOptional$1(oB),IW=PR(context$c(),e=>{const t=e.unsafeMap.get(oB.key);return void 0!==t&&"Span"===t._tag?succeed$u(t):fail$r(new bL)}),TW=dual(e=>isEffect$1(e[0]),(e,t,r)=>UD(e,oL,GA({_tag:"SpanLink",span:t,attributes:r??{}}))),OW=BigInt(0),EW=ir(e=>jA(e.context,cB)?"Span"===e._tag?EW(e.parent):none$c():Ut(e)),unsafeMakeSpan=(e,name,t)=>{const r=!e.getFiberRef(nL)||t.context&&jA(t.context,cB),n=e.getFiberRef($D),i=t.parent?Ut(t.parent):t.root?none$c():EW(DA(n,oB));let s;if(r)s=(e=>Object.assign(Object.create(pU),e))({name,parent:i,context:NA(t.context??empty$S(),cB,!0)});else{const r=e.getFiberRef(pB),n=jA(r,sB),o=jA(r,xB),a=e.getFiberRef(iL),u=e.getFiberRefs(),c=jB(u,sL),l=jB(u,oL),p="Some"===l._tag?void 0!==t.links?[...toReadonlyArray$1(l.value),...t.links??[]]:toReadonlyArray$1(l.value):t.links??[];s=n.span(name,i,t.context??empty$S(),p,a?o.unsafeCurrentTimeNanos():OW,t.kind??"internal",t),"Some"===c._tag&&OP(c.value,(e,t)=>s.attribute(t,e)),void 0!==t.attributes&&Object.entries(t.attributes).forEach(([e,t])=>s.attribute(e,t))}return"function"==typeof t.captureStackTrace&&bR.set(s,t.captureStackTrace),s},AW=fiberRefGet(sL),CW=fiberRefGet(oL),endSpan=(e,t,r,n)=>sync$l(()=>{"Ended"!==e.status._tag&&(exitIsFailure$1(t)&&bR.has(e)&&e.attribute("code.stacktrace",bR.get(e)()),e.end(n?r.unsafeCurrentTimeNanos():OW,t))}),useSpan$1=(name,...e)=>{const t=addSpanStackTrace(1===e.length?void 0:e[0]),r=e[e.length-1];return withFiberRuntime$1(e=>{const n=unsafeMakeSpan(e,name,t),i=e.getFiberRef(iL),s=jA(e.getFiberRef(pB),c$);return GR(r(n),e=>endSpan(n,e,s,i))})},MW=dual(2,(e,t)=>Gq(e,oB,t)),withSpan$7=function(){const e="string"!=typeof arguments[0],name=e?arguments[1]:arguments[0],t=addSpanStackTrace(e?arguments[2]:arguments[1]);if(e){const e=arguments[0];return useSpan$1(name,t,t=>MW(e,t))}return e=>useSpan$1(name,t,t=>MW(e,t))},FW="Sequential",PW="Parallel",NW="ParallelN",jW={_tag:FW},isSequential$1=e=>e._tag===FW,isParallel$1=e=>e._tag===PW,RW=jW,DW={_tag:PW},parallelN=e=>({_tag:NW,parallelism:e});var LW=Object.freeze({__proto__:null,isParallel:isParallel$1,isParallelN:e=>e._tag===NW,isSequential:isSequential$1,match:dual(2,(e,t)=>{switch(e._tag){case FW:return t.onSequential();case PW:return t.onParallel();case NW:return t.onParallelN(e.parallelism)}}),parallel:DW,parallelN,sequential:RW});const UW=diff$4,$W=rq;var BW=Object.freeze({__proto__:null,combine:tq,diff:UW,empty:eq,patch:$W});const zW="effect/FiberStatus",qW=Symbol.for(zW),WW="Done",VW="Running",KW="Suspended",GW=string$6(`${zW}-${WW}`);let JW=class{[qW]=qW;_tag=WW;[Z](){return GW}[Y](e){return isFiberStatus$1(e)&&e._tag===WW}};class Running{runtimeFlags;[qW]=qW;_tag=VW;constructor(e){this.runtimeFlags=e}[Z](){return pipe(hash$3(zW),combine$h(hash$3(this._tag)),combine$h(hash$3(this.runtimeFlags)),cached$2(this))}[Y](e){return isFiberStatus$1(e)&&e._tag===VW&&this.runtimeFlags===e.runtimeFlags}}class Suspended{runtimeFlags;blockingOn;[qW]=qW;_tag=KW;constructor(e,t){this.runtimeFlags=e,this.blockingOn=t}[Z](){return pipe(hash$3(zW),combine$h(hash$3(this._tag)),combine$h(hash$3(this.runtimeFlags)),combine$h(hash$3(this.blockingOn)),cached$2(this))}[Y](e){return isFiberStatus$1(e)&&e._tag===KW&&this.runtimeFlags===e.runtimeFlags&&equals$4(this.blockingOn,e.blockingOn)}}const isFiberStatus$1=e=>C(e,qW),HW=new JW,running$1=e=>new Running(e),suspended=(e,t)=>new Suspended(e,t),isDone$5=e=>e._tag===WW,isRunning$1=e=>e._tag===VW,isSuspended=e=>e._tag===KW;var ZW=Object.freeze({__proto__:null,FiberStatusTypeId:qW,done:HW,isDone:isDone$5,isFiberStatus:isFiberStatus$1,isRunning:isRunning$1,isSuspended,running:running$1,suspended});const QW=Symbol.for("effect/Micro"),YW=Symbol.for("effect/Micro/MicroExit"),isMicro=e=>"object"==typeof e&&null!==e&&QW in e,XW=Symbol.for("effect/Micro/MicroCause"),eV={_E:identity$5};class MicroCauseImpl extends globalThis.Error{_tag;traces;[XW];constructor(e,t,r){const n="MicroCause."+e;let name,i,s;if(t instanceof globalThis.Error){name=`(${n}) ${t.name}`,i=t.message;const e=i.split("\n").length;s=t.stack?`(${n}) ${t.stack.split("\n").slice(0,e+3).join("\n")}`:`${name}: ${i}`}else name=n,i=toStringUnknown(t,0),s=`${name}: ${i}`;r.length>0&&(s+="\n    "+r.join("\n    ")),super(i),this._tag=e,this.traces=r,this[XW]=eV,this.name=name,this.stack=s}pipe(){return pipeArguments(this,arguments)}toString(){return this.stack}[ee](){return this.stack}}class Fail extends MicroCauseImpl{error;constructor(e,t=[]){super("Fail",e,t),this.error=e}}const causeFail=(e,t=[])=>new Fail(e,t);class Die extends MicroCauseImpl{defect;constructor(e,t=[]){super("Die",e,t),this.defect=e}}const causeDie=(e,t=[])=>new Die(e,t);class Interrupt extends MicroCauseImpl{constructor(e=[]){super("Interrupt","interrupted",e)}}const causeInterrupt=(e=[])=>new Interrupt(e),causeIsFail=e=>"Fail"===e._tag,causeIsDie=e=>"Die"===e._tag,causeIsInterrupt=e=>"Interrupt"===e._tag,tV=dual(2,(e,t)=>{const r=[...e.traces,t];switch(e._tag){case"Die":return causeDie(e.defect,r);case"Interrupt":return causeInterrupt(r);case"Fail":return causeFail(e.error,r)}}),rV=Symbol.for("effect/Micro/MicroFiber"),nV={_A:identity$5,_E:identity$5};class MicroFiberImpl{context;interruptible;[rV];_stack=[];_observers=[];_exit;_children;currentOpCount=0;constructor(e,t=!0){this.context=e,this.interruptible=t,this[rV]=nV}getRef(e){return((e,t)=>e.unsafeMap.has(t.key)?e.unsafeMap.get(t.key):getDefaultValue(t))(this.context,e)}addObserver(e){return this._exit?(e(this._exit),o):(this._observers.push(e),()=>{const t=this._observers.indexOf(e);t>=0&&this._observers.splice(t,1)})}_interrupted=!1;unsafeInterrupt(){this._exit||(this._interrupted=!0,this.interruptible&&this.evaluate(LV))}unsafePoll(){return this._exit}evaluate(e){if(this._exit)return;if(void 0!==this._yielded){const e=this._yielded;this._yielded=void 0,e()}const t=this.runLoop(e);if(t===pV)return;const r=iV.interruptChildren&&iV.interruptChildren(this);if(void 0!==r)return this.evaluate(PV(r,()=>t));this._exit=t;for(let e=0;e<this._observers.length;e++)this._observers[e](t);this._observers.length=0}runLoop(e){let t=!1,r=e;this.currentOpCount=0;try{for(;;){if(this.currentOpCount++,!t&&this.getRef(CurrentScheduler).shouldYield(this)){t=!0;const e=r;r=PV(SV,()=>e)}if(r=r[aV](this),r===pV){const e=this._yielded;return YW in e?(this._yielded=void 0,e):pV}}}catch(e){return C(r,aV)?exitDie(e):exitDie("MicroFiber.runLoop: Not a valid effect: "+r)}}getCont(e){for(;;){const t=this._stack.pop();if(!t)return;const r=t[lV]&&t[lV](this);if(r)return{[e]:r};if(t[e])return t}}_yielded=void 0;yieldWith(e){return this._yielded=e,pV}children(){return this._children??=new Set}}const iV=globalValue("effect/Micro/fiberMiddleware",()=>({interruptChildren:void 0})),fiberInterruptChildren=e=>{if(void 0!==e._children&&0!==e._children.size)return fiberInterruptAll(e._children)},fiberAwait=e=>async$1(t=>gV(e.addObserver(e=>t(dV(e))))),fiberInterrupt=e=>yV(()=>(e.unsafeInterrupt(),asVoid$7(fiberAwait(e)))),fiberInterruptAll=e=>yV(()=>{for(const t of e)t.unsafeInterrupt();const t=e[Symbol.iterator](),r=yV(()=>{let e=t.next();for(;!e.done;){if(e.value.unsafePoll()){e=t.next();continue}const n=e.value;return async$1(e=>{n.addObserver(t=>{e(r)})})}return UV});return r}),sV=Symbol.for("effect/Micro/identifier"),oV=Symbol.for("effect/Micro/args"),aV=Symbol.for("effect/Micro/evaluate"),uV=Symbol.for("effect/Micro/successCont"),cV=Symbol.for("effect/Micro/failureCont"),lV=Symbol.for("effect/Micro/ensureCont"),pV=Symbol.for("effect/Micro/Yield"),fV={_A:identity$5,_E:identity$5,_R:identity$5},hV={...uz,_op:"Micro",[QW]:fV,pipe(){return pipeArguments(this,arguments)},[Symbol.iterator](){return new z(new YieldWrap(this))},toJSON(){return{_id:"Micro",op:this[sV],...oV in this?{args:this[oV]}:void 0}},toString(){return format$6(this)},[ee](){return format$6(this)}};function defaultEvaluate(e){return exitDie("Micro.evaluate: Not implemented")}const makePrimitiveProto=e=>({...hV,[sV]:e.op,[aV]:e.eval??defaultEvaluate,[uV]:e.contA,[cV]:e.contE,[lV]:e.ensure}),makePrimitive=e=>{const t=makePrimitiveProto(e);return function(){const r=Object.create(t);return r[oV]=!1===e.single?arguments:arguments[0],r}},makeExit=e=>{const t={...makePrimitiveProto(e),[YW]:YW,_tag:e.op,get[e.prop](){return this[oV]},toJSON(){return{_id:"MicroExit",_tag:e.op,[e.prop]:this[oV]}},[Y](t){return isMicroExit(t)&&t._tag===e.op&&equals$4(this[oV],t[oV])},[Z](){return cached$2(this,combine$h(string$6(e.op))(hash$3(this[oV])))}};return function(e){const r=Object.create(t);return r[oV]=e,r[uV]=void 0,r[cV]=void 0,r[lV]=void 0,r}},dV=makeExit({op:"Success",prop:"value",eval(e){const t=e.getCont(uV);return t?t[uV](this[oV],e):e.yieldWith(this)}}),mV=makeExit({op:"Failure",prop:"cause",eval(e){let t=e.getCont(cV);for(;causeIsInterrupt(this[oV])&&t&&e.interruptible;)t=e.getCont(cV);return t?t[cV](this[oV],e):e.yieldWith(this)}}),fail$o=e=>mV(causeFail(e)),gV=makePrimitive({op:"Sync",eval(e){const t=this[oV](),r=e.getCont(uV);return r?r[uV](t,e):e.yieldWith(RV(t))}}),yV=makePrimitive({op:"Suspend",eval(e){return this[oV]()}}),bV=makePrimitive({op:"Yield",eval(e){let t=!1;return e.getRef(CurrentScheduler).scheduleTask(()=>{t||e.evaluate(UV)},this[oV]??0),e.yieldWith(()=>{t=!0})}}),SV=bV(0),vV=dV(none$c()),die$d=e=>exitDie(e),_V=dV(void 0),wV=makePrimitive({op:"WithMicroFiber",eval(e){return this[oV](e)}}),kV=wV(e=>(e.getRef(CurrentScheduler).flush(),UV)),xV=makePrimitive({op:"Async",single:!1,eval(e){const t=this[oV][0];let r=!1,n=!1;const i=this[oV][1]?new AbortController:void 0,s=t(t=>{r||(r=!0,n?e.evaluate(t):n=t)},i?.signal);return!1!==n?n:(n=!0,e._yielded=()=>{r=!0},void 0===i&&void 0===s||e._stack.push(IV(()=>(r=!0,i?.abort(),s??UV))),pV)}}),IV=makePrimitive({op:"AsyncFinalizer",ensure(e){e.interruptible&&(e.interruptible=!1,e._stack.push(qK(!0)))},contE(e,t){return causeIsInterrupt(e)?PV(this[oV](),()=>mV(e)):mV(e)}}),async$1=e=>xV(e,e.length>=2),TV=async$1(function(){const e=setInterval(o,2147483646);return gV(()=>clearInterval(e))}),OV=makePrimitive({op:"Iterator",contA(e,t){const r=this[oV].next(e);return r.done?dV(r.value):(t._stack.push(this),yieldWrapGet(r.value))},eval(e){return this[uV](void 0,e)}}),EV=dual(2,(e,t)=>jV(e,e=>t)),asSome$3=e=>jV(e,Ut),AV=dual(2,(e,t)=>PV(e,e=>{const r=isMicro(t)?t:"function"==typeof t?t(e):t;return isMicro(r)?r:dV(r)})),CV=dual(2,(e,t)=>PV(e,e=>{const r=isMicro(t)?t:"function"==typeof t?t(e):t;return isMicro(r)?EV(r,e):dV(e)})),asVoid$7=e=>PV(e,e=>UV),exit$1=e=>IK(e,{onFailure:DV,onSuccess:RV}),raceAll$4=e=>wV(t=>async$1(r=>{const n=fromIterable$v(e),i=n.length;let s=0,o=!1;const a=new Set,u=[],onExit=e=>{if(s++,"Failure"===e._tag)return u.push(e.cause),void(s>=i&&r(mV(u[0])));o=!0,r(0===a.size?e:PV(uninterruptible$1(fiberInterruptAll(a)),()=>e))};for(let e=0;e<i&&!o;e++){const r=unsafeFork$2(t,interruptible$2(n[e]),!0,!0);a.add(r),r.addObserver(e=>{a.delete(r),onExit(e)})}return fiberInterruptAll(a)})),raceAllFirst=e=>wV(t=>async$1(r=>{let n=!1;const i=new Set,onExit=e=>{n=!0,r(0===i.size?e:PV(fiberInterruptAll(i),()=>e))};for(const r of e){if(n)break;const e=unsafeFork$2(t,interruptible$2(r),!0,!0);i.add(e),e.addObserver(t=>{i.delete(e),onExit(t)})}return fiberInterruptAll(i)})),MV=dual(2,(e,t)=>raceAll$4([e,t])),FV=dual(2,(e,t)=>raceAllFirst([e,t])),PV=dual(2,(e,t)=>{const r=Object.create(NV);return r[oV]=e,r[uV]=t,r}),NV=makePrimitiveProto({op:"OnSuccess",eval(e){return e._stack.push(this),this[oV]}}),flatten$a=e=>PV(e,identity$5),jV=dual(2,(e,t)=>PV(e,e=>dV(t(e)))),isMicroExit=e=>C(e,YW),RV=dV,DV=mV,LV=DV(causeInterrupt()),exitDie=e=>DV(causeDie(e)),exitIsFailure=e=>"Failure"===e._tag,exitIsInterrupt=e=>exitIsFailure(e)&&"Interrupt"===e.cause._tag,UV=RV(void 0),exitVoidAll=e=>{for(const t of e)if("Failure"===t._tag)return t;return UV},$V="setImmediate"in globalThis?globalThis.setImmediate:e=>setTimeout(e,0);class MicroSchedulerDefault{tasks=[];running=!1;scheduleTask(e,t){this.tasks.push(e),this.running||(this.running=!0,$V(this.afterScheduled))}afterScheduled=()=>{this.running=!1,this.runTasks()};runTasks(){const e=this.tasks;this.tasks=[];for(let t=0,r=e.length;t<r;t++)e[t]()}shouldYield(e){return e.currentOpCount>=e.getRef(MaxOpsBeforeYield)}flush(){for(;this.tasks.length>0;)this.runTasks()}}const service$2=e=>wV(t=>dV(RA(t.context,e))),BV=dual(2,(e,t)=>wV(r=>{const n=r.context;return r.context=t(n),DK(e,()=>(r.context=n,_V))})),zV=dual(3,(e,t,r)=>wV(n=>{const i=RA(n.context,t);return n.context=NA(n.context,t,r(i)),DK(e,()=>(n.context=NA(n.context,t,i),_V))})),qV=wV(e=>dV(e.context)),WV=dual(2,(e,t)=>BV(e,LA(t))),VV=dual(3,(e,t,r)=>BV(e,NA(t,r))),KV=dual(3,(e,t,r)=>PV(r,r=>VV(e,t,r)));class MaxOpsBeforeYield extends(Reference()("effect/Micro/currentMaxOpsBeforeYield",{defaultValue:()=>2048})){}class CurrentConcurrency extends(Reference()("effect/Micro/currentConcurrency",{defaultValue:()=>"unbounded"})){}class CurrentScheduler extends(Reference()("effect/Micro/currentScheduler",{defaultValue:()=>new MicroSchedulerDefault})){}const GV=dual(2,(e,t)=>VV(e,CurrentConcurrency,t)),JV=dual(e=>isMicro(e[1]),(e,t,r)=>HV(e,t,(e,t)=>[e,t],r)),HV=dual(e=>isMicro(e[1]),(e,t,r,n)=>n?.concurrent?jV(all$7([e,t],{concurrency:2}),([e,t])=>r(e,t)):PV(e,e=>jV(t,t=>r(e,t)))),ZV=dual(e=>isMicro(e[0]),(e,t,r)=>PV(e,e=>t(e)?dV(e):mV(r(e)))),QV=dual(e=>isMicro(e[0]),(e,t,r)=>PV(e,e=>t(e)?dV(e):fail$o(r(e)))),YV=dual(2,(e,t)=>PV(isMicro(t)?t:gV(t),t=>t?asSome$3(e):vV)),XV=dual(2,(e,t)=>yV(()=>{const r=t.schedule?Date.now():0;let n=0;const i=PV(exit$1(e),e=>{if(void 0!==t.while&&!t.while(e))return e;if(void 0!==t.times&&n>=t.times)return e;n++;let s=SV;if(void 0!==t.schedule){const i=Date.now()-r,o=t.schedule(n,i);if(Bt(o))return e;s=sleep$2(o.value)}return PV(s,()=>i)});return i})),eK=dual(e=>isMicro(e[0]),(e,t)=>XV(e,{...t,while:e=>"Success"===e._tag&&(void 0===t?.while||t.while(e.value))})),tK=dual(2,(e,t)=>Array.from({length:t},()=>e)),rK=dual(e=>isMicro(e[0]),(e,t,r)=>all$7(tK(e,t),r)),nK=dual(2,(e,t)=>(r,n)=>er(e(r,n),e=>e+t())),iK=dual(2,(e,t)=>(r,n)=>er(e(r,n),e=>Math.min(e,t))),sK=dual(2,(e,t)=>(r,n)=>n<t?e(r,n):none$c()),oK=dual(2,(e,t)=>(r,n)=>fr(e(r,n),t(r,n),(e,t)=>Math.min(e,t))),aK=dual(2,(e,t)=>(r,n)=>fr(e(r,n),t(r,n),(e,t)=>Math.max(e,t))),uK=dual(2,(e,t)=>{const r=Object.create(cK);return r[oV]=e,r[cV]=t,r}),cK=makePrimitiveProto({op:"OnFailure",eval(e){return e._stack.push(this),this[oV]}}),lK=dual(3,(e,t,r)=>uK(e,e=>t(e)?r(e):mV(e))),pK=dual(2,(e,t)=>lK(e,causeIsFail,e=>t(e.error))),fK=dual(2,(e,t)=>lK(e,causeIsDie,e=>t(e.defect))),hK=dual(2,(e,t)=>dK(e,r,t)),dK=dual(3,(e,t,r)=>lK(e,t,e=>AV(r(e),mV(e)))),mK=dual(2,(e,t)=>dK(e,causeIsFail,e=>t(e.error))),gK=dual(2,(e,t)=>dK(e,causeIsDie,e=>t(e.defect))),yK=dual(3,(e,t,r)=>lK(e,e=>causeIsFail(e)&&t(e.error),e=>r(e.error))),bK=dual(3,(e,t,r)=>yK(e,M(t),r)),SK=dual(2,(e,t)=>uK(e,e=>mV(t(e)))),vK=dual(2,(e,t)=>pK(e,e=>fail$o(t(e)))),_K=dual(2,(e,t)=>pK(e,e=>gV(t))),wK=dual(e=>isMicro(e[0]),(e,t)=>XV(e,{...t,while:e=>"Failure"===e._tag&&"Fail"===e.cause._tag&&(void 0===t?.while||t.while(e.cause.error))})),kK=dual(2,(e,t)=>{const r=Object.create(xK);return r[oV]=e,r[uV]=t.onSuccess,r[cV]=t.onFailure,r}),xK=makePrimitiveProto({op:"OnSuccessAndFailure",eval(e){return e._stack.push(this),this[oV]}}),IK=dual(2,(e,t)=>kK(e,{onFailure:e=>gV(()=>t.onFailure(e)),onSuccess:e=>gV(()=>t.onSuccess(e))})),TK=dual(2,(e,t)=>kK(e,{onFailure:e=>"Fail"===e._tag?t.onFailure(e.error):mV(e),onSuccess:t.onSuccess})),OK=dual(2,(e,t)=>TK(e,{onFailure:e=>gV(()=>t.onFailure(e)),onSuccess:e=>gV(()=>t.onSuccess(e))})),sleep$2=e=>async$1(t=>{const r=setTimeout(()=>{t(_V)},e);return gV(()=>{clearTimeout(r)})}),EK=dual(2,(e,t)=>AV(sleep$2(t),e)),AK=dual(2,(e,t)=>FV(e,AV(interruptible$2(sleep$2(t.duration)),t.onTimeout))),CK=dual(2,(e,t)=>AK(e,{duration:t,onTimeout:()=>fail$o(new XK)})),MK=dual(2,(e,t)=>FV(asSome$3(e),EV(interruptible$2(sleep$2(t)),none$c()))),FK=Symbol.for("effect/Micro/MicroScope"),PK=GenericTag("effect/Micro/MicroScope");class MicroScopeImpl{[FK];state={_tag:"Open",finalizers:new Set};constructor(){this[FK]=FK}unsafeAddFinalizer(e){"Open"===this.state._tag&&this.state.finalizers.add(e)}addFinalizer(e){return yV(()=>"Open"===this.state._tag?(this.state.finalizers.add(e),_V):e(this.state.exit))}unsafeRemoveFinalizer(e){"Open"===this.state._tag&&this.state.finalizers.delete(e)}close(e){return yV(()=>{if("Open"===this.state._tag){const t=Array.from(this.state.finalizers).reverse();return this.state={_tag:"Closed",exit:e},PV(forEach$h(t,t=>exit$1(t(e))),exitVoidAll)}return _V})}get fork(){return gV(()=>{const e=new MicroScopeImpl;if("Closed"===this.state._tag)return e.state=this.state,e;function fin(t){return e.close(t)}return this.state.finalizers.add(fin),e.unsafeAddFinalizer(e=>gV(()=>this.unsafeRemoveFinalizer(fin))),e})}}const NK=gV(()=>new MicroScopeImpl),jK=service$2(PK),RK=dual(2,(e,t)=>VV(e,PK,t)),DK=dual(2,(e,t)=>uninterruptibleMask$1(r=>kK(r(e),{onFailure:e=>PV(t(DV(e)),()=>mV(e)),onSuccess:e=>PV(t(RV(e)),()=>dV(e))}))),LK=dual(2,(e,t)=>DK(e,e=>t)),UK=dual(3,(e,t,r)=>DK(e,e=>t(e)?r(e):UV)),$K=dual(2,(e,t)=>UK(e,exitIsFailure,e=>t(e.cause))),BK=dual(2,(e,t)=>UK(e,exitIsInterrupt,e=>t)),zK=mV(causeInterrupt()),uninterruptible$1=e=>wV(t=>t.interruptible?(t.interruptible=!1,t._stack.push(qK(!0)),e):e),qK=makePrimitive({op:"SetInterruptible",ensure(e){if(e.interruptible=this[oV],e._interrupted&&e.interruptible)return()=>LV}}),interruptible$2=e=>wV(t=>t.interruptible?e:(t.interruptible=!0,t._stack.push(qK(!1)),t._interrupted?LV:e)),uninterruptibleMask$1=e=>wV(t=>t.interruptible?(t.interruptible=!1,t._stack.push(qK(!0)),e(interruptible$2)):e(identity$5)),all$7=(e,t)=>Array.isArray(e)||isIterable(e)?forEach$h(e,identity$5,t):t?.discard?forEach$h(Object.values(e),identity$5,t):yV(()=>{const r={};return EV(forEach$h(Object.entries(e),([e,t])=>jV(t,t=>{r[e]=t}),{discard:!0,concurrency:t?.concurrency}),r)}),WK=makePrimitive({op:"While",contA(e,t){return this[oV].step(e),this[oV].while()?(t._stack.push(this),this[oV].body()):UV},eval(e){return this[oV].while()?(e._stack.push(this),this[oV].body()):UV}}),forEach$h=(e,t,r)=>wV(n=>{const i="inherit"===r?.concurrency?n.getRef(CurrentConcurrency):r?.concurrency??1,s="unbounded"===i?1/0:Math.max(1,i),o=fromIterable$v(e);let a=o.length;if(0===a)return r?.discard?_V:dV([]);const u=r?.discard?void 0:Array(a);let c=0;return 1===s?EV(WK({while:()=>c<o.length,body:()=>t(o[c],c),step:u?e=>u[c++]=e:e=>c++}),u):async$1(e=>{const r=new Set;let i,l=0,p=0,d=!1,m=!1;return function pump(){for(d=!0;l<s&&c<a;){const g=c,y=o[g];c++,l++;try{const o=unsafeFork$2(n,t(y,g),!0,!0);r.add(o),o.addObserver(t=>{r.delete(o),m||("Failure"===t._tag?void 0===i&&(i=t,a=c,r.forEach(e=>e.unsafeInterrupt())):void 0!==u&&(u[g]=t.value),p++,l--,p===a?e(i??dV(u)):!d&&l<s&&pump())})}catch(e){i=exitDie(e),a=c,r.forEach(e=>e.unsafeInterrupt())}}d=!1}(),yV(()=>(m=!0,c=a,fiberInterruptAll(r)))})}),filterMap$5=(e,t,r)=>yV(()=>{const n=[];return EV(forEach$h(e,e=>jV(t(e),e=>{"Some"===e._tag&&n.push(e.value)}),{discard:!0,concurrency:r?.concurrency}),n)}),VK=dV({}),KK=bindTo$a(jV),GK=bind$a(jV,PV),JK=let_$a(jV),unsafeFork$2=(e,t,r=!1,n=!1)=>{const i=new MicroFiberImpl(e.context,e.interruptible);return n||(e.children().add(i),i.addObserver(()=>e.children().delete(i))),r?i.evaluate(t):e.getRef(CurrentScheduler).scheduleTask(()=>i.evaluate(t),0),i},forkDaemon$2=e=>wV(t=>dV(unsafeFork$2(t,e,!1,!0))),HK=dual(2,(e,t)=>uninterruptibleMask$1(r=>PV(t.fork,t=>CV(r(forkDaemon$2(DK(e,e=>t.close(e)))),e=>t.addFinalizer(t=>fiberInterrupt(e)))))),runFork$2=(e,t)=>{const r=new MicroFiberImpl(CurrentScheduler.context(t?.scheduler??new MicroSchedulerDefault));if(r.evaluate(e),t?.signal)if(t.signal.aborted)r.unsafeInterrupt();else{const abort=()=>r.unsafeInterrupt();t.signal.addEventListener("abort",abort,{once:!0}),r.addObserver(()=>t.signal.removeEventListener("abort",abort))}return r},runPromiseExit$2=(e,t)=>new Promise((r,n)=>{runFork$2(e,t).addObserver(r)}),runSyncExit$2=e=>{const t=new MicroSchedulerDefault,r=runFork$2(e,{scheduler:t});return t.flush(),r._exit??exitDie(r)},ZK=function(){class YieldableError extends globalThis.Error{}return Object.assign(YieldableError.prototype,hV,Ce,{[sV]:"Failure",[aV](){return fail$o(this)},toString(){return this.message?`${this.name}: ${this.message}`:this.name},toJSON(){return{...this}},[ee](){const e=this.stack;return e?`${this.toString()}\n${e.split("\n").slice(1).join("\n")}`:this.toString()}}),YieldableError}(),QK=function(){return class extends ZK{constructor(e){super(),e&&Object.assign(this,e)}}}(),TaggedError$2=e=>{class Base extends QK{_tag=e}return Base.prototype.name=e,Base};let YK=class extends(TaggedError$2("NoSuchElementException")){},XK=class extends(TaggedError$2("TimeoutException")){};var eG=Object.freeze({__proto__:null,CurrentConcurrency,CurrentScheduler,Do:VK,Error:QK,MaxOpsBeforeYield,MicroCauseTypeId:XW,MicroExitTypeId:YW,MicroFiberTypeId:rV,MicroSchedulerDefault,MicroScope:PK,MicroScopeTypeId:FK,NoSuchElementException:YK,TaggedError:TaggedError$2,TimeoutException:XK,TypeId:QW,acquireRelease:(e,t)=>uninterruptible$1(PV(jK,r=>CV(e,e=>r.addFinalizer(r=>t(e,r))))),acquireUseRelease:(e,t,r)=>uninterruptibleMask$1(n=>PV(e,e=>PV(exit$1(n(t(e))),t=>AV(r(e,t),t)))),addFinalizer:e=>PV(jK,t=>t.addFinalizer(e)),all:all$7,andThen:AV,as:EV,asSome:asSome$3,asVoid:asVoid$7,async:async$1,bind:GK,bindTo:KK,catchAll:pK,catchAllCause:uK,catchAllDefect:fK,catchCauseIf:lK,catchIf:yK,catchTag:bK,causeDie,causeFail,causeInterrupt,causeIsDie,causeIsFail,causeIsInterrupt,causeSquash:e=>"Fail"===e._tag?e.error:"Die"===e._tag?e.defect:e,causeWithTrace:tV,context:()=>qV,delay:EK,die:die$d,either:e=>OK(e,{onFailure:He,onSuccess:Ge}),ensuring:LK,exit:exit$1,exitDie,exitFail:e=>DV(causeFail(e)),exitFailCause:DV,exitInterrupt:LV,exitIsDie:e=>exitIsFailure(e)&&"Die"===e.cause._tag,exitIsFail:e=>exitIsFailure(e)&&"Fail"===e.cause._tag,exitIsFailure,exitIsInterrupt,exitIsSuccess:e=>"Success"===e._tag,exitSucceed:RV,exitVoid:UV,exitVoidAll,fail:fail$o,failCause:mV,failCauseSync:e=>yV(()=>mV(e())),failSync:e=>yV(()=>fail$o(e())),fiberAwait,fiberInterrupt,fiberInterruptAll,fiberJoin:e=>flatten$a(fiberAwait(e)),filter:(e,t,r)=>filterMap$5(e,e=>jV(t(e),t=>(t=r?.negate?!t:t)?Ut(e):none$c()),r),filterMap:filterMap$5,filterOrFail:QV,filterOrFailCause:ZV,flatMap:PV,flatten:flatten$a,flip:e=>TK(e,{onFailure:dV,onSuccess:fail$o}),forEach:forEach$h,forever:e=>eK(e),fork:e=>wV(t=>(iV.interruptChildren??=fiberInterruptChildren,dV(unsafeFork$2(t,e)))),forkDaemon:forkDaemon$2,forkIn:HK,forkScoped:e=>PV(jK,t=>HK(e,t)),fromEither:e=>"Right"===e._tag?dV(e.right):fail$o(e.left),fromOption:e=>"Some"===e._tag?dV(e.value):fail$o(new YK({})),gen:(...e)=>yV(()=>OV(1===e.length?e[0]():e[1].call(e[0]))),ignore:e=>TK(e,{onFailure:e=>_V,onSuccess:e=>_V}),ignoreLogged:e=>TK(e,{onFailure:e=>gV(()=>console.error(e)),onSuccess:e=>_V}),interrupt:zK,interruptible:interruptible$2,isMicro,isMicroCause:e=>C(e,XW),isMicroExit,let:JK,map:jV,mapError:vK,mapErrorCause:SK,match:OK,matchCause:IK,matchCauseEffect:kK,matchEffect:TK,never:TV,onError:$K,onExit:DK,onExitIf:UK,onInterrupt:BK,option:e=>OK(e,{onFailure:none$c,onSuccess:Ut}),orDie:e=>pK(e,die$d),orElseSucceed:_K,promise:e=>xV(function(t,r){e(r).then(e=>t(dV(e)),e=>t(die$d(e)))},0!==e.length),provideContext:WV,provideScope:RK,provideService:VV,provideServiceEffect:KV,race:MV,raceAll:raceAll$4,raceAllFirst,raceFirst:FV,repeat:eK,repeatExit:XV,replicate:tK,replicateEffect:rK,retry:wK,runFork:runFork$2,runPromise:(e,t)=>runPromiseExit$2(e,t).then(e=>{if("Failure"===e._tag)throw e.cause;return e.value}),runPromiseExit:runPromiseExit$2,runSync:e=>{const t=runSyncExit$2(e);if("Failure"===t._tag)throw t.cause;return t.value},runSyncExit:runSyncExit$2,sandbox:e=>uK(e,fail$o),scheduleAddDelay:nK,scheduleExponential:(e,t=2)=>r=>Ut(Math.pow(t,r)*e),scheduleIntersect:aK,scheduleRecurs:e=>t=>t<=e?Ut(0):none$c(),scheduleSpaced:e=>()=>Ut(e),scheduleUnion:oK,scheduleWithMaxDelay:iK,scheduleWithMaxElapsed:sK,scope:jK,scopeMake:NK,scopeUnsafeMake:()=>new MicroScopeImpl,scoped:e=>yV(()=>{const t=new MicroScopeImpl;return DK(VV(e,PK,t),e=>t.close(e))}),service:service$2,serviceOption:e=>wV(t=>dV(DA(t.context,e))),sleep:sleep$2,succeed:dV,succeedNone:vV,succeedSome:e=>dV(Ut(e)),suspend:yV,sync:gV,tap:CV,tapDefect:gK,tapError:mK,tapErrorCause:hK,tapErrorCauseIf:dK,timeout:CK,timeoutOption:MK,timeoutOrElse:AK,try:e=>yV(()=>{try{return dV(e.try())}catch(t){return fail$o(e.catch(t))}}),tryPromise:e=>xV(function(t,r){try{e.try(r).then(e=>t(dV(e)),r=>t(fail$o(e.catch(r))))}catch(r){t(fail$o(e.catch(r)))}},0!==e.try.length),uninterruptible:uninterruptible$1,uninterruptibleMask:uninterruptibleMask$1,updateContext:BV,updateService:zV,void:_V,when:YV,whileLoop:WK,withConcurrency:GV,withMicroFiber:wV,withTrace:function(){const e=globalThis.Error.stackTraceLimit;globalThis.Error.stackTraceLimit=2;const t=new globalThis.Error;globalThis.Error.stackTraceLimit=e;const f=name=>e=>$K(e,e=>mV(function(name,e){const r=t.stack;if(!r)return e;const n=r.split("\n")[2]?.trim().replace(/^at /,"");if(!n)return e;const i=n.match(/\((.*)\)$/);return tV(e,`at ${name} (${i?i[1]:n})`)}(name,e)));return 2===arguments.length?f(arguments[1])(arguments[0]):f(arguments[0])},yieldFlush:kV,yieldNow:SV,yieldNowWith:bV,zip:JV,zipWith:HV});class PriorityBuckets{buckets=[];scheduleTask(e,t){const r=this.buckets.length;let n,i=0;for(;i<r&&this.buckets[i][0]<=t;i++)n=this.buckets[i];n&&n[0]===t?n[1].push(e):i===r?this.buckets.push([t,[e]]):this.buckets.splice(i,0,[t,[e]])}}class MixedScheduler{maxNextTickBeforeTimer;running=!1;tasks=new PriorityBuckets;constructor(e){this.maxNextTickBeforeTimer=e}starveInternal(e){const t=this.tasks.buckets;this.tasks.buckets=[];for(const[e,r]of t)for(let e=0;e<r.length;e++)r[e]();0===this.tasks.buckets.length?this.running=!1:this.starve(e)}starve(e=0){e>=this.maxNextTickBeforeTimer?setTimeout(()=>this.starveInternal(0),0):Promise.resolve(void 0).then(()=>this.starveInternal(e+1))}shouldYield(e){return e.currentOpCount>e.getFiberRef(zD)&&e.getFiberRef(BD)}scheduleTask(e,t){this.tasks.scheduleTask(e,t),this.running||(this.running=!0,this.starve())}}const tG=globalValue(Symbol.for("effect/Scheduler/defaultScheduler"),()=>new MixedScheduler(2048));class SyncScheduler{tasks=new PriorityBuckets;deferred=!1;scheduleTask(e,t){this.deferred?tG.scheduleTask(e,t):this.tasks.scheduleTask(e,t)}shouldYield(e){return e.currentOpCount>e.getFiberRef(zD)&&e.getFiberRef(BD)}flush(){for(;this.tasks.buckets.length>0;){const e=this.tasks.buckets;this.tasks.buckets=[];for(const[t,r]of e)for(let e=0;e<r.length;e++)r[e]()}this.deferred=!0}}const defaultShouldYield=e=>e.currentOpCount>e.getFiberRef(zD)&&e.getFiberRef(BD),make$1K=(e,t=defaultShouldYield)=>({scheduleTask:e,shouldYield:t}),makeBatched$2=(e,t=defaultShouldYield)=>{let r=!1;const n=new PriorityBuckets,starveInternal=()=>{const e=n.buckets;n.buckets=[];for(const[t,r]of e)for(let e=0;e<r.length;e++)r[e]();0===n.buckets.length?r=!1:starve()},starve=()=>e(starveInternal);return make$1K((e,t)=>{n.scheduleTask(e,t),r||(r=!0,starve())},t)},rG=globalValue(Symbol.for("effect/FiberRef/currentScheduler"),()=>fiberRefUnsafeMake(tG)),nG=dual(2,(e,t)=>LD(e,rG,t));var iG=Object.freeze({__proto__:null,ControlledScheduler:class{tasks=new PriorityBuckets;deferred=!1;scheduleTask(e,t){this.deferred?tG.scheduleTask(e,t):this.tasks.scheduleTask(e,t)}shouldYield(e){return e.currentOpCount>e.getFiberRef(zD)&&e.getFiberRef(BD)}step(){const e=this.tasks.buckets;this.tasks.buckets=[];for(const[t,r]of e)for(let e=0;e<r.length;e++)r[e]()}},MixedScheduler,PriorityBuckets,SyncScheduler,currentScheduler:rG,defaultScheduler:tG,defaultShouldYield,make:make$1K,makeBatched:makeBatched$2,makeMatrix:(...e)=>{const t=e.sort(([e],[t])=>e<t?-1:e>t?1:0);return{shouldYield(t){for(const r of e){const e=r[1].shouldYield(t);if(!1!==e)return e}return!1},scheduleTask(e,r){let n;for(const i of t){if(!(r>=i[0]))return(n??tG).scheduleTask(e,r);n=i[1]}return(n??tG).scheduleTask(e,r)}}},timer:(e,t=defaultShouldYield)=>make$1K(t=>setTimeout(t,e),t),timerBatched:(e,t=defaultShouldYield)=>makeBatched$2(t=>setTimeout(t,e),t),withScheduler:nG});const sG=globalValue(Symbol.for("effect/FiberRef/currentRequestMap"),()=>fiberRefUnsafeMake(new Map)),match$u=(e,t,r,n)=>{switch(e){case void 0:return t();case"unbounded":return r();case"inherit":return ED(JD,e=>"unbounded"===e?r():e>1?n(e):t());default:return e>1?n(e):t()}},matchSimple=(e,t,r)=>{switch(e){case void 0:return t();case"unbounded":return r();case"inherit":return ED(JD,e=>"unbounded"===e||e>1?r():t());default:return e>1?r():t()}},oG="InterruptSignal",aG="Stateful",uG="Resume",cG="YieldNow",interruptSignal=e=>({_tag:oG,cause:e}),stateful=e=>({_tag:aG,onFiber:e}),resume=e=>({_tag:uG,effect:e}),yieldNow$1=()=>({_tag:cG}),lG=Symbol.for("effect/FiberScope");class Global{[lG]=lG;fiberId=aP;roots=new Set;add(e,t){this.roots.add(t),t.addObserver(()=>{this.roots.delete(t)})}}class Local{fiberId;parent;[lG]=lG;constructor(e,t){this.fiberId=e,this.parent=t}add(e,t){this.parent.tell(stateful(e=>{e.addChild(t),t.addObserver(()=>{e.removeChild(t)})}))}}const pG=globalValue(Symbol.for("effect/FiberScope/Global"),()=>new Global),fG=Symbol.for("effect/Fiber"),hG={_E:e=>e,_A:e=>e},dG={[fG]:hG,pipe(){return pipeArguments(this,arguments)}},mG=Symbol.for("effect/Fiber"),gG=pipe(tuple$4(qI,qI),Pt(e=>[e.id().startTimeMillis,e.id().id])),isRuntimeFiber$1=e=>mG in e,_await$3=e=>e.await,done$b=e=>({...Me,commit(){return join$4(this)},...dG,id:()=>aP,await:succeed$u(e),children:succeed$u([]),inheritAll:tD,poll:succeed$u(Ut(e)),interruptAsFork:()=>tD}),dump$1=e=>qR(e.status,t=>({id:e.id(),status:t})),failCause$f=e=>done$b(OU(e)),inheritAll$1=e=>e.inheritAll,yG=dual(2,fnUntraced$1(function*(e,t){for(const r of e)isRuntimeFiber$1(r)?r.unsafeInterruptAsFork(t):yield*r.interruptAsFork(t);for(const t of e)isRuntimeFiber$1(t)&&t.unsafePoll()||(yield*t.await)})),bG=dual(2,(e,t)=>e.interruptAsFork(t)),join$4=e=>cD(flatten$c(e.await),e.inheritAll),SG=dual(2,(e,t)=>vG(e,e=>sync$l(()=>t(e)))),vG=dual(2,(e,t)=>({...Me,commit(){return join$4(this)},...dG,id:()=>e.id(),await:PR(e.await,EU(t)),children:e.children,inheritAll:e.inheritAll,poll:PR(e.poll,e=>{switch(e._tag){case"None":return succeed$u(none$c());case"Some":return pipe(EU(e.value,t),qR(Ut))}}),interruptAsFork:t=>e.interruptAsFork(t)})),_G=dual(2,(e,t)=>qR(e.await,FU({onFailure:e=>failCause$f(e),onSuccess:e=>t(e)}))),wG=dual(2,(e,{onFiber:t,onRuntimeFiber:r})=>isRuntimeFiber$1(e)?r(e):t(e)),kG={...Me,commit(){return join$4(this)},...dG,id:()=>aP,await:fD,children:succeed$u([]),inheritAll:fD,poll:succeed$u(none$c()),interruptAsFork:()=>fD},xG=dual(2,(e,t)=>({...Me,commit(){return join$4(this)},...dG,id:()=>lP(e.id(),t.id()),await:pD(e.await,t.await,(e,t)=>kU(e)?e:t),children:e.children,inheritAll:lD(t.inheritAll,e.inheritAll),poll:pD(e.poll,t.poll,(e,t)=>{switch(e._tag){case"None":return none$c();case"Some":return kU(e.value)?e:t}}),interruptAsFork:r=>pipe(hD(e,r),lD(pipe(t,hD(r))),asVoid$9)})),IG=dual(2,(e,t)=>xG(SG(e,He),SG(t,Ge))),unsafeRoots$1=()=>Array.from(pG.roots),TG=sync$l(unsafeRoots$1),succeed$q=e=>done$b(NU(e)),OG=succeed$q(void 0),EG="effect/FiberCurrent",AG=Symbol.for("effect/Logger"),CG={_Message:e=>e,_Output:e=>e},makeLogger=e=>({[AG]:CG,log:e,pipe(){return pipeArguments(this,arguments)}}),MG=dual(2,(e,t)=>makeLogger(r=>e.log({...r,message:t(r.message)}))),FG=dual(2,(e,t)=>makeLogger(r=>e.log(t(r)))),PG=dual(2,(e,t)=>makeLogger(r=>t(r.logLevel)?Ut(e.log(r)):none$c())),NG=dual(2,(e,t)=>makeLogger(r=>t(e.log(r)))),jG={[AG]:CG,log:o,pipe(){return pipeArguments(this,arguments)}},simple$1=e=>({[AG]:CG,log:({message:t})=>e(t),pipe(){return pipeArguments(this,arguments)}}),RG=dual(2,(e,t)=>makeLogger(r=>[e.log(r),t.log(r)])),DG=dual(2,(e,t)=>NG(RG(e,t),e=>e[0])),LG=dual(2,(e,t)=>NG(RG(e,t),e=>e[1])),UG=/^[^\s"=]*$/,format$3=(e,t)=>({annotations:r,cause:n,date:i,fiberId:s,logLevel:o,message:a,spans:u})=>{const format=(t,r)=>`${formatLabel(t)}=${(t=>t.match(UG)?t:e(t))(r)}`,append=(e,t)=>" "+format(e,t);let c=format("timestamp",i.toISOString());c+=append("level",o.label),c+=append("fiber",threadName$1(s));const l=ensure(a);for(let e=0;e<l.length;e++)c+=append("message",toStringUnknown(l[e],t));isEmptyType$1(n)||(c+=append("cause",pretty$4(n,{renderErrorCause:!0})));for(const e of u)c+=" "+render$2(i.getTime())(e);for(const[e,n]of r)c+=append(e,toStringUnknown(n,t));return c},$G=makeLogger(format$3(e=>`"${e.replace(/\\([\s\S])|(")/g,"\\$1$2")}"`)),BG=makeLogger(format$3(JSON.stringify,0)),zG=makeLogger(({annotations:e,cause:t,date:r,fiberId:n,logLevel:i,message:s,spans:o})=>{const a=r.getTime(),u={},c={};if(wP(e)>0)for(const[t,r]of e)u[t]=structuredMessage(r);if(isCons(o))for(const e of o)c[e.label]=a-e.startTime;const l=ensure(s);return{message:1===l.length?structuredMessage(l[0]):l.map(structuredMessage),logLevel:i.label,timestamp:r.toISOString(),cause:isEmpty$o(t)?void 0:pretty$4(t,{renderErrorCause:!0}),annotations:u,spans:c,fiberId:threadName$1(n)}}),structuredMessage=e=>{switch(typeof e){case"bigint":case"function":case"symbol":return e+"";default:return toJSON(e)}},qG=NG(zG,stringifyCircular),withColor=(e,...t)=>{let r="";for(let e=0;e<t.length;e++)r+=`\x1b[${t[e]}m`;return r+e+"\x1b[0m"},withColorNoop=(e,...t)=>e,WG={None:[],All:[],Trace:["90"],Debug:["34"],Info:["32"],Warning:["33"],Error:["31"],Fatal:["101","30"]},VG={None:"",All:"",Trace:"color:gray",Debug:"color:blue",Info:"color:green",Warning:"color:orange",Error:"color:red",Fatal:"background-color:red;color:white"},defaultDateFormat=e=>`${e.getHours().toString().padStart(2,"0")}:${e.getMinutes().toString().padStart(2,"0")}:${e.getSeconds().toString().padStart(2,"0")}.${e.getMilliseconds().toString().padStart(3,"0")}`,KG="object"==typeof process&&null!==process&&"object"==typeof process.stdout&&null!==process.stdout,GG=KG&&!0===process.stdout.isTTY,JG=KG||"Deno"in globalThis,prettyLogger$2=e=>{const t=e?.mode??"auto",r="browser"===("auto"===t?JG?"tty":"browser":t),n="boolean"==typeof e?.colors?e.colors:GG||r,i=e?.formatDate??defaultDateFormat;return r?prettyLoggerBrowser({colors:n,formatDate:i}):prettyLoggerTty({colors:n,formatDate:i,stderr:!0===e?.stderr})},prettyLoggerTty=e=>{const t=e.colors?withColor:withColorNoop;return makeLogger(({annotations:r,cause:n,context:i,date:s,fiberId:o,logLevel:a,message:u,spans:c})=>{const l=RB(i,pB),p=jA(l,eB).unsafe,d=!0===e.stderr?p.error:p.log,m=ensure(u);let g=t(`[${e.formatDate(s)}]`,"37")+" "+t(a.label,...WG[a._tag])+` (${threadName$1(o)})`;if(isCons(c)){const e=s.getTime(),t=render$2(e);for(const e of c)g+=" "+t(e)}g+=":";let y=0;if(m.length>0){const e=structuredMessage(m[0]);"string"==typeof e&&(g+=" "+t(e,"1","36"),y++)}if(d(g),p.group(),isEmpty$o(n)||d(pretty$4(n,{renderErrorCause:!0})),y<m.length)for(;y<m.length;y++)d(redact(m[y]));if(wP(r)>0)for(const[e,n]of r)d(t(e+":","1","37"),redact(n));p.groupEnd()})},prettyLoggerBrowser=e=>{const t=e.colors?"%c":"";return makeLogger(({annotations:r,cause:n,context:i,date:s,fiberId:o,logLevel:a,message:u,spans:c})=>{const l=RB(i,pB),p=jA(l,eB).unsafe,d=ensure(u);let m=`${t}[${e.formatDate(s)}]`;const g=[];if(e.colors&&g.push("color:gray"),m+=` ${t}${a.label}${t} (${threadName$1(o)})`,e.colors&&g.push(VG[a._tag],""),isCons(c)){const e=s.getTime(),t=render$2(e);for(const e of c)m+=" "+t(e)}m+=":";let y=0;if(d.length>0){const r=structuredMessage(d[0]);"string"==typeof r&&(m+=` ${t}${r}`,e.colors&&g.push("color:deepskyblue"),y++)}if(p.groupCollapsed(m,...g),isEmpty$o(n)||p.error(pretty$4(n,{renderErrorCause:!0})),y<d.length)for(;y<d.length;y++)p.log(redact(d[y]));if(wP(r)>0)for(const[t,n]of r){const r=redact(n);e.colors?p.log(`%c${t}:`,"color:gray",r):p.log(t+":",r)}p.groupEnd()})},HG=globalValue("effect/Logger/prettyLoggerDefault",()=>prettyLogger$2()),ZG="effect/MetricBoundaries",QG=Symbol.for(ZG);class MetricBoundariesImpl{values;[QG]=QG;constructor(e){this.values=e,this._hash=pipe(string$6(ZG),combine$h(array$6(this.values)))}_hash;[Z](){return this._hash}[Y](e){return isMetricBoundaries$1(e)&&equals$4(this.values,e.values)}pipe(){return pipeArguments(this,arguments)}}const isMetricBoundaries$1=e=>C(e,QG),fromIterable$m=e=>{const t=pipe(e,ni(of$5(1/0)),dedupe$1);return new MetricBoundariesImpl(t)},exponential$3=e=>pipe(Gn(e.count-1,t=>e.start*Math.pow(e.factor,t)),unsafeFromArray,fromIterable$m),YG=Symbol.for("effect/MetricKeyType"),XG="effect/MetricKeyType/Counter",eJ=Symbol.for(XG),tJ="effect/MetricKeyType/Frequency",rJ=Symbol.for(tJ),nJ="effect/MetricKeyType/Gauge",iJ=Symbol.for(nJ),sJ="effect/MetricKeyType/Histogram",oJ=Symbol.for(sJ),aJ="effect/MetricKeyType/Summary",uJ=Symbol.for(aJ),cJ={_In:e=>e,_Out:e=>e};class CounterKeyType{incremental;bigint;[YG]=cJ;[eJ]=eJ;constructor(e,t){this.incremental=e,this.bigint=t,this._hash=string$6(XG)}_hash;[Z](){return this._hash}[Y](e){return isCounterKey$1(e)}pipe(){return pipeArguments(this,arguments)}}const lJ=string$6(tJ);class FrequencyKeyType{preregisteredWords;[YG]=cJ;[rJ]=rJ;constructor(e){this.preregisteredWords=e}[Z](){return lJ}[Y](e){return isFrequencyKey$1(e)}pipe(){return pipeArguments(this,arguments)}}const pJ=string$6(nJ);class GaugeKeyType{bigint;[YG]=cJ;[iJ]=iJ;constructor(e){this.bigint=e}[Z](){return pJ}[Y](e){return isGaugeKey$1(e)}pipe(){return pipeArguments(this,arguments)}}class HistogramKeyType{boundaries;[YG]=cJ;[oJ]=oJ;constructor(e){this.boundaries=e,this._hash=pipe(string$6(sJ),combine$h(hash$3(this.boundaries)))}_hash;[Z](){return this._hash}[Y](e){return isHistogramKey$1(e)&&equals$4(this.boundaries,e.boundaries)}pipe(){return pipeArguments(this,arguments)}}class SummaryKeyType{maxAge;maxSize;error;quantiles;[YG]=cJ;[uJ]=uJ;constructor(e,t,r,n){this.maxAge=e,this.maxSize=t,this.error=r,this.quantiles=n,this._hash=pipe(string$6(aJ),combine$h(hash$3(this.maxAge)),combine$h(hash$3(this.maxSize)),combine$h(hash$3(this.error)),combine$h(array$6(this.quantiles)))}_hash;[Z](){return this._hash}[Y](e){return isSummaryKey$1(e)&&equals$4(this.maxAge,e.maxAge)&&this.maxSize===e.maxSize&&this.error===e.error&&equals$4(this.quantiles,e.quantiles)}pipe(){return pipeArguments(this,arguments)}}const counter$9=e=>new CounterKeyType(e?.incremental??!1,e?.bigint??!1),frequency$9=e=>new FrequencyKeyType(e?.preregisteredWords??[]),gauge$9=e=>new GaugeKeyType(e?.bigint??!1),histogram$9=e=>new HistogramKeyType(e),summary$9=e=>new SummaryKeyType(decode$5(e.maxAge),e.maxSize,e.error,e.quantiles),isCounterKey$1=e=>C(e,eJ),isFrequencyKey$1=e=>C(e,rJ),isGaugeKey$1=e=>C(e,iJ),isHistogramKey$1=e=>C(e,oJ),isSummaryKey$1=e=>C(e,uJ),fJ=Symbol.for("effect/MetricKey"),hJ={_Type:e=>e},dJ=Ts(equals$4);class MetricKeyImpl{name;keyType;description;tags;[fJ]=hJ;constructor(name,e,description,t=[]){this.name=name,this.keyType=e,this.description=description,this.tags=t,this._hash=pipe(string$6(this.name+this.description),combine$h(hash$3(this.keyType)),combine$h(array$6(this.tags)))}_hash;[Z](){return this._hash}[Y](e){return isMetricKey$1(e)&&this.name===e.name&&equals$4(this.keyType,e.keyType)&&equals$4(this.description,e.description)&&dJ(this.tags,e.tags)}pipe(){return pipeArguments(this,arguments)}}const isMetricKey$1=e=>C(e,fJ),counter$8=(name,e)=>new MetricKeyImpl(name,counter$9(e),fromNullable$3(e?.description)),frequency$8=(name,e)=>new MetricKeyImpl(name,frequency$9(e),fromNullable$3(e?.description)),gauge$8=(name,e)=>new MetricKeyImpl(name,gauge$9(e),fromNullable$3(e?.description)),histogram$8=(name,e,description)=>new MetricKeyImpl(name,histogram$9(e),fromNullable$3(description)),summary$8=e=>new MetricKeyImpl(e.name,summary$9(e),fromNullable$3(e.description)),mJ=dual(3,(e,t,r)=>gJ(e,[make$1L(t,r)])),gJ=dual(2,(e,t)=>0===t.length?e:new MetricKeyImpl(e.name,e.keyType,e.description,is(e.tags,t))),yJ=Symbol.for("effect/MetricState"),bJ="effect/MetricState/Counter",SJ=Symbol.for(bJ),vJ="effect/MetricState/Frequency",_J=Symbol.for(vJ),wJ="effect/MetricState/Gauge",kJ=Symbol.for(wJ),xJ="effect/MetricState/Histogram",IJ=Symbol.for(xJ),TJ="effect/MetricState/Summary",OJ=Symbol.for(TJ),EJ={_A:e=>e};class CounterState{count;[yJ]=EJ;[SJ]=SJ;constructor(e){this.count=e}[Z](){return pipe(hash$3(bJ),combine$h(hash$3(this.count)),cached$2(this))}[Y](e){return isCounterState$1(e)&&this.count===e.count}pipe(){return pipeArguments(this,arguments)}}const AJ=Ts(equals$4);class FrequencyState{occurrences;[yJ]=EJ;[_J]=_J;constructor(e){this.occurrences=e}_hash;[Z](){return pipe(string$6(vJ),combine$h(array$6(fromIterable$v(this.occurrences.entries()))),cached$2(this))}[Y](e){return isFrequencyState$1(e)&&AJ(fromIterable$v(this.occurrences.entries()),fromIterable$v(e.occurrences.entries()))}pipe(){return pipeArguments(this,arguments)}}class GaugeState{value;[yJ]=EJ;[kJ]=kJ;constructor(e){this.value=e}[Z](){return pipe(hash$3(wJ),combine$h(hash$3(this.value)),cached$2(this))}[Y](e){return isGaugeState$1(e)&&this.value===e.value}pipe(){return pipeArguments(this,arguments)}}class HistogramState{buckets;count;min;max;sum;[yJ]=EJ;[IJ]=IJ;constructor(e,t,r,n,i){this.buckets=e,this.count=t,this.min=r,this.max=n,this.sum=i}[Z](){return pipe(hash$3(xJ),combine$h(hash$3(this.buckets)),combine$h(hash$3(this.count)),combine$h(hash$3(this.min)),combine$h(hash$3(this.max)),combine$h(hash$3(this.sum)),cached$2(this))}[Y](e){return isHistogramState$1(e)&&equals$4(this.buckets,e.buckets)&&this.count===e.count&&this.min===e.min&&this.max===e.max&&this.sum===e.sum}pipe(){return pipeArguments(this,arguments)}}class SummaryState{error;quantiles;count;min;max;sum;[yJ]=EJ;[OJ]=OJ;constructor(e,t,r,n,i,s){this.error=e,this.quantiles=t,this.count=r,this.min=n,this.max=i,this.sum=s}[Z](){return pipe(hash$3(TJ),combine$h(hash$3(this.error)),combine$h(hash$3(this.quantiles)),combine$h(hash$3(this.count)),combine$h(hash$3(this.min)),combine$h(hash$3(this.max)),combine$h(hash$3(this.sum)),cached$2(this))}[Y](e){return isSummaryState$1(e)&&this.error===e.error&&equals$4(this.quantiles,e.quantiles)&&this.count===e.count&&this.min===e.min&&this.max===e.max&&this.sum===e.sum}pipe(){return pipeArguments(this,arguments)}}const counter$7=e=>new CounterState(e),frequency$7=e=>new FrequencyState(e),gauge$7=e=>new GaugeState(e),histogram$7=e=>new HistogramState(e.buckets,e.count,e.min,e.max,e.sum),summary$7=e=>new SummaryState(e.error,e.quantiles,e.count,e.min,e.max,e.sum),isCounterState$1=e=>C(e,SJ),isFrequencyState$1=e=>C(e,_J),isGaugeState$1=e=>C(e,kJ),isHistogramState$1=e=>C(e,IJ),isSummaryState$1=e=>C(e,OJ),CJ=Symbol.for("effect/MetricHook"),MJ={_In:e=>e,_Out:e=>e},make$1J=e=>({[CJ]:MJ,pipe(){return pipeArguments(this,arguments)},...e}),FJ=dual(2,(e,t)=>({[CJ]:MJ,pipe(){return pipeArguments(this,arguments)},get:e.get,update:e.update,modify:r=>(e.modify(r),t(r))})),PJ=dual(2,(e,t)=>({[CJ]:MJ,pipe(){return pipeArguments(this,arguments)},get:e.get,update:r=>(e.update(r),t(r)),modify:e.modify})),NJ=BigInt(0),counter$6=e=>{let t=e.keyType.bigint?NJ:0;const r=e.keyType.incremental?e.keyType.bigint?e=>e>=NJ:e=>e>=0:e=>!0,update=e=>{r(e)&&(t+=e)};return make$1J({get:()=>counter$7(t),update,modify:update})},frequency$6=e=>{const t=new Map;for(const r of e.keyType.preregisteredWords)t.set(r,0);const update=e=>{const r=t.get(e)??0;t.set(e,r+1)};return make$1J({get:()=>frequency$7(t),update,modify:update})},gauge$6=(e,t)=>{let r=t;return make$1J({get:()=>gauge$7(r),update:e=>{r=e},modify:e=>{r+=e}})},histogram$6=e=>{const t=e.keyType.boundaries.values,r=t.length,n=new Uint32Array(r+1),i=new Float64Array(r);let s=0,o=0,a=Number.MAX_VALUE,u=5e-324;pipe(t,Ni(qI),as((e,t)=>{i[t]=e}));const update=e=>{let t=0,c=r;for(;t!==c;){const r=Math.floor(t+(c-t)/2);e<=i[r]?c=r:t=r,c===t+1&&(e<=i[t]?c=t:t=c)}n[t]=n[t]+1,s+=1,o+=e,e<a&&(a=e),e>u&&(u=e)},getBuckets=()=>{const e=allocate$1(r);let t=0;for(let s=0;s<r;s++){const r=i[s];t+=n[s],e[s]=[r,t]}return e};return make$1J({get:()=>histogram$7({buckets:getBuckets(),count:s,min:a,max:u,sum:o}),update,modify:update})},summary$6=e=>{const{error:t,maxAge:r,maxSize:n,quantiles:i}=e.keyType,s=pipe(i,Ni(qI)),o=allocate$1(n);let a=0,u=0,c=0,l=0,p=0;const snapshot=e=>{const i=[];let a=0;for(;a!==n-1;){const t=o[a];if(null!=t){const[n,s]=t,o=millis(e-n);xM(o,iM)&&wM(o,r)&&i.push(s)}a+=1}return calculateQuantiles(t,s,Ni(i,qI))},observe=(e,t)=>{n>0&&(a+=1,o[a%n]=[t,e]),l=0===u?e:Math.min(l,e),p=0===u?e:Math.max(p,e),u+=1,c+=e};return make$1J({get:()=>summary$7({error:t,quantiles:snapshot(Date.now()),count:u,min:l,max:p,sum:c}),update:([e,t])=>observe(e,t),modify:([e,t])=>observe(e,t)})},calculateQuantiles=(e,t,r)=>{const n=r.length;if(!ci(t))return[];const i=t[0],s=t.slice(1),o=resolveQuantile(e,n,none$c(),0,i,r),a=of$6(o);return s.forEach(t=>{a.push(resolveQuantile(e,n,o.value,o.consumed,t,o.rest))}),as(a,e=>[e.quantile,e.value])},resolveQuantile=(e,t,r,n,i,s)=>{let o=e,a=t,u=r,c=n,l=i,p=s,d=e,m=t,g=r,y=n,b=i,S=s;for(;;){if(!ci(p))return{quantile:l,value:none$c(),consumed:c,rest:[]};if(1===l)return{quantile:l,value:Ut(lastNonEmpty$1(p)),consumed:c+p.length,rest:[]};const e=hi(p),t=yi(p,t=>t===e),r=l*a,n=o/2*r,i=c+t[0].length,s=Math.abs(i-r);if(i<r-n)d=o,m=a,g=fi(p),y=i,b=l,S=t[1],o=d,a=m,u=g,c=y,l=b,p=S;else{if(i>r+n)return{quantile:l,value:Bt(u)?Ut(e):u,consumed:c,rest:p};switch(u._tag){case"None":d=o,m=a,g=fi(p),y=i,b=l,S=t[1],o=d,a=m,u=g,c=y,l=b,p=S;continue;case"Some":if(s<Math.abs(r-u.value)){d=o,m=a,g=fi(p),y=i,b=l,S=t[1],o=d,a=m,u=g,c=y,l=b,p=S;continue}return{quantile:l,value:Ut(u.value),consumed:c,rest:p}}}}throw Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues")},jJ=Symbol.for("effect/MetricPair"),RJ={_Type:e=>e},unsafeMake$a=(e,t)=>({[jJ]:RJ,metricKey:e,metricState:t,pipe(){return pipeArguments(this,arguments)}}),DJ=Symbol.for("effect/MetricRegistry");class MetricRegistryImpl{[DJ]=DJ;map=empty$B();snapshot(){const e=[];for(const[t,r]of this.map)e.push(unsafeMake$a(t,r.get()));return e}get(e){const t=pipe(this.map,zU(e),Qt);if(null==t){if(isCounterKey$1(e.keyType))return this.getCounter(e);if(isGaugeKey$1(e.keyType))return this.getGauge(e);if(isFrequencyKey$1(e.keyType))return this.getFrequency(e);if(isHistogramKey$1(e.keyType))return this.getHistogram(e);if(isSummaryKey$1(e.keyType))return this.getSummary(e);throw Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues")}return t}getCounter(e){let t=pipe(this.map,zU(e),Qt);if(null==t){const r=counter$6(e);pipe(this.map,qU(e))||pipe(this.map,WU(e,r)),t=r}return t}getFrequency(e){let t=pipe(this.map,zU(e),Qt);if(null==t){const r=frequency$6(e);pipe(this.map,qU(e))||pipe(this.map,WU(e,r)),t=r}return t}getGauge(e){let t=pipe(this.map,zU(e),Qt);if(null==t){const r=gauge$6(0,e.keyType.bigint?BigInt(0):0);pipe(this.map,qU(e))||pipe(this.map,WU(e,r)),t=r}return t}getHistogram(e){let t=pipe(this.map,zU(e),Qt);if(null==t){const r=histogram$6(e);pipe(this.map,qU(e))||pipe(this.map,WU(e,r)),t=r}return t}getSummary(e){let t=pipe(this.map,zU(e),Qt);if(null==t){const r=summary$6(e);pipe(this.map,qU(e))||pipe(this.map,WU(e,r)),t=r}return t}}const make$1H=()=>new MetricRegistryImpl,LJ=Symbol.for("effect/Metric"),UJ={_Type:e=>e,_In:e=>e,_Out:e=>e},$J=globalValue(Symbol.for("effect/Metric/globalMetricRegistry"),()=>make$1H()),make$1G=function(e,t,r,n){const i=Object.assign(e=>XR(e,e=>oH(i,e)),{[LJ]:UJ,keyType:e,unsafeUpdate:t,unsafeValue:r,unsafeModify:n,register(){return this.unsafeValue([]),this},pipe(){return pipeArguments(this,arguments)}});return i},BJ=dual(2,(e,t)=>make$1G(e.keyType,(r,n)=>e.unsafeUpdate(t(r),n),e.unsafeValue,(r,n)=>e.unsafeModify(t(r),n))),counter$5=(name,e)=>fromMetricKey$1(counter$8(name,e)),zJ=dual(2,(e,t)=>BJ(e,()=>t)),fromMetricKey$1=e=>{let t;const r=new WeakMap,hook=n=>{if(0===n.length)return void 0!==t||(t=$J.get(e)),t;let i=r.get(n);return void 0!==i||(i=$J.get(gJ(e,n)),r.set(n,i)),i};return make$1G(e.keyType,(e,t)=>hook(t).update(e),e=>hook(e).get(),(e,t)=>hook(t).modify(e))},histogram$5=(name,e,description)=>fromMetricKey$1(histogram$8(name,e,description)),qJ=dual(2,(e,t)=>isCounterKey$1(e.keyType)?oH(e,t):KJ(e,t)),WJ=dual(2,(e,t)=>make$1G(e.keyType,e.unsafeUpdate,r=>t(e.unsafeValue(r)),e.unsafeModify)),VJ=dual(2,(e,t)=>make$1G(t(e.keyType),e.unsafeUpdate,e.unsafeValue,e.unsafeModify)),KJ=dual(2,(e,t)=>ED(XD,r=>sync$l(()=>e.unsafeModify(t,r)))),GJ=dual(2,(e,t)=>oH(e,t)),summaryTimestamp$1=e=>fromMetricKey$1(summary$8(e)),JJ=dual(3,(e,t,r)=>ZJ(e,[make$1L(t,r)])),HJ=dual(2,(e,t)=>WJ(make$1G(e.keyType,(r,n)=>e.unsafeUpdate(r,is(t(r),n)),e.unsafeValue,(r,n)=>e.unsafeModify(r,is(t(r),n))),o)),ZJ=dual(2,(e,t)=>make$1G(e.keyType,(r,n)=>e.unsafeUpdate(r,is(t,n)),r=>e.unsafeValue(is(t,r)),(r,n)=>e.unsafeModify(r,is(t,n)))),QJ=dual(2,(e,t)=>r=>RR(r,{onFailure:r=>lD(oH(e,t),failCause$j(r)),onSuccess:r=>lD(oH(e,t),succeed$u(r))})),YJ=dual(2,(e,t)=>XJ(e,t,identity$5)),XJ=dual(3,(e,t,r)=>{const updater=e=>oH(t,r(e));return uW(e,e=>UR(defects$1(e),updater))}),eH=dual(2,(e,t)=>tH(e,t,identity$5)),tH=dual(3,(e,t,r)=>kB(n=>{const i=n.unsafeCurrentTimeNanos();return XR(e,e=>{const s=n.unsafeCurrentTimeNanos(),o=nanos(s-i);return oH(t,r(o))})})),rH=dual(2,(e,t)=>nH(e,t,e=>e)),nH=dual(3,(e,t,r)=>cW(e,e=>oH(t,r(e)))),iH=dual(2,(e,t)=>sH(e,t,e=>e)),sH=dual(3,(e,t,r)=>XR(e,e=>oH(t,r(e)))),oH=dual(2,(e,t)=>ED(XD,r=>sync$l(()=>e.unsafeUpdate(t,r)))),value$8=e=>ED(XD,t=>sync$l(()=>e.unsafeValue(t))),withNow$1=e=>BJ(e,e=>[e,Date.now()]),aH=dual(2,(e,t)=>make$1G([e.keyType,t.keyType],(r,n)=>{const[i,s]=r;e.unsafeUpdate(i,n),t.unsafeUpdate(s,n)},r=>[e.unsafeValue(r),t.unsafeValue(r)],(r,n)=>{const[i,s]=r;e.unsafeModify(i,n),t.unsafeModify(s,n)})),unsafeSnapshot$1=()=>$J.snapshot(),uH=sync$l(unsafeSnapshot$1),cH=Symbol.for("effect/Request"),lH={...Ce,[cH]:{_E:e=>e,_A:e=>e}},pH=function(){function Class(e){e&&Object.assign(this,e)}return Class.prototype=lH,Class}(),fH=dual(2,(e,t)=>ED(sG,r=>sync$l(()=>{if(r.has(e)){const n=r.get(e);n.state.completed||(n.state.completed=!0,deferredUnsafeDone(n.result,t))}}))),hH=dual(2,(e,t)=>DR(t,{onFailure:t=>fH(e,exitFail$1(t)),onSuccess:t=>fH(e,exitSucceed$1(t))})),dH=dual(2,(e,t)=>fH(e,exitFail$1(t))),mH=dual(2,(e,t)=>fH(e,exitFailCause$1(t))),gH=dual(2,(e,t)=>fH(e,exitSucceed$1(t)));class Listeners{count=0;observers=new Set;interrupted=!1;addObserver(e){this.observers.add(e)}removeObserver(e){this.observers.delete(e)}increment(){this.count++,this.observers.forEach(e=>e(this.count))}decrement(){this.count--,this.observers.forEach(e=>e(this.count))}}const yH={Forward:0,Backward:1};class RedBlackTreeIterator{self;stack;direction;count=0;constructor(e,t,r){this.self=e,this.stack=t,this.direction=r}clone(){return new RedBlackTreeIterator(this.self,this.stack.slice(),this.direction)}reversed(){return new RedBlackTreeIterator(this.self,this.stack.slice(),this.direction===yH.Forward?yH.Backward:yH.Forward)}next(){const e=this.entry;switch(this.count++,this.direction===yH.Forward?this.moveNext():this.movePrev(),e._tag){case"None":return{done:!0,value:this.count};case"Some":return{done:!1,value:e.value}}}get key(){return this.stack.length>0?Ut(this.stack[this.stack.length-1].key):none$c()}get value(){return this.stack.length>0?Ut(this.stack[this.stack.length-1].value):none$c()}get entry(){return er(last$6(this.stack),e=>[e.key,e.value])}get index(){let e=0;const t=this.stack;if(0===t.length){const e=this.self._root;return null!=e?e.count:0}null!=t[t.length-1].left&&(e=t[t.length-1].left.count);for(let r=t.length-2;r>=0;--r)t[r+1]===t[r].right&&(++e,null!=t[r].left&&(e+=t[r].left.count));return e}moveNext(){const e=this.stack;if(0===e.length)return;let t=e[e.length-1];if(null!=t.right)for(t=t.right;null!=t;)e.push(t),t=t.left;else for(e.pop();e.length>0&&e[e.length-1].right===t;)t=e[e.length-1],e.pop()}get hasNext(){const e=this.stack;if(0===e.length)return!1;if(null!=e[e.length-1].right)return!0;for(let t=e.length-1;t>0;--t)if(e[t-1].left===e[t])return!0;return!1}movePrev(){const e=this.stack;if(0===e.length)return;let t=e[e.length-1];if(null!=t&&null!=t.left)for(t=t.left;null!=t;)e.push(t),t=t.right;else for(e.pop();e.length>0&&e[e.length-1].left===t;)t=e[e.length-1],e.pop()}get hasPrev(){const e=this.stack;if(0===e.length)return!1;if(null!=e[e.length-1].left)return!0;for(let t=e.length-1;t>0;--t)if(e[t-1].right===e[t])return!0;return!1}}const clone=({color:e,count:t,key:r,left:n,right:i,value:s})=>({color:e,key:r,value:s,left:n,right:i,count:t});function swap(e,t){e.key=t.key,e.value=t.value,e.left=t.left,e.right=t.right,e.color=t.color,e.count=t.count}const repaint=({count:e,key:t,left:r,right:n,value:i},s)=>({color:s,key:t,value:i,left:r,right:n,count:e}),recount=e=>{e.count=1+(e.left?.count??0)+(e.right?.count??0)},bH="effect/RedBlackTree",SH=Symbol.for(bH),vH={[SH]:{_Key:e=>e,_Value:e=>e},[Z](){let e=hash$3(bH);for(const t of this)e^=pipe(hash$3(t[0]),combine$h(hash$3(t[1])));return cached$2(this,e)},[Y](e){if(isRedBlackTree$1(e)){if((this._root?.count??0)!==(e._root?.count??0))return!1;const t=Array.from(e);return Array.from(this).every((e,r)=>{const n=t[r];return equals$4(e[0],n[0])&&equals$4(e[1],n[1])})}return!1},[Symbol.iterator](){const e=[];let t=this._root;for(;null!=t;)e.push(t),t=t.left;return new RedBlackTreeIterator(this,e,yH.Forward)},toString(){return format$6(this.toJSON())},toJSON(){return{_id:"RedBlackTree",values:Array.from(this).map(toJSON)}},[ee](){return this.toJSON()},pipe(){return pipeArguments(this,arguments)}},makeImpl$3=(e,t)=>{const r=Object.create(vH);return r._ord=e,r._root=t,r},isRedBlackTree$1=e=>C(e,SH),empty$u=e=>makeImpl$3(e,void 0),_H=dual(2,(e,t)=>{let r=empty$u(t);for(const[t,n]of e)r=EH(r,t,n);return r}),wH=dual(2,(e,t)=>at$2(e,t,yH.Backward)),kH=dual(2,(e,t)=>at$2(e,t,yH.Forward)),at$2=(e,t,r)=>({[Symbol.iterator]:()=>{if(t<0)return new RedBlackTreeIterator(e,[],r);let n=e._root;const i=[];for(;void 0!==n;){if(i.push(n),void 0!==n.left){if(t<n.left.count){n=n.left;continue}t-=n.left.count}if(!t)return new RedBlackTreeIterator(e,i,r);if(t-=1,void 0===n.right)break;if(t>=n.right.count)break;n=n.right}return new RedBlackTreeIterator(e,[],r)}}),xH=dual(2,(e,t)=>{const r=[];let n=e._root,i=empty$R();for(;void 0!==n||r.length>0;)if(n)r.push(n),n=n.left;else{const e=r.pop();equals$4(t,e.key)&&(i=JA(e.value)(i)),n=e.right}return i}),IH=dual(2,(e,t)=>{const r=e._ord;let n=e._root;for(;void 0!==n;){const e=r(t,n.key);if(equals$4(t,n.key))return Ut(n.value);n=e<=0?n.left:n.right}return none$c()}),TH=dual(2,(e,t)=>{if(t<0)return none$c();let r,n=e._root;for(;void 0!==n;){if(r=n,n.left){if(t<n.left.count){n=n.left;continue}t-=n.left.count}if(!t)return Ut([r.key,r.value]);if(t-=1,!n.right)break;if(t>=n.right.count)break;n=n.right}return none$c()}),OH=dual(2,(e,t)=>zt(IH(e,t))),EH=dual(3,(e,t,r)=>{const n=e._ord;let i=e._root;const s=[],o=[];for(;null!=i;){const e=n(t,i.key);s.push(i),o.push(e),i=e<=0?i.left:i.right}s.push({color:0,key:t,value:r,left:void 0,right:void 0,count:1});for(let e=s.length-2;e>=0;--e){const t=s[e];o[e]<=0?s[e]={color:t.color,key:t.key,value:t.value,left:s[e+1],right:t.right,count:t.count+1}:s[e]={color:t.color,key:t.key,value:t.value,left:t.left,right:s[e+1],count:t.count+1}}for(let e=s.length-1;e>1;--e){const t=s[e-1],r=s[e];if(1===t.color||1===r.color)break;const n=s[e-2];if(n.left===t)if(t.left===r){const i=n.right;if(!i||0!==i.color){if(n.color=0,n.left=t.right,t.color=1,t.right=n,s[e-2]=t,s[e-1]=r,recount(n),recount(t),e>=3){const r=s[e-3];r.left===n?r.left=t:r.right=t}break}t.color=1,n.right=repaint(i,1),n.color=0,e-=1}else{const i=n.right;if(!i||0!==i.color){if(t.right=r.left,n.color=0,n.left=r.right,r.color=1,r.left=t,r.right=n,s[e-2]=r,s[e-1]=t,recount(n),recount(t),recount(r),e>=3){const t=s[e-3];t.left===n?t.left=r:t.right=r}break}t.color=1,n.right=repaint(i,1),n.color=0,e-=1}else if(t.right===r){const i=n.left;if(!i||0!==i.color){if(n.color=0,n.right=t.left,t.color=1,t.left=n,s[e-2]=t,s[e-1]=r,recount(n),recount(t),e>=3){const r=s[e-3];r.right===n?r.right=t:r.left=t}break}t.color=1,n.left=repaint(i,1),n.color=0,e-=1}else{const i=n.left;if(!i||0!==i.color){if(t.left=r.right,n.color=0,n.right=r.left,r.color=1,r.right=t,r.left=n,s[e-2]=r,s[e-1]=t,recount(n),recount(t),recount(r),e>=3){const t=s[e-3];t.right===n?t.right=r:t.left=r}break}t.color=1,n.left=repaint(i,1),n.color=0,e-=1}}return s[0].color=1,makeImpl$3(e._ord,s[0])}),keys$9=(e,t)=>{const r=e[Symbol.iterator]();let n=0;return{[Symbol.iterator]:()=>keys$9(e,t),next:()=>{n++;const e=r.key;switch(t===yH.Forward?r.moveNext():r.movePrev(),e._tag){case"None":return{done:!0,value:n};case"Some":return{done:!1,value:e.value}}}}},AH=dual(2,(e,t)=>greaterThan$4(e,t,yH.Backward)),CH=dual(2,(e,t)=>greaterThan$4(e,t,yH.Forward)),greaterThan$4=(e,t,r)=>({[Symbol.iterator]:()=>{const n=e._ord;let i=e._root;const s=[];let o=0;for(;void 0!==i;){const e=n(t,i.key);s.push(i),e<0&&(o=s.length),i=e<0?i.left:i.right}return s.length=o,new RedBlackTreeIterator(e,s,r)}}),MH=dual(2,(e,t)=>greaterThanEqual$1(e,t,yH.Backward)),FH=dual(2,(e,t)=>greaterThanEqual$1(e,t,yH.Forward)),greaterThanEqual$1=(e,t,r=yH.Forward)=>({[Symbol.iterator]:()=>{const n=e._ord;let i=e._root;const s=[];let o=0;for(;void 0!==i;){const e=n(t,i.key);s.push(i),e<=0&&(o=s.length),i=e<=0?i.left:i.right}return s.length=o,new RedBlackTreeIterator(e,s,r)}}),PH=dual(2,(e,t)=>lessThan$8(e,t,yH.Backward)),NH=dual(2,(e,t)=>lessThan$8(e,t,yH.Forward)),lessThan$8=(e,t,r)=>({[Symbol.iterator]:()=>{const n=e._ord;let i=e._root;const s=[];let o=0;for(;void 0!==i;){const e=n(t,i.key);s.push(i),e>0&&(o=s.length),i=e<=0?i.left:i.right}return s.length=o,new RedBlackTreeIterator(e,s,r)}}),jH=dual(2,(e,t)=>lessThanEqual$1(e,t,yH.Backward)),RH=dual(2,(e,t)=>lessThanEqual$1(e,t,yH.Forward)),lessThanEqual$1=(e,t,r)=>({[Symbol.iterator]:()=>{const n=e._ord;let i=e._root;const s=[];let o=0;for(;void 0!==i;){const e=n(t,i.key);s.push(i),e>=0&&(o=s.length),i=e<0?i.left:i.right}return s.length=o,new RedBlackTreeIterator(e,s,r)}}),DH=dual(2,(e,t)=>{const r=e._root;void 0!==r&&visitFull(r,(e,r)=>(t(e,r),none$c()))}),LH=dual(3,(e,t,r)=>{const n=e._root,i=e._ord;void 0!==n&&visitGreaterThanEqual(n,t,i,(e,t)=>(r(e,t),none$c()))}),UH=dual(3,(e,t,r)=>{const n=e._root,i=e._ord;void 0!==n&&visitLessThan(n,t,i,(e,t)=>(r(e,t),none$c()))}),$H=dual(2,(e,{body:t,max:r,min:n})=>{const i=e._root,s=e._ord;i&&visitBetween(i,n,r,s,(e,r)=>(t(e,r),none$c()))}),BH=dual(3,(e,t,r)=>{let n=t;for(const t of e)n=r(n,t[1],t[0]);return n}),zH=dual(2,(e,t)=>{if(!OH(e,t))return e;const r=e._ord,n=r;let i=e._root;const s=[];for(;void 0!==i;){const e=n(t,i.key);s.push(i),i=equals$4(t,i.key)?void 0:e<=0?i.left:i.right}if(0===s.length)return e;const o=Array(s.length);let a=s[s.length-1];o[o.length-1]={color:a.color,key:a.key,value:a.value,left:a.left,right:a.right,count:a.count};for(let e=s.length-2;e>=0;--e)a=s[e],a.left===s[e+1]?o[e]={color:a.color,key:a.key,value:a.value,left:o[e+1],right:a.right,count:a.count}:o[e]={color:a.color,key:a.key,value:a.value,left:a.left,right:o[e+1],count:a.count};if(a=o[o.length-1],void 0!==a.left&&void 0!==a.right){const e=o.length;for(a=a.left;null!=a.right;)o.push(a),a=a.right;const t=o[e-1];o.push({color:a.color,key:t.key,value:t.value,left:a.left,right:a.right,count:a.count}),o[e-1].key=a.key,o[e-1].value=a.value;for(let t=o.length-2;t>=e;--t)a=o[t],o[t]={color:a.color,key:a.key,value:a.value,left:a.left,right:o[t+1],count:a.count};o[e-1].left=o[e]}if(a=o[o.length-1],0===a.color){const e=o[o.length-2];e.left===a?e.left=void 0:e.right===a&&(e.right=void 0),o.pop();for(let e=0;e<o.length;++e)o[e].count--;return makeImpl$3(r,o[0])}if(void 0!==a.left||void 0!==a.right){void 0!==a.left?swap(a,a.left):void 0!==a.right&&swap(a,a.right),a.color=1;for(let e=0;e<o.length-1;++e)o[e].count--;return makeImpl$3(r,o[0])}if(1===o.length)return makeImpl$3(r,void 0);{for(let e=0;e<o.length;++e)o[e].count--;const e=o[o.length-2];fixDoubleBlack(o),e.left===a?e.left=void 0:e.right=void 0}return makeImpl$3(r,o[0])}),values$8=(e,t)=>{const r=e[Symbol.iterator]();let n=0;return{[Symbol.iterator]:()=>values$8(e,t),next:()=>{n++;const e=r.value;switch(t===yH.Forward?r.moveNext():r.movePrev(),e._tag){case"None":return{done:!0,value:n};case"Some":return{done:!1,value:e.value}}}}},visitFull=(e,t)=>{let r,n=e,i=!1;for(;!i;)if(null!=n)r=make$2b(n,r),n=n.left;else if(null!=r){const e=t(r.value.key,r.value.value);if(zt(e))return e;n=r.value.right,r=r.previous}else i=!0;return none$c()},visitGreaterThanEqual=(e,t,r,n)=>{let i,s=e,o=!1;for(;!o;)if(void 0!==s)i=make$2b(s,i),s=r(t,s.key)<=0?s.left:void 0;else if(void 0!==i){if(r(t,i.value.key)<=0){const e=n(i.value.key,i.value.value);if(zt(e))return e}s=i.value.right,i=i.previous}else o=!0;return none$c()},visitLessThan=(e,t,r,n)=>{let i,s=e,o=!1;for(;!o;)if(void 0!==s)i=make$2b(s,i),s=s.left;else if(void 0!==i&&r(t,i.value.key)>0){const e=n(i.value.key,i.value.value);if(zt(e))return e;s=i.value.right,i=i.previous}else o=!0;return none$c()},visitBetween=(e,t,r,n,i)=>{let s,o=e,a=!1;for(;!a;)if(void 0!==o)s=make$2b(o,s),o=n(t,o.key)<=0?o.left:void 0;else if(void 0!==s&&n(r,s.value.key)>0){if(n(t,s.value.key)<=0){const e=i(s.value.key,s.value.value);if(zt(e))return e}o=s.value.right,s=s.previous}else a=!0;return none$c()},fixDoubleBlack=e=>{let t,r,n,i;for(let s=e.length-1;s>=0;--s){if(t=e[s],0===s)return void(t.color=1);if(r=e[s-1],r.left===t){if(n=r.right,void 0!==n&&void 0!==n.right&&0===n.right.color){if(n=r.right=clone(n),i=n.right=clone(n.right),r.right=n.left,n.left=r,n.right=i,n.color=r.color,t.color=1,r.color=1,i.color=1,recount(r),recount(n),s>1){const t=e[s-2];t.left===r?t.left=n:t.right=n}return void(e[s-1]=n)}if(void 0!==n&&void 0!==n.left&&0===n.left.color){if(n=r.right=clone(n),i=n.left=clone(n.left),r.right=i.left,n.left=i.right,i.left=r,i.right=n,i.color=r.color,r.color=1,n.color=1,t.color=1,recount(r),recount(n),recount(i),s>1){const t=e[s-2];t.left===r?t.left=i:t.right=i}return void(e[s-1]=i)}if(void 0!==n&&1===n.color){if(0===r.color)return r.color=1,void(r.right=repaint(n,0));r.right=repaint(n,0);continue}if(void 0!==n){if(n=clone(n),r.right=n.left,n.left=r,n.color=r.color,r.color=0,recount(r),recount(n),s>1){const t=e[s-2];t.left===r?t.left=n:t.right=n}e[s-1]=n,e[s]=r,s+1<e.length?e[s+1]=t:e.push(t),s+=2}}else{if(n=r.left,void 0!==n&&void 0!==n.left&&0===n.left.color){if(n=r.left=clone(n),i=n.left=clone(n.left),r.left=n.right,n.right=r,n.left=i,n.color=r.color,t.color=1,r.color=1,i.color=1,recount(r),recount(n),s>1){const t=e[s-2];t.right===r?t.right=n:t.left=n}return void(e[s-1]=n)}if(void 0!==n&&void 0!==n.right&&0===n.right.color){if(n=r.left=clone(n),i=n.right=clone(n.right),r.left=i.right,n.right=i.left,i.right=r,i.left=n,i.color=r.color,r.color=1,n.color=1,t.color=1,recount(r),recount(n),recount(i),s>1){const t=e[s-2];t.right===r?t.right=i:t.left=i}return void(e[s-1]=i)}if(void 0!==n&&1===n.color){if(0===r.color)return r.color=1,void(r.left=repaint(n,0));r.left=repaint(n,0);continue}if(void 0!==n){if(n=clone(n),r.left=n.right,n.right=r,n.color=r.color,r.color=0,recount(r),recount(n),s>1){const t=e[s-2];t.right===r?t.right=n:t.left=n}e[s-1]=n,e[s]=r,s+1<e.length?e[s+1]=t:e.push(t),s+=2}}}},qH=empty$u,WH=_H,VH=IH,first$2=e=>{let t=e._root,r=e._root;for(;void 0!==t;)r=t,t=t.left;return r?Ut([r.key,r.value]):none$c()},getOrder$2=e=>e._ord,KH=OH,GH=EH,keys$8=e=>keys$9(e,yH.Forward),last$2=e=>{let t=e._root,r=e._root;for(;void 0!==t;)r=t,t=t.right;return r?Ut([r.key,r.value]):none$c()},JH=DH,HH=BH,ZH=zH,size$r=e=>e._root?.count??0,values$7=e=>values$8(e,yH.Forward);var QH=Object.freeze({__proto__:null,Direction:yH,at:kH,atReversed:wH,empty:qH,findAll:xH,findFirst:VH,first:first$2,forEach:JH,forEachBetween:$H,forEachGreaterThanEqual:LH,forEachLessThan:UH,fromIterable:WH,getAt:TH,getOrder:getOrder$2,greaterThan:CH,greaterThanEqual:FH,greaterThanEqualReversed:MH,greaterThanReversed:AH,has:KH,insert:GH,isRedBlackTree:isRedBlackTree$1,keys:keys$8,keysReversed:e=>keys$9(e,yH.Backward),last:last$2,lessThan:NH,lessThanEqual:RH,lessThanEqualReversed:jH,lessThanReversed:PH,make:e=>(...t)=>_H(t,e),reduce:HH,removeFirst:ZH,reversed:e=>({[Symbol.iterator]:()=>{const t=[];let r=e._root;for(;void 0!==r;)t.push(r),r=r.right;return new RedBlackTreeIterator(e,t,yH.Backward)}}),size:size$r,values:values$7,valuesReversed:e=>values$8(e,yH.Backward)});const YH=Symbol.for("effect/SortedSet"),XH={[YH]:{_A:e=>e},[Z](){return pipe(hash$3(this.keyTree),combine$h(hash$3(YH)),cached$2(this))},[Y](e){return isSortedSet(e)&&equals$4(this.keyTree,e.keyTree)},[Symbol.iterator](){return keys$8(this.keyTree)},toString(){return format$6(this.toJSON())},toJSON(){return{_id:"SortedSet",values:Array.from(this).map(toJSON)}},[ee](){return this.toJSON()},pipe(){return pipeArguments(this,arguments)}},fromTree=e=>{const t=Object.create(XH);return t.keyTree=e,t},isSortedSet=e=>C(e,YH),empty$s=e=>fromTree(qH(e)),eZ=dual(2,(e,t)=>fromTree(WH(Array.from(e).map(e=>[e,!0]),t))),tZ=dual(2,(e,t)=>KH(e.keyTree,t)?e:fromTree(GH(e.keyTree,t,!0))),rZ=dual(2,(e,t)=>{let r=e;for(const e of t)r=fZ(r,e);return r}),nZ=dual(2,(e,t)=>{for(const r of e)if(!t(r))return!1;return!0}),iZ=dual(2,(e,t)=>{const r=getOrder$2(e.keyTree);let n=empty$s(r);for(const r of e)t(r)&&(n=tZ(n,r));return n}),sZ=dual(3,(e,t,r)=>{let n=empty$s(t);return oZ(e,e=>{for(const t of r(e))n=tZ(n,t)}),n}),oZ=dual(2,(e,t)=>JH(e.keyTree,t)),aZ=dual(2,(e,t)=>KH(e.keyTree,t)),uZ=dual(2,(e,t)=>{const r=getOrder$2(e.keyTree);let n=empty$s(r);for(const r of t)aZ(e,r)&&(n=tZ(n,r));return n}),cZ=dual(2,(e,t)=>nZ(e,e=>aZ(t,e))),lZ=dual(3,(e,t,r)=>{let n=empty$s(t);return oZ(e,e=>{const t=r(e);aZ(n,t)||(n=tZ(n,t))}),n}),pZ=dual(2,(e,t)=>{const r=getOrder$2(e.keyTree);let n=empty$s(r),i=empty$s(r);for(const r of e)t(r)?n=tZ(n,r):i=tZ(i,r);return[i,n]}),fZ=dual(2,(e,t)=>fromTree(ZH(e.keyTree,t))),hZ=dual(2,(e,t)=>{for(const r of e)if(t(r))return!0;return!1}),dZ=dual(2,(e,t)=>aZ(e,t)?fZ(e,t):tZ(e,t)),mZ=dual(2,(e,t)=>{const r=getOrder$2(e.keyTree);let n=empty$s(r);for(const t of e)n=tZ(t)(n);for(const e of t)n=tZ(e)(n);return n}),values$6=e=>keys$8(e.keyTree),getEquivalence$2=()=>(e,t)=>cZ(e,t)&&cZ(t,e);var gZ=Object.freeze({__proto__:null,add:tZ,difference:rZ,empty:empty$s,every:nZ,filter:iZ,flatMap:sZ,forEach:oZ,fromIterable:eZ,getEquivalence:getEquivalence$2,has:aZ,intersection:uZ,isSortedSet,isSubset:cZ,make:e=>(...t)=>eZ(t,e),map:lZ,partition:pZ,remove:fZ,size:e=>size$r(e.keyTree),some:hZ,toggle:dZ,union:mZ,values:values$6});const yZ=Symbol.for("effect/Supervisor"),bZ={_T:e=>e};class ProxySupervisor{underlying;value0;[yZ]=bZ;constructor(e,t){this.underlying=e,this.value0=t}get value(){return this.value0}onStart(e,t,r,n){this.underlying.onStart(e,t,r,n)}onEnd(e,t){this.underlying.onEnd(e,t)}onEffect(e,t){this.underlying.onEffect(e,t)}onSuspend(e){this.underlying.onSuspend(e)}onResume(e){this.underlying.onResume(e)}map(e){return new ProxySupervisor(this,pipe(this.value,qR(e)))}zip(e){return new Zip(this,e)}}class Zip{left;right;_tag="Zip";[yZ]=bZ;constructor(e,t){this.left=e,this.right=t}get value(){return uD(this.left.value,this.right.value)}onStart(e,t,r,n){this.left.onStart(e,t,r,n),this.right.onStart(e,t,r,n)}onEnd(e,t){this.left.onEnd(e,t),this.right.onEnd(e,t)}onEffect(e,t){this.left.onEffect(e,t),this.right.onEffect(e,t)}onSuspend(e){this.left.onSuspend(e),this.right.onSuspend(e)}onResume(e){this.left.onResume(e),this.right.onResume(e)}map(e){return new ProxySupervisor(this,pipe(this.value,qR(e)))}zip(e){return new Zip(this,e)}}const isZip=e=>C(e,yZ)&&M(e,"Zip");class Track{[yZ]=bZ;fibers=new Set;get value(){return sync$l(()=>Array.from(this.fibers))}onStart(e,t,r,n){this.fibers.add(n)}onEnd(e,t){this.fibers.delete(t)}onEffect(e,t){}onSuspend(e){}onResume(e){}map(e){return new ProxySupervisor(this,pipe(this.value,qR(e)))}zip(e){return new Zip(this,e)}onRun(e,t){return e()}}class Const{effect;[yZ]=bZ;constructor(e){this.effect=e}get value(){return this.effect}onStart(e,t,r,n){}onEnd(e,t){}onEffect(e,t){}onSuspend(e){}onResume(e){}map(e){return new ProxySupervisor(this,pipe(this.value,qR(e)))}zip(e){return new Zip(this,e)}onRun(e,t){return e()}}class FibersIn{ref;[yZ]=bZ;constructor(e){this.ref=e}get value(){return sync$l(()=>get$E(this.ref))}onStart(e,t,r,n){pipe(this.ref,qF(pipe(get$E(this.ref),tZ(n))))}onEnd(e,t){pipe(this.ref,qF(pipe(get$E(this.ref),fZ(t))))}onEffect(e,t){}onSuspend(e){}onResume(e){}map(e){return new ProxySupervisor(this,pipe(this.value,qR(e)))}zip(e){return new Zip(this,e)}onRun(e,t){return e()}}const unsafeTrack$1=()=>new Track,SZ=sync$l(unsafeTrack$1),fromEffect$e=e=>new Const(e),vZ=globalValue("effect/Supervisor/none",()=>fromEffect$e(tD)),_Z=aj,wZ=dual(3,(e,t,r)=>e.diff(t,r)),kZ=make$22;var xZ=Object.freeze({__proto__:null,TypeId:_Z,chunk:e=>make$22({empty:empty$L(),combine:(e,t)=>dN(t)(e),diff:(t,r)=>(e=>{let t=0,r=empty$L();for(;t<e.oldValue.length&&t<e.newValue.length;){const n=KA(t)(e.oldValue),i=KA(t)(e.newValue),s=e.differ.diff(n,i);equals$4(s,e.differ.empty)||(r=pipe(r,dN(makeUpdate$2(t,s)))),t+=1}return t<e.oldValue.length&&(r=pipe(r,dN(((e,t)=>{const r=Object.create(fN);return r.from=0,r.until=t,r})(0,t)))),t<e.newValue.length&&(r=pipe(r,dN((e=>{const t=Object.create(pN);return t.values=e,t})(ZA(t)(e.newValue))))),r})({oldValue:t,newValue:r,differ:e}),patch:(t,r)=>mN(r,e)(t)}),combine:dual(3,(e,t,r)=>e.combine(t,r)),diff:wZ,empty:e=>e.empty,environment:environment$1,hashMap:e=>make$22({empty:empty$J(),combine:(e,t)=>FN(t)(e),diff:(t,r)=>(e=>{const[t,r]=EP([e.oldValue,empty$J()],([t,r],n,i)=>{const s=yP(i)(t);switch(s._tag){case"Some":{const o=e.differ.diff(s.value,n);return equals$4(o,e.differ.empty)?[IP(i)(t),r]:[IP(i)(t),FN(makeUpdate$1(i,o))(r)]}case"None":return[t,FN(makeAdd$1(i,n))(r)]}})(e.newValue);return EP(r,(e,t,r)=>FN((e=>{const t=Object.create(CN);return t.key=e,t})(r))(e))(t)})({oldValue:t,newValue:r,differ:e}),patch:(t,r)=>PN(r,e)(t)}),hashSet:hashSet$3,make:kZ,orElseEither:cj,patch:dual(3,(e,t,r)=>e.patch(t,r)),readonlyArray:readonlyArray$1,transform:lj,update:update$f,updateWith:updateWith$3,zip:pj});const IZ="Empty",TZ="AddSupervisor",OZ="RemoveSupervisor",EZ="AndThen",AZ={_tag:IZ},combine$4=(e,t)=>({_tag:EZ,first:e,second:t}),removeSupervisor=(e,t)=>equals$4(e,t)?vZ:isZip(e)?removeSupervisor(e.left,t).zip(removeSupervisor(e.right,t)):e,toSet$1=e=>equals$4(e,vZ)?IF():isZip(e)?pipe(toSet$1(e.left),FF(toSet$1(e.right))):make$28(e),CZ=kZ({empty:AZ,patch:(e,t)=>((e,t)=>{let r=e,n=t;for(;isNonEmpty$8(n);){const e=lC(n);switch(e._tag){case IZ:n=tailNonEmpty(n);break;case TZ:r=r.zip(e.supervisor),n=tailNonEmpty(n);break;case OZ:r=removeSupervisor(r,e.supervisor),n=tailNonEmpty(n);break;case EZ:n=JA(e.first)(JA(e.second)(tailNonEmpty(n)))}}return r})(t,of$5(e)),combine:combine$4,diff:(e,t)=>{if(equals$4(e,t))return AZ;const r=toSet$1(e),n=toSet$1(t),i=pipe(n,MF(r),RF(AZ,(e,t)=>combine$4(e,{_tag:TZ,supervisor:t}))),s=pipe(r,MF(n),RF(AZ,(e,t)=>combine$4(e,{_tag:OZ,supervisor:t})));return combine$4(i,s)}}),MZ=counter$5("effect_fiber_started",{incremental:!0}),FZ=counter$5("effect_fiber_active"),PZ=counter$5("effect_fiber_successes",{incremental:!0}),NZ=counter$5("effect_fiber_failures",{incremental:!0}),jZ=JJ(histogram$5("effect_fiber_lifetimes",exponential$3({start:.5,factor:2,count:35})),"time_unit","milliseconds"),RZ="Continue",DZ="Yield",LZ={_E:e=>e,_A:e=>e},absurd=e=>{throw Error(`BUG: FiberRuntime - ${toStringUnknown(e)} - please report an issue at https://github.com/Effect-TS/effect/issues`)},UZ=Symbol.for("effect/internal/fiberRuntime/YieldedOp"),$Z=globalValue("effect/internal/fiberRuntime/yieldedOpChannel",()=>({currentOp:null})),BZ={[fe]:(e,t,r)=>K(()=>t.effect_instruction_i1(r)),OnStep:(e,t,r)=>exitSucceed$1(exitSucceed$1(r)),[he]:(e,t,r)=>K(()=>t.effect_instruction_i2(r)),[we]:(e,t,r)=>(e.patchRuntimeFlags(e.currentRuntimeFlags,t.patch),interruptible$4(e.currentRuntimeFlags)&&e.isInterrupted()?exitFailCause$1(e.getInterruptedCause()):exitSucceed$1(r)),[be]:(e,t,r)=>(K(()=>t.effect_instruction_i2(r)),K(()=>t.effect_instruction_i0())?(e.pushStack(t),K(()=>t.effect_instruction_i1())):tD),[Se]:(e,t,r)=>{const n=K(()=>t.effect_instruction_i0.next(r));return n.done?exitSucceed$1(n.value):(e.pushStack(t),yieldWrapGet(n.value))}},zZ={[oG]:(e,t,r,n)=>(e.processNewInterruptSignal(n.cause),interruptible$4(t)?exitFailCause$1(n.cause):r),[uG]:(e,t,r,n)=>{throw Error("It is illegal to have multiple concurrent run loops in a single fiber")},[aG]:(e,t,r,n)=>(n.onFiber(e,running$1(t)),r),[cG]:(e,t,r,n)=>PR(yieldNow$3(),()=>r)},qZ=getCurrentVersion$1();class FiberRuntime extends hz{[fG]=hG;[mG]=LZ;_fiberRefs;_fiberId;_queue=[];_children=null;_observers=[];_running=!1;_stack=[];_asyncInterruptor=null;_asyncBlockingOn=null;_exitValue=null;_steps=[];_isYielding=!1;currentRuntimeFlags;currentOpCount=0;currentSupervisor;currentScheduler;currentTracer;currentSpan;currentContext;currentDefaultServices;constructor(e,t,r){if(super(),this.currentRuntimeFlags=r,this._fiberId=e,this._fiberRefs=t,runtimeMetrics$1(r)){const e=this.getFiberRef(XD);MZ.unsafeUpdate(1,e),FZ.unsafeUpdate(1,e)}this.refreshRefCache()}commit(){return join$4(this)}id(){return this._fiberId}resume(e){this.tell(resume(e))}get status(){return this.ask((e,t)=>t)}get runtimeFlags(){return this.ask((e,t)=>isDone$5(t)?e.currentRuntimeFlags:t.runtimeFlags)}scope(){return new Local((e=this).id(),e);var e}get children(){return this.ask(e=>Array.from(e.getChildren()))}getChildren(){return null===this._children&&(this._children=new Set),this._children}getInterruptedCause(){return this.getFiberRef(rL)}fiberRefs(){return this.ask(e=>e.getFiberRefs())}ask(e){return suspend$g(()=>{const t=deferredUnsafeMake(this._fiberId);return this.tell(stateful((r,n)=>{deferredUnsafeDone(t,sync$l(()=>e(r,n)))})),deferredAwait(t)})}tell(e){this._queue.push(e),this._running||(this._running=!0,this.drainQueueLaterOnExecutor())}get await(){return async_(e=>{const cb=t=>e(succeed$u(t));return this.tell(stateful((e,t)=>{null!==e._exitValue?cb(this._exitValue):e.addObserver(cb)})),sync$l(()=>this.tell(stateful((e,t)=>{e.removeObserver(cb)})))},this.id())}get inheritAll(){return withFiberRuntime$1((e,t)=>{const r=e.id(),n=e.getFiberRefs(),i=t.runtimeFlags,s=this.getFiberRefs(),o=OB(n,r,s);e.setFiberRefs(o);const a=e.getFiberRef(EQ),u=pipe(Mj(i,a),Dj(1),Dj(_j));return updateRuntimeFlags$2(u)})}get poll(){return sync$l(()=>fromNullable$3(this._exitValue))}unsafePoll(){return this._exitValue}interruptAsFork(e){return sync$l(()=>this.tell(interruptSignal(interrupt$a(e))))}unsafeInterruptAsFork(e){this.tell(interruptSignal(interrupt$a(e)))}addObserver(e){null!==this._exitValue?e(this._exitValue):this._observers.push(e)}removeObserver(e){this._observers=this._observers.filter(t=>t!==e)}getFiberRefs(){return this.setFiberRef(EQ,this.currentRuntimeFlags),this._fiberRefs}unsafeDeleteFiberRef(e){this._fiberRefs=AB(this._fiberRefs,e)}getFiberRef(e){return this._fiberRefs.locals.has(e)?this._fiberRefs.locals.get(e)[0][1]:e.initial}setFiberRef(e,t){this._fiberRefs=FB(this._fiberRefs,{fiberId:this._fiberId,fiberRef:e,value:t}),this.refreshRefCache()}refreshRefCache(){this.currentDefaultServices=this.getFiberRef(pB),this.currentTracer=this.currentDefaultServices.unsafeMap.get(sB.key),this.currentSupervisor=this.getFiberRef(AQ),this.currentScheduler=this.getFiberRef(rG),this.currentContext=this.getFiberRef($D),this.currentSpan=this.currentContext.unsafeMap.get(oB.key)}setFiberRefs(e){this._fiberRefs=e,this.refreshRefCache()}addChild(e){this.getChildren().add(e)}removeChild(e){this.getChildren().delete(e)}transferChildren(e){const t=this._children;if(this._children=null,null!==t&&t.size>0)for(const r of t)null===r._exitValue&&e.add(this.currentRuntimeFlags,r)}drainQueueOnCurrentThread(){let e=!0;for(;e;){let t=RZ;const r=globalThis[EG];globalThis[EG]=this;try{for(;t===RZ;)t=0===this._queue.length?"Done":this.evaluateMessageWhileSuspended(this._queue.splice(0,1)[0])}finally{this._running=!1,globalThis[EG]=r}this._queue.length>0&&!this._running?(this._running=!0,t===DZ?(this.drainQueueLaterOnExecutor(),e=!1):e=!0):e=!1}}drainQueueLaterOnExecutor(){this.currentScheduler.scheduleTask(this.run,this.getFiberRef(BD))}drainQueueWhileRunning(e,t){let r=t;for(;this._queue.length>0;){const t=this._queue.splice(0,1)[0];r=zZ[t._tag](this,e,r,t)}return r}isInterrupted(){return!isEmpty$o(this.getFiberRef(rL))}addInterruptedCause(e){const t=this.getFiberRef(rL);this.setFiberRef(rL,sequential$4(t,e))}processNewInterruptSignal(e){this.addInterruptedCause(e),this.sendInterruptSignalToAllChildren()}sendInterruptSignalToAllChildren(){if(null===this._children||0===this._children.size)return!1;let e=!1;for(const t of this._children)t.tell(interruptSignal(interrupt$a(this.id()))),e=!0;return e}interruptAllChildren(){if(this.sendInterruptSignalToAllChildren()){const e=this._children.values();this._children=null;let t=!1;return whileLoop$2({while:()=>!t,body:()=>{const r=e.next();return r.done?sync$l(()=>{t=!0}):asVoid$9(r.value.await)},step:()=>{}})}return null}reportExitValue(e){if(runtimeMetrics$1(this.currentRuntimeFlags)){const t=this.getFiberRef(XD),r=this.id().startTimeMillis,n=Date.now();switch(jZ.unsafeUpdate(n-r,t),FZ.unsafeUpdate(-1,t),e._tag){case de:PZ.unsafeUpdate(1,t);break;case le:NZ.unsafeUpdate(1,t)}}if("Failure"===e._tag){const t=this.getFiberRef(ZD);isInterruptedOnly$1(e.cause)||"Some"!==t._tag||this.log("Fiber terminated with an unhandled error",e.cause,t)}}setExitValue(e){this._exitValue=e,this.reportExitValue(e);for(let t=this._observers.length-1;t>=0;t--)this._observers[t](e);this._observers=[]}getLoggers(){return this.getFiberRef(QZ)}log(e,t,r){const n=zt(r)?r.value:this.getFiberRef(WD),i=this.getFiberRef(WZ);if(tz(i,n))return;const s=this.getFiberRef(VD),o=this.getFiberRef(qD),a=this.getLoggers(),u=this.getFiberRefs();if(size$x(a)>0){const r=jA(this.getFiberRef(pB),c$),i=new Date(r.unsafeCurrentTimeMillis());withRedactableContext(u,()=>{for(const r of a)r.log({fiberId:this.id(),logLevel:n,message:e,cause:t,context:u,spans:s,annotations:o,date:i})})}}evaluateMessageWhileSuspended(e){switch(e._tag){case cG:return DZ;case oG:return this.processNewInterruptSignal(e.cause),null!==this._asyncInterruptor&&(this._asyncInterruptor(exitFailCause$1(e.cause)),this._asyncInterruptor=null),RZ;case uG:return this._asyncInterruptor=null,this._asyncBlockingOn=null,this.evaluateEffect(e.effect),RZ;case aG:return e.onFiber(this,null!==this._exitValue?HW:suspended(this.currentRuntimeFlags,this._asyncBlockingOn)),RZ;default:return absurd(e)}}evaluateEffect(e){this.currentSupervisor.onResume(this);try{let t=interruptible$4(this.currentRuntimeFlags)&&this.isInterrupted()?exitFailCause$1(this.getInterruptedCause()):e;for(;null!==t;){const e=t,r=this.runLoop(e);if(r===UZ){const e=$Z.currentOp;$Z.currentOp=null,e._op===_e?cooperativeYielding$1(this.currentRuntimeFlags)?(this.tell(yieldNow$1()),this.tell(resume(UL)),t=null):t=UL:e._op===ue&&(t=null)}else{this.currentRuntimeFlags=pipe(this.currentRuntimeFlags,Tj(_j));const e=this.interruptAllChildren();null!==e?t=PR(e,()=>r):(0===this._queue.length?this.setExitValue(r):this.tell(resume(r)),t=null)}}}finally{this.currentSupervisor.onSuspend(this)}}start(e){if(this._running)this.tell(resume(e));else{this._running=!0;const t=globalThis[EG];globalThis[EG]=this;try{this.evaluateEffect(e)}finally{this._running=!1,globalThis[EG]=t,this._queue.length>0&&this.drainQueueLaterOnExecutor()}}}startFork(e){this.tell(resume(e))}patchRuntimeFlags(e,t){const r=Fj(e,t);return globalThis[EG]=this,this.currentRuntimeFlags=r,r}initiateAsync(e,t){let r=!1;const callback=e=>{r||(r=!0,this.tell(resume(e)))};interruptible$4(e)&&(this._asyncInterruptor=callback);try{t(callback)}catch(e){callback(failCause$j(die$h(e)))}}pushStack(e){this._stack.push(e),"OnStep"===e._op&&this._steps.push({refs:this.getFiberRefs(),flags:this.currentRuntimeFlags})}popStack(){const e=this._stack.pop();if(e)return"OnStep"===e._op&&this._steps.pop(),e}getNextSuccessCont(){let e=this.popStack();for(;e;){if(e._op!==pe)return e;e=this.popStack()}}getNextFailCont(){let e=this.popStack();for(;e;){if(e._op!==fe&&e._op!==be&&e._op!==Se)return e;e=this.popStack()}}[ge](e){return sync$l(()=>RA(this.currentContext,e))}Left(e){return fail$r(e.left)}None(e){return fail$r(new bL)}Right(e){return exitSucceed$1(e.right)}Some(e){return exitSucceed$1(e.value)}Micro(e){return unsafeAsync(t=>{let r=t;const n=runFork$2(WV(e,this.currentContext));return n.addObserver(e=>{if("Success"===e._tag)return r(exitSucceed$1(e.value));switch(e.cause._tag){case"Interrupt":return r(exitFailCause$1(interrupt$a(aP)));case"Fail":return r(fail$r(e.cause.error));case"Die":return r(die$g(e.cause.defect))}}),unsafeAsync(e=>{r=t=>{e(tD)},n.unsafeInterrupt()})})}[me](e){const t=K(()=>e.effect_instruction_i0()),r=this.getNextSuccessCont();return void 0!==r?(r._op in BZ||absurd(r),BZ[r._op](this,r,t)):($Z.currentOp=exitSucceed$1(t),UZ)}[de](e){const t=e,r=this.getNextSuccessCont();return void 0!==r?(r._op in BZ||absurd(r),BZ[r._op](this,r,t.effect_instruction_i0)):($Z.currentOp=t,UZ)}[le](e){const t=e.effect_instruction_i0,r=this.getNextFailCont();if(void 0===r)return $Z.currentOp=exitFailCause$1(t),UZ;switch(r._op){case pe:case he:return interruptible$4(this.currentRuntimeFlags)&&this.isInterrupted()?exitFailCause$1(stripFailures$1(t)):K(()=>r.effect_instruction_i1(t));case"OnStep":return interruptible$4(this.currentRuntimeFlags)&&this.isInterrupted()?exitFailCause$1(stripFailures$1(t)):exitSucceed$1(exitFailCause$1(t));case we:return this.patchRuntimeFlags(this.currentRuntimeFlags,r.patch),interruptible$4(this.currentRuntimeFlags)&&this.isInterrupted()?exitFailCause$1(sequential$4(t,this.getInterruptedCause())):exitFailCause$1(t);default:absurd(r)}}[ve](e){return K(()=>e.effect_instruction_i0(this,running$1(this.currentRuntimeFlags)))}Blocked(e){const t=this.getFiberRefs(),r=this.currentRuntimeFlags;if(this._steps.length>0){const n=[],i=this._steps[this._steps.length-1];let s=this.popStack();for(;s&&"OnStep"!==s._op;)n.push(s),s=this.popStack();this.setFiberRefs(i.refs),this.currentRuntimeFlags=i.flags;const o=UW(i.refs,t),a=Mj(i.flags,r);return exitSucceed$1(blocked$1(e.effect_instruction_i0,withFiberRuntime$1(t=>{for(;n.length>0;)t.pushStack(n.pop());return t.setFiberRefs($W(t.id(),t.getFiberRefs())(o)),t.currentRuntimeFlags=Fj(a)(t.currentRuntimeFlags),e.effect_instruction_i1})))}return uninterruptibleMask$2(t=>PR(forkDaemon$1(runRequestBlock$1(e.effect_instruction_i0)),()=>t(e.effect_instruction_i1)))}RunBlocked(e){return t=e.effect_instruction_i0,UR((e=>{let t=of$4(e),r=RP();for(;;){const[e,n]=XP(t,[parallelCollectionEmpty(),RP()],([e,t],r)=>{const[n,i]=step$2(r);return[parallelCollectionCombine(e,n),LP(t,i)]});if(r=merge$b(r,e),isNil(n))return reverse$2(r);t=n}throw Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues")})(t),e=>forEachConcurrentDiscard((e=>Array.from(e.map))(e),([e,t])=>{const r=new Map,n=[];for(const e of t){n.push(toReadonlyArray$1(e));for(const t of e)r.set(t.request,t)}const i=n.flat();return LD(invokeWithInterrupt(e.runAll(n),i,()=>i.forEach(e=>{e.listeners.interrupted=!0})),sG,r)},!1,!1));var t}[ye](e){const t=e.effect_instruction_i0,r=this.currentRuntimeFlags,n=Fj(r,t);if(interruptible$4(n)&&this.isInterrupted())return exitFailCause$1(this.getInterruptedCause());if(this.patchRuntimeFlags(this.currentRuntimeFlags,t),e.effect_instruction_i1){const t=Mj(n,r);return this.pushStack(new RevertFlags(t,e)),K(()=>e.effect_instruction_i1(r))}return UL}[fe](e){return this.pushStack(e),e.effect_instruction_i0}OnStep(e){return this.pushStack(e),e.effect_instruction_i0}[pe](e){return this.pushStack(e),e.effect_instruction_i0}[he](e){return this.pushStack(e),e.effect_instruction_i0}[ue](e){return this._asyncBlockingOn=e.effect_instruction_i1,this.initiateAsync(this.currentRuntimeFlags,e.effect_instruction_i0),$Z.currentOp=e,UZ}[_e](e){return this._isYielding=!1,$Z.currentOp=e,UZ}[be](e){const t=e.effect_instruction_i0,r=e.effect_instruction_i1;return t()?(this.pushStack(e),r()):UL}[Se](e){return BZ[Se](this,e,void 0)}[ce](e){return K(()=>e.commit())}runLoop(e){let t=e;for(this.currentOpCount=0;;){if(2&this.currentRuntimeFlags&&this.currentSupervisor.onEffect(this,t),this._queue.length>0&&(t=this.drainQueueWhileRunning(this.currentRuntimeFlags,t)),!this._isYielding){this.currentOpCount+=1;const e=this.currentScheduler.shouldYield(this);if(!1!==e){this._isYielding=!0,this.currentOpCount=0;const r=t;t=PR(yieldNow$3({priority:e}),()=>r)}}try{if(t=this.currentTracer.context(()=>{if(qZ!==t[xR]._V){const e=this.getFiberRef(QD);if("Some"===e._tag){const r=t[xR]._V;this.log(`Executing an Effect versioned ${r} with a Runtime of version ${getCurrentVersion$1()}, you may want to dedupe the effect dependencies, you can use the language service plugin to detect this at compile time: https://github.com/Effect-TS/language-service`,tR,e)}}return this[t._op](t)},this),t===UZ){const e=$Z.currentOp;return e._op===_e||e._op===ue?UZ:($Z.currentOp=null,e._op===de||e._op===le?e:exitFailCause$1(die$h(e)))}}catch(e){t=t!==UZ&&!C(t,"_op")||!(t._op in this)?dieMessage$9("Not a valid effect: "+toStringUnknown(t)):isInterruptedException$1(e)?exitFailCause$1(sequential$4(die$h(e),interrupt$a(aP))):die$g(e)}}}run=()=>{this.drainQueueOnCurrentThread()}}const WZ=globalValue("effect/FiberRef/currentMinimumLogLevel",()=>fiberRefUnsafeMake(fromLiteral("Info"))),loggerWithConsoleLog=e=>makeLogger(t=>{const r=RB(t.context,pB);jA(r,eB).unsafe.log(e.log(t))}),VZ=globalValue(Symbol.for("effect/Logger/defaultLogger"),()=>loggerWithConsoleLog($G)),KZ=globalValue(Symbol.for("effect/Logger/jsonLogger"),()=>loggerWithConsoleLog(qG)),GZ=globalValue(Symbol.for("effect/Logger/logFmtLogger"),()=>loggerWithConsoleLog(BG)),JZ=globalValue(Symbol.for("effect/Logger/prettyLogger"),()=>HG),HZ=globalValue(Symbol.for("effect/Logger/structuredLogger"),()=>loggerWithConsoleLog(zG)),ZZ=globalValue(Symbol.for("effect/Logger/tracerLogger"),()=>makeLogger(({annotations:e,cause:t,context:r,fiberId:n,logLevel:i,message:s})=>{const o=DA(MB(r,$D),oB);if("None"===o._tag||"ExternalSpan"===o.value._tag)return;const a=RA(MB(r,pB),c$),u={};for(const[t,r]of e)u[t]=r;u["effect.fiberId"]=fP(n),u["effect.logLevel"]=i.label,null!==t&&"Empty"!==t._tag&&(u["effect.cause"]=pretty$4(t,{renderErrorCause:!0})),o.value.event(toStringUnknown(Array.isArray(s)&&1===s.length?s[0]:s),a.unsafeCurrentTimeNanos(),u)})),QZ=globalValue(Symbol.for("effect/FiberRef/currentLoggers"),()=>fiberRefUnsafeMakeHashSet(make$28(VZ,ZZ))),YZ=dual(3,(e,t,r)=>PR(wQ,n=>{let i=[];const s=suspend$g(()=>{if(0===i.length)return tD;const e=i;return i=[],r(e)});return uninterruptibleMask$2(r=>pipe(eW(t),lD(s),forever$6,r,forkDaemon$1,PR(e=>scopeAddFinalizer(n,interruptFiber(e))),lD(addFinalizer$2(()=>s)),TR(makeLogger(t=>{i.push(e.log(t))}))))})),XZ=dual(2,(e,t)=>{const r="string"==typeof t?fromLiteral(t):t;return withFiberRuntime$1(t=>{const n=t.getFiberRef(WZ);return tz(n,r)?succeed$u(none$c()):qR(e,Ut)})}),eQ=dual(e=>isEffect$1(e[0]),(e,t)=>uninterruptible$2(XR(e,e=>addFinalizer$2(r=>t(e,r))))),tQ=dual(e=>isEffect$1(e[0]),(e,t)=>PQ(e,addFinalizer$2(e=>t(e)))),addFinalizer$2=e=>withFiberRuntime$1(t=>{const r=t.getFiberRefs(),n=xj(t.currentRuntimeFlags,1);return PR(wQ,t=>scopeAddFinalizerExit(t,t=>withFiberRuntime$1(i=>{const s=i.getFiberRefs(),o=i.currentRuntimeFlags,a=UW(s,r),u=Mj(o,n),c=UW(r,s);return i.setFiberRefs($W(a,i.id(),r)),PQ(sD(e(t),u),sync$l(()=>{i.setFiberRefs($W(c,i.id(),i.getFiberRefs()))}))})))}),rQ=Symbol.for("effect/Effect/existsPar/found"),nQ=dual(e=>isIterable(e[0])&&!isEffect$1(e[0]),(e,t,r)=>matchSimple(r?.concurrency,()=>suspend$g(()=>existsLoop(e[Symbol.iterator](),0,t)),()=>DR(aQ(e,(e,r)=>$R(t(e,r),{onTrue:()=>fail$r(rQ),onFalse:()=>tD}),r),{onFailure:e=>e===rQ?succeed$u(!0):fail$r(e),onSuccess:()=>succeed$u(!1)}))),existsLoop=(e,t,r)=>{const n=e.next();return n.done?succeed$u(!1):PR(r(n.value,t),n=>n?succeed$u(n):existsLoop(e,t+1,r))},iQ=dual(e=>isIterable(e[0])&&!isEffect$1(e[0]),(e,t,r)=>{const n=r?.negate?(e,r)=>qR(t(e,r),not$2):t;return matchSimple(r?.concurrency,()=>suspend$g(()=>fromIterable$v(e).reduceRight((e,t,r)=>pD(e,suspend$g(()=>n(t,r)),(e,r)=>r?[t,...e]:e),sync$l(()=>[]))),()=>qR(aQ(e,(e,t)=>qR(n(e,t),t=>t?Ut(e):none$c()),r),hs))}),all$6=(e,t)=>{const[r,n]=(e=>{if(Array.isArray(e)||isIterable(e))return[e,none$c()];const t=Object.keys(e),r=t.length;return[t.map(t=>e[t]),Ut(e=>{const n={};for(let i=0;i<r;i++)n[t[i]]=e[i];return n})]})(e);return"validate"===t?.mode?((e,t,r)=>{const n=[];for(const t of e)n.push(either$a(t));return PR(aQ(n,identity$5,{concurrency:r?.concurrency,batching:r?.batching,concurrentFinalizers:r?.concurrentFinalizers}),e=>{const n=none$c(),i=e.length,s=Array(i),o=Array(i);let a=!1;for(let t=0;t<i;t++){const r=e[t];"Left"===r._tag?(s[t]=Ut(r.left),a=!0):(o[t]=r.right,s[t]=n)}return a?"Some"===t._tag?fail$r(t.value(s)):fail$r(s):r?.discard?tD:"Some"===t._tag?succeed$u(t.value(o)):succeed$u(o)})})(r,n,t):"either"===t?.mode?((e,t,r)=>{const n=[];for(const t of e)n.push(either$a(t));return r?.discard?aQ(n,identity$5,{concurrency:r?.concurrency,batching:r?.batching,discard:!0,concurrentFinalizers:r?.concurrentFinalizers}):qR(aQ(n,identity$5,{concurrency:r?.concurrency,batching:r?.batching,concurrentFinalizers:r?.concurrentFinalizers}),e=>"Some"===t._tag?t.value(e):e)})(r,n,t):!0!==t?.discard&&"Some"===n._tag?qR(aQ(r,identity$5,t),n.value):aQ(r,identity$5,t)},sQ=dual(2,(e,t)=>Array.from({length:t},()=>e)),oQ=dual(e=>isEffect$1(e[0]),(e,t,r)=>all$6(sQ(e,t),r)),aQ=dual(e=>isIterable(e[0]),(e,t,r)=>withFiberRuntime$1(n=>{const i=!0===r?.batching||"inherit"===r?.batching&&n.getFiberRef(HD);return r?.discard?match$u(r.concurrency,()=>finalizersMaskInternal(RW,r?.concurrentFinalizers)(r=>i?forEachConcurrentDiscard(e,(e,n)=>r(t(e,n)),!0,!1,1):UR(e,(e,n)=>r(t(e,n)))),()=>finalizersMaskInternal(DW,r?.concurrentFinalizers)(r=>forEachConcurrentDiscard(e,(e,n)=>r(t(e,n)),i,!1)),n=>finalizersMaskInternal(parallelN(n),r?.concurrentFinalizers)(r=>forEachConcurrentDiscard(e,(e,n)=>r(t(e,n)),i,!1,n))):match$u(r?.concurrency,()=>finalizersMaskInternal(RW,r?.concurrentFinalizers)(r=>i?forEachParN(e,1,(e,n)=>r(t(e,n)),!0):LR(e,(e,n)=>r(t(e,n)))),()=>finalizersMaskInternal(DW,r?.concurrentFinalizers)(r=>forEachParUnbounded(e,(e,n)=>r(t(e,n)),i)),n=>finalizersMaskInternal(parallelN(n),r?.concurrentFinalizers)(r=>forEachParN(e,n,(e,n)=>r(t(e,n)),i)))})),forEachParUnbounded=(e,t,r)=>suspend$g(()=>{const n=fromIterable$v(e),i=Array(n.length);return lD(forEachConcurrentDiscard(n,(e,r)=>PR(t(e,r),e=>sync$l(()=>i[r]=e)),r,!1),succeed$u(i))}),forEachConcurrentDiscard=(e,t,r,n,i)=>uninterruptibleMask$2(s=>transplant$1(o=>withFiberRuntime$1(a=>{let u=Array.from(e).reverse(),c=u.length;if(0===c)return tD;let l=0,p=!1;const d=i?Math.min(u.length,i):u.length,m=new Set,g=[],y=[],b=[],S=[],collectExits=()=>{const e=g.filter(({exit:e})=>"Failure"===e._tag).sort((e,t)=>e.index<t.index?-1:e.index===t.index?0:1).map(({exit:e})=>e);return 0===e.length&&e.push(UL),e},runFiber=(e,t=!1)=>{const r=uninterruptible$2(o(e)),n=unsafeForkUnstarted(r,a,a.currentRuntimeFlags,pG);return a.currentScheduler.scheduleTask(()=>{t&&n.unsafeInterruptAsFork(a.id()),n.resume(r)},0),n},onInterruptSignal=()=>{n||(c-=u.length,u=[]),p=!0,m.forEach(e=>{e.currentScheduler.scheduleTask(()=>{e.unsafeInterruptAsFork(a.id())},0)})},v=r?step$1:exit$2,_=runFiber(async_(e=>{const pushResult=(e,t)=>{"Blocked"===e._op?S.push(e):(g.push({index:t,exit:e}),"Failure"!==e._op||p||onInterruptSignal())},next=()=>{if(u.length>0){const n=u.pop();let o=l++;const returnNextElement=()=>{const e=u.pop();return o=l++,PR(yieldNow$3(),()=>PR(v(s(t(e,o))),onRes))},onRes=e=>u.length>0&&(pushResult(e,o),u.length>0)?returnNextElement():succeed$u(e),d=PR(v(s(t(n,o))),onRes),_=runFiber(d);y.push(_),m.add(_),p&&_.currentScheduler.scheduleTask(()=>{_.unsafeInterruptAsFork(a.id())},0),_.addObserver(t=>{let n;if(n="Failure"===t._op?t:t.effect_instruction_i0,b.push(_),m.delete(_),pushResult(n,o),g.length===c)e(succeed$u(Kt(exitCollectAll(collectExits(),{parallel:!0}),()=>UL)));else if(S.length+g.length===c){const t=collectExits(),n=S.map(e=>e.effect_instruction_i0).reduce(par);e(succeed$u(blocked$1(n,forEachConcurrentDiscard([Kt(exitCollectAll(t,{parallel:!0}),()=>UL),...S.map(e=>e.effect_instruction_i1)],e=>e,r,!0,i))))}else next()})}};for(let e=0;e<d;e++)next()}));return asVoid$9(GR(flatten$c(s(join$4(_))),DL({onFailure:e=>{onInterruptSignal();const t=S.length+1,r=Math.min("number"==typeof i?i:S.length,S.length),n=Array.from(S);return async_(i=>{let s=0;const check=(r,o)=>r=>{s++,s===t&&i(exitSucceed$1(exitFailCause$1(e))),n.length>0&&o&&next()},next=()=>{runFiber(n.pop(),!0).addObserver(check(0,!0))};_.addObserver(check(0,!1));for(let e=0;e<r;e++)next()})},onSuccess:()=>LR(b,e=>e.inheritAll)})))}))),forEachParN=(e,t,r,n)=>suspend$g(()=>{const i=fromIterable$v(e),s=Array(i.length);return lD(forEachConcurrentDiscard(i,(e,t)=>qR(r(e,t),e=>s[t]=e),n,!1,t),succeed$u(s))}),fork$2=e=>withFiberRuntime$1((t,r)=>succeed$u(unsafeFork$1(e,t,r.runtimeFlags))),forkDaemon$1=e=>forkWithScopeOverride(e,pG),uQ=dual(2,(e,t)=>fork$2(KR(e,e=>{const r=failureOrCause$1(e);switch(r._tag){case"Left":return t(r.left);case"Right":return failCause$j(r.right)}}))),unsafeFork$1=(e,t,r,n=null)=>{const i=unsafeMakeChildFiber(e,t,r,n);return i.resume(e),i},unsafeForkUnstarted=(e,t,r,n=null)=>unsafeMakeChildFiber(e,t,r,n),unsafeMakeChildFiber=(e,t,r,n=null)=>{const i=unsafeMake$h(),s=t.getFiberRefs(),o=EB(s,i),a=new FiberRuntime(i,o,r),u=MB(o,$D),c=a.currentSupervisor;return c.onStart(u,e,Ut(t),a),a.addObserver(e=>c.onEnd(e,a)),(null!==n?n:pipe(t.getFiberRef(tL),Kt(()=>t.scope()))).add(r,a),a},forkWithScopeOverride=(e,t)=>withFiberRuntime$1((r,n)=>succeed$u(unsafeFork$1(e,r,n.runtimeFlags,t))),cQ=dual(e=>A(e[2]),(e,t,r,n)=>matchSimple(n?.concurrency,()=>fromIterable$v(e).reduce((e,t,n)=>pD(e,t,(e,t)=>r(e,t,n)),succeed$u(t)),()=>PR(Nz(t),t=>PR(aQ(e,(e,n)=>PR(e,e=>qz(t,t=>r(t,e,n))),n),()=>jz(t))))),lQ=dual(e=>isIterable(e[0]),(e,t,r)=>pipe(aQ(e,(e,r)=>either$a(t(e,r)),r),qR(e=>QR(e,identity$5)))),pQ=dual(e=>isIterable(e[0]),(e,t,r)=>PR(lQ(e,t,{concurrency:r?.concurrency,batching:r?.batching,concurrentFinalizers:r?.concurrentFinalizers}),([e,t])=>ui(e)?fail$r(e):r?.discard?tD:succeed$u(t))),fQ=dual(e=>isIterable(e[0])&&!isEffect$1(e[0]),(e,t,r,n)=>matchSimple(n?.concurrency,()=>fromIterable$v(e).reduce((e,t,n)=>pD(e,t,(e,t)=>r(e,t,n)),t),()=>suspend$g(()=>pipe(cQ([t,...e],none$c(),(e,t,n)=>{switch(e._tag){case"None":return Ut(t);case"Some":return Ut(r(e.value,t,n))}},n),qR(e=>{switch(e._tag){case"None":throw Error("BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/effect/issues");case"Some":return e.value}}))))),parallelFinalizers$1=e=>contextWithEffect$7(t=>qt(DA(t,_Q),{onNone:()=>e,onSome:t=>{switch(t.strategy._tag){case"Parallel":return e;case"Sequential":case"ParallelN":return PR(scopeFork(t,DW),t=>xQ(e,t))}}})),parallelNFinalizers=e=>t=>contextWithEffect$7(r=>qt(DA(r,_Q),{onNone:()=>t,onSome:r=>"ParallelN"===r.strategy._tag&&r.strategy.parallelism===e?t:PR(scopeFork(r,parallelN(e)),e=>xQ(t,e))})),finalizersMaskInternal=(e,t)=>r=>contextWithEffect$7(n=>qt(DA(n,_Q),{onNone:()=>r(identity$5),onSome:n=>{if(!0!==t)return r(identity$5);{const t="Parallel"===e._tag?parallelFinalizers$1:"Sequential"===e._tag?sequentialFinalizers$1:parallelNFinalizers(e.parallelism);switch(n.strategy._tag){case"Parallel":return t(r(parallelFinalizers$1));case"Sequential":return t(r(sequentialFinalizers$1));case"ParallelN":return t(r(parallelNFinalizers(n.strategy.parallelism)))}}}})),scopeWith$1=e=>PR(_Q,e),scopedWith$5=e=>PR(scopeMake(),t=>GR(e(t),e=>t.close(e))),scopedEffect=e=>PR(scopeMake(),t=>IQ(e,t)),sequentialFinalizers$1=e=>contextWithEffect$7(t=>qt(DA(t,_Q),{onNone:()=>e,onSome:t=>{switch(t.strategy._tag){case"Sequential":return e;case"Parallel":case"ParallelN":return PR(scopeFork(t,RW),t=>xQ(e,t))}}})),labelMetricsScoped$1=e=>OQ(XD,t=>is(t,e)),hQ=dual(2,(e,t)=>scopedWith$5(r=>PR(xQ(e,r),t))),dQ=dual(e=>isEffect$1(e[1]),(e,t,r)=>mQ(e,t,(e,t)=>[e,t],r)),mQ=dual(e=>isEffect$1(e[1]),(e,t,r,n)=>flatten$c(vQ(exit$2(e),exit$2(t),(e,t)=>KL(e,t,{onSuccess:r,onFailure:(e,t)=>n?.concurrent?parallel$4(e,t):sequential$4(e,t)}),n))),gQ=dual(e=>isIterable(e[0]),(e,t,r)=>flip$4(aQ(e,(e,r)=>flip$4(t(e,r)),r))),withClockScoped$1=e=>OQ(pB,NA(c$,e)),withConfigProviderScoped$1=e=>OQ(pB,NA(W$,e)),yQ=dual(e=>isEffect$1(e[1]),(e,t,r)=>vQ(e,t,(e,t)=>[e,t],r)),bQ=dual(e=>isEffect$1(e[1]),(e,t,r)=>!0===r?.concurrent||void 0!==r?.batching&&!1!==r.batching?vQ(e,t,(e,t)=>e,r):cD(e,t)),SQ=dual(e=>isEffect$1(e[1]),(e,t,r)=>!0===r?.concurrent||void 0!==r?.batching&&!1!==r.batching?vQ(e,t,(e,t)=>t,r):lD(e,t)),vQ=dual(e=>isEffect$1(e[1]),(e,t,r,n)=>qR(all$6([e,t],{concurrency:n?.concurrent?2:1,batching:n?.batching,concurrentFinalizers:n?.concurrentFinalizers}),([e,t])=>r(e,t))),withRuntimeFlagsScoped=e=>e===Nj?tD:pipe(YR,PR(t=>{const r=Fj(t,e),n=Mj(r,t);return pipe(updateRuntimeFlags$2(e),lD(addFinalizer$2(()=>updateRuntimeFlags$2(n))),asVoid$9)}),uninterruptible$2),_Q=GenericTag("effect/Scope"),wQ=_Q,kQ={[aL]:aL,[uL]:uL,pipe(){return pipeArguments(this,arguments)},fork(e){return sync$l(()=>{const t=scopeUnsafeMake(e);if("Closed"===this.state._tag)return t.state=this.state,t;const r={};return this.state.finalizers.set(r,e=>t.close(e)),((e,t)=>{"Open"===e.state._tag&&e.state.finalizers.set({},t)})(t,e=>sync$l(()=>{"Open"===this.state._tag&&this.state.finalizers.delete(r)})),t})},close(e){return suspend$g(()=>{if("Closed"===this.state._tag)return tD;const t=Array.from(this.state.finalizers.values()).reverse();return this.state={_tag:"Closed",exit:e},0===t.length?tD:isSequential$1(this.strategy)?pipe(LR(t,t=>exit$2(t(e))),PR(e=>pipe(exitCollectAll(e),er(exitAsVoid),Kt(()=>UL)))):isParallel$1(this.strategy)?pipe(forEachParUnbounded(t,t=>exit$2(t(e)),!1),PR(e=>pipe(exitCollectAll(e,{parallel:!0}),er(exitAsVoid),Kt(()=>UL)))):pipe(forEachParN(t,this.strategy.parallelism,t=>exit$2(t(e)),!1),PR(e=>pipe(exitCollectAll(e,{parallel:!0}),er(exitAsVoid),Kt(()=>UL))))})},addFinalizer(e){return suspend$g(()=>"Closed"===this.state._tag?e(this.state.exit):(this.state.finalizers.set({},e),tD))}},scopeUnsafeMake=(e=jW)=>{const t=Object.create(kQ);return t.strategy=e,t.state={_tag:"Open",finalizers:new Map},t},scopeMake=(e=jW)=>sync$l(()=>scopeUnsafeMake(e)),xQ=dual(2,(e,t)=>uU(e,LA(PA(_Q,t)))),IQ=dual(2,(e,t)=>pipe(e,xQ(t),GR(e=>t.close(e)))),fiberRefUnsafeMakeSupervisor=e=>fiberRefUnsafeMakePatch(e,{differ:CZ,fork:AZ}),TQ=dual(2,(e,t)=>asVoid$9(eQ(PR(fiberRefGet(e),r=>TR(AD(e,t),r)),t=>AD(e,t)))),OQ=dual(2,(e,t)=>ED(e,r=>TQ(e,t(r)))),fiberRefMake=(e,t)=>fiberRefMakeWith(()=>fiberRefUnsafeMake(e,t)),fiberRefMakeWith=e=>eQ(XR(sync$l(e),e=>MD(e,identity$5)),e=>fiberRefDelete(e)),EQ=fiberRefUnsafeMakeRuntimeFlags(Cj),AQ=fiberRefUnsafeMakeSupervisor(vZ),fiberAwaitAll=e=>aQ(e,_await$3),fiberAll=e=>{const t={...cz,commit(){return join$4(this)},[fG]:hG,id:()=>fromIterable$v(e).reduce((e,t)=>cP(e,t.id()),aP),await:exit$2(forEachParUnbounded(e,e=>flatten$c(e.await),!1)),children:qR(forEachParUnbounded(e,e=>e.children,!1),cs),inheritAll:UR(e,e=>e.inheritAll),poll:qR(LR(e,e=>e.poll),bs(Ut(exitSucceed$1([])),(e,t)=>{switch(t._tag){case"None":return none$c();case"Some":switch(e._tag){case"None":return none$c();case"Some":return Ut(KL(t.value,e.value,{onSuccess:(e,t)=>[e,...t],onFailure:parallel$4}))}}})),interruptAsFork:t=>UR(e,e=>e.interruptAsFork(t))};return t},CQ=dual(3,(e,t,r)=>FQ(e,t,{onSelfWin:(e,t)=>PR(e.await,n=>{switch(n._tag){case de:return PR(e.inheritAll,()=>r.onSelfDone(n,t));case le:return r.onSelfDone(n,t)}}),onOtherWin:(e,t)=>PR(e.await,n=>{switch(n._tag){case de:return PR(e.inheritAll,()=>r.onOtherDone(n,t));case le:return r.onOtherDone(n,t)}})})),MQ=dual(2,(e,t)=>fiberIdWith$1(r=>CQ(e,t,{onSelfDone:(e,t)=>LL(e,{onFailure:e=>pipe(join$4(t),Wq(t=>parallel$4(e,t))),onSuccess:e=>pipe(t,hD(r),TR(e))}),onOtherDone:(e,t)=>LL(e,{onFailure:e=>pipe(join$4(t),Wq(t=>parallel$4(t,e))),onSuccess:e=>pipe(t,hD(r),TR(e))})}))),FQ=dual(3,(e,t,r)=>withFiberRuntime$1((n,i)=>{const s=i.runtimeFlags,o=make$27(!0),a=unsafeMakeChildFiber(e,n,s,r.selfScope),u=unsafeMakeChildFiber(t,n,s,r.otherScope);return async_(n=>{a.addObserver(()=>completeRace(a,u,r.onSelfWin,o,n)),u.addObserver(()=>completeRace(u,a,r.onOtherWin,o,n)),a.startFork(e),u.startFork(t)},cP(a.id(),u.id()))})),completeRace=(e,t,r,n,i)=>{$F(!0,!1)(n)&&i(r(e,t))},PQ=dual(2,(e,t)=>uninterruptibleMask$2(r=>RR(r(e),{onFailure:e=>RR(t,{onFailure:t=>failCause$j(sequential$4(e,t)),onSuccess:()=>failCause$j(e)}),onSuccess:e=>TR(t,e)}))),invokeWithInterrupt=(e,t,r)=>fiberIdWith$1(n=>PR(PR(forkDaemon$1(interruptible$3(e)),e=>async_(n=>{const i=t.map(e=>e.listeners.count),checkDone=()=>{i.every(e=>0===e)&&t.every(e=>"Pending"===e.result.state.current._tag||!("Done"!==e.result.state.current._tag||!exitIsExit(e.result.state.current.effect)||"Failure"!==e.result.state.current.effect._tag||!isInterrupted$2(e.result.state.current.effect.cause)))&&(s.forEach(e=>e()),r?.(),n(interruptFiber(e)))};e.addObserver(e=>{s.forEach(e=>e()),n(e)});const s=t.map((e,t)=>{const observer=e=>{i[t]=e,checkDone()};return e.listeners.addObserver(observer),()=>e.listeners.removeObserver(observer)});return checkDone(),sync$l(()=>{s.forEach(e=>e())})})),()=>suspend$g(()=>{const e=t.flatMap(e=>e.state.completed?[]:[e]);return UR(e,e=>fH(e.request,exitInterrupt$1(n)))}))),NQ=dual(2,(e,t)=>ED(sG,r=>suspend$g(()=>{const n=fromIterable$v(t).flatMap(e=>r.has(e)?[r.get(e)]:[]);return invokeWithInterrupt(e,n)}))),makeSpanScoped$1=(name,e)=>(e=addSpanStackTrace(e),uninterruptible$2(withFiberRuntime$1(t=>{const r=RA(t.getFiberRef($D),_Q),n=unsafeMakeSpan(t,name,e),i=t.getFiberRef(iL),s=jA(t.getFiberRef(pB),c$);return TR(scopeAddFinalizerExit(r,e=>endSpan(n,e,s,i)),n)}))),withTracerScoped$1=e=>OQ(pB,NA(sB,e)),complete$2=(e,t,r,n)=>struct$2({_tag:"Complete",key:e,exit:t,entryStats:r,timeToLiveMillis:n}),pending$3=(e,t)=>struct$2({_tag:"Pending",key:e,deferred:t}),jQ=Symbol.for("effect/Cache/MapKey");class MapKeyImpl{current;[jQ]=jQ;previous=void 0;next=void 0;constructor(e){this.current=e}[Z](){return pipe(hash$3(this.current),combine$h(hash$3(this.previous)),combine$h(hash$3(this.next)),cached$2(this))}[Y](e){return this===e||isMapKey(e)&&equals$4(this.current,e.current)&&equals$4(this.previous,e.previous)&&equals$4(this.next,e.next)}}const makeMapKey=e=>new MapKeyImpl(e),isMapKey=e=>C(e,jQ);class KeySetImpl{head=void 0;tail=void 0;add(e){if(e!==this.tail)if(void 0===this.tail)this.head=e,this.tail=e;else{const t=e.previous,r=e.next;void 0!==r&&(e.next=void 0,void 0!==t?(t.next=r,r.previous=t):(this.head=r,this.head.previous=void 0)),this.tail.next=e,e.previous=this.tail,this.tail=e}}remove(){const e=this.head;if(void 0!==e){const t=e.next;void 0!==t?(e.next=void 0,this.head=t,this.head.previous=void 0):(this.head=void 0,this.tail=void 0)}return e}}const makeKeySet=()=>new KeySetImpl,RQ=Symbol.for("effect/Cache"),DQ={_Key:e=>e,_Error:e=>e,_Value:e=>e},LQ=Symbol.for("effect/ConsumerCache"),UQ={_Key:e=>e,_Error:e=>e,_Value:e=>e},makeEntryStats$1=e=>({loadedMillis:e});class CacheImpl{capacity;context;fiberId;lookup;timeToLive;[RQ]=DQ;[LQ]=UQ;cacheState;constructor(e,t,r,n,i){this.capacity=e,this.context=t,this.fiberId=r,this.lookup=n,this.timeToLive=i,this.cacheState={map:empty$B(),keys:makeKeySet(),accesses:unbounded$8(),updating:make$27(!1),hits:0,misses:0}}get(e){return qR(this.getEither(e),ct)}get cacheStats(){return sync$l(()=>({hits:this.cacheState.hits,misses:this.cacheState.misses,size:size$t(this.cacheState.map)}))}getOption(e){return suspend$g(()=>qt(zU(this.cacheState.map,e),{onNone:()=>{const t=makeMapKey(e);return this.trackAccess(t),this.trackMiss(),succeed$u(none$c())},onSome:e=>this.resolveMapValue(e)}))}getOptionComplete(e){return suspend$g(()=>qt(zU(this.cacheState.map,e),{onNone:()=>{const t=makeMapKey(e);return this.trackAccess(t),this.trackMiss(),succeed$u(none$c())},onSome:e=>this.resolveMapValue(e,!0)}))}contains(e){return sync$l(()=>qU(this.cacheState.map,e))}entryStats(e){return sync$l(()=>{const t=zU(this.cacheState.map,e);if(zt(t))switch(t.value._tag){case"Complete":{const e=t.value.entryStats.loadedMillis;return Ut(makeEntryStats$1(e))}case"Pending":return none$c();case"Refreshing":{const e=t.value.complete.entryStats.loadedMillis;return Ut(makeEntryStats$1(e))}}return none$c()})}getEither(e){return suspend$g(()=>{const t=e;let r,n,i=Qt(zU(this.cacheState.map,t));return void 0===i&&(n=bU(this.fiberId),r=makeMapKey(t),qU(this.cacheState.map,t)?i=Qt(zU(this.cacheState.map,t)):WU(this.cacheState.map,t,pending$3(r,n))),void 0===i?(this.trackAccess(r),this.trackMiss(),qR(this.lookupValueOf(e,n),Ge)):PR(this.resolveMapValue(i),qt({onNone:()=>this.getEither(e),onSome:e=>succeed$u(He(e))}))})}invalidate(e){return sync$l(()=>{GU(this.cacheState.map,e)})}invalidateWhen(e,t){return sync$l(()=>{const r=zU(this.cacheState.map,e);zt(r)&&"Complete"===r.value._tag&&"Success"===r.value.exit._tag&&t(r.value.exit.value)&&GU(this.cacheState.map,e)})}get invalidateAll(){return sync$l(()=>{this.cacheState.map=empty$B()})}refresh(e){return fq(t=>suspend$g(()=>{const r=e,n=bU(this.fiberId);let i=Qt(zU(this.cacheState.map,r));if(void 0===i&&(qU(this.cacheState.map,r)?i=Qt(zU(this.cacheState.map,r)):WU(this.cacheState.map,r,pending$3(makeMapKey(r),n))),void 0===i)return asVoid$9(this.lookupValueOf(e,n));switch(i._tag){case"Complete":return this.hasExpired(t,i.timeToLiveMillis)?(equals$4(Qt(zU(this.cacheState.map,r)),i)&&GU(this.cacheState.map,r),asVoid$9(this.get(e))):pipe(this.lookupValueOf(e,n),SW(()=>{if(equals$4(Qt(zU(this.cacheState.map,r)),i)){const e=((e,t)=>struct$2({_tag:"Refreshing",deferred:e,complete:t}))(n,i);return WU(this.cacheState.map,r,e),!0}return!1}),asVoid$9);case"Pending":case"Refreshing":return hU(i.deferred)}}))}set(e,t){return fq(r=>sync$l(()=>{const n=r.unsafeCurrentTimeMillis(),i=e,s=NU(t),o=complete$2(makeMapKey(i),s,makeEntryStats$1(n),n+toMillis(decode$5(this.timeToLive(s))));WU(this.cacheState.map,i,o)}))}get size(){return sync$l(()=>size$t(this.cacheState.map))}get values(){return sync$l(()=>{const e=[];for(const t of this.cacheState.map)"Complete"===t[1]._tag&&"Success"===t[1].exit._tag&&e.push(t[1].exit.value);return e})}get entries(){return sync$l(()=>{const e=[];for(const t of this.cacheState.map)"Complete"===t[1]._tag&&"Success"===t[1].exit._tag&&e.push([t[0],t[1].exit.value]);return e})}get keys(){return sync$l(()=>{const e=[];for(const t of this.cacheState.map)"Complete"===t[1]._tag&&"Success"===t[1].exit._tag&&e.push(t[0]);return e})}resolveMapValue(e,t=!1){return fq(r=>{switch(e._tag){case"Complete":return this.trackAccess(e.key),this.hasExpired(r,e.timeToLiveMillis)?(GU(this.cacheState.map,e.key.current),succeed$u(none$c())):(this.trackHit(),qR(e.exit,Ut));case"Pending":return this.trackAccess(e.key),this.trackHit(),t?succeed$u(none$c()):qR(hU(e.deferred),Ut);case"Refreshing":return this.trackAccess(e.complete.key),this.trackHit(),this.hasExpired(r,e.complete.timeToLiveMillis)?t?succeed$u(none$c()):qR(hU(e.deferred),Ut):qR(e.complete.exit,Ut)}})}trackHit(){this.cacheState.hits=this.cacheState.hits+1}trackMiss(){this.cacheState.misses=this.cacheState.misses+1}trackAccess(e){if(n$(this.cacheState.accesses,e),$F(this.cacheState.updating,!1,!0)){let e=!0;for(;e;){const t=s$(this.cacheState.accesses,t$);t===t$?e=!1:this.cacheState.keys.add(t)}let t=size$t(this.cacheState.map);for(e=t>this.capacity;e;){const r=this.cacheState.keys.remove();void 0!==r?qU(this.cacheState.map,r.current)&&(GU(this.cacheState.map,r.current),t-=1,e=t>this.capacity):e=!1}qF(this.cacheState.updating,!1)}}hasExpired(e,t){return e.unsafeCurrentTimeMillis()>t}lookupValueOf(e,t){return fq(r=>suspend$g(()=>{const n=e;return pipe(this.lookup(e),oU(this.context),exit$2,PR(e=>{const i=r.unsafeCurrentTimeMillis(),s=makeEntryStats$1(i),o=complete$2(makeMapKey(n),e,s,i+toMillis(decode$5(this.timeToLive(e))));return WU(this.cacheState.map,n,o),lD(dU(t,e),e)}),JR(()=>lD(interrupt$8(t),sync$l(()=>{GU(this.cacheState.map,n)}))))}))}}const make$1B=e=>{const t=decode$5(e.timeToLive);return makeWith$7({capacity:e.capacity,lookup:e.lookup,timeToLive:()=>t})},makeWith$7=e=>qR(all$6([context$c(),FR]),([t,r])=>new CacheImpl(e.capacity,t,r,e.lookup,t=>decode$5(e.timeToLive(t))));var $Q=Object.freeze({__proto__:null,CacheTypeId:RQ,ConsumerCacheTypeId:LQ,make:make$1B,makeCacheStats:e=>e,makeEntryStats:makeEntryStats$1,makeWith:makeWith$7});const BQ=tR,zQ=fail$s,qQ=die$h,WQ=interrupt$a,VQ=parallel$4,KQ=sequential$4,GQ=isCause$1,isFailType=e=>e._tag===Jj,JQ=isDieType$1,HQ=isInterrupted$2,ZQ=isInterruptedOnly$1,QQ=interruptors$1,YQ=failureOrCause$1,flipCauseOption=e=>dR(e,{onEmpty:Ut(tR),onFail:er(fail$s),onDie:e=>Ut(die$h(e)),onInterrupt:e=>Ut(interrupt$a(e)),onSequential:mergeWith$4(sequential$4),onParallel:mergeWith$4(parallel$4)}),XQ=iR,squash=e=>cL(identity$5)(e),eY=gR,tY=gL,rY=bL,nY=fL,isRuntimeException=e=>C(e,pL),iY=pretty$4;var sY=Object.freeze({__proto__:null,CauseTypeId:Xj,ExceededCapacityException:wL,ExceededCapacityExceptionTypeId:_L,IllegalArgumentException:tY,IllegalArgumentExceptionTypeId:mL,InterruptedException:dL,InterruptedExceptionTypeId:hL,InvalidPubSubCapacityExceptionTypeId:SL,NoSuchElementException:rY,NoSuchElementExceptionTypeId:yL,RuntimeException:nY,RuntimeExceptionTypeId:pL,TimeoutException:xL,TimeoutExceptionTypeId:kL,UnknownException:TL,UnknownExceptionTypeId:IL,YieldableError:lL,andThen:oR,as:nR,contains:aR,defects:defects$1,die:qQ,dieOption:dieOption$1,empty:BQ,fail:zQ,failureOption:failureOption$1,failureOrCause:YQ,failures:failures$1,filter:cR,find:uR,flatMap:sR,flatten:flatten$d,flipCauseOption,interrupt:WQ,interruptOption:interruptOption$1,interruptors:QQ,isCause:GQ,isDie:e=>zt(dieOption$1(e)),isDieType:JQ,isEmpty:isEmpty$o,isEmptyType:isEmptyType$1,isExceededCapacityException:e=>C(e,_L),isFailType,isFailure:e=>zt(failureOption$1(e)),isIllegalArgumentException:e=>C(e,mL),isInterruptType:e=>e._tag===Hj,isInterrupted:HQ,isInterruptedException:isInterruptedException$1,isInterruptedOnly:ZQ,isNoSuchElementException:isNoSuchElementException$1,isParallelType:e=>e._tag===Zj,isRuntimeException,isSequentialType:e=>e._tag===Qj,isTimeoutException:e=>C(e,kL),isUnknownException:e=>C(e,IL),keepDefects:keepDefects$1,linearize:e=>dR(e,{onEmpty:IF(),onFail:e=>make$28(fail$s(e)),onDie:e=>make$28(die$h(e)),onInterrupt:e=>make$28(interrupt$a(e)),onSequential:(e,t)=>NF(e,e=>PF(t,t=>sequential$4(e,t))),onParallel:(e,t)=>NF(e,e=>PF(t,t=>parallel$4(e,t)))}),map:XQ,match:dR,originalError:e=>C(e,MR)?e[MR]:e,parallel:VQ,pretty:iY,prettyErrors:prettyErrors$1,reduce:mR,reduceWithContext:eY,sequential:KQ,size:e=>gR(e,void 0,lR),squash,squashWith:cL,stripFailures:stripFailures$1,stripSomeDefects:rR});const oY=Symbol.for("effect/ScheduleInterval"),aY={[oY]:oY,startMillis:0,endMillis:0},make$1z=(e,t)=>e>t?aY:{[oY]:oY,startMillis:e,endMillis:t},uY=dual(2,(e,t)=>cY(e,t)===e),cY=dual(2,(e,t)=>e.endMillis<=t.startMillis?e:t.endMillis<=e.startMillis?t:e.startMillis<t.startMillis?e:t.startMillis<e.startMillis?t:e.endMillis<=t.endMillis?e:t),lY=dual(2,(e,t)=>cY(e,t)===e?t:e),isEmpty$j=e=>e.startMillis>=e.endMillis,pY=dual(2,(e,t)=>{const start=Math.max(e.startMillis,t.startMillis),r=Math.min(e.endMillis,t.endMillis);return make$1z(start,r)}),fY=dual(2,(e,t)=>{const start=Math.max(e.startMillis,t.startMillis),r=Math.min(e.endMillis,t.endMillis);return start<r?none$c():Ut(make$1z(start,r))}),hY=make$1z,dY=aY,mY=uY,gY=isEmpty$j,yY=pY,size$n=e=>millis(e.endMillis-e.startMillis),after=e=>make$1z(e,1/0);var bY=Object.freeze({__proto__:null,IntervalTypeId:oY,after,before:e=>make$1z(-1/0,e),empty:dY,intersect:yY,isEmpty:gY,isNonEmpty:e=>!isEmpty$j(e),lessThan:mY,make:hY,max:lY,min:cY,size:size$n,union:fY});const SY=Symbol.for("effect/ScheduleIntervals"),make$1x=e=>({[SY]:SY,intervals:e}),vY=make$1x(empty$R()),_Y=dual(2,(e,t)=>isNonEmpty$8(t.intervals)?isNonEmpty$8(e.intervals)?lC(e.intervals).startMillis<lC(t.intervals).startMillis?unionLoop(tailNonEmpty(e.intervals),t.intervals,lC(e.intervals),empty$R()):unionLoop(e.intervals,tailNonEmpty(t.intervals),lC(t.intervals),empty$R()):t:e),unionLoop=(e,t,r,n)=>{let i=e,s=t,o=r,a=n;for(;isNonEmpty$8(i)||isNonEmpty$8(s);)if(!isNonEmpty$8(i)&&isNonEmpty$8(s))o.endMillis<lC(s).startMillis?(a=pipe(a,JA(o)),o=lC(s),s=tailNonEmpty(s),i=empty$R()):(o=hY(o.startMillis,lC(s).endMillis),s=tailNonEmpty(s),i=empty$R());else if(isNonEmpty$8(i)&&isEmpty$t(s))o.endMillis<lC(i).startMillis?(a=pipe(a,JA(o)),o=lC(i),s=empty$R(),i=tailNonEmpty(i)):(o=hY(o.startMillis,lC(i).endMillis),s=empty$R(),i=tailNonEmpty(i));else{if(!isNonEmpty$8(i)||!isNonEmpty$8(s))throw Error(getBugErrorMessage("Intervals.unionLoop"));lC(i).startMillis<lC(s).startMillis?o.endMillis<lC(i).startMillis?(a=pipe(a,JA(o)),o=lC(i),i=tailNonEmpty(i)):(o=hY(o.startMillis,lC(i).endMillis),i=tailNonEmpty(i)):o.endMillis<lC(s).startMillis?(a=pipe(a,JA(o)),o=lC(s),s=tailNonEmpty(s)):(o=hY(o.startMillis,lC(s).endMillis),s=tailNonEmpty(s))}return make$1x(pipe(a,JA(o),reverse$3))},wY=dual(2,(e,t)=>intersectLoop(e.intervals,t.intervals,empty$R())),intersectLoop=(e,t,r)=>{let n=e,i=t,s=r;for(;isNonEmpty$8(n)&&isNonEmpty$8(i);){const e=pipe(lC(n),yY(lC(i))),t=gY(e)?s:pipe(s,JA(e));pipe(lC(n),mY(lC(i)))?n=tailNonEmpty(n):i=tailNonEmpty(i),s=t}return make$1x(reverse$3(s))},start$3=e=>pipe(e.intervals,cC,Kt(()=>dY)).startMillis,kY=dual(2,(e,t)=>start$3(e)<start$3(t)),xY=dual(2,(e,t)=>kY(e,t)?t:e),IY=make$1x,TY=_Y,OY=wY,EY=start$3,end$4=e=>pipe(e.intervals,cC,Kt(()=>dY)).endMillis,AY=kY,isNonEmpty$4=e=>isNonEmpty$8(e.intervals),CY=xY;var MY=Object.freeze({__proto__:null,IntervalsTypeId:SY,empty:vY,end:end$4,fromIterable:e=>Array.from(e).reduce((e,t)=>pipe(e,_Y(make$1x(of$5(t)))),vY),intersect:OY,isNonEmpty:isNonEmpty$4,lessThan:AY,make:IY,max:CY,start:EY,union:TY});const FY="Continue",PY="Done",_continue=e=>({_tag:FY,intervals:e}),continueWith=e=>({_tag:FY,intervals:IY(of$5(e))}),NY={_tag:PY},isContinue$2=e=>e._tag===FY,isDone$3=e=>e._tag===PY;var jY=Object.freeze({__proto__:null,continue:_continue,continueWith,done:NY,isContinue:isContinue$2,isDone:isDone$3});const RY=_Q,DY=scopeAddFinalizer,LY=scopeAddFinalizerExit,UY=scopeClose,$Y=xQ,BY=scopeFork,zY=scopeMake;var qY=Object.freeze({__proto__:null,CloseableScopeTypeId:uL,Scope:RY,ScopeTypeId:aL,addFinalizer:DY,addFinalizerExit:LY,close:UY,extend:$Y,fork:BY,make:zY,use:IQ});class Semaphore{permits;waiters=new Set;taken=0;constructor(e){this.permits=e}get free(){return this.permits-this.taken}take=e=>asyncInterrupt(t=>{if(this.free<e){const observer=()=>{this.free<e||(this.waiters.delete(observer),this.taken+=e,t(succeed$u(e)))};return this.waiters.add(observer),sync$l(()=>{this.waiters.delete(observer)})}return this.taken+=e,t(succeed$u(e))});updateTakenUnsafe(e,t){return this.taken=t(this.taken),this.waiters.size>0&&e.getFiberRef(rG).scheduleTask(()=>{const e=this.waiters.values();let t=e.next();for(;!1===t.done&&this.free>0;)t.value(),t=e.next()},e.getFiberRef(BD)),succeed$u(this.free)}updateTaken(e){return withFiberRuntime$1(t=>this.updateTakenUnsafe(t,e))}resize=e=>asVoid$9(withFiberRuntime$1(t=>(this.permits=e,this.free<0?tD:this.updateTakenUnsafe(t,e=>e))));release=e=>this.updateTaken(t=>t-e);releaseAll=this.updateTaken(e=>0);withPermits=e=>t=>uninterruptibleMask$2(r=>PR(r(this.take(e)),e=>PQ(r(t),this.release(e))));withPermitsIfAvailable=e=>t=>uninterruptibleMask$2(r=>suspend$g(()=>this.free<e?tW:(this.taken+=e,PQ(r(asSome$4(t)),this.release(e)))))}const unsafeMakeSemaphore$2=e=>new Semaphore(e);class Latch extends hz{isOpen;waiters=[];scheduled=!1;constructor(e){super(),this.isOpen=e}commit(){return this.await}unsafeSchedule(e){return this.scheduled||0===this.waiters.length||(this.scheduled=!0,e.currentScheduler.scheduleTask(this.flushWaiters,e.getFiberRef(BD))),tD}flushWaiters=()=>{this.scheduled=!1;const e=this.waiters;this.waiters=[];for(let t=0;t<e.length;t++)e[t](UL)};open=withFiberRuntime$1(e=>this.isOpen?tD:(this.isOpen=!0,this.unsafeSchedule(e)));unsafeOpen(){this.isOpen||(this.isOpen=!0,this.flushWaiters())}release=withFiberRuntime$1(e=>this.isOpen?tD:this.unsafeSchedule(e));await=asyncInterrupt(e=>this.isOpen?e(tD):(this.waiters.push(e),sync$l(()=>{const t=this.waiters.indexOf(e);-1!==t&&this.waiters.splice(t,1)})));unsafeClose(){this.isOpen=!1}close=sync$l(()=>{this.isOpen=!1});whenOpen=e=>lD(this.await,e)}const unsafeMakeLatch$1=e=>new Latch(e??!1),WY=dual(2,(e,t)=>qR(VY(e,t),e=>e[0])),VY=dual(2,(e,t)=>{const r=decode$5(t);return PR(context$c(),t=>qR(makeSynchronized(none$c()),n=>[oU(getCachedValue(e,r,n),t),invalidateCache(n)]))}),computeCachedValue=(e,t,start)=>{const r=toMillis(decode$5(t));return pipe(deferredMake(),XR(t=>zR(e,t)),qR(e=>Ut([start+r,e])))},getCachedValue=(e,t,r)=>uninterruptibleMask$2(n=>pipe(fq(e=>e.currentTimeMillis),PR(n=>oX(r,r=>{switch(r._tag){case"None":return Ut(computeCachedValue(e,t,n));case"Some":{const[i]=r.value;return i-n<=0?Ut(computeCachedValue(e,t,n)):none$c()}}})),PR(e=>Bt(e)?dieMessage$9("BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues"):n(deferredAwait(e.value[1]))))),invalidateCache=e=>wz(e,none$c()),KY=dual(2,(e,t)=>GY(e,e=>t(fiberAll(e)))),GY=dual(2,(e,t)=>PR(SZ,r=>pipe(YY(e,r),PQ(PR(r.value,t))))),JY=dual(e=>isIterable(e[0]),(e,t)=>t?.discard?UR(e,fork$2):qR(LR(e,fork$2),fiberAll)),HY=dual(2,(e,t)=>withFiberRuntime$1((r,n)=>{const i=t,s=unsafeFork$1(e,r,n.runtimeFlags,pG);if("Open"===i.state._tag){const finalizer=()=>fiberIdWith$1(e=>equals$4(e,s.id())?tD:asVoid$9(interruptFiber(s))),e={};i.state.finalizers.set(e,finalizer),s.addObserver(()=>{"Closed"!==i.state._tag&&i.state.finalizers.delete(e)})}else s.unsafeInterruptAsFork(r.id());return succeed$u(s)})),forkScoped$1=e=>scopeWith$1(t=>HY(e,t)),ZY=Symbol.for("effect/Effect/memoizeFunction.key");class Key{a;eq;[ZY]=ZY;constructor(e,t){this.a=e,this.eq=t}[Y](e){return!!C(e,ZY)&&(this.eq?this.eq(this.a,e.a):equals$4(this.a,e.a))}[Z](){return this.eq?0:cached$2(this,hash$3(this.a))}}const QY=dual(2,(e,t)=>pipe(exit$2(e),MQ(exit$2(t)),e=>flatten$c(e))),YY=dual(2,(e,t)=>UD(AQ,e=>e.zip(t))(e)),XY=dual(2,(e,t)=>eX(e,{onTimeout:()=>(e=>new xL(`Operation timed out after '${format$4(e)}'`))(t),duration:t})),eX=dual(2,(e,{duration:t,onTimeout:r})=>flatten$c(nX(e,{onTimeout:()=>failSync$d(r),onSuccess:succeed$u,duration:t}))),tX=dual(2,(e,{duration:t,onTimeout:r})=>flatten$c(nX(e,{onTimeout:()=>failCauseSync$b(r),onSuccess:succeed$u,duration:t}))),rX=dual(2,(e,t)=>nX(e,{duration:t,onSuccess:Ut,onTimeout:none$c})),nX=dual(2,(e,{duration:t,onSuccess:r,onTimeout:n})=>fiberIdWith$1(i=>uninterruptibleMask$2(s=>FQ(s(e),interruptible$3(eW(t)),{onSelfWin:(e,t)=>PR(e.await,n=>"Success"===n._tag?PR(e.inheritAll,()=>TR(hD(t,i),r(n.value))):PR(hD(t,i),()=>exitFailCause$1(n.cause))),onOtherWin:(e,t)=>PR(e.await,r=>"Success"===r._tag?PR(e.inheritAll,()=>TR(hD(t,i),n())):PR(hD(t,i),()=>exitFailCause$1(r.cause))),otherScope:pG})))),iX=Symbol.for("effect/Ref/SynchronizedRef"),sX={_A:e=>e};class SynchronizedImpl extends hz{ref;withLock;[iX]=sX;[vz]=_z;[mz]=mz;constructor(e,t){super(),this.ref=e,this.withLock=t,this.get=get$z(this.ref)}get;commit(){return this.get}modify(e){return this.modifyEffect(t=>succeed$u(e(t)))}modifyEffect(e){return this.withLock(pipe(PR(get$z(this.ref),e),PR(([e,t])=>TR(wz(this.ref,t),e))))}}const makeSynchronized=e=>sync$l(()=>unsafeMakeSynchronized(e)),unsafeMakeSynchronized=e=>{const t=unsafeMake$d(e),r=unsafeMakeSemaphore$2(1);return new SynchronizedImpl(t,r.withPermits(1))},oX=dual(2,(e,t)=>e.modifyEffect(e=>{const r=t(e);switch(r._tag){case"None":return succeed$u([e,e]);case"Some":return qR(r.value,e=>[e,e])}})),aX=dual(2,(e,t)=>lX(e,t,(e,t)=>[e,t])),uX=dual(2,(e,t)=>lX(e,t,(e,t)=>e)),cX=dual(2,(e,t)=>lX(e,t,(e,t)=>t)),lX=dual(3,(e,t,r)=>({...cz,commit(){return join$4(this)},[fG]:hG,id:()=>pipe(e.id(),lP(t.id())),await:pipe(e.await,flatten$c,vQ(flatten$c(t.await),r,{concurrent:!0}),exit$2),children:e.children,inheritAll:lD(t.inheritAll,e.inheritAll),poll:pD(e.poll,t.poll,(e,t)=>pipe(e,ir(e=>pipe(t,er(t=>LU(e,t,{onSuccess:r,onFailure:parallel$4})))))),interruptAsFork:r=>lD(e.interruptAsFork(r),t.interruptAsFork(r)),pipe(){return pipeArguments(this,arguments)}})),pX=dual(e=>isEffect$1(e[0]),(e,t,r)=>PR(e,e=>all$6(t(e),r).pipe(qR(t=>Object.assign({},e,t))))),fX=Symbol.for("effect/ManagedRuntime"),hX="Fresh",dX="ProvideMerge",mX=_await$3,gX=inheritAll$1,yX=interruptFiber,bX=hD,SX=yG,vX=join$4,poll$8=e=>e.poll;var _X=Object.freeze({__proto__:null,FiberTypeId:fG,Order:gG,RuntimeFiberTypeId:mG,all:fiberAll,await:mX,awaitAll:fiberAwaitAll,children:e=>e.children,done:done$b,dump:dump$1,dumpAll:e=>LR(e,dump$1),fail:e=>done$b(TU(e)),failCause:failCause$f,fromEffect:e=>qR(exit$2(e),done$b),getCurrentFiber:()=>fromNullable$3(globalThis[EG]),id:e=>e.id(),inheritAll:gX,interrupt:yX,interruptAll:e=>PR(FR,t=>pipe(e,yG(t))),interruptAllAs:SX,interruptAs:bX,interruptAsFork:bG,interruptFork:e=>asVoid$9(forkDaemon$1(interruptFiber(e))),interrupted:e=>done$b(AU(e)),isFiber:e=>C(e,fG),isRuntimeFiber:isRuntimeFiber$1,join:vX,joinAll:e=>join$4(fiberAll(e)),map:SG,mapEffect:vG,mapFiber:_G,match:wG,never:kG,orElse:xG,orElseEither:IG,poll:poll$8,pretty:e=>PR(_B,t=>qR(dump$1(e),e=>{const r=t-e.id.startTimeMillis,{days:n,hours:i,milliseconds:s,minutes:o,seconds:a}=(e=>{const t=e>0?Math.floor:Math.ceil;return{days:t(e/864e5),hours:t(e/36e5)%24,minutes:t(e/6e4)%60,seconds:t(e/1e3)%60,milliseconds:t(e)%1e3,microseconds:t(1e3*e)%1e3,nanoseconds:t(1e6*e)%1e3}})(r),u=(0===n?"":n+"d")+(0===n&&0===i?"":i+"h")+(0===n&&0===i&&0===o?"":o+"m")+(0===n&&0===i&&0===o&&0===a?"":a+"s")+s+"ms",c=isSuspended(e.status)?(()=>{const t=pP(e.status.blockingOn);return size$x(t)>0?"waiting on "+Array.from(t).map(e=>""+e).join(", "):""})():"",l=(p=e.status,isDone$5(p)?"Done":isRunning$1(p)?"Running":`Suspended(${interruptible$4(p.runtimeFlags)?"interruptible":"uninterruptible"})`);var p;return`[Fiber](#${e.id.id}) (${u}) ${c}\n   Status: ${l}`})),roots:TG,scoped:e=>eQ(succeed$u(e),interruptFiber),status:e=>e.status,succeed:succeed$q,unsafeRoots:unsafeRoots$1,void:OG,zip:aX,zipLeft:uX,zipRight:cX,zipWith:lX});const makeDual=e=>function(){if(1===arguments.length){const t=arguments[0];return(r,...n)=>e(t,r,...n)}return e.apply(this,arguments)},wX=makeDual((e,t,r)=>{const n=unsafeMake$h(),i=[[$D,[[n,e.context]]]];r?.scheduler&&i.push([rG,[[n,r.scheduler]]]);let s=UB(e.fiberRefs,{entries:i,forkAs:n});r?.updateRefs&&(s=r.updateRefs(s,n));const o=new FiberRuntime(n,s,e.runtimeFlags);let a=t;r?.scope&&(a=PR(BY(r.scope,jW),e=>lD(scopeAddFinalizer(e,fiberIdWith$1(e=>equals$4(e,o.id())?tD:hD(o,e))),GR(t,t=>UY(e,t)))));const u=o.currentSupervisor;return u!==vZ&&(u.onStart(e.context,a,none$c(),o),o.addObserver(e=>u.onEnd(e,o))),pG.add(e.runtimeFlags,o),!1===r?.immediate?o.resume(a):o.start(a),o}),kX=makeDual((e,t,r={})=>{const n=wX(e,t,r);return r.onExit&&n.addObserver(e=>{r.onExit(e)}),(t,r)=>kX(e)(pipe(n,bX(t??aP)),{...r,onExit:r?.onExit?e=>r.onExit(flatten$b(e)):void 0})}),xX=makeDual((e,t)=>{const r=OX(e)(t);if("Failure"===r._tag)throw fiberFailure(r.effect_instruction_i0);return r.effect_instruction_i0});class AsyncFiberExceptionImpl extends Error{fiber;_tag="AsyncFiberException";constructor(e){super(`Fiber #${e.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`),this.fiber=e,this.name=this._tag,this.stack=this.message}}const IX=Symbol.for("effect/Runtime/FiberFailure"),TX=Symbol.for("effect/Runtime/FiberFailure/Cause");class FiberFailureImpl extends Error{[IX];[TX];constructor(e){const t=prettyErrors$1(e)[0];super(t?.message||"An error has occurred"),this[IX]=IX,this[TX]=e,this.name=t?"(FiberFailure) "+t.name:"FiberFailure",t?.stack&&(this.stack=t.stack)}toJSON(){return{_id:"FiberFailure",cause:this[TX].toJSON()}}toString(){return"(FiberFailure) "+pretty$4(this[TX],{renderErrorCause:!0})}[ee](){return this.toString()}}const fiberFailure=e=>{const t=Error.stackTraceLimit;Error.stackTraceLimit=0;const r=new FiberFailureImpl(e);return Error.stackTraceLimit=t,r},fastPath=e=>{const t=e;switch(t._op){case"Failure":case"Success":return t;case"Left":return exitFail$1(t.left);case"Right":return exitSucceed$1(t.right);case"Some":return exitSucceed$1(t.value);case"None":return exitFail$1(bL())}},OX=makeDual((e,t)=>{const r=fastPath(t);if(r)return r;const n=new SyncScheduler,i=wX(e)(t,{scheduler:n});n.flush();return i.unsafePoll()||exitDie$1(capture((e=>{const t=Error.stackTraceLimit;Error.stackTraceLimit=0;const r=new AsyncFiberExceptionImpl(e);return Error.stackTraceLimit=t,r})(i),currentSpanFromFiber(i)))}),EX=makeDual((e,t,r)=>AX(e,t,r).then(e=>{switch(e._tag){case de:return e.effect_instruction_i0;case le:throw fiberFailure(e.effect_instruction_i0)}})),AX=makeDual((e,t,r)=>new Promise(n=>{const i=fastPath(t);i&&n(i);const s=wX(e)(t);s.addObserver(e=>{n(e)}),void 0!==r?.signal&&(r.signal.aborted?s.unsafeInterruptAsFork(s.id()):r.signal.addEventListener("abort",()=>{s.unsafeInterruptAsFork(s.id())},{once:!0}))}));class RuntimeImpl{context;runtimeFlags;fiberRefs;constructor(e,t,r){this.context=e,this.runtimeFlags=t,this.fiberRefs=r}pipe(){return pipeArguments(this,arguments)}}const make$1u=e=>new RuntimeImpl(e.context,e.runtimeFlags,e.fiberRefs),runtime$4=()=>withFiberRuntime$1((e,t)=>succeed$u(new RuntimeImpl(e.getFiberRef($D),t.runtimeFlags,e.getFiberRefs()))),CX=make$20(1,wj,4),MX=make$1u({context:empty$S(),runtimeFlags:CX,fiberRefs:$B()}),FX=dual(2,(e,t)=>make$1u({context:e.context,runtimeFlags:t(e.runtimeFlags),fiberRefs:e.fiberRefs})),PX=dual(2,(e,t)=>FX(e,xj(t))),NX=dual(2,(e,t)=>FX(e,Tj(t))),jX=dual(2,(e,t)=>make$1u({context:t(e.context),runtimeFlags:e.runtimeFlags,fiberRefs:e.fiberRefs})),RX=dual(3,(e,t,r)=>jX(e,NA(t,r))),DX=dual(2,(e,t)=>make$1u({context:e.context,runtimeFlags:e.runtimeFlags,fiberRefs:t(e.fiberRefs)})),LX=dual(3,(e,t,r)=>DX(e,LB({fiberId:aP,fiberRef:t,value:r}))),UX=dual(2,(e,t)=>DX(e,NB(t))),$X=kX(MX),BX=wX(MX),zX=EX(MX),qX=AX(MX),WX=xX(MX),VX=OX(MX),KX=dual(2,(e,t)=>e.modifyEffect(e=>qR(t(e),t=>[e,t]))),GX=dual(2,(e,t)=>e.modifyEffect(e=>{const r=t(e);switch(r._tag){case"None":return succeed$u([e,e]);case"Some":return qR(r.value,t=>[e,t])}})),JX=dual(2,(e,t)=>e.modify(t)),HX=dual(2,(e,t)=>e.modifyEffect(t)),ZX=dual(3,(e,t,r)=>e.modifyEffect(e=>pipe(r(e),Kt(()=>succeed$u([t,e]))))),QX=dual(2,(e,t)=>e.modifyEffect(e=>qR(t(e),e=>[void 0,e]))),YX=dual(2,(e,t)=>e.modifyEffect(e=>qR(t(e),e=>[e,e]))),XX=dual(2,(e,t)=>e.modifyEffect(e=>{const r=t(e);switch(r._tag){case"None":return succeed$u([void 0,e]);case"Some":return qR(r.value,e=>[void 0,e])}})),e0=Symbol.for("effect/Layer"),t0={[e0]:{_RIn:e=>e,_E:e=>e,_ROut:e=>e},pipe(){return pipeArguments(this,arguments)}},r0=Symbol.for("effect/Layer/MemoMap"),n0=Reference()("effect/Layer/CurrentMemoMap",{defaultValue:()=>unsafeMakeMemoMap()}),isLayer$1=e=>C(e,e0),isFresh$1=e=>e._op_layer===hX;class MemoMapImpl{ref;[r0];constructor(e){this.ref=e,this[r0]=r0}getOrElseMemoize(e,t){return pipe(HX(this.ref,r=>{const n=r.get(e);if(void 0!==n){const[e,i]=n,s=pipe(e,PR(([e,t])=>pipe(patchFiberRefs$1(e),TR(t))),GR(DL({onFailure:()=>tD,onSuccess:()=>scopeAddFinalizerExit(t,i)})));return succeed$u([s,r])}return pipe(make$1O(0),PR(n=>pipe(deferredMake(),PR(i=>pipe(make$1O(()=>tD),qR(s=>{const o=uninterruptibleMask$2(o=>pipe(scopeMake(),PR(a=>pipe(o(PR(makeBuilder(e,a,!0),e=>diffFiberRefs$1(e(this)))),exit$2,PR(o=>{switch(o._tag){case le:return pipe(YL(i,o.effect_instruction_i0),lD(scopeClose(a,o)),lD(failCause$j(o.effect_instruction_i0)));case de:return pipe(wz(s,e=>pipe(scopeClose(a,e),rD(Oz(n,e=>[1===e,e-1])),asVoid$9)),lD(Az(n,e=>e+1)),lD(scopeAddFinalizerExit(t,t=>pipe(sync$l(()=>r.delete(e)),lD(get$z(s)),PR(e=>e(t))))),lD(nU(i,o.effect_instruction_i0)),TR(o.effect_instruction_i0[1]))}}))))),a=[pipe(deferredAwait(i),GR(LL({onFailure:()=>tD,onSuccess:()=>Az(n,e=>e+1)}))),e=>pipe(get$z(s),PR(t=>t(e)))];return[o,isFresh$1(e)?r:r.set(e,a)]}))))))}),flatten$c)}}const i0=suspend$g(()=>qR(makeSynchronized(new Map),e=>new MemoMapImpl(e))),unsafeMakeMemoMap=()=>new MemoMapImpl(unsafeMakeSynchronized(new Map)),build$1=e=>scopeWith$1(t=>s0(e,t)),s0=dual(2,(e,t)=>PR(i0,r=>o0(e,r,t))),o0=dual(3,(e,t,r)=>PR(makeBuilder(e,r),e=>Gq(e(t),n0,t))),makeBuilder=(e,t,r=!1)=>{const n=e;switch(n._op_layer){case"Locally":return sync$l(()=>e=>n.f(e.getOrElseMemoize(n.self,t)));case"ExtendScope":return sync$l(()=>e=>scopeWith$1(t=>e.getOrElseMemoize(n.layer,t)));case"Fold":return sync$l(()=>e=>pipe(e.getOrElseMemoize(n.layer,t),RR({onFailure:r=>e.getOrElseMemoize(n.failureK(r),t),onSuccess:r=>e.getOrElseMemoize(n.successK(r),t)})));case"Fresh":return sync$l(()=>e=>pipe(n.layer,s0(t)));case"FromEffect":return sync$l(r?()=>e=>n.effect:()=>r=>r.getOrElseMemoize(e,t));case"Provide":return sync$l(()=>e=>pipe(e.getOrElseMemoize(n.first,t),PR(r=>pipe(e.getOrElseMemoize(n.second,t),oU(r)))));case"Scoped":return sync$l(r?()=>e=>xQ(n.effect,t):()=>r=>r.getOrElseMemoize(e,t));case"Suspend":return sync$l(()=>e=>e.getOrElseMemoize(n.evaluate(),t));case"ProvideMerge":return sync$l(()=>e=>pipe(e.getOrElseMemoize(n.first,t),pD(e.getOrElseMemoize(n.second,t),n.zipK)));case"ZipWith":return sync$l(()=>e=>pipe(e.getOrElseMemoize(n.first,t),vQ(e.getOrElseMemoize(n.second,t),n.zipK,{concurrent:!0})))}},a0=dual(2,(e,t)=>b0(e,{onFailure:t,onSuccess:succeedContext$1})),u0=dual(2,(e,t)=>y0(e,{onFailure:t,onSuccess:succeedContext$1})),die$b=e=>failCause$c(qQ(e)),context$a=()=>fromEffectContext(context$c()),fail$j=e=>failCause$c(zQ(e)),failSync$a=e=>failCauseSync$8(()=>zQ(e())),failCause$c=e=>fromEffectContext(failCause$j(e)),failCauseSync$8=e=>fromEffectContext(failCauseSync$b(e)),c0=dual(2,(e,t)=>b0(e,{onFailure:fail$j,onSuccess:t})),l0=dual(2,(e,t)=>c0(e,jA(t))),fresh$1=e=>{const t=Object.create(t0);return t._op_layer=hX,t.layer=e,t},p0=dual(2,(e,t)=>{const r=isTag(e),n=r?e:t;return fromEffectContext(qR(r?t:e,e=>PA(n,e)))});function fromEffectContext(e){const t=Object.create(t0);return t._op_layer="FromEffect",t.effect=e,t}const f0=dual(3,(e,t,r)=>h0(e,LD(t,r))),h0=dual(2,(e,t)=>{const r=Object.create(t0);return r._op_layer="Locally",r.self=e,r.f=t,r}),d0=dual(3,(e,t,r)=>h0(e,UD(t,r))),mockImpl=(e,t)=>I0(e,new Proxy({...t},{get(t,r,n){if(r in t)return t[r];const i=Error.stackTraceLimit;Error.stackTraceLimit=2;const s=Error(`${e.key}: Unimplemented method "${r.toString()}"`);return Error.stackTraceLimit=i,s.name="UnimplementedError",makeUnimplemented(s)},has:r})),makeUnimplemented=e=>{const t=die$g(e);function unimplemented(){return t}return Object.assign(unimplemented,t),Object.setPrototypeOf(unimplemented,Object.getPrototypeOf(t)),unimplemented},m0=dual(2,(e,t)=>c0(e,e=>succeedContext$1(t(e)))),g0=dual(2,(e,t)=>a0(e,e=>failSync$a(()=>t(e)))),y0=dual(2,(e,{onFailure:t,onSuccess:r})=>{const n=Object.create(t0);return n._op_layer="Fold",n.layer=e,n.failureK=t,n.successK=r,n}),b0=dual(2,(e,{onFailure:t,onSuccess:r})=>y0(e,{onFailure:e=>{const r=YQ(e);switch(r._tag){case"Left":return t(r.left);case"Right":return failCause$c(r.right)}},onSuccess:r})),S0=dual(2,(e,t)=>N0(e,t,(e,t)=>LA(e,t))),mergeAll$8=(...e)=>{let t=e[0];for(let r=1;r<e.length;r++)t=S0(t,e[r]);return t},v0=dual(2,(e,t)=>a0(e,t)),_0=dual(4,(e,t,r,n)=>m0(e,e=>PA(r,n(RA(e,t))))),w0=dual(2,(e,t)=>suspend$e(()=>{const r=GenericTag("effect/Layer/retry/{ state: unknown }");return pipe(I0(r,{state:t.initial}),c0(n=>retryLoop(e,t,r,pipe(n,jA(r)).state)))})),retryLoop=(e,t,r,n)=>pipe(e,a0(i=>pipe(retryUpdate(t,r,i,n),c0(n=>fresh$1(retryLoop(e,t,r,pipe(n,jA(r)).state)))))),retryUpdate=(e,t,r,n)=>p0(t,pipe(_B,PR(t=>pipe(e.step(t,r,n),PR(([e,n,i])=>isDone$3(i)?fail$r(r):pipe(sleep$4(millis(EY(i.intervals)-t)),TR({state:e}))))))),k0=dual(2,(e,t)=>{const r=isTag(e),n=r?e:t;return scopedContext$1(qR(r?t:e,e=>PA(n,e)))}),scopedDiscard$1=e=>scopedContext$1(pipe(e,TR(empty$S()))),scopedContext$1=e=>{const t=Object.create(t0);return t._op_layer="Scoped",t.effect=e,t},x0=scopedContext$1(qR(eQ(scopeMake(),(e,t)=>e.close(t)),e=>PA(RY,e))),I0=dual(2,(e,t)=>{const r=isTag(e);return fromEffectContext(succeed$u(PA(r?e:t,r?t:e)))}),succeedContext$1=e=>fromEffectContext(succeed$u(e)),T0=succeedContext$1(empty$S()),suspend$e=e=>{const t=Object.create(t0);return t._op_layer="Suspend",t.evaluate=e,t},O0=dual(2,(e,t)=>{const r=isTag(e),n=r?e:t,i=r?t:e;return fromEffectContext(sync$l(()=>PA(n,i())))}),syncContext$1=e=>fromEffectContext(sync$l(e)),E0=dual(2,(e,t)=>c0(e,e=>fromEffectContext(TR(t(e),e)))),A0=dual(2,(e,t)=>a0(e,e=>fromEffectContext(PR(t(e),()=>fail$r(e))))),C0=dual(2,(e,t)=>u0(e,e=>fromEffectContext(PR(t(e),()=>failCause$j(e))))),M0=dual(2,(e,t)=>PR(scopeWith$1(r=>o0(e,t,r)),e=>pipe(runtime$4(),oU(e)))),F0=dual(2,(e,t)=>suspend$e(()=>{const r=Object.create(t0);return r._op_layer="Provide",r.first=Object.create(t0,{_op_layer:{value:dX,enumerable:!0},first:{value:context$a(),enumerable:!0},second:{value:Array.isArray(t)?mergeAll$8(...t):t},zipK:{value:(e,t)=>pipe(e,LA(t))}}),r.second=e,r})),P0=dual(2,(e,t)=>{const r=Object.create(t0);return r._op_layer=dX,r.first=t,r.second=F0(e,t),r.zipK=(e,t)=>pipe(e,LA(t)),r}),N0=dual(3,(e,t,r)=>suspend$e(()=>{const n=Object.create(t0);return n._op_layer="ZipWith",n.first=e,n.second=t,n.zipK=r,n})),unwrapEffect$1=e=>{const t=GenericTag("effect/Layer/unwrapEffect/Layer.Layer<R1, E1, A>");return c0(p0(t,e),e=>jA(e,t))},unwrapScoped$7=e=>{const t=GenericTag("effect/Layer/unwrapScoped/Layer.Layer<R1, E1, A>");return c0(k0(t,e),e=>jA(e,t))},j0=dual(e=>isLayer$1(e[0]),function(){const e=arguments;return d0(e[0],qD,"string"==typeof e[1]?vP(e[1],e[2]):t=>Object.entries(e[1]).reduce((e,[t,r])=>vP(e,t,r),t))}),R0=dual(e=>isLayer$1(e[0]),function(){const e=arguments;return d0(e[0],sL,"string"==typeof e[1]?vP(e[1],e[2]):t=>Object.entries(e[1]).reduce((e,[t,r])=>vP(e,t,r),t))}),D0=dual(2,(e,t)=>F0(e,succeedContext$1(PA(oB,t)))),L0=dual(2,(e,t)=>scopedWith$5(r=>PR(s0(t,r),t=>aU(e,t)))),U0=dual(2,(e,t)=>{const r=UW(MX.fiberRefs,t.fiberRefs),n=Mj(MX.runtimeFlags,t.runtimeFlags);return uninterruptibleMask$2(i=>withFiberRuntime$1(s=>{const o=s.getFiberRef($D),a=s.getFiberRefs(),u=$W(s.id(),a)(r),c=s.currentRuntimeFlags,l=Fj(n)(c),p=UW(u,a),d=Mj(l,c);return s.setFiberRefs(u),s.currentRuntimeFlags=l,PQ(aU(i(e),LA(o,t.context)),withFiberRuntime$1(e=>(e.setFiberRefs($W(e.id(),e.getFiberRefs())(p)),e.currentRuntimeFlags=Fj(d)(e.currentRuntimeFlags),tD)))}))}),$0=dual(2,(e,t)=>Array.isArray(t)?L0(e,mergeAll$8(...t)):isLayer$1(t)?L0(e,t):FA(t)?aU(e,t):fX in t?PR(t.runtimeEffect,t=>U0(e,t)):U0(e,t)),B0=qR(fiberRefGet(pB),jA(eB)),consoleWith$2=e=>ED(pB,t=>e(jA(t,eB))),z0=dual(2,(e,t)=>UD(e,pB,NA(eB,t))),q0=consoleWith$2(e=>e.clear),W0=dual(e=>isEffect$1(e[0]),(e,t)=>consoleWith$2(r=>IR(r.group(t),()=>e,()=>r.groupEnd))),V0=dual(e=>isEffect$1(e[0]),(e,t)=>consoleWith$2(r=>IR(r.time(t),()=>e,()=>r.timeEnd(t)))),K0=struct$2,array$2=e=>unsafeArray(e.slice(0)),unsafeArray=e=>Object.setPrototypeOf(e,sN),tagged$4=e=>t=>{const r=void 0===t?Object.create(Ce):K0(t);return r._tag=e,r},G0=oN,J0=oN;function taggedMatch(){if(1===arguments.length){const e=arguments[0];return function(t){return e[t._tag](t)}}const e=arguments[0];return arguments[1][e._tag](e)}const H0=function(){const e=Symbol.for("effect/Data/Error/plainArgs");return class extends lL{constructor(t){super(t?.message,t?.cause?{cause:t.cause}:void 0),t&&(Object.assign(this,t),Object.defineProperty(this,e,{value:t,enumerable:!1}))}toJSON(){return{...this[e],...this}}}}(),TaggedError$1=e=>{const t={BaseEffectError:class extends H0{_tag=e}};return t.BaseEffectError.prototype.name=e,t.BaseEffectError};var Z0=Object.freeze({__proto__:null,Class:G0,Error:H0,Structural:J0,TaggedClass:e=>class extends G0{_tag=e},TaggedError:TaggedError$1,array:array$2,case:()=>e=>void 0===e?Object.create(Ce):K0(e),struct:K0,tagged:tagged$4,taggedEnum:()=>new Proxy({},{get:(e,t,r)=>"$is"===t?M:"$match"===t?taggedMatch:tagged$4(t)}),tuple:(...e)=>unsafeArray(e),unsafeArray,unsafeStruct:e=>Object.setPrototypeOf(e,Ce)});const Q0=Symbol.for("effect/DateTime"),Y0=Symbol.for("effect/DateTime/TimeZone"),X0={[Q0]:Q0,pipe(){return pipeArguments(this,arguments)},[ee](){return this.toString()},toJSON(){return toDateUtc$1(this).toJSON()}},e1={...X0,_tag:"Utc",[Z](){return cached$2(this,number$4(this.epochMillis))},[Y](e){return isDateTime$1(e)&&"Utc"===e._tag&&this.epochMillis===e.epochMillis},toString(){return`DateTime.Utc(${toDateUtc$1(this).toJSON()})`}},t1={...X0,_tag:"Zoned",[Z](){return pipe(number$4(this.epochMillis),combine$h(hash$3(this.zone)),cached$2(this))},[Y](e){return isDateTime$1(e)&&"Zoned"===e._tag&&this.epochMillis===e.epochMillis&&equals$4(this.zone,e.zone)},toString(){return`DateTime.Zoned(${formatIsoZoned$1(this)})`}},r1={[Y0]:Y0,[ee](){return this.toString()}},n1={...r1,_tag:"Named",[Z](){return cached$2(this,string$6("Named:"+this.id))},[Y](e){return isTimeZone$1(e)&&"Named"===e._tag&&this.id===e.id},toString(){return`TimeZone.Named(${this.id})`},toJSON(){return{_id:"TimeZone",_tag:"Named",id:this.id}}},i1={...r1,_tag:"Offset",[Z](){return cached$2(this,string$6("Offset:"+this.offset))},[Y](e){return isTimeZone$1(e)&&"Offset"===e._tag&&this.offset===e.offset},toString(){return`TimeZone.Offset(${offsetToString(this.offset)})`},toJSON(){return{_id:"TimeZone",_tag:"Offset",offset:this.offset}}},makeZonedProto=(e,t,r)=>{const n=Object.create(t1);return n.epochMillis=e,n.zone=t,Object.defineProperty(n,"partsUtc",{value:r,enumerable:!1,writable:!0}),Object.defineProperty(n,"adjustedEpochMillis",{value:void 0,enumerable:!1,writable:!0}),Object.defineProperty(n,"partsAdjusted",{value:void 0,enumerable:!1,writable:!0}),n},isDateTime$1=e=>C(e,Q0),isDateTimeArgs=e=>isDateTime$1(e[0]),isTimeZone$1=e=>C(e,Y0),isTimeZoneNamed$1=e=>isTimeZone$1(e)&&"Named"===e._tag,isZoned$1=e=>"Zoned"===e._tag,s1=make$2l((e,t)=>e.epochMillis===t.epochMillis),o1=make$2k((e,t)=>e.epochMillis<t.epochMillis?-1:e.epochMillis>t.epochMillis?1:0),a1=clamp$8(o1),makeUtc=e=>{const t=Object.create(e1);return t.epochMillis=e,Object.defineProperty(t,"partsUtc",{value:void 0,enumerable:!1,writable:!0}),t},unsafeFromDate$1=e=>{const t=e.getTime();if(Number.isNaN(t))throw new tY("Invalid date");return makeUtc(t)},unsafeMake$9=e=>{if(isDateTime$1(e))return e;if(e instanceof Date)return unsafeFromDate$1(e);if("object"==typeof e){const t=new Date(0);return setPartsDate(t,e),unsafeFromDate$1(t)}return"string"!=typeof e||hasZone(e)?unsafeFromDate$1(new Date(e)):unsafeFromDate$1(new Date(e+"Z"))},hasZone=e=>/Z|[+-]\d{2}$|[+-]\d{2}:?\d{2}$|\]$/.test(e),unsafeMakeZoned$1=(e,t)=>{if(void 0===t?.timeZone&&isDateTime$1(e)&&isZoned$1(e))return e;const r=unsafeMake$9(e);if(r.epochMillis<-86399999568e5||r.epochMillis>86399999496e5)throw new RangeError("Epoch millis out of range: "+r.epochMillis);let n;if(void 0===t?.timeZone){const e=-60*new Date(r.epochMillis).getTimezoneOffset()*1e3;n=zoneMakeOffset$1(e)}else if(isTimeZone$1(t?.timeZone))n=t.timeZone;else if("number"==typeof t?.timeZone)n=zoneMakeOffset$1(t.timeZone);else{const e=zoneFromString$1(t.timeZone);if(Bt(e))throw new tY("Invalid time zone: "+t.timeZone);n=e.value}return!0!==t?.adjustForTimeZone?makeZonedProto(r.epochMillis,n,r.partsUtc):makeZonedFromAdjusted(r.epochMillis,n,t?.disambiguation??"compatible")},u1=liftThrowable(unsafeMakeZoned$1),c1=liftThrowable(unsafeMake$9),l1=/^(.{17,35})\[(.+)\]$/,p1=qR(_B,makeUtc),f1=qR(_B,e=>new Date(e)),unsafeNow$1=()=>makeUtc(Date.now()),h1=dual(isDateTimeArgs,(e,t,r)=>!0===r?.adjustForTimeZone?makeZonedFromAdjusted(e.epochMillis,t,r?.disambiguation??"compatible"):makeZonedProto(e.epochMillis,t,e.partsUtc)),d1=dual(isDateTimeArgs,(e,t,r)=>h1(e,zoneMakeOffset$1(t),r)),m1=globalValue("effect/DateTime/validZoneCache",()=>new Map),g1={day:"numeric",month:"numeric",year:"numeric",hour:"numeric",minute:"numeric",second:"numeric",timeZoneName:"longOffset",fractionalSecondDigits:3,hourCycle:"h23"},zoneMakeIntl=e=>{const t=e.resolvedOptions().timeZone;if(m1.has(t))return m1.get(t);const r=Object.create(n1);return r.id=t,r.format=e,m1.set(t,r),r},zoneUnsafeMakeNamed$1=e=>{if(m1.has(e))return m1.get(e);try{return zoneMakeIntl(new Intl.DateTimeFormat("en-US",{...g1,timeZone:e}))}catch{throw new tY("Invalid time zone: "+e)}},zoneMakeOffset$1=e=>{const t=Object.create(i1);return t.offset=e,t},y1=liftThrowable(zoneUnsafeMakeNamed$1),zoneMakeNamedEffect$1=e=>try_$4({try:()=>zoneUnsafeMakeNamed$1(e),catch:e=>e}),b1=/^(?:GMT|[+-])/,zoneFromString$1=e=>{if(b1.test(e)){const t=parseOffset(e);return null===t?none$c():Ut(zoneMakeOffset$1(t))}return y1(e)},S1=dual(isDateTimeArgs,(e,t,r)=>er(y1(t),t=>h1(e,t,r))),v1=dual(isDateTimeArgs,(e,t,r)=>h1(e,zoneUnsafeMakeNamed$1(t),r)),_1=dual(2,(e,t)=>toEpochMillis$1(t)-toEpochMillis$1(e)),w1=dual(2,(e,t)=>{const r=_1(e,t);return r>0?Ge(millis(r)):He(millis(-r))}),k1=dual(2,(e,t)=>millis(Math.abs(_1(e,t)))),x1=min$9(o1),I1=max$b(o1),T1=greaterThan$a(o1),O1=greaterThanOrEqualTo$7(o1),E1=lessThan$e(o1),A1=lessThanOrEqualTo$7(o1),C1=between$7(o1),toDateUtc$1=e=>new Date(e.epochMillis),toDate$1=e=>{if("Utc"===e._tag)return new Date(e.epochMillis);if("Offset"===e.zone._tag)return new Date(e.epochMillis+e.zone.offset);if(void 0!==e.adjustedEpochMillis)return new Date(e.adjustedEpochMillis);const t=e.zone.format.formatToParts(e.epochMillis).filter(e=>"literal"!==e.type),r=new Date(0);return r.setUTCFullYear(Number(t[2].value),Number(t[0].value)-1,Number(t[1].value)),r.setUTCHours(Number(t[3].value),Number(t[4].value),Number(t[5].value),Number(t[6].value)),e.adjustedEpochMillis=r.getTime(),r},zonedOffset$1=e=>toDate$1(e).getTime()-toEpochMillis$1(e),offsetToString=e=>{const t=Math.abs(e);let r=Math.floor(t/36e5),n=Math.round(t%36e5/6e4);return 60===n&&(r+=1,n=0),`${e<0?"-":"+"}${(r+"").padStart(2,"0")}:${(n+"").padStart(2,"0")}`},zonedOffsetIso$1=e=>offsetToString(zonedOffset$1(e)),toEpochMillis$1=e=>e.epochMillis,dateToParts=e=>({millis:e.getUTCMilliseconds(),seconds:e.getUTCSeconds(),minutes:e.getUTCMinutes(),hours:e.getUTCHours(),day:e.getUTCDate(),weekDay:e.getUTCDay(),month:e.getUTCMonth()+1,year:e.getUTCFullYear()}),toParts$1=e=>"Utc"===e._tag?toPartsUtc$1(e):(void 0!==e.partsAdjusted||(e.partsAdjusted=$1(e,dateToParts)),e.partsAdjusted),toPartsUtc$1=e=>(void 0!==e.partsUtc||(e.partsUtc=B1(e,dateToParts)),e.partsUtc),M1=dual(2,(e,t)=>toPartsUtc$1(e)[t]),F1=dual(2,(e,t)=>toParts$1(e)[t]),setPartsDate=(e,t)=>{if(void 0!==t.year&&e.setUTCFullYear(t.year),void 0!==t.month&&e.setUTCMonth(t.month-1),void 0!==t.day&&e.setUTCDate(t.day),void 0!==t.weekDay){const r=t.weekDay-e.getUTCDay();e.setUTCDate(e.getUTCDate()+r)}void 0!==t.hours&&e.setUTCHours(t.hours),void 0!==t.minutes&&e.setUTCMinutes(t.minutes),void 0!==t.seconds&&e.setUTCSeconds(t.seconds),void 0!==t.millis&&e.setUTCMilliseconds(t.millis)},P1=dual(2,(e,t)=>D1(e,e=>setPartsDate(e,t))),N1=dual(2,(e,t)=>L1(e,e=>setPartsDate(e,t))),j1=864e5,makeZonedFromAdjusted=(e,t,r)=>{if("Offset"===t._tag)return makeZonedProto(e-t.offset,t);const n=calculateNamedOffset(e-j1,e,t),i=calculateNamedOffset(e+j1,e,t);if(n===i)return makeZonedProto(e-n,t);const s=n-i;if(n<i){if(calculateNamedOffset(e-i,e,t)===i)return makeZonedProto(e-i,t);const s=makeZonedProto(e-n,t);if(e!==toDate$1(s).getTime())switch(r){case"reject":{const r=new Date(e).toISOString();throw new RangeError(`Gap time: ${r} does not exist in time zone ${t.id}`)}case"earlier":return makeZonedProto(e-i,t);case"compatible":case"later":return s}return s}if(calculateNamedOffset(e-n,e,t)===n){if("earlier"===r||"compatible"===r)return makeZonedProto(e-n,t);if(calculateNamedOffset(e-n+s,e+s,t)===n)return makeZonedProto(e-n,t);if("reject"===r){const r=new Date(e).toISOString();throw new RangeError(`Ambiguous time: ${r} occurs twice in time zone ${t.id}`)}}return makeZonedProto(e-i,t)},R1=/([+-])(\d{2}):(\d{2})$/,parseOffset=e=>{const t=R1.exec(e);if(null===t)return null;const[,r,n,i]=t;return("+"===r?1:-1)*(60*Number(n)+Number(i))*60*1e3},calculateNamedOffset=(e,t,r)=>{const n=r.format.formatToParts(e).find(e=>"timeZoneName"===e.type)?.value??"";if("GMT"===n)return 0;const i=parseOffset(n);return null===i?zonedOffset$1(makeZonedProto(t,r)):i},D1=dual(isDateTimeArgs,(e,t,r)=>{if("Utc"===e._tag){const r=toDateUtc$1(e);return t(r),makeUtc(r.getTime())}const n=toDate$1(e),i=new Date(n.getTime());return t(i),makeZonedFromAdjusted(i.getTime(),e.zone,r?.disambiguation??"compatible")}),L1=dual(2,(e,t)=>U1(e,e=>{const r=new Date(e);return t(r),r.getTime()})),U1=dual(2,(e,t)=>{const r=t(toEpochMillis$1(e));return"Utc"===e._tag?makeUtc(r):makeZonedProto(r,e.zone)}),$1=dual(2,(e,t)=>t(toDate$1(e))),B1=dual(2,(e,t)=>t(toDateUtc$1(e))),z1=dual(2,(e,t)=>"Utc"===e._tag?t.onUtc(e):t.onZoned(e)),q1=dual(2,(e,t)=>U1(e,e=>e+toMillis(t))),W1=dual(2,(e,t)=>U1(e,e=>e-toMillis(t))),addMillis=(e,t)=>{e.setTime(e.getTime()+t)},V1=dual(2,(e,t)=>D1(e,e=>{if(t.millis&&addMillis(e,t.millis),t.seconds&&addMillis(e,1e3*t.seconds),t.minutes&&addMillis(e,60*t.minutes*1e3),t.hours&&addMillis(e,60*t.hours*60*1e3),t.days&&e.setUTCDate(e.getUTCDate()+t.days),t.weeks&&e.setUTCDate(e.getUTCDate()+7*t.weeks),t.months){const r=e.getUTCDate();e.setUTCMonth(e.getUTCMonth()+t.months+1,0),r<e.getUTCDate()&&e.setUTCDate(r)}if(t.years){const r=e.getUTCDate(),n=e.getUTCMonth();e.setUTCFullYear(e.getUTCFullYear()+t.years,n+1,0),r<e.getUTCDate()&&e.setUTCDate(r)}})),K1=dual(2,(e,t)=>{const r={};for(const e in t)r[e]=-1*t[e];return V1(e,r)}),startOfDate=(e,t,r)=>{switch(t){case"second":e.setUTCMilliseconds(0);break;case"minute":e.setUTCSeconds(0,0);break;case"hour":e.setUTCMinutes(0,0,0);break;case"day":e.setUTCHours(0,0,0,0);break;case"week":{const t=r?.weekStartsOn??0,n=(e.getUTCDay()-t+7)%7;e.setUTCDate(e.getUTCDate()-n),e.setUTCHours(0,0,0,0);break}case"month":e.setUTCDate(1),e.setUTCHours(0,0,0,0);break;case"year":e.setUTCMonth(0,1),e.setUTCHours(0,0,0,0)}},G1=dual(isDateTimeArgs,(e,t,r)=>D1(e,e=>startOfDate(e,t,r))),endOfDate=(e,t,r)=>{switch(t){case"second":e.setUTCMilliseconds(999);break;case"minute":e.setUTCSeconds(59,999);break;case"hour":e.setUTCMinutes(59,59,999);break;case"day":e.setUTCHours(23,59,59,999);break;case"week":{const t=r?.weekStartsOn??0,n=(e.getUTCDay()-t+7)%7;e.setUTCDate(e.getUTCDate()-n+6),e.setUTCHours(23,59,59,999);break}case"month":e.setUTCMonth(e.getUTCMonth()+1,0),e.setUTCHours(23,59,59,999);break;case"year":e.setUTCMonth(11,31),e.setUTCHours(23,59,59,999)}},J1=dual(isDateTimeArgs,(e,t,r)=>D1(e,e=>endOfDate(e,t,r))),H1=dual(isDateTimeArgs,(e,t,r)=>D1(e,e=>{if("milli"===t)return;const n=e.getTime(),start=new Date(n);startOfDate(start,t,r);const i=start.getTime(),s=new Date(n);endOfDate(s,t,r);const o=s.getTime()+1;n-i<o-n?e.setTime(i):e.setTime(o)})),intlTimeZone=e=>"Named"===e._tag?e.id:offsetToString(e.offset),Z1=dual(isDateTimeArgs,(e,t)=>{try{return new Intl.DateTimeFormat(t?.locale,{timeZone:"Utc"===e._tag?"UTC":intlTimeZone(e.zone),...t}).format(e.epochMillis)}catch{return new Intl.DateTimeFormat(t?.locale,{timeZone:"UTC",...t}).format(toDate$1(e))}}),Q1=dual(isDateTimeArgs,(e,t)=>new Intl.DateTimeFormat(t?.locale,t).format(e.epochMillis)),Y1=dual(isDateTimeArgs,(e,t)=>new Intl.DateTimeFormat(t?.locale,{...t,timeZone:"UTC"}).format(e.epochMillis)),X1=dual(2,(e,t)=>t.format(e.epochMillis)),formatIsoOffset$1=e=>{const t=toDate$1(e);return"Utc"===e._tag?t.toISOString():`${t.toISOString().slice(0,-1)}${zonedOffsetIso$1(e)}`},formatIsoZoned$1=e=>"Offset"===e.zone._tag?formatIsoOffset$1(e):`${formatIsoOffset$1(e)}[${e.zone.id}]`,e2=isString$1,t2=l,r2=Ot,n2=dual(2,(e,t)=>e+t),toUpperCase=e=>e.toUpperCase(),toLowerCase=e=>e.toLowerCase(),capitalize=e=>0===e.length?e:toUpperCase(e[0])+e.slice(1),uncapitalize=e=>0===e.length?e:toLowerCase(e[0])+e.slice(1),isNonEmpty$3=e=>e.length>0,i2=dual(2,(e,t)=>{const r=e.split(t);return isNonEmptyArray$1(r)?r:[e]}),s2=dual(2,(e,t)=>yr(Ut(e.charCodeAt(t)),e=>!isNaN(e))),o2=dual(2,(e,t)=>fromNullable$3(e.at(t))),a2=dual(2,(e,t)=>yr(Ut(e.charAt(t)),isNonEmpty$3)),u2=dual(2,(e,t)=>fromNullable$3(e.codePointAt(t))),c2=dual(2,(e,t)=>yr(Ut(e.search(t)),GI(0))),l2=dual(2,(e,t)=>e.slice(0,Math.max(t,0))),p2=dual(2,(e,t)=>e.slice(Math.max(0,e.length-Math.floor(t)),1/0)),linesWithSeparators=e=>linesSeparated(e,!1),f2=dual(2,(e,t)=>{let r="";for(const n of linesWithSeparators(e)){let e=0;for(;e<n.length&&n.charAt(e)<=" ";)e+=1;r+=e<n.length&&n.charAt(e)===t?n.substring(e+1):n}return r});class LinesIterator{s;stripped;index;length;constructor(e,t=!1){this.s=e,this.stripped=t,this.index=0,this.length=e.length}next(){if(this.done)return{done:!0,value:void 0};const start=this.index;for(;!this.done&&!isLineBreak(this.s[this.index]);)this.index=this.index+1;let e=this.index;if(!this.done){const t=this.s[this.index];this.index=this.index+1,!this.done&&isLineBreak2(t,this.s[this.index])&&(this.index=this.index+1),this.stripped||(e=this.index)}return{done:!1,value:this.s.substring(start,e)}}[Symbol.iterator](){return new LinesIterator(this.s,this.stripped)}get done(){return this.index>=this.length}}const isLineBreak=e=>{const t=e.charCodeAt(0);return 13===t||10===t},isLineBreak2=(e,t)=>13===e.charCodeAt(0)&&10===t.charCodeAt(0),linesSeparated=(e,t)=>new LinesIterator(e,t);var h2=Object.freeze({__proto__:null,Equivalence:t2,Order:r2,at:o2,camelToSnake:e=>e.replace(/([A-Z])/g,"_$1").toLowerCase(),capitalize,charAt:a2,charCodeAt:s2,codePointAt:u2,concat:n2,empty:"",endsWith:(e,t)=>r=>r.endsWith(e,t),includes:(e,t)=>r=>r.includes(e,t),indexOf:e=>t=>yr(Ut(t.indexOf(e)),GI(0)),isEmpty:e=>0===e.length,isNonEmpty:isNonEmpty$3,isString:e2,kebabToSnake:e=>e.replace(/-/g,"_"),lastIndexOf:e=>t=>yr(Ut(t.lastIndexOf(e)),GI(0)),length:e=>e.length,linesIterator:e=>linesSeparated(e,!0),linesWithSeparators,localeCompare:(e,t,r)=>n=>sign$2(n.localeCompare(e,t,r)),match:e=>t=>fromNullable$3(t.match(e)),matchAll:e=>t=>t.matchAll(e),normalize:e=>t=>t.normalize(e),padEnd:(e,t)=>r=>r.padEnd(e,t),padStart:(e,t)=>r=>r.padStart(e,t),pascalToSnake:e=>(e.slice(0,1)+e.slice(1).replace(/([A-Z])/g,"_$1")).toLowerCase(),repeat:e=>t=>t.repeat(e),replace:(e,t)=>r=>r.replace(e,t),replaceAll:(e,t)=>r=>r.replaceAll(e,t),search:c2,slice:(start,e)=>t=>t.slice(start,e),snakeToCamel:e=>{let t=e[0];for(let r=1;r<e.length;r++)t+="_"===e[r]?e[++r].toUpperCase():e[r];return t},snakeToKebab:e=>e.replace(/_/g,"-"),snakeToPascal:e=>{let t=e[0].toUpperCase();for(let r=1;r<e.length;r++)t+="_"===e[r]?e[++r].toUpperCase():e[r];return t},split:i2,startsWith:(e,t)=>r=>r.startsWith(e,t),stripMargin:e=>f2(e,"|"),stripMarginWith:f2,substring:(start,e)=>t=>t.substring(start,e),takeLeft:l2,takeRight:p2,toLocaleLowerCase:e=>t=>t.toLocaleLowerCase(e),toLocaleUpperCase:e=>t=>t.toLocaleUpperCase(e),toLowerCase,toUpperCase,trim:e=>e.trim(),trimEnd:e=>e.trimEnd(),trimStart:e=>e.trimStart(),uncapitalize});const d2=Symbol.for("effect/Cron"),m2={[d2]:d2,[Y](e){return isCron(e)&&v2(this,e)},[Z](){return pipe(hash$3(this.tz),combine$h(array$6(fromIterable$v(this.seconds))),combine$h(array$6(fromIterable$v(this.minutes))),combine$h(array$6(fromIterable$v(this.hours))),combine$h(array$6(fromIterable$v(this.days))),combine$h(array$6(fromIterable$v(this.months))),combine$h(array$6(fromIterable$v(this.weekdays))),cached$2(this))},toString(){return format$6(this.toJSON())},toJSON(){return{_id:"Cron",tz:this.tz,seconds:fromIterable$v(this.seconds),minutes:fromIterable$v(this.minutes),hours:fromIterable$v(this.hours),days:fromIterable$v(this.days),months:fromIterable$v(this.months),weekdays:fromIterable$v(this.weekdays)}},[ee](){return this.toJSON()},pipe(){return pipeArguments(this,arguments)}},isCron=e=>C(e,d2),make$1s=e=>{const t=Object.create(m2);t.seconds=new Set(Ni(e.seconds??[0],qI)),t.minutes=new Set(Ni(e.minutes,qI)),t.hours=new Set(Ni(e.hours,qI)),t.days=new Set(Ni(e.days,qI)),t.months=new Set(Ni(e.months,qI)),t.weekdays=new Set(Ni(e.weekdays,qI)),t.tz=fromNullable$3(e.tz);const r=Array.from(t.seconds),n=Array.from(t.minutes),i=Array.from(t.hours),s=Array.from(t.days),o=Array.from(t.months),a=Array.from(t.weekdays);return t.first={second:r[0]??0,minute:n[0]??0,hour:i[0]??0,day:s[0]??1,month:(o[0]??1)-1,weekday:a[0]??0},t.next={second:nextLookupTable(r,60),minute:nextLookupTable(n,60),hour:nextLookupTable(i,24),day:nextLookupTable(s,32),month:nextLookupTable(o,13),weekday:nextLookupTable(a,7)},t},nextLookupTable=(e,t)=>{const r=Array(t).fill(void 0);if(0===e.length)return r;let n,i=e.length-1;for(let s=t-1;s>=0;s--){for(;i>=0&&e[i]>=s;)n=e[i--];r[s]=n}return r},g2=Symbol.for("effect/Cron/errors/ParseError");let y2=class extends(TaggedError$1("CronParseError")){[g2]=g2};const parse=(e,t)=>{const r=e.split(" ").filter(isNonEmpty$3);if(5!==r.length&&6!==r.length)return He(new y2({message:"Invalid number of segments in cron expression",input:e}));5===r.length&&r.unshift("0");const[n,i,s,o,a,u]=r,c=void 0===t||isTimeZone$1(t)?Ge(t):Qe(zoneFromString$1(t),()=>new y2({message:"Invalid time zone in cron expression",input:t}));return all$c({tz:c,seconds:parseSegment(n,_2),minutes:parseSegment(i,w2),hours:parseSegment(s,k2),days:parseSegment(o,x2),months:parseSegment(a,I2),weekdays:parseSegment(u,T2)}).pipe(st(make$1s))},match$n=(e,t)=>{const r=unsafeMakeZoned$1(t,{timeZone:Qt(e.tz)}).pipe(toParts$1);return!(0!==e.seconds.size&&!e.seconds.has(r.seconds))&&!(0!==e.minutes.size&&!e.minutes.has(r.minutes))&&!(0!==e.hours.size&&!e.hours.has(r.hours))&&!(0!==e.months.size&&!e.months.has(r.month))&&(0===e.days.size&&0===e.weekdays.size||(0===e.weekdays.size?e.days.has(r.day):0===e.days.size?e.weekdays.has(r.weekDay):e.days.has(r.day)||e.weekdays.has(r.weekDay)))},daysInMonth=e=>new Date(Date.UTC(e.getUTCFullYear(),e.getUTCMonth()+1,0)).getUTCDate(),next$3=(e,t)=>{const r=Qt(e.tz),n=unsafeMakeZoned$1(t??new Date,{timeZone:r}),i=void 0!==r&&isTimeZoneNamed$1(r)&&"UTC"===r.id?o:e=>{const t=unsafeMakeZoned$1(e,{timeZone:n.zone,adjustForTimeZone:!0}).pipe(toDate$1),r=e.getTime()-t.getTime();r>0&&e.setTime(e.getTime()+r)},s=D1(n,t=>{t.setUTCSeconds(t.getUTCSeconds()+1,0);for(let r=0;r<1e4;r++){if(0!==e.seconds.size){const r=t.getUTCSeconds(),n=e.next.second[r];if(void 0===n){t.setUTCMinutes(t.getUTCMinutes()+1,e.first.second),i(t);continue}if(n>r){t.setUTCSeconds(n),i(t);continue}}if(0!==e.minutes.size){const r=t.getUTCMinutes(),n=e.next.minute[r];if(void 0===n){t.setUTCHours(t.getUTCHours()+1,e.first.minute,e.first.second),i(t);continue}if(n>r){t.setUTCMinutes(n,e.first.second),i(t);continue}}if(0!==e.hours.size){const r=t.getUTCHours(),n=e.next.hour[r];if(void 0===n){t.setUTCDate(t.getUTCDate()+1),t.setUTCHours(e.first.hour,e.first.minute,e.first.second),i(t);continue}if(n>r){t.setUTCHours(n,e.first.minute,e.first.second),i(t);continue}}if(0!==e.weekdays.size||0!==e.days.size){let r=1/0,n=1/0;if(0!==e.weekdays.size){const n=t.getUTCDay(),i=e.next.weekday[n];r=void 0===i?7-n+e.first.weekday:i-n}if(0!==e.days.size&&0!==r){const r=t.getUTCDate(),i=e.next.day[r];n=void 0===i?daysInMonth(t)-r+e.first.day:i-r}const s=Math.min(r,n);if(0!==s){t.setUTCDate(t.getUTCDate()+s),t.setUTCHours(e.first.hour,e.first.minute,e.first.second),i(t);continue}}if(0!==e.months.size){const r=t.getUTCMonth()+1,n=e.next.month[r];if(void 0===n){t.setUTCFullYear(t.getUTCFullYear()+1),t.setUTCMonth(e.first.month,e.first.day),t.setUTCHours(e.first.hour,e.first.minute,e.first.second),i(t);continue}if(n>r){t.setUTCMonth(n-1,e.first.day),t.setUTCHours(e.first.hour,e.first.minute,e.first.second),i(t);continue}}return}throw Error("Unable to find next cron date")});return toDateUtc$1(s)},b2=make$2l((e,t)=>restrictionsEquals(e.seconds,t.seconds)&&restrictionsEquals(e.minutes,t.minutes)&&restrictionsEquals(e.hours,t.hours)&&restrictionsEquals(e.days,t.days)&&restrictionsEquals(e.months,t.months)&&restrictionsEquals(e.weekdays,t.weekdays)),S2=array$7(p),restrictionsEquals=(e,t)=>S2(fromIterable$v(e),fromIterable$v(t)),v2=dual(2,(e,t)=>b2(e,t)),_2={min:0,max:59},w2={min:0,max:59},k2={min:0,max:23},x2={min:1,max:31},I2={min:1,max:12,aliases:{jan:1,feb:2,mar:3,apr:4,may:5,jun:6,jul:7,aug:8,sep:9,oct:10,nov:11,dec:12}},T2={min:0,max:6,aliases:{sun:0,mon:1,tue:2,wed:3,thu:4,fri:5,sat:6}},parseSegment=(e,t)=>{const r=t.max-t.min+1,n=new Set,i=e.split(",");for(const s of i){const[i,o]=splitStep(s);if("*"===i&&void 0===o)return Ge(new Set);if(void 0!==o){if(!Number.isInteger(o))return He(new y2({message:"Expected step value to be a positive integer",input:e}));if(o<1)return He(new y2({message:"Expected step value to be greater than 0",input:e}));if(o>t.max)return He(new y2({message:"Expected step value to be less than "+t.max,input:e}))}if("*"===i)for(let e=t.min;e<=t.max;e+=o??1)n.add(e);else{const[r,s]=splitRange(i,t.aliases);if(!Number.isInteger(r))return He(new y2({message:"Expected a positive integer",input:e}));if(r<t.min||r>t.max)return He(new y2({message:`Expected a value between ${t.min} and ${t.max}`,input:e}));if(void 0===s)n.add(r);else{if(!Number.isInteger(s))return He(new y2({message:"Expected a positive integer",input:e}));if(s<t.min||s>t.max)return He(new y2({message:`Expected a value between ${t.min} and ${t.max}`,input:e}));if(r>s)return He(new y2({message:"Invalid value range",input:e}));for(let e=r;e<=s;e+=o??1)n.add(e)}}if(n.size>=r)return Ge(new Set)}return Ge(n)},splitStep=e=>{const t=e.indexOf("/");return-1!==t?[e.slice(0,t),Number(e.slice(t+1))]:[e,void 0]},splitRange=(e,t)=>{const r=e.indexOf("-");return-1!==r?[aliasOrValue(e.slice(0,r),t),aliasOrValue(e.slice(r+1),t)]:[aliasOrValue(e,t),void 0]};function aliasOrValue(e,t){return t?.[e.toLocaleLowerCase()]??Number(e)}var O2=Object.freeze({__proto__:null,Equivalence:b2,ParseError:y2,ParseErrorTypeId:g2,TypeId:d2,equals:v2,isCron,isParseError:e=>C(e,g2),make:make$1s,match:match$n,next:next$3,parse,sequence:function*(e,t){for(;;)yield t=next$3(e,t)},unsafeParse:(e,t)=>ht(parse(e,t),identity$5)});const E2=yB,fixed$2=e=>new FixedRandomImpl(e);var A2=Object.freeze({__proto__:null,Random:nB,RandomTypeId:rB,choice:e=>{const t=fromIterable$v(e);return qR(0===t.length?fail$r(new bL("Cannot select a random element from an empty array")):randomWith$2(e=>e.nextIntBetween(0,t.length)),e=>t[e])},fixed:fixed$2,make:make$1U,next:E2,nextBoolean:SB,nextInt:bB,nextIntBetween:(e,t)=>randomWith$2(r=>r.nextIntBetween(e,t)),nextRange:(e,t)=>randomWith$2(r=>r.nextRange(e,t)),randomWith:randomWith$2,shuffle:e=>randomWith$2(t=>t.shuffle(e))});const C2=Symbol.for("effect/Schedule"),isSchedule$1=e=>C(e,C2),M2=Symbol.for("effect/ScheduleDriver"),F2={start:0,now:0,input:void 0,output:void 0,elapsed:iM,elapsedSincePrevious:iM,recurrence:0},P2=Reference()("effect/Schedule/CurrentIterationMetadata",{defaultValue:()=>F2}),N2={_Out:e=>e,_In:e=>e,_R:e=>e},j2={_Out:e=>e,_In:e=>e,_R:e=>e};class ScheduleImpl{initial;step;[C2]=N2;constructor(e,t){this.initial=e,this.step=t}pipe(){return pipeArguments(this,arguments)}}const updateInfo=(e,t,r,n)=>Az(e,e=>0===e.recurrence?{now:t,input:r,output:n,recurrence:e.recurrence+1,elapsed:iM,elapsedSincePrevious:iM,start:t}:{now:t,input:r,output:n,recurrence:e.recurrence+1,elapsed:millis(t-e.start),elapsedSincePrevious:millis(t-e.now),start:e.start});class ScheduleDriverImpl{schedule;ref;[M2]=j2;constructor(e,t){this.schedule=e,this.ref=t}get state(){return qR(get$z(this.ref),e=>e[1])}get last(){return PR(get$z(this.ref),([e,t])=>{switch(e._tag){case"None":return failSync$d(()=>new bL);case"Some":return succeed$u(e.value)}})}iterationMeta=unsafeMake$d(F2);get reset(){return wz(this.ref,[none$c(),this.schedule.initial]).pipe(cD(wz(this.iterationMeta,F2)))}next(e){return pipe(qR(get$z(this.ref),e=>e[1]),PR(t=>pipe(_B,PR(r=>pipe(suspend$g(()=>this.schedule.step(r,e,t)),PR(([t,n,i])=>{const s=wz(this.ref,[Ut(n),t]);if(isDone$3(i))return s.pipe(lD(fail$r(none$c())));const o=EY(i.intervals)-r;if(o<=0)return s.pipe(lD(updateInfo(this.iterationMeta,r,e,n)),TR(n));const a=millis(o);return pipe(s,lD(updateInfo(this.iterationMeta,r,e,n)),lD(eW(a)),TR(n))}))))))}}const makeWithState$1=(e,t)=>new ScheduleImpl(e,t),R2=dual(2,(e,t)=>D2(e,e=>sync$l(()=>t(e)))),D2=dual(2,(e,t)=>a6(e,(e,r)=>qR(t(e),e=>vM(r,decode$5(e))))),L2=dual(2,(e,t)=>i6(U2(e,t),ct)),U2=dual(2,(e,t)=>makeWithState$1([e.initial,t.initial,!0],(r,n,i)=>i[2]?PR(e.step(r,n,i[0]),([e,s,o])=>isDone$3(o)?qR(t.step(r,n,i[1]),([t,r,n])=>[[e,t,!1],Ge(r),n]):succeed$u([[e,i[1],!0],He(s),o])):qR(t.step(r,n,i[1]),([e,t,r])=>[[i[0],e,!1],Ge(t),r]))),$2=dual(2,(e,t)=>i6(e,()=>t)),asVoid$6=e=>i6(e,o),B2=dual(2,(e,t)=>makeWithState$1([e.initial,t.initial],(r,[n,i],s)=>pD(e.step(r,n,s[0]),t.step(r,i,s[1]),([e,t,r],[n,i,s])=>{if(isContinue$2(r)&&isContinue$2(s)){const o=pipe(r.intervals,TY(s.intervals));return[[e,n],[t,i],_continue(o)]}return[[e,n],[t,i],NY]}))),z2=dual(2,(e,t)=>q2(e,(e,r)=>sync$l(()=>t(e,r)))),q2=dual(2,(e,t)=>makeWithState$1(e.initial,(r,n,i)=>PR(e.step(r,n,i),([e,r,i])=>isDone$3(i)?succeed$u([e,r,NY]):qR(t(n,r),t=>t?[e,r,i]:[e,r,NY])))),collectAllOutputs$1=e=>p6(e,empty$R(),(e,t)=>pipe(e,GA(t))),W2=dual(2,(e,t)=>makeWithState$1([e.initial,t.initial],(r,n,i)=>PR(e.step(r,n,i[0]),([e,n,s])=>qR(t.step(r,n,i[1]),([t,r,n])=>isDone$3(s)||isDone$3(n)?[[e,t],r,NY]:[[e,t],r,_continue(pipe(s.intervals,CY(n.intervals)))])))),V2=dual(2,(e,t)=>G2(e,e=>sync$l(()=>t(e)))),K2=dual(2,(e,t)=>makeWithState$1(e.initial,(r,n,i)=>uU(e.step(r,n,i),t))),G2=dual(2,(e,t)=>makeWithState$1(e.initial,(r,n,i)=>PR(t(n),t=>e.step(r,t,i)))),J2=dual(2,(e,t)=>H2(e,e=>sync$l(()=>t(e)))),H2=dual(2,(e,t)=>a6(e,(e,r)=>t(r))),delayedSchedule$1=e=>R2(e,e=>e),Z2=dual(2,(e,{onInput:t,onOutput:r})=>i6(V2(e,t),r)),Q2=dual(2,(e,{onInput:t,onOutput:r})=>s6(G2(e,t),r)),driver$1=e=>pipe(make$1O([none$c(),e.initial]),qR(t=>new ScheduleDriverImpl(e,t))),duration$3=e=>{const t=decode$5(e),r=toMillis(t);return makeWithState$1(!0,(e,n,i)=>succeed$u(i?[!1,t,continueWith(after(e+r))]:[!1,iM,NY]))},Y2=dual(2,(e,t)=>b6(e,t)),X2=dual(3,(e,t,r)=>S6(e,t,r)),e6=dual(2,(e,t)=>makeWithState$1(e.initial,(r,n,i)=>PR(e.step(r,n,i),([e,r,n])=>isDone$3(n)?TR(t,[e,r,n]):succeed$u([e,r,n])))),identity$3=()=>makeWithState$1(void 0,(e,t,r)=>succeed$u([r,t,continueWith(after(e))])),t6=dual(2,(e,t)=>r6(e,t,OY)),r6=dual(3,(e,t,r)=>makeWithState$1([e.initial,t.initial],(n,i,s)=>pipe(pD(e.step(n,i,s[0]),t.step(n,i,s[1]),(e,t)=>[e,t]),PR(([[n,s,o],[a,u,c]])=>isContinue$2(o)&&isContinue$2(c)?intersectWithLoop(e,t,i,n,s,o.intervals,a,u,c.intervals,r):succeed$u([[n,a],[s,u],NY]))))),intersectWithLoop=(e,t,r,n,i,s,o,a,u,c)=>{const l=c(s,u);return isNonEmpty$4(l)?succeed$u([[n,o],[i,a],_continue(l)]):pipe(s,AY(u))?PR(e.step(end$4(s),r,n),([n,i,s])=>isDone$3(s)?succeed$u([[n,o],[i,a],NY]):intersectWithLoop(e,t,r,n,i,s.intervals,o,a,u,c)):PR(t.step(end$4(u),r,o),([o,a,u])=>isDone$3(u)?succeed$u([[n,o],[i,a],NY]):intersectWithLoop(e,t,r,n,i,s,o,a,u.intervals,c))},n6=dual(2,(e,t)=>{const{max:r,min:n}=Object.assign({min:.8,max:1.2},t);return H2(e,e=>qR(E2,t=>{const i=toMillis(e);return millis(i*n*(1-t)+i*r*t)}))}),i6=dual(2,(e,t)=>s6(e,e=>sync$l(()=>t(e)))),s6=dual(2,(e,t)=>makeWithState$1(e.initial,(r,n,i)=>PR(e.step(r,n,i),([e,r,n])=>qR(t(r),t=>[e,t,n])))),o6=dual(2,(e,t)=>a6(e,(e,r)=>sync$l(()=>t(e,r)))),a6=dual(2,(e,t)=>makeWithState$1(e.initial,(r,n,i)=>PR(e.step(r,n,i),([e,n,i])=>{if(isDone$3(i))return succeed$u([e,n,i]);const s=i.intervals,o=size$n(hY(r,EY(s)));return qR(t(n,o),t=>{const i=decode$5(t),o=EY(s),a=r+toMillis(i),u=a-o,c=Math.max(0,end$4(s)+u),l=hY(a,c);return[e,n,continueWith(l)]})}))),u6=dual(2,(e,t)=>makeWithState$1(e.initial,(r,n,i)=>PR(e.step(r,n,i),([e,r,n])=>TR(t(r,n),[e,r,n])))),passthrough$2=e=>makeWithState$1(e.initial,(t,r,n)=>pipe(e.step(t,r,n),qR(([e,t,n])=>[e,r,n]))),c6=dual(2,(e,t)=>makeWithState$1(e.initial,(r,n,i)=>oU(e.step(r,n,i),t))),l6=dual(3,(e,t,r)=>makeWithState$1(e.initial,(n,i,s)=>contextWithEffect$7(o=>oU(e.step(n,i,s),NA(o,t,r))))),recurUntil$1=e=>v6(identity$3(),e),recurUntilEffect$1=e=>_6(identity$3(),e),recurUpTo$1=e=>{const t=decode$5(e);return O6(z6,e=>_M(e,t))},recurWhile$1=e=>I6(identity$3(),e),recurWhileEffect$1=e=>T6(identity$3(),e),recurs$1=e=>O6(q6,t=>t<e),p6=dual(3,(e,t,r)=>f6(e,t,(e,t)=>sync$l(()=>r(e,t)))),f6=dual(3,(e,t,r)=>makeWithState$1([e.initial,t],(t,n,[i,s])=>PR(e.step(t,n,i),([e,t,n])=>isDone$3(n)?succeed$u([[e,s],s,n]):qR(r(s,t),t=>[[e,t],s,n])))),h6=dual(2,(e,t)=>{const r=decode$5(t);return pipe(e,t6(z6),d6(([,e])=>xM(e,r)),i6(e=>e[0]))}),d6=dual(2,(e,t)=>makeWithState$1(e.initial,(r,n,i)=>PR(e.step(r,n,i),([i,s,o])=>t(s)?e.step(r,n,e.initial):succeed$u([i,s,o])))),m6=dual(3,(e,t,r)=>pipe(runLoop(e,t,fromIterable$u(r),e.initial,empty$R()),qR(e=>reverse$3(e)))),runLoop=(e,t,r,n,i)=>{if(!isNonEmpty$8(r))return succeed$u(i);const s=lC(r),o=tailNonEmpty(r);return PR(e.step(t,s,n),([t,r,n])=>isDone$3(n)?sync$l(()=>pipe(i,JA(r))):runLoop(e,EY(n.intervals),o,t,JA(i,r)))},g6=dual(2,(e,t)=>makeWithState$1(e.initial,(r,n,i)=>lD(t(n),e.step(r,n,i)))),y6=dual(2,(e,t)=>makeWithState$1(e.initial,(r,n,i)=>XR(e.step(r,n,i),([,e])=>t(e)))),unfold$3=(e,t)=>makeWithState$1(e,(e,r,n)=>sync$l(()=>[t(n),n,continueWith(after(e))])),b6=dual(2,(e,t)=>S6(e,t,TY)),S6=dual(3,(e,t,r)=>makeWithState$1([e.initial,t.initial],(n,i,s)=>pD(e.step(n,i,s[0]),t.step(n,i,s[1]),([e,t,n],[i,s,o])=>{if(isDone$3(n)&&isDone$3(o))return[[e,i],[t,s],NY];if(isDone$3(n)&&isContinue$2(o))return[[e,i],[t,s],_continue(o.intervals)];if(isContinue$2(n)&&isDone$3(o))return[[e,i],[t,s],_continue(n.intervals)];if(isContinue$2(n)&&isContinue$2(o)){const a=r(n.intervals,o.intervals);return[[e,i],[t,s],_continue(a)]}throw Error("BUG: Schedule.unionWith - please report an issue at https://github.com/Effect-TS/effect/issues")}))),v6=dual(2,(e,t)=>z2(e,(e,r)=>!t(e))),_6=dual(2,(e,t)=>q2(e,(e,r)=>negate$3(t(e)))),w6=dual(2,(e,t)=>z2(e,(e,r)=>!t(r))),k6=dual(2,(e,t)=>q2(e,(e,r)=>negate$3(t(r)))),x6=dual(2,(e,t)=>A6(e,recurUpTo$1(t))),I6=dual(2,(e,t)=>z2(e,(e,r)=>t(e))),T6=dual(2,(e,t)=>q2(e,(e,r)=>t(e))),O6=dual(2,(e,t)=>z2(e,(e,r)=>t(r))),E6=dual(2,(e,t)=>q2(e,(e,r)=>t(r))),A6=dual(2,(e,t)=>i6(t6(e,t),e=>e[0])),C6=dual(2,(e,t)=>i6(t6(e,t),e=>e[1])),M6=dual(3,(e,t,r)=>i6(t6(e,t),([e,t])=>r(e,t))),beginningOfSecond=e=>{const t=new Date(e);return new Date(t.getFullYear(),t.getMonth(),t.getDate(),t.getHours(),t.getMinutes(),t.getSeconds(),0).getTime()},endOfSecond=e=>{const t=new Date(beginningOfSecond(e));return t.setSeconds(t.getSeconds()+1)},beginningOfMinute=e=>{const t=new Date(e);return new Date(t.getFullYear(),t.getMonth(),t.getDate(),t.getHours(),t.getMinutes(),0,0).getTime()},beginningOfHour=e=>{const t=new Date(e);return new Date(t.getFullYear(),t.getMonth(),t.getDate(),t.getHours(),0,0,0).getTime()},beginningOfDay=e=>{const t=new Date(e);return new Date(t.getFullYear(),t.getMonth(),t.getDate(),0,0,0,0).getTime()},endOfDay=e=>{const t=new Date(beginningOfDay(e));return t.setDate(t.getDate()+1)},findNextMonth=(e,t,r)=>{const n=new Date(new Date(e).setDate(t));if(new Date(n.setMonth(n.getMonth()+r)).getDate()===t){const n=new Date(new Date(e).setDate(t));return n.setMonth(n.getMonth()+r)}return findNextMonth(e,t,r+1)},F6=Symbol.for("effect/Schedule/ScheduleDefect");class ScheduleDefect{error;[F6];constructor(e){this.error=e,this[F6]=F6}}const scheduleDefectWrap=e=>ER(e,e=>die$g(new ScheduleDefect(e))),scheduleDefectRefailCause=e=>qt(uR(e,e=>{return isDieType$1(e)&&(t=e.defect,C(t,F6))?Ut(e.defect):none$c();var t}),{onNone:()=>e,onSome:e=>fail$s(e.error)}),scheduleDefectRefail$1=e=>OR(e,e=>failCause$j(scheduleDefectRefailCause(e))),P6=dual(2,(e,t)=>j6(e,t,(e,t)=>fail$r(e))),N6=dual(2,(e,t)=>{if(isSchedule$1(t))return P6(e,t);const r=t.schedule??passthrough$2(q6),n=t.while?T6(r,e=>{const r=t.while(e);return"boolean"==typeof r?succeed$u(r):scheduleDefectWrap(r)}):r,i=t.until?_6(n,e=>{const r=t.until(e);return"boolean"==typeof r?succeed$u(r):scheduleDefectWrap(r)}):n,s=t.times?t6(i,recurs$1(t.times)).pipe(i6(e=>e[0])):i;return scheduleDefectRefail$1(P6(e,s))}),j6=dual(3,(e,t,r)=>PR(driver$1(t),t=>DR(e,{onFailure:e=>r(e,none$c()),onSuccess:n=>repeatOrElseEffectLoop(Jq(e,P2,get$z(t.iterationMeta)),t,(e,n)=>Jq(r(e,n),P2,get$z(t.iterationMeta)),n)}))),repeatOrElseEffectLoop=(e,t,r,n)=>DR(t.next(n),{onFailure:()=>orDie$a(t.last),onSuccess:n=>DR(e,{onFailure:e=>r(e,Ut(n)),onSuccess:n=>repeatOrElseEffectLoop(e,t,r,n)})}),R6=dual(2,(e,t)=>L6(e,t,(e,t)=>fail$r(e))),D6=dual(2,(e,t)=>isSchedule$1(t)?R6(e,t):scheduleDefectRefail$1(R6(e,fromRetryOptions(t)))),fromRetryOptions=e=>{const t=e.schedule??q6,r=e.while?T6(t,t=>{const r=e.while(t);return"boolean"==typeof r?succeed$u(r):scheduleDefectWrap(r)}):t,n=e.until?_6(r,t=>{const r=e.until(t);return"boolean"==typeof r?succeed$u(r):scheduleDefectWrap(r)}):r;return e.times?t6(n,recurs$1(e.times)):n},L6=dual(3,(e,t,r)=>PR(driver$1(t),t=>retryOrElse_EffectLoop(Jq(e,P2,get$z(t.iterationMeta)),t,(e,n)=>Jq(r(e,n),P2,get$z(t.iterationMeta))))),retryOrElse_EffectLoop=(e,t,r)=>ER(e,n=>DR(t.next(n),{onFailure:()=>pipe(t.last,orDie$a,PR(e=>r(n,e))),onSuccess:()=>retryOrElse_EffectLoop(e,t,r)})),U6=dual(2,(e,t)=>$6(e,void 0,t)),$6=dual(3,(e,t,r)=>PR(driver$1(r),r=>scheduleFrom_EffectLoop(Jq(e,P2,get$z(r.iterationMeta)),t,r))),scheduleFrom_EffectLoop=(e,t,r)=>DR(r.next(t),{onFailure:()=>orDie$a(r.last),onSuccess:()=>PR(e,t=>scheduleFrom_EffectLoop(e,t,r))}),B6=unfold$3(0,e=>e+1),z6=makeWithState$1(none$c(),(e,t,r)=>{switch(r._tag){case"None":return succeed$u([Ut(e),iM,continueWith(after(e))]);case"Some":return succeed$u([Ut(r.value),millis(e-r.value),continueWith(after(e))])}}),q6=unfold$3(0,e=>e+1),W6=asVoid$6(recurs$1(1)),V6=asVoid$6(recurs$1(0)),K6=dual(2,(e,t)=>forkScoped$1(U6(e,t))),G6=Symbol.for("effect/ExecutionPlan"),J6=dual(2,(e,t)=>suspend$g(()=>{let r,n=0;return PR(whileLoop$2({while:()=>n<t.steps.length&&(void 0===r||Xe(r)),body:()=>{const i=t.steps[n];let s=$0(e,i.provide);if(r){let e=!1;const t=s;s=suspend$g(()=>e?t:(e=!0,r)),s=scheduleDefectRefail$1(R6(s,scheduleFromStep(i,!1)))}else{const e=scheduleFromStep(i,!0);s=e?scheduleDefectRefail$1(R6(s,e)):s}return either$a(s)},step:e=>{r=e,n++}}),()=>r)})),scheduleFromStep=(e,t)=>t?1!==e.attempts&&(e.schedule||e.attempts)?fromRetryOptions({schedule:e.schedule,while:e.while,times:e.attempts?e.attempts-1:void 0}):void 0:fromRetryOptions({schedule:e.schedule?e.schedule:e.attempts?void 0:W6,times:e.attempts,while:e.while}),H6=globalValue(Symbol.for("effect/FiberRef/currentCache"),()=>fiberRefUnsafeMake(new CacheImpl(65536,empty$S(),nP,()=>qR(deferredMake(),e=>({listeners:new Listeners,handle:e})),e=>decode$5(seconds(60))))),Z6=globalValue(Symbol.for("effect/FiberRef/currentCacheEnabled"),()=>fiberRefUnsafeMake(!1)),fromRequest=(e,t)=>PR(isEffect$1(t)?t:succeed$u(t),t=>fiberIdWith$1(r=>{const n=new Proxy(e,{});return ED(Z6,e=>{if(e){const e=ED(H6,i=>PR(i.getEither(n),s=>{switch(s._tag){case"Left":return s.left.listeners.interrupted?PR(i.invalidateWhen(n,e=>e.handle===s.left.handle),()=>e):(s.left.listeners.increment(),uninterruptibleMask$2(e=>PR(exit$2(blocked$1(Uj,e(deferredAwait(s.left.handle)))),e=>(s.left.listeners.decrement(),e))));case"Right":return s.right.listeners.increment(),uninterruptibleMask$2(e=>PR(exit$2(blocked$1(single$1(t,makeEntry$1({request:n,result:s.right.handle,listeners:s.right.listeners,ownerId:r,state:{completed:!1}})),e(deferredAwait(s.right.handle)))),()=>(s.right.listeners.decrement(),deferredAwait(s.right.handle))))}}));return e}const i=new Listeners;return i.increment(),PR(deferredMake(),e=>PQ(blocked$1(single$1(t,makeEntry$1({request:n,result:e,listeners:i,ownerId:r,state:{completed:!1}})),deferredAwait(e)),sync$l(()=>i.decrement())))})})),Q6=dual(2,(e,t)=>LD(e,Z6,t)),Y6=dual(2,(e,t)=>LD(e,H6,t)),X6=cH,isRequest=e=>C(e,cH),e4=pH,t4=fH,r4=NQ,n4=hH,i4=dH,s4=mH,o4=gH;var a4=Object.freeze({__proto__:null,Class:e4,EntryTypeId:Symbol.for("effect/RequestBlock.Entry"),RequestTypeId:X6,TaggedClass:e=>class extends pH{_tag=e},complete:t4,completeEffect:n4,fail:i4,failCause:s4,interruptWhenPossible:r4,isEntry:e=>C(e,$j),isRequest,makeCache:e=>make$1B({...e,lookup:()=>qR(deferredMake(),e=>({listeners:new Listeners,handle:e}))}),makeEntry:makeEntry$1,of:()=>e=>Object.assign(Object.create(lH),e),succeed:o4,tagged:e=>t=>{const r=Object.assign(Object.create(lH),t);return r._tag=e,r}});const u4=xR,c4=isEffect$1,l4=WY,p4=VY,f4=memoize$2,h4=once$3,d4=all$6,m4=_q,g4=wq,y4=sW,b4=oW,S4=Fq,v4=nQ,_4=iQ,w4=kq,k4=Aq,x4=aQ,I4=cQ,T4=lQ,O4=Zq,E4=Yq,A4=Qq,C4=fQ,M4=sQ,F4=oQ,P4=pQ,N4=gQ,j4=async_,R4=custom$1,D4=withFiberRuntime$1,L4=fail$r,U4=failSync$d,$4=failCause$j,B4=failCauseSync$b,z4=die$g,q4=dieMessage$9,W4=dieSync$a,V4=gen$4,K4=fD,promise=e=>e.length>=1?async_((t,r)=>{try{e(r).then(e=>t(succeed$u(e)),e=>t(die$g(e)))}catch(e){t(die$g(e))}}):async_(t=>{try{e().then(e=>t(succeed$u(e)),e=>t(die$g(e)))}catch(e){t(die$g(e))}}),G4=succeed$u,J4=tW,H4=suspend$g,Z4=sync$l,Q4=tD,Y4=yieldNow$3,X4=oq,e3=ER,t3=OR,r3=aq,n3=AR,i3=CR,s3=uq,o3=cq,a3=lq,u3=pq,c3=eventually$3,l3=ignore$4,p3=ignoreLogged$2,f3=D6,h3=J6,d3=L6,m3=try_$4,g3=dW,y3=mW,b3=tryPromise$2,S3=mq,v3=BR,_3=interruptWith$2,w3=interruptible$3,k3=interruptibleMask$1,x3=JR,I3=uninterruptible$2,T3=uninterruptibleMask$2,O3=Oq,E3=TR,A3=asSome$4,C3=asVoid$9,M3=flip$4,F3=Cq,P3=qR,N3=qq,j3=WR,R3=VR,D3=Wq,L3=negate$3,U3=eQ,$3=tQ,B3=IR,z3=addFinalizer$2,q3=PQ,W3=KR,V3=GR,K3=parallelFinalizers$1,G3=sequentialFinalizers$1,J3=wQ,H3=scopeWith$1,Z3=scopedWith$5,Q3=scopedEffect,Y3=hQ,X3=gq,e5=descriptorWith$1,t5=diffFiberRefs$1,r5=KY,n5=GY,i5=FR,s5=fiberIdWith$1,o5=fork$2,a5=forkDaemon$1,u5=JY,c5=HY,l5=forkScoped$1,p5=uQ,f5=YY,h5=transplant$1,d5=nD,m5=nG,g5=KD,y5=GD,b5=hq,S5=fq,v5=withClockScoped$1,_5=dB,w5=B0,k5=consoleWith$2,x5=z0,I5=dq,T5=eW,O5=fW,E5=XY,A5=rX,C5=eX,M5=tX,F5=nX,P5=configProviderWith$1,N5=mB,j5=withConfigProviderScoped$1,R5=context$c,contextWith$8=e=>qR(context$c(),e),D5=contextWithEffect$7,L5=uU,U5=$0,$5=Gq,B5=Jq,z5=serviceFunctions$1,q5=serviceConstants$1,W5=serviceOptional$1,V5=bW,K5=yq,G5=bq,J5=pX,H5=Sq,Z5=vq,Q5=either$a,Y5=exit$2,X5=zR,e7=$R,t7=xq,r7=Iq,n7=Tq,i7=Eq,s7=cU,o7=lU,a7=gW,u7=yW,c7=SW,l7=rD,p7=vW,f7=_W,h7=PR,d7=NR,m7=flatten$c,g7=MQ,y7=QY,b7=CQ,S7=rW,v7=XR,_7=aW,w7=uW,k7=cW,x7=lW,I7=pW,T7=forever$6,O7=iterate$5,E7=N6,A7=Xq,C7=j6,M7=U6,F7=K6,P7=$6,N7=whileLoop$2,j7=Pq,R7=LD,D7=UD,L7=TQ,U7=OQ,$7=patchFiberRefs$1,B7=updateFiberRefs$3,z7=Mq,q7=jR,W7=RR,V7=DR,K7=Nq,G7=jq,J7=Rq,H7=Dq,Z7=Lq,Q7=Uq,Y7=$q,X7=Bq,e8=sq,t8=zq,r8=YD,n8=XZ,i8=orDie$a,s8=ZR,o8=HR,a8=Vq,u8=Kq,c8=Hq,l8=randomWith$2,p8=gB,f8=dual(2,(e,t)=>p8(e,fixed$2(t))),h8=runtime$4,d8=YR,m8=updateRuntimeFlags$2,g8=sD,y8=withRuntimeFlagsScoped,b8=nW,S8=iW,v8=labelMetricsScoped$1,_8=eL,w8=wW,k8=unsafeMakeSemaphore$2,makeSemaphore=e=>sync$l(()=>unsafeMakeSemaphore$2(e)),x8=unsafeMakeLatch$1,I8=BX,T8=$X,O8=zX,E8=qX,A8=WX,C8=VX,M8=dQ,F8=mQ,P8=yQ,N8=bQ,j8=SQ,R8=vQ,D8=dual(2,(e,t)=>R8(e,t,(e,t)=>e(t))),L8=blocked$1,U8=runRequestBlock$1,$8=step$1,B8=dual(e=>isRequest(e[0]),fromRequest),z8=iD,q8=Q6,W8=Y6,V8=hW,K8=tracerWith$3,G8=vB,J8=withTracerScoped$1,H8=oD,Z8=aD,Q8=kW,Y8=IW,X8=xW,e9=AW,t9=CW,r9=TW,makeSpan=(name,e)=>(e=addSpanStackTrace(e),withFiberRuntime$1(t=>succeed$u(unsafeMakeSpan(t,name,e)))),n9=makeSpanScoped$1,i9=useSpan$1,s9=withSpan$7,o9=MW,a9=dual(2,(e,t)=>isNone$3(e)?J4:P3(t(e.value),some$k)),makeTagProxy=e=>{const t=new Map;return new Proxy(e,{get(e,r,n){if(r in e)return Reflect.get(e,r,n);if(t.has(r))return t.get(r);const fn=(...n)=>NR(e,i=>"function"==typeof i[r]?(t.set(r,(...t)=>NR(e,e=>e[r](...t))),i[r](...n)):(t.set(r,NR(e,e=>e[r])),i[r])),i=NR(e,e=>e[r]);Object.assign(fn,i);const s=fn.apply,o=fn.bind,a=fn.call,u=Object.setPrototypeOf({},Object.getPrototypeOf(i));return u.apply=s,u.bind=o,u.call=a,Object.setPrototypeOf(fn,u),t.set(r,fn),fn}})};function defineLength(e,t){return Object.defineProperty(t,"length",{value:e,configurable:!0})}function fnApply(e){let t,r;if(isGeneratorFunction(e.body))t=fromIterator$1(()=>e.body.apply(e.self,e.args));else try{t=e.body.apply(e.self,e.args)}catch(e){r=e,t=z4(e)}if(e.pipeables.length>0)try{for(const r of e.pipeables)t=r(t,...e.args)}catch(e){t=r?$4(sequential$4(die$h(r),die$h(e))):z4(e)}let n=!1;const i=e.spanOptions&&"captureStackTrace"in e.spanOptions?e.spanOptions:{captureStackTrace:()=>{if(!1!==n)return n;if(e.errorCall.stack){const t=e.errorDef.stack.trim().split("\n"),r=e.errorCall.stack.trim().split("\n");let i=t.slice(2).join("\n").trim();i.includes("(")||(i=i.replace(/at (.*)/,"at ($1)"));let s=r.slice(2).join("\n").trim();return s.includes("(")||(s=s.replace(/at (.*)/,"at ($1)")),n=`${i}\n${s}`,n}},...e.spanOptions};return s9(t,e.spanName,i)}const u9=fnUntraced$1;var c9=Object.freeze({__proto__:null,Do:K5,EffectTypeId:u4,Service:function(){return function(){const[e,t]=arguments,r="accessors"in t&&t.accessors,n=Error.stackTraceLimit;Error.stackTraceLimit=2;const i=Error();Error.stackTraceLimit=n;let s="unchecked";const TagClass=function(e){if("unchecked"===s){const t=Object.getPrototypeOf(e);t===Object.prototype||null===t?s="plain":(Object.setPrototypeOf(Object.getPrototypeOf(this),t),s="patched")}if("plain"===s)Object.assign(this,e);else if("patched"===s)return Object.setPrototypeOf(e,Object.getPrototypeOf(this)),e};TagClass.prototype._tag=e,Object.defineProperty(TagClass,"make",{get(){return e=>new this(e)}}),Object.defineProperty(TagClass,"use",{get(){return e=>NR(this,e)}}),TagClass.key=e,Object.assign(TagClass,SA),Object.defineProperty(TagClass,"stack",{get:()=>i.stack});const o="dependencies"in t&&t.dependencies.length>0,a=o?"DefaultWithoutDependencies":"Default";let u,c=!1;if("effect"in t?(c="function"==typeof t.effect,Object.defineProperty(TagClass,a,{get(){return c?function(){return p0(TagClass,P3(t.effect.apply(null,arguments),e=>new this(e)))}.bind(this):u??=p0(TagClass,P3(t.effect,e=>new this(e)))}})):"scoped"in t?(c="function"==typeof t.scoped,Object.defineProperty(TagClass,a,{get(){return c?function(){return k0(TagClass,P3(t.scoped.apply(null,arguments),e=>new this(e)))}.bind(this):u??=k0(TagClass,P3(t.scoped,e=>new this(e)))}})):Object.defineProperty(TagClass,a,"sync"in t?{get(){return u??=O0(TagClass,()=>new this(t.sync()))}}:{get(){return u??=I0(TagClass,new this(t.succeed))}}),o){let e;Object.defineProperty(TagClass,"Default",{get(){return c?function(){return F0(this.DefaultWithoutDependencies.apply(null,arguments),t.dependencies)}:e??=F0(this.DefaultWithoutDependencies,t.dependencies)}})}return!0===r?makeTagProxy(TagClass):TagClass}},Tag:e=>()=>{const t=Error.stackTraceLimit;Error.stackTraceLimit=2;const r=Error();function TagClass(){}return Error.stackTraceLimit=t,Object.setPrototypeOf(TagClass,SA),TagClass.key=e,Object.defineProperty(TagClass,"use",{get(){return e=>NR(this,e)}}),Object.defineProperty(TagClass,"stack",{get:()=>r.stack}),makeTagProxy(TagClass)},acquireRelease:U3,acquireReleaseInterruptible:$3,acquireUseRelease:B3,addFinalizer:z3,all:d4,allSuccesses:(e,t)=>qR(all$6(fromIterable$v(e).map(exit$2),t),ls(e=>exitIsSuccess$1(e)?Ut(e.effect_instruction_i0):none$c())),allWith:e=>t=>all$6(t,e),allowInterrupt:S3,andThen:d7,annotateCurrentSpan:function(){const e=arguments;return ignore$4(PR(IW,t=>sync$l(()=>{if("string"==typeof e[0])t.attribute(e[0],e[1]);else for(const r in e[0])t.attribute(r,e[0][r])})))},annotateLogs:e8,annotateLogsScoped:function(){if("string"==typeof arguments[0])return OQ(qD,vP(arguments[0],arguments[1]));const e=Object.entries(arguments[0]);return OQ(qD,kP(t=>{for(let r=0;r<e.length;r++){const[n,i]=e[r];vP(t,n,i)}return t}))},annotateSpans:Q8,ap:D8,as:E3,asSome:A3,asSomeError:e=>VR(e,Ut),asVoid:C3,async:j4,asyncEffect:e=>suspend$g(()=>{let t;return PR(deferredMake(),r=>PR(runtime$4(),n=>uninterruptibleMask$2(i=>lD(fork$2(i(RR(e(e=>kX(n)(zR(e,r))),{onFailure:e=>YL(r,e),onSuccess:e=>(t=e,tD)}))),i(JR(deferredAwait(r),()=>t??tD))))))}),awaitAllChildren:e=>GY(e,fiberAwaitAll),bind:G5,bindAll:J5,bindTo:H5,blocked:L8,cacheRequestResult:(e,t)=>ED(Z6,r=>r?ED(H6,r=>PR(r.getEither(e),e=>{switch(e._tag){case"Left":return tD;case"Right":return GL(e.right.handle,t)}})):tD),cached:f4,cachedFunction:(e,t)=>pipe(sync$l(()=>empty$B()),PR(makeSynchronized),qR(r=>n=>pipe(r.modifyEffect(r=>{const i=pipe(r,zU(new Key(n,t)));return Bt(i)?pipe(deferredMake(),XR(t=>pipe(diffFiberRefs$1(e(n)),zR(t),fork$2)),qR(e=>[e,pipe(r,WU(new Key(n,t),e))])):succeed$u([i.value,r])}),PR(deferredAwait),PR(([e,t])=>pipe(patchFiberRefs$1(e),TR(t)))))),cachedInvalidateWithTTL:p4,cachedWithTTL:l4,catch:X4,catchAll:e3,catchAllCause:t3,catchAllDefect:r3,catchIf:n3,catchSome:i3,catchSomeCause:s3,catchSomeDefect:o3,catchTag:a3,catchTags:u3,cause:e=>jR(e,{onFailure:identity$5,onSuccess:()=>tR}),checkInterruptible:e=>withFiberRuntime$1((t,r)=>e(interruption$1(r.runtimeFlags))),clock:b5,clockWith:S5,configProviderWith:P5,console:w5,consoleWith:k5,context:R5,contextWith:contextWith$8,contextWithEffect:D5,currentParentSpan:X8,currentSpan:Y8,custom:R4,daemonChildren:e=>LD(tL,Ut(pG))(e),delay:I5,descriptor:X3,descriptorWith:e5,die:z4,dieMessage:q4,dieSync:W4,diffFiberRefs:t5,disconnect:e=>uninterruptibleMask$2(t=>fiberIdWith$1(r=>PR(forkDaemon$1(t(e)),e=>pipe(t(join$4(e)),JR(()=>pipe(e,bG(r))))))),dropUntil:m4,dropWhile:g4,either:Q5,ensureErrorType:()=>e=>e,ensureRequirementsType:()=>e=>e,ensureSuccessType:()=>e=>e,ensuring:q3,ensuringChild:r5,ensuringChildren:n5,eventually:c3,every:S4,exists:v4,exit:Y5,fail:L4,failCause:$4,failCauseSync:B4,failSync:U4,fiberId:i5,fiberIdWith:s5,filter:_4,filterEffectOrElse:s7,filterEffectOrFail:o7,filterMap:w4,filterOrDie:t7,filterOrDieMessage:r7,filterOrElse:n7,filterOrFail:i7,finalizersMask:e=>t=>finalizersMaskInternal(e,!0)(t),findFirst:k4,firstSuccessOf:e=>suspend$g(()=>{const t=fromIterable$u(e);return isNonEmpty$8(t)?pipe(tailNonEmpty(t),ys(lC(t),(e,t)=>HR(e,()=>t))):dieSync$a(()=>new gL("Received an empty collection of effects"))}),flatMap:h7,flatten:m7,flip:M3,flipWith:F3,fn:function(e,...t){const r=Error.stackTraceLimit;Error.stackTraceLimit=2;const n=Error();if(Error.stackTraceLimit=r,"string"!=typeof e)return defineLength(e.length,function(...r){const i=Error.stackTraceLimit;Error.stackTraceLimit=2;const s=Error();return Error.stackTraceLimit=i,fnApply({self:this,body:e,args:r,pipeables:t,spanName:"<anonymous>",spanOptions:{context:cB.context(!0)},errorDef:n,errorCall:s})});const name=e,i=t[0];return(e,...t)=>defineLength(e.length,{[name](...r){const s=Error.stackTraceLimit;Error.stackTraceLimit=2;const o=Error();return Error.stackTraceLimit=s,fnApply({self:this,body:e,args:r,pipeables:t,spanName:name,spanOptions:i,errorDef:n,errorCall:o})}}[name])},fnUntraced:u9,forEach:x4,forever:T7,fork:o5,forkAll:u5,forkDaemon:a5,forkIn:c5,forkScoped:l5,forkWithErrorHandler:p5,fromFiber:e=>join$4(e),fromFiberEffect:e=>suspend$g(()=>PR(e,join$4)),fromNullable:e=>null==e?fail$r(new bL):succeed$u(e),functionWithSpan:e=>function(){let t=e.captureStackTrace??!1;if(!1!==e.captureStackTrace){const e=Error.stackTraceLimit;Error.stackTraceLimit=2;const r=Error();Error.stackTraceLimit=e;let n=!1;t=()=>{if(!1!==n)return n;if(r.stack){const e=r.stack.trim().split("\n");return n=e.slice(2).join("\n").trim(),n}}}return suspend$g(()=>{const r="function"==typeof e.options?e.options.apply(null,arguments):e.options;return withSpan$7(suspend$g(()=>K(()=>e.body.apply(this,arguments))),r.name,{...r,captureStackTrace:t})})},gen:V4,getFiberRefs:j7,getRuntimeFlags:d8,head:e=>PR(e,e=>{const t=e[Symbol.iterator]().next();return t.done?fail$r(new bL):succeed$u(t.value)}),if:e7,ignore:l3,ignoreLogged:p3,inheritFiberRefs:e=>updateFiberRefs$3((t,r)=>DB(r,t,e)),interrupt:v3,interruptWith:_3,interruptible:w3,interruptibleMask:k3,intoDeferred:X5,isEffect:c4,isFailure:e=>Mq(e,{onFailure:r,onSuccess:n}),isSuccess:e=>Mq(e,{onFailure:n,onSuccess:r}),iterate:O7,labelMetrics:S8,labelMetricsScoped:v8,let:Z5,liftPredicate:O3,linkSpanCurrent:function(){const e=arguments,t=Array.isArray(e[0])?e[0]:[{_tag:"SpanLink",span:e[0],attributes:e[1]??{}}];return ignore$4(PR(IW,e=>sync$l(()=>e.addLinks(t))))},linkSpans:r9,locally:R7,locallyScoped:L7,locallyScopedWith:U7,locallyWith:D7,log:K7,logAnnotations:t8,logDebug:J7,logError:Q7,logFatal:Y7,logInfo:H7,logTrace:G7,logWarning:Z7,logWithLevel:(e,...t)=>logWithLevel$1(e)(...t),loop:(e,t)=>t.discard?loopDiscard(e,t.while,t.step,t.body):qR(loopInternal(e,t.while,t.step,t.body),fromIterable$v),makeLatch:e=>sync$l(()=>unsafeMakeLatch$1(e)),makeSemaphore,makeSpan,makeSpanScoped:n9,map:P3,mapAccum:N3,mapBoth:j3,mapError:R3,mapErrorCause:D3,mapInputContext:L5,match:z7,matchCause:q7,matchCauseEffect:W7,matchEffect:V7,merge:e=>DR(e,{onFailure:e=>succeed$u(e),onSuccess:succeed$u}),mergeAll:I4,metricLabels:_8,negate:L3,never:K4,none:e=>PR(e,e=>{switch(e._tag){case"None":return tD;case"Some":return fail$r(new bL)}}),onError:W3,onExit:V3,onInterrupt:x3,once:h4,option:e=>DR(e,{onFailure:()=>succeed$u(none$c()),onSuccess:e=>succeed$u(Ut(e))}),optionFromOptional:e=>ER(qR(e,Ut),e=>isNoSuchElementException$1(e)?tW:fail$r(e)),orDie:i8,orDieWith:s8,orElse:o8,orElseFail:a8,orElseSucceed:u8,parallelErrors:e=>RR(e,{onFailure:e=>{const t=fromIterable$v(failures$1(e));return 0===t.length?failCause$j(e):fail$r(t)},onSuccess:succeed$u}),parallelFinalizers:K3,partition:T4,patchFiberRefs:$7,patchRuntimeFlags:m8,promise,provide:U5,provideService:$5,provideServiceEffect:B5,race:g7,raceAll:e=>withFiberRuntime$1((t,r)=>async_(n=>{const i=new Set;let s,o=tR;const interruptAll=()=>{for(const e of i)e.unsafeInterruptAsFork(t.id())};let a=!1,u=!0;for(const c of e){u=!1;const e=unsafeFork$1(interruptible$3(c),t,r.runtimeFlags);if(i.add(e),e.addObserver(t=>{i.delete(e),s||("Success"===t._tag?(a=!0,s=e,o=tR,interruptAll()):o=parallel$4(t.cause,o)),a&&0===i.size&&n(s?lD(inheritAll$1(s),s.unsafePoll()):failCause$j(o))}),s)break}return u?n(dieSync$a(()=>new gL("Received an empty collection of effects"))):(a=!0,yG(i,t.id()))})),raceFirst:y7,raceWith:b7,random:c8,randomWith:l8,reduce:O4,reduceEffect:C4,reduceRight:A4,reduceWhile:E4,repeat:E7,repeatN:A7,repeatOrElse:C7,replicate:M4,replicateEffect:F4,request:B8,retry:f3,retryOrElse:d3,runCallback:T8,runFork:I8,runPromise:O8,runPromiseExit:E8,runRequestBlock:U8,runSync:A8,runSyncExit:C8,runtime:h8,sandbox:e=>RR(e,{onFailure:fail$r,onSuccess:succeed$u}),schedule:M7,scheduleForked:F7,scheduleFrom:P7,scope:J3,scopeWith:H3,scoped:Q3,scopedWith:Z3,sequentialFinalizers:G3,serviceConstants:q5,serviceFunction:(e,t)=>(...r)=>qR(e,e=>t(e)(...r)),serviceFunctionEffect:(e,t)=>(...r)=>PR(e,e=>t(e)(...r)),serviceFunctions:z5,serviceMembers:e=>({functions:serviceFunctions$1(e),constants:serviceConstants$1(e)}),serviceOption:e=>qR(context$c(),DA(e)),serviceOptional:W5,setFiberRefs:e=>suspend$g(()=>setAll(e)),sleep:T5,spanAnnotations:e9,spanLinks:t9,step:$8,succeed:G4,succeedNone:J4,succeedSome:e=>succeed$u(Ut(e)),summarized:S7,supervised:f5,suspend:H4,sync:Z4,tagMetrics:b8,tagMetricsScoped:(e,t)=>labelMetricsScoped$1([make$1L(e,t)]),takeUntil:y4,takeWhile:b4,tap:v7,tapBoth:_7,tapDefect:w7,tapError:k7,tapErrorCause:I7,tapErrorTag:x7,timed:e=>fW(e,wB),timedWith:O5,timeout:E5,timeoutFail:C5,timeoutFailCause:M5,timeoutOption:A5,timeoutTo:F5,tracer:V8,tracerWith:K8,transplant:h5,transposeMapOption:a9,transposeOption:e=>isNone$3(e)?J4:P3(e.value,some$k),try:m3,tryMap:g3,tryMapPromise:y3,tryPromise:b3,uninterruptible:I3,uninterruptibleMask:T3,unless:a7,unlessEffect:u7,unsafeMakeLatch:x8,unsafeMakeSemaphore:k8,unsandbox:e=>Wq(e,flatten$d),updateFiberRefs:B7,updateService:V5,useSpan:i9,using:Y3,validate:M8,validateAll:P4,validateFirst:N4,validateWith:F8,void:Q4,when:c7,whenEffect:l7,whenFiberRef:p7,whenLogLevel:n8,whenRef:f7,whileLoop:N7,withClock:_5,withClockScoped:v5,withConcurrency:d5,withConfigProvider:N5,withConfigProviderScoped:j5,withConsole:x5,withConsoleScoped:e=>OQ(pB,NA(eB,e)),withEarlyRelease:e=>scopeWith$1(t=>PR(scopeFork(t,jW),t=>pipe(e,xQ(t),qR(e=>[fiberIdWith$1(e=>scopeClose(t,exitInterrupt$1(e))),e])))),withExecutionPlan:h3,withFiberRuntime:D4,withLogSpan:X7,withMaxOpsBeforeYield:y5,withMetric:w8,withParentSpan:o9,withRandom:p8,withRandomFixed:f8,withRandomScoped:e=>OQ(pB,NA(nB,e)),withRequestBatching:z8,withRequestCache:W8,withRequestCaching:q8,withRuntimeFlagsPatch:g8,withRuntimeFlagsPatchScoped:y8,withScheduler:m5,withSchedulingPriority:g5,withSpan:s9,withSpanScoped:function(){const e="string"!=typeof arguments[0],name=e?arguments[1]:arguments[0],t=addSpanStackTrace(e?arguments[2]:arguments[1]);if(e){const e=arguments[0];return PR(makeSpanScoped$1(name,addSpanStackTrace(t)),t=>Gq(e,oB,t))}return e=>PR(makeSpanScoped$1(name,addSpanStackTrace(t)),t=>Gq(e,oB,t))},withTracer:G8,withTracerEnabled:H8,withTracerScoped:J8,withTracerTiming:Z8,withUnhandledErrorLogLevel:r8,yieldNow:Y4,zip:P8,zipLeft:N8,zipRight:j8,zipWith:R8});const l9=fiberRefUnsafeMake,p9=fiberRefGet,f9=ED,h9=$D,d9=BD,m9=rG,g9=iL;var y9=Object.freeze({__proto__:null,FiberRefTypeId:kD,currentConcurrency:JD,currentContext:h9,currentLogAnnotations:qD,currentLogLevel:WD,currentLogSpan:VD,currentLoggers:QZ,currentMaxOpsBeforeYield:zD,currentMetricLabels:XD,currentMinimumLogLevel:WZ,currentRequestBatchingEnabled:HD,currentRequestCache:H6,currentRequestCacheEnabled:Z6,currentRuntimeFlags:EQ,currentScheduler:m9,currentSchedulingPriority:d9,currentSupervisor:AQ,currentTracerEnabled:nL,currentTracerSpanAnnotations:sL,currentTracerSpanLinks:oL,currentTracerTimingEnabled:g9,delete:fiberRefDelete,get:p9,getAndSet:ID,getAndUpdate:TD,getAndUpdateSome:OD,getWith:f9,interruptedCause:rL,make:fiberRefMake,makeContext:e=>fiberRefMakeWith(()=>fiberRefUnsafeMakeContext(e)),makeRuntimeFlags:e=>fiberRefMakeWith(()=>fiberRefUnsafeMakeRuntimeFlags(e)),makeWith:fiberRefMakeWith,modify:CD,modifySome:(e,t,r)=>CD(e,e=>Kt(r(e),()=>[t,e])),reset:e=>AD(e,e.initial),set:AD,unhandledErrorLogLevel:ZD,unsafeMake:l9,unsafeMakeContext:fiberRefUnsafeMakeContext,unsafeMakeHashSet:fiberRefUnsafeMakeHashSet,unsafeMakePatch:fiberRefUnsafeMakePatch,unsafeMakeSupervisor:fiberRefUnsafeMakeSupervisor,update:MD,updateAndGet:PD,updateSome:FD,updateSomeAndGet:ND,versionMismatchErrorLogLevel:QD});const b9=dual(2,(e,t)=>LD(WZ,t)(e)),addLogger=e=>scopedDiscard$1(OQ(QZ,AF(e))),addLoggerEffect=e=>unwrapEffect$1(qR(e,addLogger)),addLoggerScoped=e=>unwrapScoped$7(qR(e,addLogger)),removeLogger=e=>scopedDiscard$1(OQ(QZ,CF(e))),S9=dual(2,(e,t)=>c0(removeLogger(e),()=>addLogger(t))),v9=dual(2,(e,t)=>c0(removeLogger(e),()=>addLoggerEffect(t))),_9=dual(2,(e,t)=>c0(removeLogger(e),()=>addLoggerScoped(t))),w9=scopedDiscard$1(withRuntimeFlagsScoped(enable$3(wj))),k9=scopedDiscard$1(withRuntimeFlagsScoped(enable$3(1))),x9=scopedDiscard$1(withRuntimeFlagsScoped(enable$3(2))),I9=scopedDiscard$1(withRuntimeFlagsScoped(enable$3(4))),T9=scopedDiscard$1(withRuntimeFlagsScoped(enable$3(_j))),O9=scopedDiscard$1(withRuntimeFlagsScoped(disable$3(wj))),E9=scopedDiscard$1(withRuntimeFlagsScoped(disable$3(1))),A9=scopedDiscard$1(withRuntimeFlagsScoped(disable$3(2))),C9=scopedDiscard$1(withRuntimeFlagsScoped(disable$3(4))),M9=scopedDiscard$1(withRuntimeFlagsScoped(disable$3(_j))),F9=e0,P9=r0,N9=n0,j9=isLayer$1,R9=isFresh$1,D9=j0,L9=R0,U9=build$1,$9=s0,B9=a0,z9=u0,q9=context$a,W9=die$b,V9=p0,K9=fromEffectContext,G9=T0,J9=fail$j,H9=failSync$a,Z9=failCause$c,Q9=failCauseSync$8,Y9=c0,X9=l0,eee=fresh$1,tee=m0,ree=g0,nee=b0,iee=y0,see=S0,oee=mergeAll$8,aee=v0,uee=_0,cee=h0,lee=f0,pee=d0,fee=w0,hee=x0,dee=k0,mee=scopedDiscard$1,gee=scopedContext$1,yee=I0,bee=succeedContext$1,See=suspend$e,vee=O0,_ee=syncContext$1,wee=E0,kee=A0,xee=C0,Iee=M0,Tee=F0,Oee=P0,Eee=N0,Aee=unwrapEffect$1,Cee=unwrapScoped$7,Mee=D0,Fee=i0,Pee=o0,Nee=dual(3,(e,t,r)=>Tee(e,tee(q9(),e=>NA(e,t,r(RA(e,t))))));var jee=Object.freeze({__proto__:null,CurrentMemoMap:N9,LayerTypeId:F9,MemoMapTypeId:P9,annotateLogs:D9,annotateSpans:L9,build:U9,buildWithMemoMap:Pee,buildWithScope:$9,catchAll:B9,catchAllCause:z9,context:q9,die:W9,dieSync:e=>failCauseSync$8(()=>qQ(e())),discard:e=>m0(e,()=>empty$S()),effect:V9,effectContext:K9,effectDiscard:e=>fromEffectContext(qR(e,()=>empty$S())),empty:G9,extendScope:e=>{const t=Object.create(t0);return t._op_layer="ExtendScope",t.layer=e,t},fail:J9,failCause:Z9,failCauseSync:Q9,failSync:H9,fiberRefLocallyScopedWith:(e,t)=>scopedDiscard$1(OQ(e,t)),flatMap:Y9,flatten:X9,fresh:eee,function:(e,t,r)=>fromEffectContext(qR(e,e=>PA(t,r(e)))),isFresh:R9,isLayer:j9,launch:e=>scopedEffect(lD(scopeWith$1(t=>pipe(e,s0(t))),fD)),locally:lee,locallyEffect:cee,locallyScoped:(e,t)=>scopedDiscard$1(TQ(e,t)),locallyWith:pee,makeMemoMap:Fee,map:tee,mapError:ree,match:nee,matchCause:iee,memoize:e=>scopeWith$1(t=>qR(memoize$2(s0(e,t)),fromEffectContext)),merge:see,mergeAll:oee,mock:function(){return 1===arguments.length?e=>mockImpl(arguments[0],e):mockImpl(arguments[0],arguments[1])},orDie:e=>a0(e,e=>die$b(e)),orElse:aee,parentSpan:e=>succeedContext$1(PA(oB,e)),passthrough:e=>S0(context$a(),e),project:uee,provide:Tee,provideMerge:Oee,retry:fee,scope:hee,scoped:dee,scopedContext:gee,scopedDiscard:mee,service:e=>p0(e,e),setClock:e=>mee(OQ(pB,NA(c$,e))),setConfigProvider:e=>scopedDiscard$1(withConfigProviderScoped$1(e)),setRandom:e=>mee(OQ(pB,NA(nB,e))),setRequestBatching:e=>mee(TQ(HD,e)),setRequestCache:e=>mee(isEffect$1(e)?PR(e,e=>TQ(H6,e)):TQ(H6,e)),setRequestCaching:e=>mee(TQ(Z6,e)),setScheduler:e=>mee(TQ(rG,e)),setTracer:e=>scopedDiscard$1(withTracerScoped$1(e)),setTracerEnabled:e=>mee(TQ(nL,e)),setTracerTiming:e=>mee(TQ(iL,e)),setUnhandledErrorLogLevel:e=>mee(TQ(ZD,e)),setVersionMismatchErrorLogLevel:e=>mee(TQ(QD,e)),span:(name,e)=>(e=addSpanStackTrace(e),k0(oB,e?.onEnd?XR(makeSpanScoped$1(name,e),t=>addFinalizer$2(r=>e.onEnd(t,r))):makeSpanScoped$1(name,e))),succeed:yee,succeedContext:bee,suspend:See,sync:vee,syncContext:_ee,tap:wee,tapError:kee,tapErrorCause:xee,toRuntime:e=>pipe(scopeWith$1(t=>s0(e,t)),PR(e=>pipe(runtime$4(),oU(e)))),toRuntimeWithMemoMap:Iee,unwrapEffect:Aee,unwrapScoped:Cee,updateService:Nee,withParentSpan:Mee,withSpan:function(){const e="string"!=typeof arguments[0],name=e?arguments[1]:arguments[0],t=addSpanStackTrace(e?arguments[2]:arguments[1]);if(e){const e=arguments[0];return unwrapScoped$7(qR(t?.onEnd?XR(makeSpanScoped$1(name,t),e=>addFinalizer$2(r=>t.onEnd(e,r))):makeSpanScoped$1(name,t),t=>D0(e,t)))}return e=>unwrapScoped$7(qR(t?.onEnd?XR(makeSpanScoped$1(name,t),e=>addFinalizer$2(r=>t.onEnd(e,r))):makeSpanScoped$1(name,t),t=>D0(e,t)))},zipWith:Eee});const Ree=Symbol.for("effect/QueueEnqueue"),Dee=Symbol.for("effect/QueueDequeue"),Lee=Symbol.for("effect/QueueStrategy"),Uee=Symbol.for("effect/BackingQueue"),$ee={_A:e=>e},Bee={_A:e=>e},zee={_In:e=>e},qee={_Out:e=>e};class QueueImpl extends hz{queue;takers;shutdownHook;shutdownFlag;strategy;[Ree]=zee;[Dee]=qee;constructor(e,t,r,n,i){super(),this.queue=e,this.takers=t,this.shutdownHook=r,this.shutdownFlag=n,this.strategy=i}pipe(){return pipeArguments(this,arguments)}commit(){return this.take}capacity(){return this.queue.capacity()}get size(){return suspend$g(()=>ER(this.unsafeSize(),()=>BR))}unsafeSize(){return get$E(this.shutdownFlag)?none$c():Ut(this.queue.length()-length$2(this.takers)+this.strategy.surplusSize())}get isEmpty(){return qR(this.size,e=>e<=0)}get isFull(){return qR(this.size,e=>e>=this.capacity())}get shutdown(){return uninterruptible$2(withFiberRuntime$1(e=>(pipe(this.shutdownFlag,qF(!0)),pipe(forEachConcurrentDiscard(unsafePollAll(this.takers),t=>rU(t,e.id()),!1,!1),lD(this.strategy.shutdown),rD(nU(this.shutdownHook,void 0)),asVoid$9))))}get isShutdown(){return sync$l(()=>get$E(this.shutdownFlag))}get awaitShutdown(){return deferredAwait(this.shutdownHook)}isActive(){return!get$E(this.shutdownFlag)}unsafeOffer(e){if(get$E(this.shutdownFlag))return!1;let t;if(0===this.queue.length()){const r=pipe(this.takers,s$(t$));r!==t$?(unsafeCompleteDeferred$1(r,e),t=!0):t=!1}else t=!1;if(t)return!0;const r=this.queue.offer(e);return unsafeCompleteTakers(this.strategy,this.queue,this.takers),r}offer(e){return suspend$g(()=>{if(get$E(this.shutdownFlag))return BR;let t;if(0===this.queue.length()){const r=pipe(this.takers,s$(t$));r!==t$?(unsafeCompleteDeferred$1(r,e),t=!0):t=!1}else t=!1;if(t)return succeed$u(!0);const r=this.queue.offer(e);return unsafeCompleteTakers(this.strategy,this.queue,this.takers),r?succeed$u(!0):this.strategy.handleSurplus([e],this.queue,this.takers,this.shutdownFlag)})}offerAll(e){return suspend$g(()=>{if(get$E(this.shutdownFlag))return BR;const t=fromIterable$v(e),r=0===this.queue.length()?fromIterable$v(unsafePollN$1(this.takers,t.length)):empty$U,[n,i]=pipe(t,Gi(r.length));for(let e=0;e<r.length;e++){const t=r[e],i=n[e];unsafeCompleteDeferred$1(t,i)}if(0===i.length)return succeed$u(!0);const s=this.queue.offerAll(i);return unsafeCompleteTakers(this.strategy,this.queue,this.takers),isEmpty$t(s)?succeed$u(!0):this.strategy.handleSurplus(s,this.queue,this.takers,this.shutdownFlag)})}get take(){return withFiberRuntime$1(e=>{if(get$E(this.shutdownFlag))return BR;const t=this.queue.poll(t$);if(t!==t$)return this.strategy.unsafeOnQueueEmptySpace(this.queue,this.takers),succeed$u(t);{const t=deferredUnsafeMake(e.id());return pipe(suspend$g(()=>(pipe(this.takers,n$(t)),unsafeCompleteTakers(this.strategy,this.queue,this.takers),get$E(this.shutdownFlag)?BR:deferredAwait(t))),JR(()=>sync$l(()=>unsafeRemove$1(this.takers,t))))}})}get takeAll(){return suspend$g(()=>get$E(this.shutdownFlag)?BR:sync$l(()=>{const e=this.queue.pollUpTo(1/0);return this.strategy.unsafeOnQueueEmptySpace(this.queue,this.takers),fromIterable$u(e)}))}takeUpTo(e){return suspend$g(()=>get$E(this.shutdownFlag)?BR:sync$l(()=>{const t=this.queue.pollUpTo(e);return this.strategy.unsafeOnQueueEmptySpace(this.queue,this.takers),fromIterable$u(t)}))}takeBetween(e,t){return suspend$g(()=>takeRemainderLoop$1(this,e,t,empty$R()))}}const takeRemainderLoop$1=(e,t,r,n)=>r<t?succeed$u(n):pipe(Gee(e,r),PR(i=>{const s=t-i.length;return 1===s?pipe(take$a(e),qR(e=>pipe(n,eC(i),GA(e)))):s>1?pipe(take$a(e),PR(t=>takeRemainderLoop$1(e,s-1,r-i.length-1,pipe(n,eC(i),GA(t))))):succeed$u(pipe(n,eC(i)))})),isEnqueue$1=e=>C(e,Ree),isDequeue$1=e=>C(e,Dee),unbounded$7=()=>pipe(sync$l(()=>unbounded$8()),PR(e=>make$1p(backingQueueFromMutableQueue(e),droppingStrategy$1()))),make$1p=(e,t)=>pipe(deferredMake(),qR(r=>((e,t,r,n,i)=>new QueueImpl(e,t,r,n,i))(e,unbounded$8(),r,make$27(!1),t)));class BackingQueueFromMutableQueue{mutable;[Uee]=Bee;constructor(e){this.mutable=e}poll(e){return s$(this.mutable,e)}pollUpTo(e){return o$(this.mutable,e)}offerAll(e){return i$(this.mutable,e)}offer(e){return n$(this.mutable,e)}capacity(){return capacity$8(this.mutable)}length(){return length$2(this.mutable)}}const backingQueueFromMutableQueue=e=>new BackingQueueFromMutableQueue(e),Wee=dual(2,(e,t)=>e.offer(t)),Vee=dual(2,(e,t)=>e.unsafeOffer(t)),Kee=dual(2,(e,t)=>e.offerAll(t)),take$a=e=>e.take,Gee=dual(2,(e,t)=>e.takeUpTo(t)),Jee=dual(3,(e,t,r)=>e.takeBetween(t,r)),Hee=dual(2,(e,t)=>e.takeBetween(t,t)),backPressureStrategy$1=()=>new Zee,droppingStrategy$1=()=>new Qee,slidingStrategy$1=()=>new Yee;let Zee=class{[Lee]=$ee;putters=unbounded$8();surplusSize(){return length$2(this.putters)}onCompleteTakersWithEmptyQueue(e){for(;!isEmpty$l(this.putters)&&!isEmpty$l(e);){const t=s$(e,void 0),r=s$(this.putters,void 0);r[2]&&unsafeCompleteDeferred$1(r[1],!0),unsafeCompleteDeferred$1(t,r[0])}}get shutdown(){return pipe(FR,PR(e=>pipe(sync$l(()=>unsafePollAll(this.putters)),PR(t=>forEachConcurrentDiscard(t,([t,r,n])=>n?pipe(rU(r,e),asVoid$9):tD,!1,!1)))))}handleSurplus(e,t,r,n){return withFiberRuntime$1(i=>{const s=deferredUnsafeMake(i.id());return pipe(suspend$g(()=>(this.unsafeOffer(e,s),this.unsafeOnQueueEmptySpace(t,r),unsafeCompleteTakers(this,t,r),get$E(n)?BR:deferredAwait(s))),JR(()=>sync$l(()=>this.unsafeRemove(s))))})}unsafeOnQueueEmptySpace(e,t){let r=!0;for(;r&&(e.capacity()===1/0||e.length()<e.capacity());){const n=pipe(this.putters,s$(t$));if(n===t$)r=!1;else{const r=e.offer(n[0]);r&&n[2]?unsafeCompleteDeferred$1(n[1],!0):r||unsafeOfferAll$1(this.putters,pipe(unsafePollAll(this.putters),JA(n))),unsafeCompleteTakers(this,e,t)}}}unsafeOffer(e,t){const r=fromIterable$v(e);for(let e=0;e<r.length;e++){const n=r[e];e===r.length-1?pipe(this.putters,n$([n,t,!0])):pipe(this.putters,n$([n,t,!1]))}}unsafeRemove(e){unsafeOfferAll$1(this.putters,pipe(unsafePollAll(this.putters),rC(([,t])=>t!==e)))}},Qee=class{[Lee]=$ee;surplusSize(){return 0}get shutdown(){return tD}onCompleteTakersWithEmptyQueue(){}handleSurplus(e,t,r,n){return succeed$u(!1)}unsafeOnQueueEmptySpace(e,t){}},Yee=class{[Lee]=$ee;surplusSize(){return 0}get shutdown(){return tD}onCompleteTakersWithEmptyQueue(){}handleSurplus(e,t,r,n){return sync$l(()=>(this.unsafeOffer(t,e),unsafeCompleteTakers(this,t,r),!0))}unsafeOnQueueEmptySpace(e,t){}unsafeOffer(e,t){const r=t[Symbol.iterator]();let n,i=!0;for(;!(n=r.next()).done&&i;){if(0===e.capacity())return;e.poll(t$),i=e.offer(n.value)}}};const unsafeCompleteDeferred$1=(e,t)=>deferredUnsafeDone(e,succeed$u(t)),unsafeOfferAll$1=(e,t)=>pipe(e,i$(t)),unsafePollAll=e=>pipe(e,o$(1/0)),unsafePollN$1=(e,t)=>pipe(e,o$(t)),unsafeRemove$1=(e,t)=>{unsafeOfferAll$1(e,pipe(unsafePollAll(e),rC(e=>t!==e)))},unsafeCompleteTakers=(e,t,r)=>{let n=!0;for(;n&&0!==t.length();){const i=pipe(r,s$(t$));if(i!==t$){const s=t.poll(t$);s!==t$?(unsafeCompleteDeferred$1(i,s),e.unsafeOnQueueEmptySpace(t,r)):unsafeOfferAll$1(r,pipe(unsafePollAll(r),JA(i))),n=!0}else n=!1}n&&0===t.length()&&!isEmpty$l(r)&&e.onCompleteTakersWithEmptyQueue(r)},Xee=Symbol.for("effect/PubSub/AbsentValue"),addSubscribers=(e,t)=>r=>{r.has(e)||r.set(e,new Set),r.get(e).add(t)},removeSubscribers=(e,t)=>r=>{if(!r.has(e))return;const n=r.get(e);n.delete(t),0===n.size&&r.delete(e)},ete=dual(2,(e,t)=>e.publish(t)),tte=dual(2,(e,t)=>e.publishAll(t)),makeBoundedPubSub=e=>{const t="number"==typeof e?{capacity:e}:e;ensureCapacity(t.capacity);const r=t.replay&&t.replay>0?new ReplayBuffer(Math.ceil(t.replay)):void 0;return 1===t.capacity?new BoundedPubSubSingle(r):nextPow2(t.capacity)===t.capacity?new BoundedPubSubPow2(t.capacity,r):new BoundedPubSubArb(t.capacity,r)};class BoundedPubSubArb{capacity;replayBuffer;array;publisherIndex=0;subscribers;subscriberCount=0;subscribersIndex=0;constructor(e,t){this.capacity=e,this.replayBuffer=t,this.array=Array.from({length:e}),this.subscribers=Array.from({length:e})}replayWindow(){return this.replayBuffer?new ReplayWindowImpl(this.replayBuffer):rte}isEmpty(){return this.publisherIndex===this.subscribersIndex}isFull(){return this.publisherIndex===this.subscribersIndex+this.capacity}size(){return this.publisherIndex-this.subscribersIndex}publish(e){if(this.isFull())return!1;if(0!==this.subscriberCount){const t=this.publisherIndex%this.capacity;this.array[t]=e,this.subscribers[t]=this.subscriberCount,this.publisherIndex+=1}return this.replayBuffer&&this.replayBuffer.offer(e),!0}publishAll(e){if(0===this.subscriberCount)return this.replayBuffer&&this.replayBuffer.offerAll(e),empty$R();const t=fromIterable$u(e),r=t.length,n=this.publisherIndex-this.subscribersIndex,i=this.capacity-n,s=Math.min(r,i);if(0===s)return t;let o=0;const a=this.publisherIndex+s;for(;this.publisherIndex!==a;){const e=KA(t,o++),r=this.publisherIndex%this.capacity;this.array[r]=e,this.subscribers[r]=this.subscriberCount,this.publisherIndex+=1,this.replayBuffer&&this.replayBuffer.offer(e)}return ZA(t,o)}slide(){if(this.subscribersIndex!==this.publisherIndex){const e=this.subscribersIndex%this.capacity;this.array[e]=Xee,this.subscribers[e]=0,this.subscribersIndex+=1}this.replayBuffer&&this.replayBuffer.slide()}subscribe(){return this.subscriberCount+=1,new BoundedPubSubArbSubscription(this,this.publisherIndex,!1)}}class BoundedPubSubArbSubscription{self;subscriberIndex;unsubscribed;constructor(e,t,r){this.self=e,this.subscriberIndex=t,this.unsubscribed=r}isEmpty(){return this.unsubscribed||this.self.publisherIndex===this.subscriberIndex||this.self.publisherIndex===this.self.subscribersIndex}size(){return this.unsubscribed?0:this.self.publisherIndex-Math.max(this.subscriberIndex,this.self.subscribersIndex)}poll(e){if(this.unsubscribed)return e;if(this.subscriberIndex=Math.max(this.subscriberIndex,this.self.subscribersIndex),this.subscriberIndex!==this.self.publisherIndex){const e=this.subscriberIndex%this.self.capacity,t=this.self.array[e];return this.self.subscribers[e]-=1,0===this.self.subscribers[e]&&(this.self.array[e]=Xee,this.self.subscribersIndex+=1),this.subscriberIndex+=1,t}return e}pollUpTo(e){if(this.unsubscribed)return empty$R();this.subscriberIndex=Math.max(this.subscriberIndex,this.self.subscribersIndex);const t=this.self.publisherIndex-this.subscriberIndex,r=Math.min(e,t);if(r<=0)return empty$R();const n=[],i=this.subscriberIndex+r;for(;this.subscriberIndex!==i;){const e=this.subscriberIndex%this.self.capacity,t=this.self.array[e];this.self.subscribers[e]-=1,0===this.self.subscribers[e]&&(this.self.array[e]=Xee,this.self.subscribersIndex+=1),n.push(t),this.subscriberIndex+=1}return fromIterable$u(n)}unsubscribe(){if(!this.unsubscribed)for(this.unsubscribed=!0,this.self.subscriberCount-=1,this.subscriberIndex=Math.max(this.subscriberIndex,this.self.subscribersIndex);this.subscriberIndex!==this.self.publisherIndex;){const e=this.subscriberIndex%this.self.capacity;this.self.subscribers[e]-=1,0===this.self.subscribers[e]&&(this.self.array[e]=Xee,this.self.subscribersIndex+=1),this.subscriberIndex+=1}}}class BoundedPubSubPow2{capacity;replayBuffer;array;mask;publisherIndex=0;subscribers;subscriberCount=0;subscribersIndex=0;constructor(e,t){this.capacity=e,this.replayBuffer=t,this.array=Array.from({length:e}),this.mask=e-1,this.subscribers=Array.from({length:e})}replayWindow(){return this.replayBuffer?new ReplayWindowImpl(this.replayBuffer):rte}isEmpty(){return this.publisherIndex===this.subscribersIndex}isFull(){return this.publisherIndex===this.subscribersIndex+this.capacity}size(){return this.publisherIndex-this.subscribersIndex}publish(e){if(this.isFull())return!1;if(0!==this.subscriberCount){const t=this.publisherIndex&this.mask;this.array[t]=e,this.subscribers[t]=this.subscriberCount,this.publisherIndex+=1}return this.replayBuffer&&this.replayBuffer.offer(e),!0}publishAll(e){if(0===this.subscriberCount)return this.replayBuffer&&this.replayBuffer.offerAll(e),empty$R();const t=fromIterable$u(e),r=t.length,n=this.publisherIndex-this.subscribersIndex,i=this.capacity-n,s=Math.min(r,i);if(0===s)return t;let o=0;const a=this.publisherIndex+s;for(;this.publisherIndex!==a;){const e=KA(t,o++),r=this.publisherIndex&this.mask;this.array[r]=e,this.subscribers[r]=this.subscriberCount,this.publisherIndex+=1,this.replayBuffer&&this.replayBuffer.offer(e)}return ZA(t,o)}slide(){if(this.subscribersIndex!==this.publisherIndex){const e=this.subscribersIndex&this.mask;this.array[e]=Xee,this.subscribers[e]=0,this.subscribersIndex+=1}this.replayBuffer&&this.replayBuffer.slide()}subscribe(){return this.subscriberCount+=1,new BoundedPubSubPow2Subscription(this,this.publisherIndex,!1)}}class BoundedPubSubPow2Subscription{self;subscriberIndex;unsubscribed;constructor(e,t,r){this.self=e,this.subscriberIndex=t,this.unsubscribed=r}isEmpty(){return this.unsubscribed||this.self.publisherIndex===this.subscriberIndex||this.self.publisherIndex===this.self.subscribersIndex}size(){return this.unsubscribed?0:this.self.publisherIndex-Math.max(this.subscriberIndex,this.self.subscribersIndex)}poll(e){if(this.unsubscribed)return e;if(this.subscriberIndex=Math.max(this.subscriberIndex,this.self.subscribersIndex),this.subscriberIndex!==this.self.publisherIndex){const e=this.subscriberIndex&this.self.mask,t=this.self.array[e];return this.self.subscribers[e]-=1,0===this.self.subscribers[e]&&(this.self.array[e]=Xee,this.self.subscribersIndex+=1),this.subscriberIndex+=1,t}return e}pollUpTo(e){if(this.unsubscribed)return empty$R();this.subscriberIndex=Math.max(this.subscriberIndex,this.self.subscribersIndex);const t=this.self.publisherIndex-this.subscriberIndex,r=Math.min(e,t);if(r<=0)return empty$R();const n=[],i=this.subscriberIndex+r;for(;this.subscriberIndex!==i;){const e=this.subscriberIndex&this.self.mask,t=this.self.array[e];this.self.subscribers[e]-=1,0===this.self.subscribers[e]&&(this.self.array[e]=Xee,this.self.subscribersIndex+=1),n.push(t),this.subscriberIndex+=1}return fromIterable$u(n)}unsubscribe(){if(!this.unsubscribed)for(this.unsubscribed=!0,this.self.subscriberCount-=1,this.subscriberIndex=Math.max(this.subscriberIndex,this.self.subscribersIndex);this.subscriberIndex!==this.self.publisherIndex;){const e=this.subscriberIndex&this.self.mask;this.self.subscribers[e]-=1,0===this.self.subscribers[e]&&(this.self.array[e]=Xee,this.self.subscribersIndex+=1),this.subscriberIndex+=1}}}class BoundedPubSubSingle{replayBuffer;publisherIndex=0;subscriberCount=0;subscribers=0;value=Xee;capacity=1;constructor(e){this.replayBuffer=e}replayWindow(){return this.replayBuffer?new ReplayWindowImpl(this.replayBuffer):rte}pipe(){return pipeArguments(this,arguments)}isEmpty(){return 0===this.subscribers}isFull(){return!this.isEmpty()}size(){return this.isEmpty()?0:1}publish(e){return!this.isFull()&&(0!==this.subscriberCount&&(this.value=e,this.subscribers=this.subscriberCount,this.publisherIndex+=1),this.replayBuffer&&this.replayBuffer.offer(e),!0)}publishAll(e){if(0===this.subscriberCount)return this.replayBuffer&&this.replayBuffer.offerAll(e),empty$R();const t=fromIterable$u(e);return isEmpty$t(t)?t:this.publish(unsafeHead$1(t))?ZA(t,1):t}slide(){this.isFull()&&(this.subscribers=0,this.value=Xee),this.replayBuffer&&this.replayBuffer.slide()}subscribe(){return this.subscriberCount+=1,new BoundedPubSubSingleSubscription(this,this.publisherIndex,!1)}}class BoundedPubSubSingleSubscription{self;subscriberIndex;unsubscribed;constructor(e,t,r){this.self=e,this.subscriberIndex=t,this.unsubscribed=r}isEmpty(){return this.unsubscribed||0===this.self.subscribers||this.subscriberIndex===this.self.publisherIndex}size(){return this.isEmpty()?0:1}poll(e){if(this.isEmpty())return e;const t=this.self.value;return this.self.subscribers-=1,0===this.self.subscribers&&(this.self.value=Xee),this.subscriberIndex+=1,t}pollUpTo(e){if(this.isEmpty()||e<1)return empty$R();const t=this.self.value;return this.self.subscribers-=1,0===this.self.subscribers&&(this.self.value=Xee),this.subscriberIndex+=1,of$5(t)}unsubscribe(){this.unsubscribed||(this.unsubscribed=!0,this.self.subscriberCount-=1,this.subscriberIndex!==this.self.publisherIndex&&(this.self.subscribers-=1,0===this.self.subscribers&&(this.self.value=Xee)))}}class UnboundedPubSub{replayBuffer;publisherHead={value:Xee,subscribers:0,next:null};publisherTail=this.publisherHead;publisherIndex=0;subscribersIndex=0;capacity=Number.MAX_SAFE_INTEGER;constructor(e){this.replayBuffer=e}replayWindow(){return this.replayBuffer?new ReplayWindowImpl(this.replayBuffer):rte}isEmpty(){return this.publisherHead===this.publisherTail}isFull(){return!1}size(){return this.publisherIndex-this.subscribersIndex}publish(e){const t=this.publisherTail.subscribers;return 0!==t&&(this.publisherTail.next={value:e,subscribers:t,next:null},this.publisherTail=this.publisherTail.next,this.publisherIndex+=1),this.replayBuffer&&this.replayBuffer.offer(e),!0}publishAll(e){if(0!==this.publisherTail.subscribers)for(const t of e)this.publish(t);else this.replayBuffer&&this.replayBuffer.offerAll(e);return empty$R()}slide(){this.publisherHead!==this.publisherTail&&(this.publisherHead=this.publisherHead.next,this.publisherHead.value=Xee,this.subscribersIndex+=1),this.replayBuffer&&this.replayBuffer.slide()}subscribe(){return this.publisherTail.subscribers+=1,new UnboundedPubSubSubscription(this,this.publisherTail,this.publisherIndex,!1)}}class UnboundedPubSubSubscription{self;subscriberHead;subscriberIndex;unsubscribed;constructor(e,t,r,n){this.self=e,this.subscriberHead=t,this.subscriberIndex=r,this.unsubscribed=n}isEmpty(){if(this.unsubscribed)return!0;let e=!0,t=!0;for(;t;)this.subscriberHead===this.self.publisherTail?t=!1:this.subscriberHead.next.value!==Xee?(e=!1,t=!1):(this.subscriberHead=this.subscriberHead.next,this.subscriberIndex+=1);return e}size(){return this.unsubscribed?0:this.self.publisherIndex-Math.max(this.subscriberIndex,this.self.subscribersIndex)}poll(e){if(this.unsubscribed)return e;let t=!0,r=e;for(;t;)if(this.subscriberHead===this.self.publisherTail)t=!1;else{const e=this.subscriberHead.next.value;e!==Xee&&(r=e,this.subscriberHead.subscribers-=1,0===this.subscriberHead.subscribers&&(this.self.publisherHead=this.self.publisherHead.next,this.self.publisherHead.value=Xee,this.self.subscribersIndex+=1),t=!1),this.subscriberHead=this.subscriberHead.next,this.subscriberIndex+=1}return r}pollUpTo(e){const t=[],r=Xee;let n=0;for(;n!==e;){const i=this.poll(r);i===r?n=e:(t.push(i),n+=1)}return fromIterable$u(t)}unsubscribe(){if(!this.unsubscribed)for(this.unsubscribed=!0,this.self.publisherTail.subscribers-=1;this.subscriberHead!==this.self.publisherTail;)this.subscriberHead.next.value!==Xee&&(this.subscriberHead.subscribers-=1,0===this.subscriberHead.subscribers&&(this.self.publisherHead=this.self.publisherHead.next,this.self.publisherHead.value=Xee,this.self.subscribersIndex+=1)),this.subscriberHead=this.subscriberHead.next}}class SubscriptionImpl extends hz{pubsub;subscribers;subscription;pollers;shutdownHook;shutdownFlag;strategy;replayWindow;[Dee]=qee;constructor(e,t,r,n,i,s,o,a){super(),this.pubsub=e,this.subscribers=t,this.subscription=r,this.pollers=n,this.shutdownHook=i,this.shutdownFlag=s,this.strategy=o,this.replayWindow=a}commit(){return this.take}pipe(){return pipeArguments(this,arguments)}capacity(){return this.pubsub.capacity}isActive(){return!get$E(this.shutdownFlag)}get size(){return suspend$g(()=>get$E(this.shutdownFlag)?BR:succeed$u(this.subscription.size()+this.replayWindow.remaining))}unsafeSize(){return get$E(this.shutdownFlag)?none$c():Ut(this.subscription.size()+this.replayWindow.remaining)}get isFull(){return suspend$g(()=>get$E(this.shutdownFlag)?BR:succeed$u(this.subscription.size()===this.capacity()))}get isEmpty(){return qR(this.size,e=>0===e)}get shutdown(){return uninterruptible$2(withFiberRuntime$1(e=>(qF(this.shutdownFlag,!0),pipe(forEachParUnbounded(unsafePollAllQueue(this.pollers),t=>rU(t,e.id()),!1),lD(sync$l(()=>{this.subscribers.delete(this.subscription),this.subscription.unsubscribe(),this.strategy.unsafeOnPubSubEmptySpace(this.pubsub,this.subscribers)})),rD(nU(this.shutdownHook,void 0)),asVoid$9))))}get isShutdown(){return sync$l(()=>get$E(this.shutdownFlag))}get awaitShutdown(){return deferredAwait(this.shutdownHook)}get take(){return withFiberRuntime$1(e=>{if(get$E(this.shutdownFlag))return BR;if(this.replayWindow.remaining>0){const e=this.replayWindow.take();return succeed$u(e)}const t=isEmpty$l(this.pollers)?this.subscription.poll(t$):t$;if(t===t$){const t=deferredUnsafeMake(e.id());return pipe(suspend$g(()=>(pipe(this.pollers,n$(t)),pipe(this.subscribers,addSubscribers(this.subscription,this.pollers)),this.strategy.unsafeCompletePollers(this.pubsub,this.subscribers,this.subscription,this.pollers),get$E(this.shutdownFlag)?BR:deferredAwait(t))),JR(()=>sync$l(()=>unsafeRemove(this.pollers,t))))}return this.strategy.unsafeOnPubSubEmptySpace(this.pubsub,this.subscribers),succeed$u(t)})}get takeAll(){return suspend$g(()=>{if(get$E(this.shutdownFlag))return BR;const e=isEmpty$l(this.pollers)?unsafePollAllSubscription(this.subscription):empty$R();return this.strategy.unsafeOnPubSubEmptySpace(this.pubsub,this.subscribers),this.replayWindow.remaining>0?succeed$u(eC(this.replayWindow.takeAll(),e)):succeed$u(e)})}takeUpTo(e){return suspend$g(()=>{if(get$E(this.shutdownFlag))return BR;let t;if(this.replayWindow.remaining>=e){const t=this.replayWindow.takeN(e);return succeed$u(t)}this.replayWindow.remaining>0&&(t=this.replayWindow.takeAll(),e-=t.length);const r=isEmpty$l(this.pollers)?unsafePollN(this.subscription,e):empty$R();return this.strategy.unsafeOnPubSubEmptySpace(this.pubsub,this.subscribers),succeed$u(t?eC(t,r):r)})}takeBetween(e,t){return suspend$g(()=>takeRemainderLoop(this,e,t,empty$R()))}}const takeRemainderLoop=(e,t,r,n)=>r<t?succeed$u(n):pipe(e.takeUpTo(r),PR(i=>{const s=t-i.length;return 1===s?pipe(e.take,qR(e=>pipe(n,eC(i),GA(e)))):s>1?pipe(e.take,PR(t=>takeRemainderLoop(e,s-1,r-i.length-1,pipe(n,eC(i),GA(t))))):succeed$u(pipe(n,eC(i)))}));class PubSubImpl{pubsub;subscribers;scope;shutdownHook;shutdownFlag;strategy;[Ree]=zee;[Dee]=qee;constructor(e,t,r,n,i,s){this.pubsub=e,this.subscribers=t,this.scope=r,this.shutdownHook=n,this.shutdownFlag=i,this.strategy=s}capacity(){return this.pubsub.capacity}get size(){return suspend$g(()=>get$E(this.shutdownFlag)?BR:sync$l(()=>this.pubsub.size()))}unsafeSize(){return get$E(this.shutdownFlag)?none$c():Ut(this.pubsub.size())}get isFull(){return qR(this.size,e=>e===this.capacity())}get isEmpty(){return qR(this.size,e=>0===e)}get awaitShutdown(){return deferredAwait(this.shutdownHook)}get isShutdown(){return sync$l(()=>get$E(this.shutdownFlag))}get shutdown(){return uninterruptible$2(withFiberRuntime$1(e=>(pipe(this.shutdownFlag,qF(!0)),pipe(this.scope.close(exitInterrupt$1(e.id())),lD(this.strategy.shutdown),rD(nU(this.shutdownHook,void 0)),asVoid$9))))}publish(e){return suspend$g(()=>get$E(this.shutdownFlag)?BR:this.pubsub.publish(e)?(this.strategy.unsafeCompleteSubscribers(this.pubsub,this.subscribers),succeed$u(!0)):this.strategy.handleSurplus(this.pubsub,this.subscribers,of$5(e),this.shutdownFlag))}isActive(){return!get$E(this.shutdownFlag)}unsafeOffer(e){return!get$E(this.shutdownFlag)&&!!this.pubsub.publish(e)&&(this.strategy.unsafeCompleteSubscribers(this.pubsub,this.subscribers),!0)}publishAll(e){return suspend$g(()=>{if(get$E(this.shutdownFlag))return BR;const t=unsafePublishAll(this.pubsub,e);return this.strategy.unsafeCompleteSubscribers(this.pubsub,this.subscribers),isEmpty$t(t)?succeed$u(!0):this.strategy.handleSurplus(this.pubsub,this.subscribers,t,this.shutdownFlag)})}get subscribe(){const e=XR(all$6([this.scope.fork(jW),(t=this.pubsub,r=this.subscribers,n=this.strategy,qR(deferredMake(),e=>((e,t,r,n,i,s,o)=>new SubscriptionImpl(e,t,r,n,i,s,o,e.replayWindow()))(t,r,t.subscribe(),unbounded$8(),e,make$27(!1),n)))]),e=>e[0].addFinalizer(()=>e[1].shutdown));var t,r,n;return qR(eQ(e,(e,t)=>e[0].close(t)),e=>e[1])}offer(e){return this.publish(e)}offerAll(e){return this.publishAll(e)}pipe(){return pipeArguments(this,arguments)}}const makePubSub=(e,t)=>PR(scopeMake(),r=>qR(deferredMake(),n=>unsafeMakePubSub(e,new Map,r,n,make$27(!1),t))),unsafeMakePubSub=(e,t,r,n,i,s)=>new PubSubImpl(e,t,r,n,i,s),ensureCapacity=e=>{if(e<=0)throw new vL("Cannot construct PubSub with capacity of "+e)},unsafeCompleteDeferred=(e,t)=>{deferredUnsafeDone(e,succeed$u(t))},unsafeOfferAll=(e,t)=>pipe(e,i$(t)),unsafePollAllQueue=e=>pipe(e,o$(1/0)),unsafePollAllSubscription=e=>e.pollUpTo(1/0),unsafePollN=(e,t)=>e.pollUpTo(t),unsafePublishAll=(e,t)=>e.publishAll(t),unsafeRemove=(e,t)=>{unsafeOfferAll(e,pipe(unsafePollAllQueue(e),rC(e=>e!==t)))};class BackPressureStrategy{publishers=unbounded$8();get shutdown(){return PR(FR,e=>PR(sync$l(()=>unsafePollAllQueue(this.publishers)),t=>forEachConcurrentDiscard(t,([t,r,n])=>n?pipe(rU(r,e),asVoid$9):tD,!1,!1)))}handleSurplus(e,t,r,n){return withFiberRuntime$1(i=>{const s=deferredUnsafeMake(i.id());return pipe(suspend$g(()=>(this.unsafeOffer(r,s),this.unsafeOnPubSubEmptySpace(e,t),this.unsafeCompleteSubscribers(e,t),get$E(n)?BR:deferredAwait(s))),JR(()=>sync$l(()=>this.unsafeRemove(s))))})}unsafeOnPubSubEmptySpace(e,t){let r=!0;for(;r&&!e.isFull();){const n=pipe(this.publishers,s$(t$));if(n===t$)r=!1;else{const r=e.publish(n[0]);r&&n[2]?unsafeCompleteDeferred(n[1],!0):r||unsafeOfferAll(this.publishers,pipe(unsafePollAllQueue(this.publishers),JA(n))),this.unsafeCompleteSubscribers(e,t)}}}unsafeCompletePollers(e,t,r,n){return unsafeStrategyCompletePollers(this,e,t,r,n)}unsafeCompleteSubscribers(e,t){return unsafeStrategyCompleteSubscribers(this,e,t)}unsafeOffer(e,t){const r=e[Symbol.iterator]();let n=r.next();if(!n.done)for(;;){const e=n.value;if(n=r.next(),n.done){pipe(this.publishers,n$([e,t,!0]));break}pipe(this.publishers,n$([e,t,!1]))}}unsafeRemove(e){unsafeOfferAll(this.publishers,pipe(unsafePollAllQueue(this.publishers),rC(([t,r])=>r!==e)))}}class DroppingStrategy{get shutdown(){return tD}handleSurplus(e,t,r,n){return succeed$u(!1)}unsafeOnPubSubEmptySpace(e,t){}unsafeCompletePollers(e,t,r,n){return unsafeStrategyCompletePollers(this,e,t,r,n)}unsafeCompleteSubscribers(e,t){return unsafeStrategyCompleteSubscribers(this,e,t)}}class SlidingStrategy{get shutdown(){return tD}handleSurplus(e,t,r,n){return sync$l(()=>(this.unsafeSlidingPublish(e,r),this.unsafeCompleteSubscribers(e,t),!0))}unsafeOnPubSubEmptySpace(e,t){}unsafeCompletePollers(e,t,r,n){return unsafeStrategyCompletePollers(this,e,t,r,n)}unsafeCompleteSubscribers(e,t){return unsafeStrategyCompleteSubscribers(this,e,t)}unsafeSlidingPublish(e,t){const r=t[Symbol.iterator]();let n=r.next();if(!n.done&&e.capacity>0){let t=n.value,i=!0;for(;i;){e.slide();const s=e.publish(t);s&&(n=r.next())&&!n.done?t=n.value:s&&(i=!1)}}}}const unsafeStrategyCompletePollers=(e,t,r,n,i)=>{let s=!0;for(;s&&!n.isEmpty();){const o=pipe(i,s$(t$));if(o===t$)pipe(r,removeSubscribers(n,i)),isEmpty$l(i)?s=!1:pipe(r,addSubscribers(n,i));else{const s=n.poll(t$);s===t$?unsafeOfferAll(i,pipe(unsafePollAllQueue(i),JA(o))):(unsafeCompleteDeferred(o,s),e.unsafeOnPubSubEmptySpace(t,r))}}},unsafeStrategyCompleteSubscribers=(e,t,r)=>{for(const[n,i]of r)for(const s of i)e.unsafeCompletePollers(t,r,n,s)};class ReplayBuffer{capacity;constructor(e){this.capacity=e}head={value:Xee,next:null};tail=this.head;size=0;index=0;slide(){this.index++}offer(e){this.tail.value=e,this.tail.next={value:Xee,next:null},this.tail=this.tail.next,this.size===this.capacity?this.head=this.head.next:this.size+=1}offerAll(e){for(const t of e)this.offer(t)}}class ReplayWindowImpl{buffer;head;index;remaining;constructor(e){this.buffer=e,this.index=e.index,this.remaining=e.size,this.head=e.head}fastForward(){for(;this.index<this.buffer.index;)this.head=this.head.next,this.index++}take(){if(0===this.remaining)return;this.index<this.buffer.index&&this.fastForward(),this.remaining--;const e=this.head.value;return this.head=this.head.next,e}takeN(e){if(0===this.remaining)return empty$R();this.index<this.buffer.index&&this.fastForward();const t=Math.min(e,this.remaining),r=Array(t);for(let e=0;e<t;e++){const t=this.head.value;this.head=this.head.next,r[e]=t}return this.remaining-=t,unsafeFromArray(r)}takeAll(){return this.takeN(this.remaining)}}const rte={remaining:0,take:()=>{},takeN:()=>empty$R(),takeAll:()=>empty$R()},bounded$5=e=>suspend$g(()=>{const t=makeBoundedPubSub(e);return makePubSub(t,new BackPressureStrategy)}),dropping$5=e=>suspend$g(()=>{const t=makeBoundedPubSub(e);return makePubSub(t,new DroppingStrategy)}),sliding$7=e=>suspend$g(()=>{const t=makeBoundedPubSub(e);return makePubSub(t,new SlidingStrategy)}),unbounded$5=e=>suspend$g(()=>{const t=(e=>new UnboundedPubSub(e?.replay?new ReplayBuffer(e.replay):void 0))(e);return makePubSub(t,new DroppingStrategy)}),shutdown$5=e=>e.shutdown,nte=ete,subscribe$2=e=>e.subscribe;var ite=Object.freeze({__proto__:null,awaitShutdown:e=>e.awaitShutdown,bounded:bounded$5,capacity:e=>e.capacity(),dropping:dropping$5,isEmpty:e=>e.isEmpty,isFull:e=>e.isFull,isShutdown:e=>e.isShutdown,publish:nte,publishAll:tte,shutdown:shutdown$5,size:e=>e.size,sliding:sliding$7,subscribe:subscribe$2,unbounded:unbounded$5});const ste=Dee,bounded$4=e=>pipe(sync$l(()=>bounded$8(e)),PR(e=>make$1p(backingQueueFromMutableQueue(e),backPressureStrategy$1()))),dropping$4=e=>pipe(sync$l(()=>bounded$8(e)),PR(e=>make$1p(backingQueueFromMutableQueue(e),droppingStrategy$1()))),sliding$6=e=>pipe(sync$l(()=>bounded$8(e)),PR(e=>make$1p(backingQueueFromMutableQueue(e),slidingStrategy$1()))),ote=unbounded$7,capacity$4=e=>e.capacity(),size$j=e=>e.size,isEmpty$d=e=>e.isEmpty,isFull$4=e=>e.isFull,isShutdown$4=e=>e.isShutdown,awaitShutdown$4=e=>e.awaitShutdown,shutdown$4=e=>e.shutdown,ate=Wee,ute=Kee,poll$6=e=>qR(e.takeUpTo(1),cC),cte=take$a,takeAll$4=e=>e.takeAll,lte=Gee,pte=Jee,fte=Hee;var hte=Object.freeze({__proto__:null,BackingQueueTypeId:Uee,DequeueTypeId:ste,EnqueueTypeId:Ree,QueueStrategyTypeId:Lee,awaitShutdown:awaitShutdown$4,backPressureStrategy:backPressureStrategy$1,bounded:bounded$4,capacity:capacity$4,dropping:dropping$4,droppingStrategy:droppingStrategy$1,isDequeue:isDequeue$1,isEmpty:isEmpty$d,isEnqueue:isEnqueue$1,isFull:isFull$4,isQueue:e=>isEnqueue$1(e)&&isDequeue$1(e),isShutdown:isShutdown$4,make:make$1p,offer:ate,offerAll:ute,poll:poll$6,shutdown:shutdown$4,size:size$j,sliding:sliding$6,slidingStrategy:slidingStrategy$1,take:cte,takeAll:takeAll$4,takeBetween:pte,takeN:fte,takeUpTo:lte,unbounded:ote,unsafeOffer:Vee});const dte="Continue",mte="Close",gte="Yield",yte=Symbol.for("effect/ChannelChildExecutorDecision"),bte={[yte]:yte},Continue$1=e=>{const t=Object.create(bte);return t._tag=dte,t},Ste=dual(2,(e,{onClose:t,onContinue:r,onYield:n})=>{switch(e._tag){case dte:return r();case mte:return t(e.value);case gte:return n()}}),vte="ContinuationK",_te=Symbol.for("effect/ChannelContinuation"),wte={_Env:e=>e,_InErr:e=>e,_InElem:e=>e,_InDone:e=>e,_OutErr:e=>e,_OutDone:e=>e,_OutErr2:e=>e,_OutElem:e=>e,_OutDone2:e=>e};class ContinuationKImpl{onSuccess;onHalt;_tag=vte;[_te]=wte;constructor(e,t){this.onSuccess=e,this.onHalt=t}onExit(e){return wU(e)?this.onHalt(e.cause):this.onSuccess(e.value)}}class ContinuationFinalizerImpl{finalizer;_tag="ContinuationFinalizer";[_te]=wte;constructor(e){this.finalizer=e}}const kte="PullAfterNext",xte="PullAfterAllEnqueued",Ite=Symbol.for("effect/ChannelUpstreamPullStrategy"),Tte={[Ite]:{_A:e=>e}},PullAfterNext$1=e=>{const t=Object.create(Tte);return t._tag=kte,t.emitSeparator=e,t},Ote=dual(2,(e,{onAllEnqueued:t,onNext:r})=>{switch(e._tag){case kte:return r(e.emitSeparator);case xte:return t(e.emitSeparator)}}),Ete="BracketOut",Ate="Bridge",Cte="ConcatAll",Mte="Emit",Fte="Ensuring",Pte="Fail",Nte="Fold",jte="FromEffect",Rte="PipeTo",Dte="Provide",Lte="Read",Ute="Succeed",$te="SucceedNow",Bte="Suspend",zte=Symbol.for("effect/Channel"),qte={[zte]:{_Env:e=>e,_InErr:e=>e,_InElem:e=>e,_InDone:e=>e,_OutErr:e=>e,_OutElem:e=>e,_OutDone:e=>e},pipe(){return pipeArguments(this,arguments)}},isChannel$1=e=>C(e,zte)||c4(e),Wte=dual(2,(e,t)=>{const r=Object.create(qte);return r._tag=Ete,r.acquire=()=>e,r.finalizer=t,r}),Vte=dual(2,(e,t)=>{const r=Object.create(qte);return r._tag=Nte,r.channel=e,r.k=new ContinuationKImpl(succeed$g,t),r}),collectElements=e=>suspend$b(()=>{const t=[];return Zte(Yte(e,collectElementsReader(t)),e=>sync$c(()=>[fromIterable$u(t),e]))}),collectElementsReader=e=>readWith$1({onInput:t=>Zte(sync$c(()=>{e.push(t)}),()=>collectElementsReader(e)),onFailure:fail$f,onDone:succeedNow}),concatAll$3=e=>concatAllWith$1(e,o,o),concatAllWith$1=(e,t,r)=>{const n=Object.create(qte);return n._tag=Cte,n.combineInners=t,n.combineAll=r,n.onPull=()=>PullAfterNext$1(none$c()),n.onEmit=()=>Continue$1,n.value=()=>e,n.k=identity$5,n},Kte=dual(4,(e,t,r,n)=>{const i=Object.create(qte);return i._tag=Cte,i.combineInners=r,i.combineAll=n,i.onPull=()=>PullAfterNext$1(none$c()),i.onEmit=()=>Continue$1,i.value=()=>e,i.k=t,i}),Gte=dual(6,(e,t,r,n,i,s)=>{const o=Object.create(qte);return o._tag=Cte,o.combineInners=r,o.combineAll=n,o.onPull=i,o.onEmit=s,o.value=()=>e,o.k=t,o}),Jte=dual(2,(e,t)=>{const r=Object.create(qte);return r._tag=Ate,r.input=t,r.channel=e,r}),Hte=dual(2,(e,t)=>{const r=Object.create(qte);return r._tag=Fte,r.channel=e,r.finalizer=t,r}),fail$f=e=>failCause$8(zQ(e)),failSync$7=e=>failCauseSync$5(()=>zQ(e())),failCause$8=e=>failCauseSync$5(()=>e),failCauseSync$5=e=>{const t=Object.create(qte);return t._tag=Pte,t.error=e,t},Zte=dual(2,(e,t)=>{const r=Object.create(qte);return r._tag=Nte,r.channel=e,r.k=new ContinuationKImpl(t,failCause$8),r}),Qte=dual(2,(e,t)=>{const r=Object.create(qte);return r._tag=Nte,r.channel=e,r.k=new ContinuationKImpl(t.onSuccess,t.onFailure),r}),fromEffect$b=e=>{const t=Object.create(qte);return t._tag=jte,t.effect=()=>e,t},Yte=dual(2,(e,t)=>{const r=Object.create(qte);return r._tag=Rte,r.left=()=>e,r.right=()=>t,r}),Xte=dual(2,(e,t)=>{const r=Object.create(qte);return r._tag=Dte,r.context=()=>t,r.inner=e,r}),readOrFail$1=e=>{const t=Object.create(qte);return t._tag=Lte,t.more=succeed$g,t.done=new ContinuationKImpl(()=>fail$f(e),()=>fail$f(e)),t},readWith$1=e=>readWithCause$1({onInput:e.onInput,onFailure:t=>ot(YQ(t),{onLeft:e.onFailure,onRight:failCause$8}),onDone:e.onDone}),readWithCause$1=e=>{const t=Object.create(qte);return t._tag=Lte,t.more=e.onInput,t.done=new ContinuationKImpl(e.onDone,e.onFailure),t},succeed$g=e=>sync$c(()=>e),succeedNow=e=>{const t=Object.create(qte);return t._tag=$te,t.terminal=e,t},suspend$b=e=>{const t=Object.create(qte);return t._tag=Bte,t.channel=e,t},sync$c=e=>{const t=Object.create(qte);return t._tag=Ute,t.evaluate=e,t},ere=succeedNow(void 0),write$1=e=>{const t=Object.create(qte);return t._tag=Mte,t.out=e,t},tre="Done",rre="Emit",nre="FromEffect",ire="Read",sre=Symbol.for("effect/ChannelState"),ore={[sre]:{_E:e=>e,_R:e=>e}},Done$2=()=>{const e=Object.create(ore);return e._tag=tre,e},Emit$1=()=>{const e=Object.create(ore);return e._tag=rre,e},fromEffect$a=e=>{const t=Object.create(ore);return t._tag=nre,t.effect=e,t},Read=(e,t,r,n)=>{const i=Object.create(ore);return i._tag=ire,i.upstream=e,i.onEffect=t,i.onEmit=r,i.onDone=n,i},isFromEffect=e=>e._tag===nre,effectOrUndefinedIgnored=e=>isFromEffect(e)?l3(e.effect):void 0,are="PullFromChild",ure="PullFromUpstream",cre="DrainChildExecutors",lre="Emit";class PullFromChild{childExecutor;parentSubexecutor;onEmit;_tag=are;constructor(e,t,r){this.childExecutor=e,this.parentSubexecutor=t,this.onEmit=r}close(e){const t=this.childExecutor.close(e),r=this.parentSubexecutor.close(e);return void 0!==t&&void 0!==r?R8(Y5(t),Y5(r),(e,t)=>pipe(e,DU(t))):void 0!==t?t:void 0!==r?r:void 0}enqueuePullFromChild(e){return this}}class PullFromUpstream{upstreamExecutor;createChild;lastDone;activeChildExecutors;combineChildResults;combineWithChildResult;onPull;onEmit;_tag=ure;constructor(e,t,r,n,i,s,o,a){this.upstreamExecutor=e,this.createChild=t,this.lastDone=r,this.activeChildExecutors=n,this.combineChildResults=i,this.combineWithChildResult=s,this.onPull=o,this.onEmit=a}close(e){const t=this.upstreamExecutor.close(e);return[...this.activeChildExecutors.map(t=>void 0!==t?t.childExecutor.close(e):void 0),t].reduce((e,t)=>void 0!==e&&void 0!==t?R8(e,Y5(t),(e,t)=>DU(e,t)):void 0!==e?e:void 0!==t?Y5(t):void 0,void 0)}enqueuePullFromChild(e){return new PullFromUpstream(this.upstreamExecutor,this.createChild,this.lastDone,[...this.activeChildExecutors,e],this.combineChildResults,this.combineWithChildResult,this.onPull,this.onEmit)}}class DrainChildExecutors{upstreamExecutor;lastDone;activeChildExecutors;upstreamDone;combineChildResults;combineWithChildResult;onPull;_tag=cre;constructor(e,t,r,n,i,s,o){this.upstreamExecutor=e,this.lastDone=t,this.activeChildExecutors=r,this.upstreamDone=n,this.combineChildResults=i,this.combineWithChildResult=s,this.onPull=o}close(e){const t=this.upstreamExecutor.close(e);return[...this.activeChildExecutors.map(t=>void 0!==t?t.childExecutor.close(e):void 0),t].reduce((e,t)=>void 0!==e&&void 0!==t?R8(e,Y5(t),(e,t)=>DU(e,t)):void 0!==e?e:void 0!==t?Y5(t):void 0,void 0)}enqueuePullFromChild(e){return new DrainChildExecutors(this.upstreamExecutor,this.lastDone,[...this.activeChildExecutors,e],this.upstreamDone,this.combineChildResults,this.combineWithChildResult,this.onPull)}}class Emit{value;next;_tag=lre;constructor(e,t){this.value=e,this.next=t}close(e){return this.next.close(e)}enqueuePullFromChild(e){return this}}const pre="Pulled",fre="NoUpstream",hre=Symbol.for("effect/ChannelUpstreamPullRequest"),dre={[hre]:{_A:e=>e}},Pulled$1=e=>{const t=Object.create(dre);return t._tag=pre,t.value=e,t},NoUpstream$1=e=>{const t=Object.create(dre);return t._tag=fre,t.activeDownstreamCount=e,t},mre=dual(2,(e,{onNoUpstream:t,onPulled:r})=>{switch(e._tag){case pre:return r(e.value);case fre:return t(e.activeDownstreamCount)}});class ChannelExecutor{_activeSubexecutor=void 0;_cancelled=void 0;_closeLastSubstream=void 0;_currentChannel;_done=void 0;_doneStack=[];_emitted=void 0;_executeCloseLastSubstream;_input=void 0;_inProgressFinalizer=void 0;_providedEnv;constructor(e,t,r){this._currentChannel=e,this._executeCloseLastSubstream=r,this._providedEnv=t}run(){let e;for(;void 0===e;)if(void 0!==this._cancelled)e=this.processCancellation();else if(void 0!==this._activeSubexecutor)e=this.runSubexecutor();else try{if(void 0===this._currentChannel)e=Done$2();else switch(c4(this._currentChannel)&&(this._currentChannel=fromEffect$b(this._currentChannel)),this._currentChannel._tag){case Ete:e=this.runBracketOut(this._currentChannel);break;case Ate:{const t=this._currentChannel.input;if(this._currentChannel=this._currentChannel.channel,void 0!==this._input){const r=this._input;this._input=void 0;const drainer=()=>h7(t.awaitRead(),()=>H4(()=>{const e=r.run();switch(e._tag){case tre:return FU(r.getDone(),{onFailure:e=>t.error(e),onSuccess:e=>t.done(e)});case rre:return h7(t.emit(r.getEmit()),()=>drainer());case nre:return W7(e.effect,{onFailure:e=>t.error(e),onSuccess:()=>drainer()});case ire:return readUpstream(e,()=>drainer(),e=>t.error(e))}}));e=fromEffect$a(h7(a5(w3(drainer())),e=>Z4(()=>this.addFinalizer(t=>h7(yX(e),()=>H4(()=>{const e=this.restorePipe(t,r);return void 0!==e?e:Q4}))))))}break}case Cte:{const e=new ChannelExecutor(this._currentChannel.value(),this._providedEnv,e=>Z4(()=>{const t=void 0===this._closeLastSubstream?Q4:this._closeLastSubstream;this._closeLastSubstream=pipe(t,j8(e))}));e._input=this._input;const t=this._currentChannel;this._activeSubexecutor=new PullFromUpstream(e,e=>t.k(e),void 0,[],(e,r)=>t.combineInners(e,r),(e,r)=>t.combineAll(e,r),e=>t.onPull(e),e=>t.onEmit(e)),this._closeLastSubstream=void 0,this._currentChannel=void 0;break}case Mte:this._emitted=this._currentChannel.out,this._currentChannel=void 0!==this._activeSubexecutor?void 0:ere,e=Emit$1();break;case Fte:this.runEnsuring(this._currentChannel);break;case Pte:e=this.doneHalt(this._currentChannel.error());break;case Nte:this._doneStack.push(this._currentChannel.k),this._currentChannel=this._currentChannel.channel;break;case jte:{const t=void 0===this._providedEnv?this._currentChannel.effect():pipe(this._currentChannel.effect(),U5(this._providedEnv));e=fromEffect$a(W7(t,{onFailure:e=>{const t=this.doneHalt(e);return void 0!==t&&isFromEffect(t)?t.effect:Q4},onSuccess:e=>{const t=this.doneSucceed(e);return void 0!==t&&isFromEffect(t)?t.effect:Q4}}));break}case Rte:{const e=this._input,t=new ChannelExecutor(this._currentChannel.left(),this._providedEnv,e=>this._executeCloseLastSubstream(e));t._input=e,this._input=t,this.addFinalizer(t=>{const r=this.restorePipe(t,e);return void 0!==r?r:Q4}),this._currentChannel=this._currentChannel.right();break}case Dte:{const e=this._providedEnv;this._providedEnv=this._currentChannel.context(),this._currentChannel=this._currentChannel.inner,this.addFinalizer(()=>Z4(()=>{this._providedEnv=e}));break}case Lte:{const t=this._currentChannel;e=Read(this._input,identity$5,e=>{try{this._currentChannel=t.more(e)}catch(e){this._currentChannel=t.done.onExit(IU(e))}},e=>{this._currentChannel=(e=>t.done.onExit(e))(e)});break}case Ute:e=this.doneSucceed(this._currentChannel.evaluate());break;case $te:e=this.doneSucceed(this._currentChannel.terminal);break;case Bte:this._currentChannel=this._currentChannel.channel()}}catch(e){this._currentChannel=failCause$8(qQ(e))}return e}getDone(){return this._done}getEmit(){return this._emitted}cancelWith(e){this._cancelled=e}clearInProgressFinalizer(){this._inProgressFinalizer=void 0}storeInProgressFinalizer(e){this._inProgressFinalizer=e}popAllFinalizers(e){const t=[];let r=this._doneStack.pop();for(;r;)"ContinuationFinalizer"===r._tag&&t.push(r.finalizer),r=this._doneStack.pop();const n=0===t.length?Q4:runFinalizers(t,e);return this.storeInProgressFinalizer(n),n}popNextFinalizers(){const e=[];for(;0!==this._doneStack.length;){const t=this._doneStack[this._doneStack.length-1];if(t._tag===vte)return e;e.push(t),this._doneStack.pop()}return e}restorePipe(e,t){const r=this._input;return this._input=t,void 0!==r?r.close(e):Q4}close(e){let t;const r=this._inProgressFinalizer;let n;void 0!==r&&(t=pipe(r,q3(Z4(()=>this.clearInProgressFinalizer()))));const i=this.popAllFinalizers(e);void 0!==i&&(n=pipe(i,q3(Z4(()=>this.clearInProgressFinalizer()))));const s=void 0===this._activeSubexecutor?void 0:this._activeSubexecutor.close(e);if(void 0!==s||void 0!==t||void 0!==n)return pipe(Y5(ifNotNull(s)),P8(Y5(ifNotNull(t))),P8(Y5(ifNotNull(n))),P3(([[e,t],r])=>pipe(e,DU(t),DU(r))),I3,h7(e=>H4(()=>e)))}doneSucceed(e){if(0===this._doneStack.length)return this._done=NU(e),this._currentChannel=void 0,Done$2();const t=this._doneStack[this._doneStack.length-1];if(t._tag===vte)return this._doneStack.pop(),void(this._currentChannel=t.onSuccess(e));const r=this.popNextFinalizers();if(0===this._doneStack.length)return this._doneStack=r.reverse(),this._done=NU(e),this._currentChannel=void 0,Done$2();const n=runFinalizers(r.map(e=>e.finalizer),NU(e));this.storeInProgressFinalizer(n);const i=pipe(n,q3(Z4(()=>this.clearInProgressFinalizer())),I3,h7(()=>Z4(()=>this.doneSucceed(e))));return fromEffect$a(i)}doneHalt(e){if(0===this._doneStack.length)return this._done=OU(e),this._currentChannel=void 0,Done$2();const t=this._doneStack[this._doneStack.length-1];if(t._tag===vte){this._doneStack.pop();try{this._currentChannel=t.onHalt(e)}catch(e){this._currentChannel=failCause$8(qQ(e))}return}const r=this.popNextFinalizers();if(0===this._doneStack.length)return this._doneStack=r.reverse(),this._done=OU(e),this._currentChannel=void 0,Done$2();const n=runFinalizers(r.map(e=>e.finalizer),OU(e));this.storeInProgressFinalizer(n);const i=pipe(n,q3(Z4(()=>this.clearInProgressFinalizer())),I3,h7(()=>Z4(()=>this.doneHalt(e))));return fromEffect$a(i)}processCancellation(){return this._currentChannel=void 0,this._done=this._cancelled,this._cancelled=void 0,Done$2()}runBracketOut(e){const t=I3(W7(this.provide(e.acquire()),{onFailure:e=>Z4(()=>{this._currentChannel=failCause$8(e)}),onSuccess:t=>Z4(()=>{this.addFinalizer(r=>this.provide(e.finalizer(t,r))),this._currentChannel=write$1(t)})}));return fromEffect$a(t)}provide(e){return void 0===this._providedEnv?e:pipe(e,U5(this._providedEnv))}runEnsuring(e){this.addFinalizer(e.finalizer),this._currentChannel=e.channel}addFinalizer(e){this._doneStack.push(new ContinuationFinalizerImpl(e))}runSubexecutor(){const e=this._activeSubexecutor;switch(e._tag){case are:return this.pullFromChild(e.childExecutor,e.parentSubexecutor,e.onEmit,e);case ure:return this.pullFromUpstream(e);case cre:return this.drainChildExecutors(e);case lre:return this._emitted=e.value,this._activeSubexecutor=e.next,Emit$1()}}replaceSubexecutor(e){this._currentChannel=void 0,this._activeSubexecutor=e}finishWithExit(e){const t=FU(e,{onFailure:e=>this.doneHalt(e),onSuccess:e=>this.doneSucceed(e)});return this._activeSubexecutor=void 0,void 0===t?Q4:isFromEffect(r=t)?r.effect:Q4;var r}finishSubexecutorWithCloseEffect(e,...t){this.addFinalizer(()=>pipe(t,x4(t=>pipe(Z4(()=>t(e)),h7(e=>void 0!==e?e:Q4)),{discard:!0})));const r=pipe(e,FU({onFailure:e=>this.doneHalt(e),onSuccess:e=>this.doneSucceed(e)}));return this._activeSubexecutor=void 0,r}applyUpstreamPullStrategy(e,t,r){switch(r._tag){case kte:{const n=!e||t.some(e=>void 0!==e);return[r.emitSeparator,n?[void 0,...t]:t]}case xte:{const n=!e||t.some(e=>void 0!==e);return[r.emitSeparator,n?[...t,void 0]:t]}}}pullFromChild(e,t,r,n){return Read(e,identity$5,i=>{const s=r(i);switch(s._tag){case dte:break;case mte:this.finishWithDoneValue(e,t,s.value);break;case gte:{const e=t.enqueuePullFromChild(n);this.replaceSubexecutor(e);break}}this._activeSubexecutor=new Emit(i,this._activeSubexecutor)},FU({onFailure:r=>{const n=this.handleSubexecutorFailure(e,t,r);return void 0===n?void 0:effectOrUndefinedIgnored(n)},onSuccess:r=>{this.finishWithDoneValue(e,t,r)}}))}finishWithDoneValue(e,t,r){const n=t;switch(n._tag){case ure:{const t=new PullFromUpstream(n.upstreamExecutor,n.createChild,void 0!==n.lastDone?n.combineChildResults(n.lastDone,r):r,n.activeChildExecutors,n.combineChildResults,n.combineWithChildResult,n.onPull,n.onEmit);this._closeLastSubstream=e.close(NU(r)),this.replaceSubexecutor(t);break}case cre:{const t=new DrainChildExecutors(n.upstreamExecutor,void 0!==n.lastDone?n.combineChildResults(n.lastDone,r):r,n.activeChildExecutors,n.upstreamDone,n.combineChildResults,n.combineWithChildResult,n.onPull);this._closeLastSubstream=e.close(NU(r)),this.replaceSubexecutor(t);break}}}handleSubexecutorFailure(e,t,r){return this.finishSubexecutorWithCloseEffect(OU(r),e=>t.close(e),t=>e.close(t))}pullFromUpstream(e){if(0===e.activeChildExecutors.length)return this.performPullFromUpstream(e);const t=e.activeChildExecutors[0],r=new PullFromUpstream(e.upstreamExecutor,e.createChild,e.lastDone,e.activeChildExecutors.slice(1),e.combineChildResults,e.combineWithChildResult,e.onPull,e.onEmit);if(void 0===t)return this.performPullFromUpstream(r);this.replaceSubexecutor(new PullFromChild(t.childExecutor,r,t.onEmit))}performPullFromUpstream(e){return Read(e.upstreamExecutor,e=>{const t=void 0===this._closeLastSubstream?Q4:this._closeLastSubstream;return this._closeLastSubstream=void 0,pipe(this._executeCloseLastSubstream(t),j8(e))},t=>{if(void 0!==this._closeLastSubstream){const r=this._closeLastSubstream;return this._closeLastSubstream=void 0,pipe(this._executeCloseLastSubstream(r),P3(()=>{const r=new ChannelExecutor(e.createChild(t),this._providedEnv,this._executeCloseLastSubstream);r._input=this._input;const[n,i]=this.applyUpstreamPullStrategy(!1,e.activeChildExecutors,e.onPull(Pulled$1(t)));this._activeSubexecutor=new PullFromChild(r,new PullFromUpstream(e.upstreamExecutor,e.createChild,e.lastDone,i,e.combineChildResults,e.combineWithChildResult,e.onPull,e.onEmit),e.onEmit),zt(n)&&(this._activeSubexecutor=new Emit(n.value,this._activeSubexecutor))}))}const r=new ChannelExecutor(e.createChild(t),this._providedEnv,this._executeCloseLastSubstream);r._input=this._input;const[n,i]=this.applyUpstreamPullStrategy(!1,e.activeChildExecutors,e.onPull(Pulled$1(t)));this._activeSubexecutor=new PullFromChild(r,new PullFromUpstream(e.upstreamExecutor,e.createChild,e.lastDone,i,e.combineChildResults,e.combineWithChildResult,e.onPull,e.onEmit),e.onEmit),zt(n)&&(this._activeSubexecutor=new Emit(n.value,this._activeSubexecutor))},t=>{if(e.activeChildExecutors.some(e=>void 0!==e)){const t=new DrainChildExecutors(e.upstreamExecutor,e.lastDone,[void 0,...e.activeChildExecutors],e.upstreamExecutor.getDone(),e.combineChildResults,e.combineWithChildResult,e.onPull);if(void 0!==this._closeLastSubstream){const e=this._closeLastSubstream;return this._closeLastSubstream=void 0,pipe(this._executeCloseLastSubstream(e),P3(()=>this.replaceSubexecutor(t)))}return void this.replaceSubexecutor(t)}const r=this._closeLastSubstream,n=this.finishSubexecutorWithCloseEffect(pipe(t,CU(t=>e.combineWithChildResult(e.lastDone,t))),()=>r,t=>e.upstreamExecutor.close(t));return void 0===n?void 0:effectOrUndefinedIgnored(n)})}drainChildExecutors(e){if(0===e.activeChildExecutors.length){const t=this._closeLastSubstream;return void 0!==t&&this.addFinalizer(()=>G4(t)),this.finishSubexecutorWithCloseEffect(e.upstreamDone,()=>t,t=>e.upstreamExecutor.close(t))}const t=e.activeChildExecutors[0],r=e.activeChildExecutors.slice(1);if(void 0===t){const[t,n]=this.applyUpstreamPullStrategy(!0,r,e.onPull(NoUpstream$1(r.reduce((e,t)=>void 0!==t?e+1:e,0))));return this.replaceSubexecutor(new DrainChildExecutors(e.upstreamExecutor,e.lastDone,n,e.upstreamDone,e.combineChildResults,e.combineWithChildResult,e.onPull)),zt(t)?(this._emitted=t.value,Emit$1()):void 0}const n=new DrainChildExecutors(e.upstreamExecutor,e.lastDone,r,e.upstreamDone,e.combineChildResults,e.combineWithChildResult,e.onPull);this.replaceSubexecutor(new PullFromChild(t.childExecutor,n,t.onEmit))}}const ifNotNull=e=>void 0!==e?e:Q4,runFinalizers=(e,t)=>pipe(x4(e,e=>Y5(e(t))),P3(e=>pipe(xU(e),Kt(()=>jU))),h7(e=>H4(()=>e))),readUpstream=(e,t,r)=>{const n=[e],read=()=>{const e=n.pop();if(void 0===e||void 0===e.upstream)return q4("Unexpected end of input for channel execution");const i=e.upstream.run();switch(i._tag){case rre:{const i=e.onEmit(e.upstream.getEmit());return 0===n.length?void 0===i?H4(t):pipe(i,W7({onFailure:r,onSuccess:t})):void 0===i?H4(()=>read()):pipe(i,W7({onFailure:r,onSuccess:()=>read()}))}case tre:{const i=e.onDone(e.upstream.getDone());return 0===n.length?void 0===i?H4(t):pipe(i,W7({onFailure:r,onSuccess:t})):void 0===i?H4(()=>read()):pipe(i,W7({onFailure:r,onSuccess:()=>read()}))}case nre:return n.push(e),pipe(e.onEffect(i.effect),t3(t=>H4(()=>{const r=e.onDone(OU(t));return void 0===r?Q4:r})),W7({onFailure:r,onSuccess:()=>read()}));case ire:return n.push(e),n.push(i),H4(()=>read())}};return read()},gre=dual(2,(e,t)=>T3(r=>d4([BY(t,RW),fU(),fU()]).pipe(h7(([n,i,s])=>r(((t,r,n)=>B3(Z4(()=>new ChannelExecutor(e,void 0,identity$5)),e=>H4(()=>runScopedInterpret(e.run(),e).pipe(X5(t),j8(hU(t)),N8(hU(r)))),(e,t)=>{const r=e.close(t);return void 0===r?Q4:I7(r,e=>DY(n,$4(e)))}))(i,s,n)).pipe(c5(t),h7(e=>t.addFinalizer(t=>{const r=wU(t)?QQ(t.cause):void 0;return isDone$7(i).pipe(h7(t=>t?yU(s,void 0).pipe(j8(mX(e)),j8(gX(e))):yU(s,void 0).pipe(j8(r&&size$x(r)>0?bX(e,combineAll$1(r)):yX(e)),j8(gX(e)))))}).pipe(j8(r(hU(i)))))))))),runScopedInterpret=(e,t)=>{const r=e;switch(r._tag){case nre:return pipe(r.effect,h7(()=>runScopedInterpret(t.run(),t)));case rre:return runScopedInterpret(t.run(),t);case tre:return H4(()=>t.getDone());case ire:return readUpstream(r,()=>runScopedInterpret(t.run(),t),$4)}},yre="Done",bre="Await",Sre=Symbol.for("effect/ChannelMergeDecision"),vre={[Sre]:{_R:e=>e,_E0:e=>e,_Z0:e=>e,_E:e=>e,_Z:e=>e}},Done$1=e=>{const t=Object.create(vre);return t._tag=yre,t.effect=e,t},Await$1=e=>{const t=Object.create(vre);return t._tag=bre,t.f=e,t},_re=dual(2,(e,{onAwait:t,onDone:r})=>{const n=e;switch(n._tag){case yre:return r(n.effect);case bre:return t(n.f)}}),wre="BothRunning",kre="LeftDone",xre="RightDone",Ire=Symbol.for("effect/ChannelMergeState"),Tre={[Ire]:Ire},BothRunning$1=(e,t)=>{const r=Object.create(Tre);return r._tag=wre,r.left=e,r.right=t,r},LeftDone$1=e=>{const t=Object.create(Tre);return t._tag=kre,t.f=e,t},RightDone$1=e=>{const t=Object.create(Tre);return t._tag=xre,t.f=e,t},Ore=dual(2,(e,{onBothRunning:t,onLeftDone:r,onRightDone:n})=>{switch(e._tag){case wre:return t(e.left,e.right);case kre:return r(e.f);case xre:return n(e.f)}}),Ere="BackPressure",Are="BufferSliding",Cre=Symbol.for("effect/ChannelMergeStrategy"),Mre={[Cre]:Cre},BackPressure$2=e=>{const t=Object.create(Mre);return t._tag=Ere,t},BufferSliding$1=e=>{const t=Object.create(Mre);return t._tag=Are,t},Fre=dual(2,(e,{onBackPressure:t,onBufferSliding:r})=>{switch(e._tag){case Ere:return t();case Are:return r()}}),Pre="Empty",Nre="Emit",jre="Error",Rre="Done",stateEmpty$1=e=>({_tag:Pre,notifyProducer:e}),stateEmit=e=>({_tag:Nre,notifyConsumers:e}),stateError=e=>({_tag:jre,cause:e}),stateDone=e=>({_tag:Rre,done:e});class SingleProducerAsyncInputImpl{ref;constructor(e){this.ref=e}awaitRead(){return m7(Uz(this.ref,e=>e._tag===Pre?[hU(e.notifyProducer),e]:[Q4,e]))}get close(){return s5(e=>this.error(WQ(e)))}done(e){return m7(Uz(this.ref,t=>{switch(t._tag){case Pre:return[hU(t.notifyProducer),t];case Nre:return[x4(t.notifyConsumers,t=>yU(t,He(e)),{discard:!0}),stateDone(e)];case jre:case Rre:return[v3,t]}}))}emit(e){return h7(fU(),t=>m7(Uz(this.ref,r=>{switch(r._tag){case Pre:return[hU(r.notifyProducer),r];case Nre:{const n=r.notifyConsumers[0],i=r.notifyConsumers.slice(1);if(void 0!==n)return[yU(n,Ge(e)),0===i.length?stateEmpty$1(t):stateEmit(i)];throw Error("Bug: Channel.SingleProducerAsyncInput.emit - Queue was empty! please report an issue at https://github.com/Effect-TS/effect/issues")}case jre:case Rre:return[v3,r]}})))}error(e){return m7(Uz(this.ref,t=>{switch(t._tag){case Pre:return[hU(t.notifyProducer),t];case Nre:return[x4(t.notifyConsumers,t=>gU(t,e),{discard:!0}),stateError(e)];case jre:case Rre:return[v3,t]}}))}get take(){return this.takeWith(e=>OU(XQ(e,He)),e=>NU(e),e=>TU(Ge(e)))}takeWith(e,t,r){return h7(fU(),n=>m7(Uz(this.ref,i=>{switch(i._tag){case Pre:return[j8(yU(i.notifyProducer,void 0),q7(hU(n),{onFailure:e,onSuccess:ot({onLeft:r,onRight:t})})),stateEmit([n])];case Nre:return[q7(hU(n),{onFailure:e,onSuccess:ot({onLeft:r,onRight:t})}),stateEmit([...i.notifyConsumers,n])];case jre:return[G4(e(i.cause)),i];case Rre:return[G4(r(i.done)),i]}})))}}const make$1n=()=>pipe(fU(),h7(e=>Nz(stateEmpty$1(e))),P3(e=>new SingleProducerAsyncInputImpl(e))),acquireUseRelease$3=(e,t,r)=>Zte(fromEffect$b(Nz(()=>Q4)),n=>pipe(fromEffect$b(I3(v7(e,e=>Bz(n,t=>r(e,t))))),Zte(t),Hte(e=>h7(jz(n),t=>t(e))))),Dre=dual(2,(e,t)=>Qre(e,()=>t)),buffer$3=e=>suspend$b(()=>{const doBuffer=(e,t,r)=>unwrap$8(Uz(r,n=>t(n)?[readWith$1({onInput:n=>Zte(write$1(n),()=>doBuffer(e,t,r)),onFailure:e=>fail$f(e),onDone:e=>succeedNow(e)}),n]:[Zte(write$1(n),()=>doBuffer(e,t,r)),e]));return doBuffer(e.empty,e.isEmpty,e.ref)}),bufferChunk$1=e=>buffer$3({empty:empty$R(),isEmpty:isEmpty$t,ref:e}),Lre=dual(2,(e,t)=>Vte(e,e=>ot(YQ(e),{onLeft:t,onRight:failCause$8}))),Ure=dual(2,(e,t)=>Kte(e,t,()=>{},()=>{})),$re=dual(2,(e,t)=>{const r=readWith$1({onInput:e=>qt(t(e),{onNone:()=>r,onSome:e=>Zte(write$1(e),()=>r)}),onFailure:fail$f,onDone:succeedNow});return Yte(e,r)}),Bre=dual(2,(e,t)=>{const r=readWith$1({onInput:e=>Zte(write$1(e),()=>r),onFailure:fail$f,onDone:e=>succeedNow(t(e))});return Yte(r,e)}),zre=dual(2,(e,t)=>{const r=readWith$1({onInput:e=>Zte(write$1(e),()=>r),onFailure:fail$f,onDone:e=>fromEffect$b(t(e))});return Yte(r,e)}),qre=dual(2,(e,t)=>{const r=readWith$1({onInput:e=>Zte(write$1(e),()=>r),onFailure:e=>fail$f(t(e)),onDone:succeedNow});return Yte(r,e)}),Wre=dual(2,(e,t)=>{const r=readWith$1({onInput:e=>Zte(write$1(e),()=>r),onFailure:e=>fromEffect$b(t(e)),onDone:succeedNow});return Yte(r,e)}),Vre=dual(2,(e,t)=>{const r=readWith$1({onInput:e=>Zte(write$1(t(e)),()=>r),onFailure:fail$f,onDone:succeedNow});return Yte(r,e)}),Kre=dual(2,(e,t)=>{const r=readWith$1({onInput:e=>Zte(Zte(fromEffect$b(t(e)),write$1),()=>r),onFailure:fail$f,onDone:succeedNow});return Yte(r,e)}),doneCollect$1=e=>suspend$b(()=>{const t=[];return pipe(Yte(e,doneCollectReader(t)),Zte(e=>succeed$g([unsafeFromArray(t),e])))}),doneCollectReader=e=>readWith$1({onInput:t=>Zte(sync$c(()=>{e.push(t)}),()=>doneCollectReader(e)),onFailure:fail$f,onDone:succeed$g}),drain$5=e=>{const t=readWithCause$1({onInput:()=>t,onFailure:failCause$8,onDone:succeed$g});return Yte(e,t)},Gre=dual(2,(e,t)=>Hte(e,()=>t)),context$7=()=>fromEffect$b(R5()),contextWithChannel$1=e=>Zte(context$7(),e),flatten$5=e=>Zte(e,identity$5),Jre=dual(2,(e,t)=>Qte(e,{onFailure:e=>{const r=YQ(e);switch(r._tag){case"Left":return t.onFailure(r.left);case"Right":return failCause$8(r.right)}},onSuccess:t.onSuccess})),fromInput$3=e=>unwrap$8(e.takeWith(failCause$8,t=>Zte(write$1(t),()=>fromInput$3(e)),succeed$g)),fromQueue$5=e=>suspend$b(()=>fromQueueInternal(e)),fromQueueInternal=e=>pipe(fromEffect$b(cte(e)),Zte(ot({onLeft:FU({onFailure:failCause$8,onSuccess:succeedNow}),onRight:t=>Zte(write$1(t),()=>fromQueueInternal(e))}))),identityChannel=()=>readWith$1({onInput:e=>Zte(write$1(e),()=>identityChannel()),onFailure:fail$f,onDone:succeedNow}),Hre=dual(2,(e,t)=>ane(e,{other:fromEffect$b(t),onSelfDone:e=>Done$1(H4(()=>e)),onOtherDone:e=>Done$1(H4(()=>e))})),Zre=dual(2,(e,t)=>Hre(e,hU(t))),Qre=dual(2,(e,t)=>Zte(e,e=>sync$c(()=>t(e)))),Yre=dual(2,(e,t)=>Zte(e,e=>fromEffect$b(t(e)))),Xre=dual(2,(e,t)=>ene(e,XQ(t))),ene=dual(2,(e,t)=>Vte(e,e=>failCause$8(t(e)))),tne=dual(2,(e,t)=>{const r=readWith$1({onInput:e=>Zte(write$1(t(e)),()=>r),onFailure:fail$f,onDone:succeedNow});return Yte(e,r)}),rne=dual(2,(e,t)=>{const r=readWithCause$1({onInput:e=>pipe(fromEffect$b(t(e)),Zte(write$1),Zte(()=>r)),onFailure:failCause$8,onDone:succeedNow});return Yte(e,r)}),nne=dual(3,(e,t,r)=>unwrapScopedWith$5(n=>V4(function*(){const i=yield*make$1n(),s=fromInput$3(i),o=yield*bounded$4(r);yield*DY(n,shutdown$4(o));const a=yield*fU(),u=r===1/0?e=>identity$5:(yield*makeSemaphore(r)).withPermits,c=yield*s.pipe(Yte(e),yne(n));yield*c.pipe(W7({onFailure:e=>ate(o,$4(e)),onSuccess:ot({onLeft:e=>j8(w3(u(r)(Q4)),C3(ate(o,G4(He(e))))),onRight:e=>V4(function*(){const r=yield*fU(),i=yield*fU();yield*ate(o,P3(hU(r),Ge)),yield*yU(i,void 0).pipe(j8(T3(r=>Y5(r(hU(a))).pipe(y7(Y5(r(t(e)))),h7(identity$5))).pipe(I7(e=>gU(a,e)),X5(r))),u(1),c5(n)),yield*hU(i)})})}),T7,w3,c5(n));const l=unwrap$8(q7(m7(cte(o)),{onFailure:failCause$8,onSuccess:ot({onLeft:succeedNow,onRight:e=>Zte(write$1(e),()=>l)})}));return Jte(l,i)}))),mergeAll$5=e=>t=>mergeAllWith$1(e)(t,o),mergeAllWith$1=({bufferSize:e=16,concurrency:t,mergeStrategy:r=BackPressure$2()})=>(n,i)=>unwrapScopedWith$5(s=>V4(function*(){const o="unbounded"===t?Number.MAX_SAFE_INTEGER:t,a=yield*make$1n(),u=fromInput$3(a),c=yield*bounded$4(e);yield*DY(s,shutdown$4(c));const l=yield*ote();yield*DY(s,shutdown$4(l));const p=yield*Nz(none$c()),d=yield*fU(),m=(yield*makeSemaphore(o)).withPermits,g=yield*yne(Yte(u,n),s);function evaluatePull(e){return e.pipe(h7(ot({onLeft:e=>G4(Ut(e)),onRight:e=>E3(ate(c,G4(Ge(e))),none$c())})),E7({until:e=>zt(e)}),h7(e=>qz(p,qt({onNone:()=>Ut(e.value),onSome:t=>Ut(i(t,e.value))}))),t3(e=>HQ(e)?$4(e):ate(c,$4(e)).pipe(j8(yU(d,void 0)),C3)))}yield*g.pipe(W7({onFailure:e=>ate(c,$4(e)).pipe(j8(G4(!1))),onSuccess:ot({onLeft:e=>b7(w3(hU(d)),w3(m(o)(Q4)),{onSelfDone:(e,t)=>E3(yX(t),!1),onOtherDone:(t,r)=>j8(yX(r),jz(p).pipe(h7(qt({onNone:()=>ate(c,G4(He(e))),onSome:t=>ate(c,G4(He(i(t,e))))})),E3(!1)))}),onRight:e=>Fre(r,{onBackPressure:()=>V4(function*(){const t=yield*fU(),r=Z3(t=>yne(Yte(u,e),t).pipe(h7(e=>g7(Y5(evaluatePull(e)),Y5(w3(hU(d))))),h7(identity$5)));return yield*yU(t,void 0).pipe(j8(r),m(1),c5(s)),yield*hU(t),!(yield*isDone$7(d))}),onBufferSliding:()=>V4(function*(){const t=yield*fU(),r=yield*fU(),n=yield*size$j(l);yield*cte(l).pipe(h7(e=>yU(e,void 0)),c7(()=>n>=o)),yield*ate(l,t);const i=Z3(r=>yne(Yte(u,e),r).pipe(h7(e=>Y5(evaluatePull(e)).pipe(g7(Y5(w3(hU(d)))),g7(Y5(w3(hU(t)))))),h7(identity$5)));return yield*yU(r,void 0).pipe(j8(i),m(1),c5(s)),yield*hU(r),!(yield*isDone$7(d))})})})}),E7({while:e=>e}),c5(s));const y=pipe(cte(c),m7,q7({onFailure:failCause$8,onSuccess:ot({onLeft:succeedNow,onRight:e=>Zte(write$1(e),()=>y)})}),unwrap$8);return Jte(y,a)})),ine=dual(3,(e,t,r)=>mergeAll$5(r)(tne(e,t))),sne=dual(2,(e,t)=>mergeAll$5({concurrency:t})(tne(e,identity$5))),one=dual(3,(e,t,r)=>mergeAllWith$1({concurrency:t})(tne(e,identity$5),r)),ane=dual(2,(e,t)=>unwrapScopedWith$5(function(r){return V4(function*(){const n=yield*make$1n(),i=fromInput$3(n),s=yield*yne(Yte(i,e),r),o=yield*yne(Yte(i,t.other),r);function handleSide(e,t,n){return(i,s,o)=>{function onDecision(e){const r=e;return r._tag===yre?G4(fromEffect$b(j8(yX(t),r.effect))):P3(mX(t),FU({onFailure:e=>fromEffect$b(r.f(OU(e))),onSuccess:ot({onLeft:e=>fromEffect$b(r.f(NU(e))),onRight:e=>_ne(write$1(e),go(o(r.f)))})}))}return FU(e,{onFailure:e=>onDecision(i(OU(e))),onSuccess:ot({onLeft:e=>onDecision(i(NU(e))),onRight:e=>G4(Zte(write$1(e),()=>Zte(fromEffect$b(c5(w3(n),r)),e=>go(s(e,t)))))})})}}function go(e){switch(e._tag){case wre:{const r=w3(vX(e.left)),n=w3(vX(e.right));return unwrap$8(b7(r,n,{onSelfDone:(r,n)=>j8(yX(n),handleSide(r,e.right,s)(t.onSelfDone,BothRunning$1,e=>LeftDone$1(e))),onOtherDone:(r,n)=>j8(yX(n),handleSide(r,e.left,o)(t.onOtherDone,(e,t)=>BothRunning$1(t,e),e=>RightDone$1(e)))}))}case kre:return unwrap$8(P3(Y5(o),FU({onFailure:t=>fromEffect$b(e.f(OU(t))),onSuccess:ot({onLeft:t=>fromEffect$b(e.f(NU(t))),onRight:t=>Zte(write$1(t),()=>go(LeftDone$1(e.f)))})})));case xre:return unwrap$8(P3(Y5(s),FU({onFailure:t=>fromEffect$b(e.f(OU(t))),onSuccess:ot({onLeft:t=>fromEffect$b(e.f(NU(t))),onRight:t=>Zte(write$1(t),()=>go(RightDone$1(e.f)))})})))}}return fromEffect$b(D4(e=>{const t=D4(t=>(t.transferChildren(e.scope()),Q4)),n=w3(s).pipe(q3(t),c5(r)),i=w3(o).pipe(q3(t),c5(r));return R8(n,i,(e,t)=>BothRunning$1(e,t))})).pipe(Zte(go),Jte(n))})})),une=fromEffect$b(K4),cne=dual(2,(e,t)=>lne(e,t)),lne=dual(2,(e,t)=>Lre(e,e=>failCauseSync$5(()=>qQ(t(e))))),pne=dual(2,(e,t)=>Lre(e,t)),fne=dual(2,(e,t)=>suspend$b(()=>{let r;const n=readWith$1({onInput:e=>Zte(write$1(e),()=>n),onFailure:e=>(r=ChannelException$1(e),failCause$8(qQ(r))),onDone:succeedNow}),i=readWithCause$1({onInput:e=>pipe(write$1(e),Zte(()=>i)),onFailure:e=>JQ(e)&&isChannelException$1(e.defect)&&equals$4(e.defect,r)?fail$f(e.defect.error):failCause$8(e),onDone:succeedNow});return Yte(Yte(Yte(e,n),t),i)})),hne=dual(3,(e,t,r)=>Zte(context$7(),n=>Xte(e,NA(n,t,r)))),dne=dual(2,(e,t)=>unwrapScopedWith$5(r=>P3($9(t,r),t=>Xte(e,t)))),mne=dual(2,(e,t)=>contextWithChannel$1(r=>Xte(e,t(r)))),gne=dual(2,(e,t)=>dne(e,see(q9(),t))),repeated$2=e=>Zte(e,()=>repeated$2(e)),run$7=e=>Z3(t=>gre(e,t)),runDrain$3=e=>run$7(drain$5(e)),runScoped$3=e=>H3(t=>gre(e,t)),scoped$3=e=>unwrap$8(T3(t=>P3(zY(),r=>Wte(I7(t($Y(e,r)),e=>UY(r,OU(e))),(e,t)=>UY(r,t))))),scopedWith$3=e=>unwrapScoped$5(P3(J3,t=>Zte(fromEffect$b(e(t)),write$1))),splitLines$3=()=>suspend$b(()=>{let e="",t=!1;const r=readWithCause$1({onInput:n=>{const i=(r=>{const n=[];return fC(r,r=>{if(0!==r.length){let i=0,s=r.indexOf("\r"),o=r.indexOf("\n");for(t&&(0===o?(n.push(e),e="",i=1,o=r.indexOf("\n",i)):e+="\r",t=!1);-1!==s||-1!==o;)-1===s||-1!==o&&o<s?(0===e.length?n.push(r.substring(i,o)):(n.push(e+r.substring(i,o)),e=""),i=o+1,o=r.indexOf("\n",i)):r.length===s+1?(t=!0,s=-1):o===s+1?(0===e.length?n.push(r.substring(i,s)):(e+=r.substring(i,s),n.push(e),e=""),i=s+2,s=r.indexOf("\r",i),o=r.indexOf("\n",i)):s=r.indexOf("\r",s+1);e+=t?r.substring(i,r.length-1):r.substring(i,r.length)}}),unsafeFromArray(n)})(n);return isEmpty$t(i)?r:Zte(write$1(i),()=>r)},onFailure:t=>0===e.length?failCause$8(t):Zte(write$1(of$5(e)),()=>failCause$8(t)),onDone:t=>0===e.length?succeed$g(t):Zte(write$1(of$5(e)),()=>succeed$g(t))});return r}),toPubSub$3=e=>toQueue$3(e),toPull$3=e=>h7(J3,t=>yne(e,t)),yne=dual(2,(e,t)=>P8(Z4(()=>new ChannelExecutor(e,void 0,identity$5)),h8()).pipe(v7(([e,r])=>LY(t,t=>{const n=e.close(t);return void 0!==n?U5(n,r):Q4})),I3,P3(([e])=>H4(()=>interpretToPull(e.run(),e))))),interpretToPull=(e,t)=>{const r=e;switch(r._tag){case tre:return FU(t.getDone(),{onFailure:$4,onSuccess:e=>G4(He(e))});case rre:return G4(Ge(t.getEmit()));case nre:return pipe(r.effect,h7(()=>interpretToPull(t.run(),t)));case ire:return readUpstream(r,()=>interpretToPull(t.run(),t),e=>$4(e))}},toQueue$3=e=>suspend$b(()=>toQueueInternal(e)),toQueueInternal=e=>readWithCause$1({onInput:t=>Zte(fromEffect$b(ate(e,Ge(t))),()=>toQueueInternal(e)),onFailure:t=>fromEffect$b(ate(e,He(OU(t)))),onDone:t=>fromEffect$b(ate(e,He(NU(t))))}),unwrap$8=e=>flatten$5(fromEffect$b(e)),unwrapScoped$5=e=>concatAllWith$1(scoped$3(e),(e,t)=>e,(e,t)=>e),unwrapScopedWith$5=e=>concatAllWith$1(scopedWith$3(e),(e,t)=>e,(e,t)=>e),bne=dual(3,(e,t,r)=>mne(e,e=>LA(e,PA(t,r(RA(e,t)))))),withSpan$3=function(){const e="string"!=typeof arguments[0],name=e?arguments[1]:arguments[0],t=addSpanStackTrace(e?arguments[2]:arguments[1]),r=d4([makeSpan(name,t),R5(),b5,p9(g9)]);if(e){const e=arguments[0];return acquireUseRelease$3(r,([t,r])=>Xte(e,NA(r,oB,t)),([e,,t,r],n)=>endSpan(e,n,t,r))}return e=>acquireUseRelease$3(r,([t,r])=>Xte(e,NA(r,oB,t)),([e,,t,r],n)=>endSpan(e,n,t,r))},writeAll$1=(...e)=>writeChunk$1(fromIterable$u(e)),writeChunk$1=e=>writeChunkWriter(0,e.length,e),writeChunkWriter=(e,t,r)=>e===t?ere:pipe(write$1(pipe(r,KA(e))),Zte(()=>writeChunkWriter(e+1,t,r))),Sne=dual(e=>isChannel$1(e[1]),(e,t,r)=>r?.concurrent?ane(e,{other:t,onSelfDone:e=>Await$1(t=>H4(()=>RU(e,t))),onOtherDone:e=>Await$1(t=>H4(()=>RU(t,e)))}):Zte(e,e=>Qre(t,t=>[e,t]))),vne=dual(e=>isChannel$1(e[1]),(e,t,r)=>r?.concurrent?Qre(Sne(e,t,{concurrent:!0}),e=>e[0]):Zte(e,e=>Dre(t,e))),_ne=dual(e=>isChannel$1(e[1]),(e,t,r)=>r?.concurrent?Qre(Sne(e,t,{concurrent:!0}),e=>e[1]):Zte(e,()=>t)),wne=Symbol.for("effect/Channel/ChannelException"),ChannelException$1=e=>({_tag:"ChannelException",[wne]:wne,error:e}),isChannelException$1=e=>C(e,wne),kne=Symbol.for("effect/Sink"),xne={_A:e=>e,_In:e=>e,_L:e=>e,_E:e=>e,_R:e=>e};class SinkImpl{channel;[kne]=xne;constructor(e){this.channel=e}pipe(){return pipeArguments(this,arguments)}}const isSink=e=>C(e,kne),suspend$a=e=>new SinkImpl(suspend$b(()=>toChannel$5(e()))),Ine=dual(2,(e,t)=>pipe(e,zne(()=>t))),collectAll$3=()=>new SinkImpl(collectAllLoop(empty$R())),collectAllLoop=e=>readWithCause$1({onInput:t=>collectAllLoop(pipe(e,eC(t))),onFailure:failCause$8,onDone:()=>succeed$g(e)}),collectAllN$1=e=>suspend$a(()=>fromChannel$3(collectAllNLoop(e,empty$R()))),collectAllNLoop=(e,t)=>readWithCause$1({onInput:r=>{const[n,i]=bC(r,e);return n.length<e?collectAllNLoop(e-n.length,eC(t,n)):isEmpty$t(i)?succeed$g(eC(t,n)):Zte(write$1(i),()=>succeed$g(eC(t,n)))},onFailure:failCause$8,onDone:()=>succeed$g(t)}),collectAllWhileReader=(e,t)=>readWith$1({onInput:r=>{const[n,i]=pipe(toReadonlyArray$1(r),yi(e));return 0===i.length?collectAllWhileReader(e,pipe(t,eC(unsafeFromArray(n)))):pipe(write$1(unsafeFromArray(i)),_ne(succeed$g(pipe(t,eC(unsafeFromArray(n))))))},onFailure:fail$f,onDone:()=>succeed$g(t)}),collectAllWhileEffectReader=(e,t)=>readWith$1({onInput:r=>pipe(fromEffect$b(pipe(r,b4(e),P3(unsafeFromArray))),Zte(n=>{const i=pipe(r,ZA(n.length));return isEmpty$t(i)?collectAllWhileEffectReader(e,pipe(t,eC(n))):pipe(write$1(i),_ne(succeed$g(pipe(t,eC(n)))))})),onFailure:fail$f,onDone:()=>succeed$g(t)}),Tne=dual(2,(e,t)=>{const r=pipe(Nz(empty$R()),P8(Nz(!1))),n=pipe(fromEffect$b(r),Zte(([r,n])=>{const i=readWith$1({onInput:e=>pipe(write$1(e),Zte(()=>i)),onFailure:fail$f,onDone:e=>pipe(fromEffect$b(Bz(n,!0)),Dre(e))});return pipe(i,Yte(bufferChunk$1(r)),Yte(collectAllWhileWithLoop(e,r,n,t.initial,t.while,t.body)))}));return new SinkImpl(n)}),collectAllWhileWithLoop=(e,t,r,n,i,s)=>pipe(toChannel$5(e),doneCollect$1,Jre({onFailure:fail$f,onSuccess:([o,a])=>i(a)?pipe(fromEffect$b(Bz(t,oC(o))),Zte(()=>pipe(fromEffect$b(jz(r)),Zte(u=>{const c=s(n,a);return u?pipe(write$1(oC(o)),Dre(c)):collectAllWhileWithLoop(e,t,r,c,i,s)})))):pipe(write$1(oC(o)),Dre(n))})),collectLeftover$1=e=>new SinkImpl(pipe(collectElements(toChannel$5(e)),Qre(([e,t])=>[t,oC(e)]))),One=dual(2,(e,t)=>pipe(e,Ane(fC(t)))),Ene=dual(2,(e,t)=>Cne(e,e=>P3(x4(e,e=>t(e)),unsafeFromArray))),Ane=dual(2,(e,t)=>{const r=readWith$1({onInput:e=>pipe(write$1(t(e)),Zte(()=>r)),onFailure:fail$f,onDone:succeed$g});return new SinkImpl(pipe(r,Yte(toChannel$5(e))))}),Cne=dual(2,(e,t)=>{const r=readWith$1({onInput:e=>pipe(fromEffect$b(t(e)),Zte(write$1),Zte(()=>r)),onFailure:fail$f,onDone:succeed$g});return new SinkImpl(pipe(r,fne(toChannel$5(e))))}),Mne=dual(2,(e,t)=>zne(One(e,t.onInput),t.onDone)),Fne=dual(2,(e,t)=>qne(Ene(e,t.onInput),t.onDone)),Pne=dual(2,(e,t)=>zne(Ane(e,t.onInput),t.onDone)),Nne=dual(2,(e,t)=>qne(Cne(e,t.onInput),t.onDone)),jne=new SinkImpl(drain$5(identityChannel())),drop$3=e=>suspend$a(()=>new SinkImpl(dropLoop(e))),dropLoop=e=>readWith$1({onInput:t=>{const r=pipe(t,ZA(e)),n=Math.max(e-t.length,0);return isEmpty$t(t)||n>0?dropLoop(n):pipe(write$1(r),_ne(identityChannel()))},onFailure:fail$f,onDone:()=>ere}),dropUntilEffectReader=e=>readWith$1({onInput:t=>pipe(t,m4(e),P3(t=>0===t.length?dropUntilEffectReader(e):pipe(write$1(unsafeFromArray(t)),_ne(identityChannel()))),unwrap$8),onFailure:fail$f,onDone:()=>ere}),dropWhile$3=e=>new SinkImpl(dropWhileReader(e)),dropWhileReader=e=>readWith$1({onInput:t=>{const r=pipe(t,YA(e));return isEmpty$t(r)?dropWhileReader(e):pipe(write$1(r),_ne(identityChannel()))},onFailure:fail$f,onDone:succeedNow}),dropWhileEffectReader=e=>readWith$1({onInput:t=>pipe(t,g4(e),P3(t=>0===t.length?dropWhileEffectReader(e):pipe(write$1(unsafeFromArray(t)),_ne(identityChannel()))),unwrap$8),onFailure:fail$f,onDone:()=>ere}),Rne=dual(2,(e,t)=>new SinkImpl(pipe(e,toChannel$5,Gre(t)))),Dne=dual(2,(e,t)=>new SinkImpl(pipe(e,toChannel$5,Hte(t)))),context$6=()=>fromEffect$9(R5()),fail$e=e=>new SinkImpl(fail$f(e)),failCause$7=e=>new SinkImpl(failCause$8(e)),failCauseSync$4=e=>new SinkImpl(failCauseSync$5(e)),Lne=dual(2,(e,t)=>Cne(e,e=>P3(_4(e,t),unsafeFromArray))),Une=dual(2,(e,t)=>{const r=pipe(fromEffect$b(pipe(Nz(empty$R()),P8(Nz(!1)))),Zte(([r,n])=>{const i=readWith$1({onInput:e=>pipe(write$1(e),Zte(()=>i)),onFailure:fail$f,onDone:e=>pipe(fromEffect$b(Bz(n,!0)),Dre(e))}),s=Jre(collectElements(toChannel$5(e)),{onFailure:fail$f,onSuccess:([e,i])=>pipe(fromEffect$b(t(i)),Zte(t=>pipe(fromEffect$b(Bz(r,oC(e))),_ne(pipe(fromEffect$b(jz(n)),Zte(r=>t?pipe(write$1(oC(e)),Dre(Ut(i))):r?pipe(write$1(oC(e)),Dre(none$c())):s))))))});return pipe(i,Yte(bufferChunk$1(r)),Yte(s))}));return new SinkImpl(r)}),fold$1=(e,t,r)=>suspend$a(()=>new SinkImpl(foldReader(e,t,r))),foldReader=(e,t,r)=>t(e)?readWith$1({onInput:n=>{const[i,s]=foldChunkSplit(e,n,t,r,0,n.length);return isNonEmpty$8(s)?pipe(write$1(s),Dre(i)):foldReader(i,t,r)},onFailure:fail$f,onDone:()=>succeedNow(e)}):succeedNow(e),foldChunkSplit=(e,t,r,n,i,s)=>{if(i===s)return[e,empty$R()];const o=n(e,pipe(t,KA(i)));return r(o)?foldChunkSplit(o,t,r,n,i+1,s):[o,pipe(t,ZA(i+1))]},$ne=dual(2,(e,t)=>{const r=pipe(toChannel$5(e),collectElements,Jre({onFailure:e=>toChannel$5(t.onFailure(e)),onSuccess:([e,r])=>suspend$b(()=>{const n={ref:pipe(e,rC(isNonEmpty$8))},i=pipe(sync$c(()=>{const e=n.ref;return n.ref=empty$R(),e}),Zte(e=>writeChunk$1(e))),s=identityChannel(),o=pipe(i,_ne(s),Yte(toChannel$5(t.onSuccess(r))));return Zte(collectElements(o),([e,t])=>pipe(succeed$g(n.ref),Zte(writeChunk$1),_ne(writeChunk$1(e)),Dre(t)))})}));return new SinkImpl(r)}),foldChunks$1=(e,t,r)=>suspend$a(()=>new SinkImpl(foldChunksReader(e,t,r))),foldChunksReader=(e,t,r)=>t(e)?readWith$1({onInput:n=>foldChunksReader(r(e,n),t,r),onFailure:fail$f,onDone:()=>succeedNow(e)}):succeedNow(e),foldChunksEffect$1=(e,t,r)=>suspend$a(()=>new SinkImpl(foldChunksEffectReader(e,t,r))),foldChunksEffectReader=(e,t,r)=>t(e)?readWith$1({onInput:n=>pipe(fromEffect$b(r(e,n)),Zte(e=>foldChunksEffectReader(e,t,r))),onFailure:fail$f,onDone:()=>succeedNow(e)}):succeedNow(e),foldEffect$1=(e,t,r)=>suspend$a(()=>new SinkImpl(foldEffectReader(e,t,r))),foldEffectReader=(e,t,r)=>t(e)?readWith$1({onInput:n=>pipe(fromEffect$b(foldChunkSplitEffect(e,n,t,r)),Zte(([e,n])=>pipe(n,qt({onNone:()=>foldEffectReader(e,t,r),onSome:t=>pipe(write$1(t),Dre(e))})))),onFailure:fail$f,onDone:()=>succeedNow(e)}):succeedNow(e),foldChunkSplitEffect=(e,t,r,n)=>foldChunkSplitEffectInternal(e,t,0,t.length,r,n),foldChunkSplitEffectInternal=(e,t,r,n,i,s)=>r===n?G4([e,none$c()]):pipe(s(e,pipe(t,KA(r))),h7(e=>i(e)?foldChunkSplitEffectInternal(e,t,r+1,n,i,s):G4([e,Ut(pipe(t,ZA(r+1)))]))),foldLeftChunks$1=(e,t)=>foldChunks$1(e,r,t),foldWeighted$1=e=>foldWeightedDecompose$1({...e,decompose:of$5}),foldWeightedDecompose$1=e=>suspend$a(()=>new SinkImpl(foldWeightedDecomposeLoop(e.initial,0,!1,e.maxCost,e.cost,e.decompose,e.body))),foldWeightedDecomposeLoop=(e,t,r,n,i,s,o)=>readWith$1({onInput:a=>{const[u,c,l,p]=foldWeightedDecomposeFold(a,e,t,r,n,i,s,o);return isNonEmpty$8(p)?pipe(write$1(p),_ne(succeedNow(u))):t>n?succeedNow(u):foldWeightedDecomposeLoop(u,c,l,n,i,s,o)},onFailure:fail$f,onDone:()=>succeedNow(e)}),foldWeightedDecomposeFold=(e,t,r,n,i,s,o,a)=>{for(let u=0;u<e.length;u++){const c=KA(e,u),l=r;if((r+=s(t,c))<=i){t=a(t,c),n=!0;continue}const p=o(c);if(p.length<=1&&!n)return[a(t,c),r,!0,ZA(e,u+1)];if(p.length<=1&&n)return[t,l,n,ZA(e,u)];e=eC(p,ZA(e,u+1)),r=l,u=-1}return[t,r,n,empty$R()]},foldWeightedDecomposeEffect$1=e=>suspend$a(()=>new SinkImpl(foldWeightedDecomposeEffectLoop(e.initial,e.maxCost,e.cost,e.decompose,e.body,0,!1))),foldWeightedDecomposeEffectLoop=(e,t,r,n,i,s,o)=>readWith$1({onInput:a=>pipe(fromEffect$b(foldWeightedDecomposeEffectFold(e,t,r,n,i,a,o,s,0)),Zte(([e,o,a,u])=>isNonEmpty$8(u)?pipe(write$1(u),_ne(succeedNow(e))):s>t?succeedNow(e):foldWeightedDecomposeEffectLoop(e,t,r,n,i,o,a))),onFailure:fail$f,onDone:()=>succeedNow(e)}),foldWeightedDecomposeEffectFold=(e,t,r,n,i,s,o,a,u)=>{if(u===s.length)return G4([e,a,o,empty$R()]);const c=pipe(s,KA(u));return pipe(r(e,c),P3(e=>a+e),h7(l=>l<=t?pipe(i(e,c),h7(e=>foldWeightedDecomposeEffectFold(e,t,r,n,i,s,!0,l,u+1))):pipe(n(c),h7(p=>{if(p.length<=1&&!o)return pipe(i(e,c),P3(e=>[e,l,!0,pipe(s,ZA(u+1))]));if(p.length<=1&&o)return G4([e,a,o,pipe(s,ZA(u))]);const d=pipe(p,eC(pipe(s,ZA(u+1))));return foldWeightedDecomposeEffectFold(e,t,r,n,i,d,o,a,0)}))))},Bne=dual(2,(e,t)=>$ne(e,{onFailure:fail$e,onSuccess:t})),forEach$b=e=>{const t=readWithCause$1({onInput:r=>pipe(fromEffect$b(x4(r,t=>e(t),{discard:!0})),Zte(()=>t)),onFailure:failCause$8,onDone:()=>ere});return new SinkImpl(t)},forEachChunk$1=e=>{const t=readWithCause$1({onInput:r=>pipe(fromEffect$b(e(r)),Zte(()=>t)),onFailure:failCause$8,onDone:()=>ere});return new SinkImpl(t)},forEachWhile$1=e=>{const t=readWithCause$1({onInput:r=>forEachWhileReader(e,r,0,r.length,t),onFailure:failCause$8,onDone:()=>ere});return new SinkImpl(t)},forEachWhileReader=(e,t,r,n,i)=>r===n?i:pipe(fromEffect$b(e(pipe(t,KA(r)))),Zte(s=>s?forEachWhileReader(e,t,r+1,n,i):write$1(pipe(t,ZA(r)))),Lre(e=>pipe(write$1(pipe(t,ZA(r))),_ne(fail$f(e))))),fromChannel$3=e=>new SinkImpl(e),fromEffect$9=e=>new SinkImpl(fromEffect$b(e)),fromPushPull=e=>readWith$1({onInput:t=>Jre(fromEffect$b(e(Ut(t))),{onFailure:([e,t])=>ot(e,{onLeft:e=>pipe(write$1(t),_ne(fail$f(e))),onRight:e=>pipe(write$1(t),_ne(succeedNow(e)))}),onSuccess:()=>fromPushPull(e)}),onFailure:fail$f,onDone:()=>Jre(fromEffect$b(e(none$c())),{onFailure:([e,t])=>ot(e,{onLeft:e=>pipe(write$1(t),_ne(fail$f(e))),onRight:e=>pipe(write$1(t),_ne(succeedNow(e)))}),onSuccess:()=>fromEffect$b(q4("BUG: Sink.fromPush - please report an issue at https://github.com/Effect-TS/effect/issues"))})}),fromQueue$4=(e,t)=>t?.shutdown?unwrapScoped$4(P3(U3(G4(e),shutdown$4),fromQueue$4)):forEachChunk$1(t=>ute(e,t)),head$4=()=>fold$1(none$c(),Bt,(e,t)=>qt(e,{onNone:()=>Ut(t),onSome:()=>e})),ignoreLeftover$1=e=>new SinkImpl(drain$5(toChannel$5(e))),last$1=()=>foldLeftChunks$1(none$c(),(e,t)=>Gt(last$5(t),()=>e)),zne=dual(2,(e,t)=>new SinkImpl(pipe(toChannel$5(e),Qre(t)))),qne=dual(2,(e,t)=>new SinkImpl(pipe(toChannel$5(e),Yre(t)))),Wne=dual(2,(e,t)=>new SinkImpl(pipe(toChannel$5(e),Xre(t)))),Vne=dual(2,(e,t)=>new SinkImpl(pipe(toChannel$5(e),tne(fC(t))))),Kne=fromEffect$9(K4),Gne=dual(2,(e,t)=>new SinkImpl(pipe(toChannel$5(e),pne(()=>toChannel$5(t()))))),Jne=dual(2,(e,t)=>new SinkImpl(pipe(toChannel$5(e),Xte(t)))),Hne=dual(2,(e,t)=>pipe(e,Zne(t),zne(ct))),Zne=dual(e=>isSink(e[1]),(e,t,r)=>Qne(e,{other:t,onSelfDone:e=>Done$1(P3(e,He)),onOtherDone:e=>Done$1(P3(e,Ge)),capacity:r?.capacity??16})),Qne=dual(2,(e,t)=>unwrapScopedWith$4(function(r){return V4(function*(){const n=yield*bounded$5(t?.capacity??16),i=yield*$Y(subscribe$2(n),r),s=yield*$Y(subscribe$2(n),r),o=toPubSub$3(n),a=fromQueue$5(i).pipe(Yte(toChannel$5(e)),vne(fromEffect$b(shutdown$4(i))),ane({other:fromQueue$5(s).pipe(Yte(toChannel$5(t.other)),vne(fromEffect$b(shutdown$4(s)))),onSelfDone:t.onSelfDone,onOtherDone:t.onOtherDone})),u=ane(o,{other:a,onSelfDone:()=>Await$1(identity$5),onOtherDone:e=>Done$1(e)});return new SinkImpl(u)})})),Yne=dual(2,(e,t)=>pipe(e,Xne(t,identity$5))),Xne=dual(3,(e,t,r)=>{const n=pipe(e,toChannel$5,Lre(e=>qt(t(e),{onNone:()=>failCauseSync$5(()=>qQ(r(e))),onSome:fail$f})));return new SinkImpl(n)}),eie=dual(2,(e,t)=>{const r=pipe(fromEffect$b(Nz(empty$R())),Zte(r=>pipe(splitWhereSplitter(!1,r,t),fne(toChannel$5(e)),collectElements,Zte(([e,t])=>pipe(fromEffect$b(jz(r)),Zte(r=>pipe(write$1(pipe(r,eC(oC(e)))),_ne(succeed$g(t)))))))));return new SinkImpl(r)}),splitWhereSplitter=(e,t,r)=>readWithCause$1({onInput:n=>{if(isEmpty$t(n))return splitWhereSplitter(e,t,r);if(e){const e=indexWhere(n,r);if(-1===e)return _ne(write$1(n),splitWhereSplitter(!0,t,r));const[i,s]=bC(n,e);return _ne(write$1(i),fromEffect$b(Bz(t,s)))}const i=indexWhere(n,r,1);if(-1===i)return _ne(write$1(n),splitWhereSplitter(!0,t,r));const[s,o]=pipe(n,bC(Math.max(i,1)));return _ne(write$1(s),fromEffect$b(Bz(t,o)))},onFailure:failCause$8,onDone:succeed$g}),indexWhere=(e,t,r=0)=>{const n=e[Symbol.iterator]();let i,s=0,o=-1;for(;o<0&&(i=n.next())&&!i.done;){const e=i.value;s>=r&&t(e)&&(o=s),s+=1}return o},tie=foldLeftChunks$1(0,(e,t)=>e+qC(t,0,(e,t)=>e+t)),rie=dual(3,(e,t,r)=>{const n=pipe(fromEffect$b(t),Zte(start=>pipe(e,toChannel$5,Zte(e=>pipe(fromEffect$b(t),Qre(t=>[e,r(start,t)]))))));return new SinkImpl(n)}),toChannel$5=e=>c4(e)?toChannel$5(fromEffect$9(e)):e.channel,unwrapScoped$4=e=>new SinkImpl(unwrapScoped$5(e.pipe(P3(e=>toChannel$5(e))))),unwrapScopedWith$4=e=>new SinkImpl(unwrapScopedWith$5(t=>e(t).pipe(P3(e=>toChannel$5(e))))),withDuration$1=e=>pipe(e,rie(_B,(start,e)=>millis(e-start))),nie=dual(e=>isSink(e[1]),(e,t,r)=>oie(e,t,(e,t)=>[e,t],r)),iie=dual(e=>isSink(e[1]),(e,t,r)=>oie(e,t,(e,t)=>e,r)),sie=dual(e=>isSink(e[1]),(e,t,r)=>oie(e,t,(e,t)=>t,r)),oie=dual(e=>isSink(e[1]),(e,t,r,n)=>n?.concurrent?Qne(e,{other:t,onSelfDone:FU({onFailure:e=>Done$1($4(e)),onSuccess:e=>Await$1(FU({onFailure:$4,onSuccess:t=>G4(r(e,t))}))}),onOtherDone:FU({onFailure:e=>Done$1($4(e)),onSuccess:e=>Await$1(FU({onFailure:$4,onSuccess:t=>G4(r(t,e))}))})}):Bne(e,e=>zne(t,t=>r(e,t)))),aie=foldLeftChunks$1(0,(e,t)=>e+t.length),uie=suspend$a(()=>{const e=[];return pipe(foldLeftChunks$1(void 0,(t,r)=>fC(r,t=>{e.push(t+"")})),zne(()=>e.join("")))}),cie=pipe(withDuration$1(jne),zne(e=>e[1])),lie=Done$1,pie=Await$1;var fie=Object.freeze({__proto__:null,Await:pie,AwaitConst:e=>Await$1(()=>e),Done:lie,MergeDecisionTypeId:Sre,isMergeDecision:e=>C(e,Sre),match:_re});const hie=Symbol.for("effect/RcRef"),die={_tag:"Empty"},mie={_tag:"Closed"},gie={_A:identity$5,_E:identity$5};class RcRefImpl extends hz{acquire;context;scope;idleTimeToLive;[hie]=gie;[mz]=mz;state=die;semaphore=unsafeMakeSemaphore$2(1);constructor(e,t,r,n){super(),this.acquire=e,this.context=t,this.scope=r,this.idleTimeToLive=n,this.get=get$w(this)}get;commit(){return this.get}}const get$w=e=>{const t=e;return uninterruptibleMask$2(e=>suspend$g(()=>{switch(t.state._tag){case"Closed":return BR;case"Acquired":return t.state.refCount++,t.state.fiber?TR(interruptFiber(t.state.fiber),t.state):succeed$u(t.state);case"Empty":return scopeMake().pipe(Sq("scope"),bq("value",({scope:r})=>e(LD(t.acquire,$D,NA(t.context,_Q,r)))),qR(({scope:e,value:r})=>{const n={_tag:"Acquired",value:r,scope:e,fiber:void 0,refCount:1};return t.state=n,n}))}})).pipe(t.semaphore.withPermits(1),Sq("state"),bq("scope",()=>_Q),XR(({scope:e,state:r})=>e.addFinalizer(()=>suspend$g(()=>(r.refCount--,r.refCount>0?tD:void 0===t.idleTimeToLive?(t.state=die,scopeClose(r.scope,UL)):eW(t.idleTimeToLive).pipe(interruptible$3,lD(suspend$g(()=>"Acquired"===t.state._tag&&0===t.state.refCount?(t.state=die,scopeClose(r.scope,UL)):tD)),PQ(sync$l(()=>{r.fiber=void 0})),HY(t.scope),XR(e=>{r.fiber=e}),t.semaphore.withPermits(1)))))),qR(({state:e})=>e.value))},make$1l=e=>withFiberRuntime$1(t=>{const r=t.getFiberRef($D),n=jA(r,_Q),i=new RcRefImpl(e.acquire,r,n,e.idleTimeToLive?decode$5(e.idleTimeToLive):void 0);return TR(n.addFinalizer(()=>i.semaphore.withPermits(1)(suspend$g(()=>{const e="Acquired"===i.state._tag?scopeClose(i.state.scope,UL):tD;return i.state=mie,e}))),i)}),yie=get$w;var bie=Object.freeze({__proto__:null,TypeId:hie,get:yie,make:make$1l});const Sie=wX,vie=OX,_ie=xX,wie=kX,kie=EX,xie=AX,Iie=MX,Tie=CX,Oie=make$1u;var Eie=Object.freeze({__proto__:null,FiberFailureCauseId:TX,FiberFailureId:Symbol.for("effect/Runtime/FiberFailure"),defaultRuntime:Iie,defaultRuntimeFlags:Tie,deleteFiberRef:UX,disableRuntimeFlag:PX,enableRuntimeFlag:NX,isAsyncFiberException:e=>M(e,"AsyncFiberException")&&"fiber"in e,isFiberFailure:e=>C(e,IX),make:Oie,makeFiberFailure:fiberFailure,provideService:RX,runCallback:wie,runFork:Sie,runPromise:kie,runPromiseExit:xie,runSync:_ie,runSyncExit:vie,setFiberRef:LX,updateContext:jX,updateFiberRefs:DX,updateRuntimeFlags:FX});const Aie=driver$1,Cie=q6,spaced=e=>R2(q6,()=>e),Mie=P2;var Fie=Object.freeze({__proto__:null,CurrentIterationMetadata:Mie,ScheduleDriverTypeId:M2,ScheduleTypeId:C2,addDelay:R2,addDelayEffect:D2,andThen:L2,andThenEither:U2,as:$2,asVoid:asVoid$6,bothInOut:B2,check:z2,checkEffect:q2,collectAllInputs:()=>collectAllOutputs$1(identity$3()),collectAllOutputs:collectAllOutputs$1,collectUntil:e=>collectAllOutputs$1(recurUntil$1(e)),collectUntilEffect:e=>collectAllOutputs$1(recurUntilEffect$1(e)),collectWhile:e=>collectAllOutputs$1(recurWhile$1(e)),collectWhileEffect:e=>collectAllOutputs$1(recurWhileEffect$1(e)),compose:W2,count:B6,cron:(e,t)=>{const r=isCron(e)?Ge(e):parse(e,t);return makeWithState$1([!0,[Number.MIN_SAFE_INTEGER,0,0]],(e,t,[n,i])=>{if(e<i[0])return succeed$u([[!1,i],[i[1],i[2]],continueWith(hY(i[1],i[2]))]);if(Xe(r))return die$g(r.left);const s=r.right,o=new Date(e);let a;n&&match$n(s,o)&&(a=e),a=next$3(s,o).getTime();const start=beginningOfSecond(a),u=endOfSecond(a);return succeed$u([[!1,[a,start,u]],[start,u],continueWith(hY(start,u))])})},dayOfMonth:e=>makeWithState$1([-1/0,0],(t,r,n)=>{if(!Number.isInteger(e)||e<1||31<e)return dieSync$a(()=>new gL(`Invalid argument in: dayOfMonth(${e}). Must be in range 1...31`));const i=n[1],s=((e,t,r)=>{const n=new Date(e);return n.getDate()===t&&r?e:n.getDate()<t?n.setDate(t):findNextMonth(e,t,1)})(t,e,0===i),start=beginningOfDay(s),o=endOfDay(s),a=hY(start,o);return succeed$u([[o,i+1],i,continueWith(a)])}),dayOfWeek:e=>makeWithState$1([Number.MIN_SAFE_INTEGER,0],(t,r,n)=>{if(!Number.isInteger(e)||e<1||7<e)return dieSync$a(()=>new gL(`Invalid argument in: dayOfWeek(${e}). Must be in range 1 (Monday)...7 (Sunday)`));const i=n[1],s=((e,t,r)=>{const n=new Date(e);if(n.getDay()===t&&r)return e;const i=(7+t-n.getDay())%7;return n.setDate(n.getDate()+(0===i?7:i))})(t,e,0===i),start=beginningOfDay(s),o=endOfDay(s),a=hY(start,o);return succeed$u([[o,i+1],i,continueWith(a)])}),delayed:J2,delayedEffect:H2,delayedSchedule:delayedSchedule$1,delays:e=>makeWithState$1(e.initial,(t,r,n)=>pipe(e.step(t,r,n),PR(([e,r,n])=>isDone$3(n)?succeed$u([e,iM,n]):succeed$u([e,millis(EY(n.intervals)-t),n])))),driver:Aie,duration:duration$3,either:Y2,eitherWith:X2,elapsed:z6,ensuring:e6,exponential:(e,t=2)=>{const r=decode$5(e);return delayedSchedule$1(i6(q6,e=>bM(r,Math.pow(t,e))))},fibonacci:e=>{const t=decode$5(e);return delayedSchedule$1(pipe(unfold$3([t,t],([e,t])=>[t,vM(e,t)]),i6(e=>e[0])))},fixed:e=>{const t=decode$5(e),r=toMillis(t);return makeWithState$1([none$c(),0],(e,n,[i,s])=>sync$l(()=>{switch(i._tag){case"None":return[[Ut([e,e+r]),s+1],s,continueWith(after(e+r))];case"Some":{const[n,o]=i.value,a=e>o+r,u=equals$4(t,iM)?t:millis(r-(e-n)%r),c=equals$4(u,iM)?t:u,l=a?e:e+toMillis(c);return[[Ut([n,l]),s+1],s,continueWith(after(l))]}}}))},forever:Cie,fromDelay:e=>duration$3(e),fromDelays:(e,...t)=>makeWithState$1([[e,...t].map(e=>decode$5(e)),!0],(e,t,[r,n])=>sync$l(()=>{if(n){const t=r[0],n=after(e+toMillis(t));return r.length>=2?[[r.slice(1),!0],t,continueWith(n)]:[[[t,...r.slice(1)],!1],t,continueWith(n)]}return[[r,!1],iM,NY]})),fromFunction:e=>i6(identity$3(),e),hourOfDay:e=>makeWithState$1([-1/0,0],(t,r,n)=>{if(!Number.isInteger(e)||e<0||23<e)return dieSync$a(()=>new gL(`Invalid argument in: hourOfDay(${e}). Must be in range 0...23`));const i=n[1],s=((e,t,r)=>{const n=new Date(e);if(n.getHours()===t&&r)return e;if(n.getHours()<t)return n.setHours(t);const i=new Date(n.setHours(t));return i.setTime(i.getTime()+864e5)})(t,e,0===i),start=beginningOfHour(s),o=(e=>{const t=new Date(beginningOfHour(e));return t.setHours(t.getHours()+1)})(s),a=hY(start,o);return succeed$u([[o,i+1],i,continueWith(a)])}),identity:identity$3,intersect:t6,intersectWith:r6,isSchedule:isSchedule$1,jittered:e=>n6(e,{min:.8,max:1.2}),jitteredWith:n6,linear:e=>{const t=decode$5(e);return delayedSchedule$1(i6(q6,e=>bM(t,e+1)))},makeWithState:makeWithState$1,map:i6,mapBoth:Z2,mapBothEffect:Q2,mapEffect:s6,mapInput:V2,mapInputContext:K2,mapInputEffect:G2,minuteOfHour:e=>makeWithState$1([Number.MIN_SAFE_INTEGER,0],(t,r,n)=>{if(!Number.isInteger(e)||e<0||59<e)return dieSync$a(()=>new gL(`Invalid argument in: minuteOfHour(${e}). Must be in range 0...59`));const i=n[1],s=((e,t,r)=>{const n=new Date(e);if(n.getMinutes()===t&&r)return e;if(n.getMinutes()<t)return n.setMinutes(t);const i=new Date(n.setMinutes(t));return i.setTime(i.getTime()+36e5)})(t,e,0===i),start=beginningOfMinute(s),o=(e=>{const t=new Date(beginningOfMinute(e));return t.setMinutes(t.getMinutes()+1)})(s),a=hY(start,o);return succeed$u([[o,i+1],i,continueWith(a)])}),modifyDelay:o6,modifyDelayEffect:a6,onDecision:u6,once:W6,passthrough:passthrough$2,provideContext:c6,provideService:l6,recurUntil:recurUntil$1,recurUntilEffect:recurUntilEffect$1,recurUntilOption:e=>w6(i6(identity$3(),e),zt),recurUpTo:recurUpTo$1,recurWhile:recurWhile$1,recurWhileEffect:recurWhileEffect$1,recurs:recurs$1,reduce:p6,reduceEffect:f6,repeatForever:q6,repetitions:e=>p6(e,0,(e,t)=>e+1),resetAfter:h6,resetWhen:d6,run:m6,secondOfMinute:e=>makeWithState$1([-1/0,0],(t,r,n)=>{if(!Number.isInteger(e)||e<0||59<e)return dieSync$a(()=>new gL(`Invalid argument in: secondOfMinute(${e}). Must be in range 0...59`));const i=n[1],s=((e,t,r)=>{const n=new Date(e);if(n.getSeconds()===t&&r)return e;if(n.getSeconds()<t)return n.setSeconds(t);const i=new Date(n.setSeconds(t));return i.setTime(i.getTime()+6e4)})(t,e,0===i),start=beginningOfSecond(s),o=endOfSecond(s),a=hY(start,o);return succeed$u([[o,i+1],i,continueWith(a)])}),spaced,stop:V6,succeed:e=>i6(q6,()=>e),sync:e=>i6(q6,e),tapInput:g6,tapOutput:y6,unfold:unfold$3,union:b6,unionWith:S6,untilInput:v6,untilInputEffect:_6,untilOutput:w6,untilOutputEffect:k6,upTo:x6,whileInput:I6,whileInputEffect:T6,whileOutput:O6,whileOutputEffect:E6,windowed:e=>{const t=decode$5(e),r=toMillis(t);return makeWithState$1([none$c(),0],(e,t,[n,i])=>{switch(n._tag){case"None":return succeed$u([[Ut(e),i+1],i,continueWith(after(e+r))]);case"Some":return succeed$u([[Ut(n.value),i+1],i,continueWith(after(e+(r-(e-n.value)%r)))])}})},zipLeft:A6,zipRight:C6,zipWith:M6});const Pie="Left",Nie="Right",jie="Both",Rie="Either",Lie={_tag:Pie},Uie={_tag:Nie},$ie={_tag:jie},Bie={_tag:Rie},fromInput$2=e=>{switch(e){case"left":return Lie;case"right":return Uie;case"both":return $ie;case"either":return Bie;default:return e}},zie=$ie;var qie=Object.freeze({__proto__:null,Both:zie,Either:Bie,Left:Lie,Right:Uie,fromInput:fromInput$2,isBoth:e=>e._tag===jie,isEither:e=>e._tag===Rie,isLeft:e=>e._tag===Pie,isRight:e=>e._tag===Nie,match:dual(2,(e,t)=>{switch(e._tag){case Pie:return t.onLeft();case Nie:return t.onRight();case jie:return t.onBoth();case Rie:return t.onEither()}})});class Versioned{value;constructor(e){this.value=e}}const make$1j=(e,t)=>({ref:e,isNew:t,isChanged:!1,expected:e.versioned,newValue:e.versioned.value}),unsafeGet$5=e=>e.newValue,unsafeSet$3=(e,t)=>{e.isChanged=!0,e.newValue=t},commit$2=e=>{e.ref.versioned=new Versioned(e.newValue)},copy=e=>({ref:e.ref,isNew:e.isNew,isChanged:e.isChanged,expected:e.expected,newValue:e.newValue}),isInvalid=e=>e.ref.versioned!==e.expected,isChanged=e=>e.isChanged,Wie="Invalid",Vie="ReadWrite",commitJournal=e=>{for(const t of e)commit$2(t[1])},analyzeJournal=e=>{let t="ReadOnly";for(const[,r]of e)if(t=isInvalid(r)?Wie:isChanged(r)?Vie:t,t===Wie)return t;return t},Kie="WithSTMRuntime",Gie="OnFailure",Jie="OnRetry",Hie="OnSuccess",Zie="Provide",Qie="Sync",Yie="Succeed",Xie="Retry",ese="Fail",tse="Interrupt",rse="Fail",nse="Die",ise="Interrupt",sse="Succeed",ose="Retry",ase="Done",use="Suspend",cse="Done",lse="Interrupted",pse="Running",fse="effect/STM/State",hse=Symbol.for(fse),isSTMState=e=>C(e,hse),isRunning=e=>e._tag===pse,isDone$2=e=>e._tag===cse,done$7=e=>({[hse]:hse,_tag:cse,exit:e,[Z](){return pipe(hash$3(fse),combine$h(hash$3(cse)),combine$h(hash$3(e)),cached$2(this))},[Y]:t=>isSTMState(t)&&t._tag===cse&&equals$4(e,t.exit)}),dse=pipe(hash$3(fse),combine$h(hash$3(lse)),combine$h(hash$3("interrupted"))),mse={[hse]:hse,_tag:lse,[Z]:()=>dse,[Y]:e=>isSTMState(e)&&e._tag===lse},gse=pipe(hash$3(fse),combine$h(hash$3(pse)),combine$h(hash$3("running"))),yse={[hse]:hse,_tag:pse,[Z]:()=>gse,[Y]:e=>isSTMState(e)&&e._tag===pse},fromTExit=e=>{switch(e._tag){case rse:return done$7(TU(e.error));case nse:return done$7(IU(e.defect));case ise:return done$7(AU(e.fiberId));case sse:return done$7(NU(e.value));case ose:throw Error("BUG: STM.STMState.fromTExit - please report an issue at https://github.com/Effect-TS/effect/issues")}},bse="effect/TExit",Sse=Symbol.for(bse),vse={_A:e=>e,_E:e=>e},isExit=e=>C(e,Sse),fail$d=e=>({[Sse]:vse,_tag:rse,error:e,[Z](){return pipe(hash$3(bse),combine$h(hash$3(rse)),combine$h(hash$3(e)),cached$2(this))},[Y]:t=>isExit(t)&&t._tag===rse&&equals$4(e,t.error)}),die$7=e=>({[Sse]:vse,_tag:nse,defect:e,[Z](){return pipe(hash$3(bse),combine$h(hash$3(nse)),combine$h(hash$3(e)),cached$2(this))},[Y]:t=>isExit(t)&&t._tag===nse&&equals$4(e,t.defect)}),interrupt$2=e=>({[Sse]:vse,_tag:ise,fiberId:e,[Z](){return pipe(hash$3(bse),combine$h(hash$3(ise)),combine$h(hash$3(e)),cached$2(this))},[Y]:t=>isExit(t)&&t._tag===ise&&equals$4(e,t.fiberId)}),succeed$d=e=>({[Sse]:vse,_tag:sse,value:e,[Z](){return pipe(hash$3(bse),combine$h(hash$3(sse)),combine$h(hash$3(e)),cached$2(this))},[Y]:t=>isExit(t)&&t._tag===sse&&equals$4(e,t.value)}),_se=pipe(hash$3(bse),combine$h(hash$3(ose)),combine$h(hash$3("retry"))),wse={[Sse]:vse,_tag:ose,[Z]:()=>_se,[Y]:e=>isExit(e)&&e._tag===ose},suspend$9=e=>({_tag:use,journal:e}),kse={ref:0},xse=Symbol.for("effect/STM"),Ise={_R:e=>e,_E:e=>e,_A:e=>e};class STMPrimitive{effect_instruction_i0;_op=ce;effect_instruction_i1=void 0;effect_instruction_i2=void 0;[u4];[Ie];[kne];[zte];get[xse](){return Ise}constructor(e){this.effect_instruction_i0=e,this[u4]=Ee,this[Ie]=Ise,this[kne]=Ise,this[zte]=Ise}[Y](e){return this===e}[Z](){return cached$2(this,random$2(this))}[Symbol.iterator](){return new SingleShotGen(new YieldWrap(this))}commit(){return unsafeAtomically(this,o,o)}pipe(){return pipeArguments(this,arguments)}}const isSTM$1=e=>C(e,xse),commit$1=e=>unsafeAtomically(e,o,o),unsafeAtomically=(e,t,r)=>withFiberRuntime$1(n=>{const i=n.id(),s=n.getFiberRef(h9),o=n.getFiberRef(m9),a=n.getFiberRef(d9),u=tryCommitSync(i,e,s,o,a);switch(u._tag){case ase:return t(u.exit),u.exit;case use:{const n=(()=>{const e=kse.ref+1;return kse.ref=e,e})(),u={value:yse},c=j4(t=>tryCommitAsync(i,e,n,u,s,o,a,t));return T3(e=>pipe(e(c),t3(e=>{let n=u.value;return isRunning(n)&&(u.value=mse),n=u.value,isDone$2(n)?(t(n.exit),n.exit):(r(),$4(e))})))}}}),tryCommitSync=(e,t,r,n,i)=>{const s=new Map,o=new STMDriver(t,s,e,r).run(),a=analyzeJournal(s);if(a===Vie&&o._tag===sse)commitJournal(s);else if(a===Wie)throw Error("BUG: STM.TryCommit.tryCommitSync - please report an issue at https://github.com/Effect-TS/effect/issues");switch(o._tag){case sse:return completeTodos(NU(o.value),s,n,i);case rse:{const e=zQ(o.error);return completeTodos(OU(e),s,n,i)}case nse:{const e=qQ(o.defect);return completeTodos(OU(e),s,n,i)}case ise:{const t=WQ(e);return completeTodos(OU(t),s,n,i)}case ose:return suspend$9(s)}},tryCommitAsync=(e,t,r,n,i,s,o,a)=>{if(isRunning(n.value)){const u=((e,t,r,n,i,s)=>{const o=new Map,a=new STMDriver(t,o,e,n).run(),u=analyzeJournal(o);if(u===Vie)commitJournal(o);else if(u===Wie)throw Error("BUG: STM.TryCommit.tryCommit - please report an issue at https://github.com/Effect-TS/effect/issues");switch(a._tag){case sse:return r.value=fromTExit(a),completeTodos(NU(a.value),o,i,s);case rse:{r.value=fromTExit(a);const e=zQ(a.error);return completeTodos(OU(e),o,i,s)}case nse:{r.value=fromTExit(a);const e=qQ(a.defect);return completeTodos(OU(e),o,i,s)}case ise:{r.value=fromTExit(a);const t=WQ(e);return completeTodos(OU(t),o,i,s)}case ose:return suspend$9(o)}})(e,t,n,i,s,o);switch(u._tag){case ase:completeTryCommit(u.exit,a);break;case use:((e,t,r)=>{let n=!1;for(const[,i]of t)i.ref.todos.has(e)||(i.ref.todos.set(e,r),n=!0)})(r,u.journal,()=>tryCommitAsync(e,t,r,n,i,s,o,a))}}},completeTodos=(e,t,r,n)=>{const i=(e=>{const t=new Map;for(const[,r]of e){for(const e of r.ref.todos)t.set(e[0],e[1]);r.ref.todos=new Map}return t})(t);return i.size>0&&r.scheduleTask(()=>(e=>{const t=Array.from(e.entries()).sort((e,t)=>e[0]-t[0]);for(const[e,r]of t)r()})(i),n),(e=>({_tag:ase,exit:e}))(e)},completeTryCommit=(e,t)=>{t(e)},context$5=()=>effect((e,t,r)=>r),contextWithSTM$1=e=>Ase(context$5(),e);class STMDriver{self;journal;fiberId;contStack=[];env;constructor(e,t,r,n){this.self=e,this.journal=t,this.fiberId=r,this.env=n}getEnv(){return this.env}pushStack(e){this.contStack.push(e)}popStack(){return this.contStack.pop()}nextSuccess(){let e=this.popStack();for(;void 0!==e&&e.effect_instruction_i0!==Hie;)e=this.popStack();return e}nextFailure(){let e=this.popStack();for(;void 0!==e&&e.effect_instruction_i0!==Gie;)e=this.popStack();return e}nextRetry(){let e=this.popStack();for(;void 0!==e&&e.effect_instruction_i0!==Jie;)e=this.popStack();return e}run(){let e,t=this.self;for(;void 0===e&&void 0!==t;)try{const r=t;if(r)switch(r._op){case"Tag":t=effect((e,t,n)=>RA(n,r));break;case"Left":t=fail$c(r.left);break;case"None":t=fail$c(new rY);break;case"Right":t=succeed$c(r.right);break;case"Some":t=succeed$c(r.value);break;case"Commit":switch(r.effect_instruction_i0){case"Die":e=die$7(K(()=>r.effect_instruction_i1()));break;case ese:{const n=this.nextFailure();void 0===n?e=fail$d(K(()=>r.effect_instruction_i1())):t=K(()=>n.effect_instruction_i2(K(()=>r.effect_instruction_i1())));break}case Xie:{const r=this.nextRetry();void 0===r?e=wse:t=K(()=>r.effect_instruction_i2());break}case tse:e=interrupt$2(this.fiberId);break;case Kie:t=K(()=>r.effect_instruction_i1(this));break;case Hie:case Gie:case Jie:this.pushStack(r),t=r.effect_instruction_i1;break;case Zie:{const e=this.env;this.env=K(()=>r.effect_instruction_i2(e)),t=pipe(r.effect_instruction_i1,Ese(sync$9(()=>this.env=e)));break}case Yie:{const n=r.effect_instruction_i1,i=this.nextSuccess();void 0===i?e=succeed$d(n):t=K(()=>i.effect_instruction_i2(n));break}case Qie:{const n=K(()=>r.effect_instruction_i1()),i=this.nextSuccess();void 0===i?e=succeed$d(n):t=K(()=>i.effect_instruction_i2(n));break}}}}catch(e){t=die$6(e)}return e}}const Tse=dual(2,(e,t)=>{const r=new STMPrimitive(Gie);return r.effect_instruction_i1=e,r.effect_instruction_i2=t,r}),Ose=dual(2,(e,t)=>{const r=new STMPrimitive(Zie);return r.effect_instruction_i1=e,r.effect_instruction_i2=t,r}),die$6=e=>dieSync$4(()=>e),dieMessage$6=e=>dieSync$4(()=>new nY(e)),dieSync$4=e=>{const t=new STMPrimitive("Die");return t.effect_instruction_i1=e,t},effect=e=>withSTMRuntime(t=>succeed$c(e(t.journal,t.fiberId,t.getEnv()))),Ese=dual(2,(e,t)=>Cse(e,{onFailure:e=>Dse(t,fail$c(e)),onSuccess:e=>Dse(t,succeed$c(e))})),fail$c=e=>failSync$5(()=>e),failSync$5=e=>{const t=new STMPrimitive(ese);return t.effect_instruction_i1=e,t},Ase=dual(2,(e,t)=>{const r=new STMPrimitive(Hie);return r.effect_instruction_i1=e,r.effect_instruction_i2=t,r}),Cse=dual(2,(e,{onFailure:t,onSuccess:r})=>pipe(e,Fse(Ge),Tse(e=>pipe(t(e),Fse(He))),Ase(e=>{switch(e._tag){case"Left":return succeed$c(e.left);case"Right":return r(e.right)}}))),withSTMRuntime=e=>{const t=new STMPrimitive(Kie);return t.effect_instruction_i1=e,t},Mse=withSTMRuntime(e=>{const t=new STMPrimitive(tse);return t.effect_instruction_i1=e.fiberId,t}),interruptAs$1=e=>{const t=new STMPrimitive(tse);return t.effect_instruction_i1=e,t},Fse=dual(2,(e,t)=>pipe(e,Ase(e=>sync$9(()=>t(e))))),Pse=dual(2,(e,t)=>{const r=new STMPrimitive(Jie);return r.effect_instruction_i1=e,r.effect_instruction_i2=t,r}),Nse=new STMPrimitive(Xie),succeed$c=e=>{const t=new STMPrimitive(Yie);return t.effect_instruction_i1=e,t},sync$9=e=>{const t=new STMPrimitive(Qie);return t.effect_instruction_i1=e,t},jse=dual(2,(e,t)=>pipe(e,Lse(t,(e,t)=>[e,t]))),Rse=dual(2,(e,t)=>pipe(e,Ase(e=>pipe(t,Fse(()=>e))))),Dse=dual(2,(e,t)=>pipe(e,Ase(()=>t))),Lse=dual(3,(e,t,r)=>pipe(e,Ase(e=>pipe(t,Fse(t=>r(e,t)))))),Use="BackPressure",$se="Dropping",Bse="Sliding",zse=dual(3,(e,t,r)=>T3(n=>{let i=yse;return pipe(n(unsafeAtomically(e,e=>{i=done$7(e)},()=>{i=mse})),W7({onFailure:e=>isDone$2(i)&&kU(i.exit)?pipe(r(i.exit.value),W7({onFailure:t=>$4(VQ(e,t)),onSuccess:()=>$4(e)})):$4(e),onSuccess:e=>pipe(n(t(e)),W7({onFailure:t=>pipe(r(e),W7({onFailure:e=>$4(VQ(t,e)),onSuccess:()=>$4(t)})),onSuccess:t=>pipe(r(e),E3(t))}))}))})),qse=dual(2,(e,t)=>pipe(e,Fse(()=>t))),asSome$1=e=>pipe(e,Fse(Ut)),asVoid$2=e=>pipe(e,Fse(o)),attempt$1=e=>suspend$8(()=>{try{return succeed$c(e())}catch(e){return fail$c(e)}}),Wse=dual(3,(e,t,r)=>Ase(e,e=>Fse(r(e),r=>({...e,[t]:r})))),Vse=dual(2,(e,t)=>Fse(e,e=>({[t]:e}))),Kse=dual(3,(e,t,r)=>Fse(e,e=>({...e,[t]:r(e)}))),Gse=dual(2,(e,t)=>Tse(e,e=>Kt(t(e),()=>fail$c(e)))),Jse=dual(3,(e,t,r)=>Tse(e,e=>"_tag"in e&&e._tag===t?r(e):fail$c(e))),Hse=dual(2,(e,t)=>Tse(e,e=>"_tag"in e&&Object.keys(t).includes(e._tag)?t[e._tag](e):fail$c(e))),Zse=dual(2,(e,t)=>Qse(e,e=>er(t(e),succeed$c))),Qse=dual(2,(e,t)=>Cse(e,{onFailure:fail$c,onSuccess:e=>{const r=t(e);return zt(r)?r.value:Nse}})),either$5=e=>uoe(e,{onFailure:He,onSuccess:Ge}),eventually$1=e=>Cse(e,{onFailure:()=>eventually$1(e),onSuccess:succeed$c}),Yse=dual(2,(e,t)=>Ase(sync$9(()=>e[Symbol.iterator]()),e=>{const r=suspend$8(()=>{const n=e.next();return n.done?succeed$c(!0):pipe(t(n.value),Ase(e=>e?r:succeed$c(e)))});return r})),Xse=dual(2,(e,t)=>Ase(sync$9(()=>e[Symbol.iterator]()),e=>{const r=suspend$8(()=>{const n=e.next();return n.done?succeed$c(!1):Ase(t(n.value),e=>e?succeed$c(e):r)});return r})),eoe=effect((e,t)=>t),toe=dual(2,(e,t)=>Array.from(e).reduce((e,r)=>pipe(e,Lse(t(r),(e,t)=>t?(e.push(r),e):e)),succeed$c([]))),roe=dual(2,(e,t)=>toe(e,e=>negate$1(t(e)))),noe=dual(3,(e,t,r)=>soe(e,t,()=>dieSync$4(r))),ioe=dual(3,(e,t,r)=>soe(e,t,()=>dieMessage$6(r))),soe=dual(3,(e,t,r)=>Ase(e,e=>t(e)?succeed$c(e):r(e))),ooe=dual(3,(e,t,r)=>soe(e,t,e=>failSync$5(()=>r(e)))),flatten$4=e=>Ase(e,identity$5),flip$1=e=>Cse(e,{onFailure:succeed$c,onSuccess:fail$c}),aoe=dual(2,(e,t)=>flip$1(t(flip$1(e)))),uoe=dual(2,(e,{onFailure:t,onSuccess:r})=>Cse(e,{onFailure:e=>succeed$c(t(e)),onSuccess:e=>succeed$c(r(e))})),coe=dual(e=>isIterable(e[0]),(e,t,r)=>r?.discard?pipe(sync$9(()=>e[Symbol.iterator]()),Ase(e=>{const r=suspend$8(()=>{const n=e.next();return n.done?Voe:pipe(t(n.value),Ase(()=>r))});return r})):suspend$8(()=>fromIterable$v(e).reduce((e,r)=>Lse(e,t(r),(e,t)=>(e.push(t),e)),succeed$c([])))),fromEither$2=e=>{switch(e._tag){case"Left":return fail$c(e.left);case"Right":return succeed$c(e.right)}},loe=dual(e=>"boolean"==typeof e[0]||isSTM$1(e[0]),(e,{onFalse:t,onTrue:r})=>"boolean"==typeof e?e?r:t:Ase(e,e=>e?r:t)),iterate$3=(e,t)=>iterateLoop(e,t.while,t.body),iterateLoop=(e,t,r)=>t(e)?pipe(r(e),Ase(e=>iterateLoop(e,t,r))):succeed$c(e),loopLoop=(e,t,r,n)=>t(e)?pipe(n(e),Ase(i=>pipe(loopLoop(r(e),t,r,n),Fse(GA(i))))):succeed$c(empty$R()),loopDiscardLoop=(e,t,r,n)=>t(e)?pipe(n(e),Ase(()=>loopDiscardLoop(r(e),t,r,n))):Voe,poe=dual(2,(e,t)=>Cse(e,{onFailure:e=>fail$c(e),onSuccess:e=>attempt$1(()=>t(e))})),foe=dual(2,(e,{onFailure:t,onSuccess:r})=>Cse(e,{onFailure:e=>fail$c(t(e)),onSuccess:e=>succeed$c(r(e))})),hoe=dual(2,(e,t)=>Cse(e,{onFailure:e=>fail$c(t(e)),onSuccess:succeed$c})),doe=dual(3,(e,t,r)=>suspend$8(()=>Array.from(e).reduce((e,t)=>pipe(e,Lse(t,r)),succeed$c(t)))),negate$1=e=>pipe(e,Fse(e=>!e)),moe=dual(2,(e,t)=>pipe(e,hoe(t),Tse(die$6))),goe=dual(2,(e,t)=>Ase(effect(e=>(e=>{const t=new Map;for(const r of e)t.set(r[0],copy(r[1]));return()=>{e.clear();for(const r of t)e.set(r[0],r[1])}})(e)),r=>pipe(Pse(e,()=>Ase(sync$9(r),t)),Tse(()=>Ase(sync$9(r),t))))),yoe=dual(2,(e,t)=>goe(Fse(e,He),()=>Fse(t(),Ge))),boe=dual(2,(e,t)=>goe(e,()=>failSync$5(t))),Soe=dual(2,(e,t)=>Tse(e,qt({onNone:t,onSome:e=>fail$c(Ut(e))}))),voe=dual(2,(e,t)=>goe(e,()=>sync$9(t))),_oe=dual(2,(e,t)=>Ose(e,e=>t)),woe=dual(2,(e,t)=>Ose(e,e=>LA(e,t))),koe=dual(3,(e,t,r)=>xoe(e,t,succeed$c(r))),xoe=dual(3,(e,t,r)=>contextWithSTM$1(n=>Ase(r,r=>_oe(e,NA(n,t,r))))),Ioe=dual(3,(e,t,r)=>suspend$8(()=>Array.from(e).reduce((e,t)=>pipe(e,Ase(e=>r(e,t))),succeed$c(t)))),Toe=dual(3,(e,t,r)=>suspend$8(()=>Array.from(e).reduce((e,t)=>pipe(e,Lse(t,r)),t))),Ooe=dual(3,(e,t,r)=>suspend$8(()=>Array.from(e).reduceRight((e,t)=>pipe(e,Ase(e=>r(e,t))),succeed$c(t)))),Eoe=dual(2,(e,t)=>Aoe(e,t,identity$5)),Aoe=dual(3,(e,t,r)=>Tse(e,e=>qt(t(e),{onNone:()=>die$6(r(e)),onSome:fail$c}))),Coe=dual(2,(e,t)=>Moe(e,e=>er(t(e),fail$c))),Moe=dual(2,(e,t)=>Ase(e,e=>qt(t(e),{onNone:()=>succeed$c(e),onSome:Ase(fail$c)}))),Foe=dual(2,(e,t)=>repeatUntilLoop(e,t)),repeatUntilLoop=(e,t)=>Ase(e,r=>t(r)?succeed$c(r):repeatUntilLoop(e,t)),Poe=dual(2,(e,t)=>repeatWhileLoop(e,t)),repeatWhileLoop=(e,t)=>Ase(e,r=>t(r)?repeatWhileLoop(e,t):succeed$c(r)),Noe=dual(2,(e,t)=>Array.from({length:t},()=>e)),joe=dual(2,(e,t)=>all$3(Noe(e,t))),Roe=dual(2,(e,t)=>all$3(Noe(e,t),{discard:!0})),Doe=dual(2,(e,t)=>Cse(e,{onFailure:fail$c,onSuccess:e=>t(e)?succeed$c(e):Nse})),Loe=dual(2,(e,t)=>Cse(e,{onFailure:fail$c,onSuccess:e=>t(e)?Nse:succeed$c(e)})),Uoe=dual(2,(e,t)=>pipe(coe(e,e=>either$5(t(e))),Fse(e=>QR(e,identity$5)))),all$3=(e,t)=>Symbol.iterator in e?coe(e,identity$5,t):t?.discard?coe(Object.values(e),identity$5,t):Fse(coe(Object.entries(e),([e,t])=>Fse(t,t=>[e,t])),e=>{const t={};for(const[r,n]of e)t[r]=n;return t}),$oe=succeed$c(none$c()),succeedSome$1=e=>succeed$c(Ut(e)),Boe=dual(3,(e,t,r)=>Ase(t,start=>Ase(e,e=>Fse(t,t=>[r(start,t),e])))),suspend$8=e=>flatten$4(sync$9(e)),zoe=dual(2,(e,t)=>Ase(e,e=>qse(t(e),e))),qoe=dual(2,(e,{onFailure:t,onSuccess:r})=>Cse(e,{onFailure:e=>pipe(t(e),Dse(fail$c(e))),onSuccess:e=>pipe(r(e),qse(e))})),Woe=dual(2,(e,t)=>Cse(e,{onFailure:e=>Dse(t(e),fail$c(e)),onSuccess:succeed$c})),Voe=succeed$c(void 0),Koe=dual(2,(e,t)=>suspend$8(()=>t()?$oe:asSome$1(e))),Goe=dual(2,(e,t)=>Ase(t,t=>t?$oe:asSome$1(e))),Joe=dual(2,(e,t)=>Ase(Uoe(e,t),([e,t])=>ui(e)?fail$c(e):succeed$c(t))),Hoe=dual(2,(e,t)=>flip$1(coe(e,e=>flip$1(t(e))))),Zoe=dual(2,(e,t)=>suspend$8(()=>t()?asSome$1(e):$oe)),Qoe=dual(2,(e,t)=>Ase(t,t=>t?asSome$1(e):$oe)),Yoe=Symbol.for("effect/TRef"),Xoe={_A:e=>e};class TRefImpl{[Yoe]=Xoe;todos;versioned;constructor(e){this.versioned=new Versioned(e),this.todos=new Map}modify(e){return effect(t=>{const r=getOrMakeEntry(this,t),[n,i]=e(unsafeGet$5(r));return unsafeSet$3(r,i),n})}pipe(){return pipeArguments(this,arguments)}}const make$1h=e=>effect(t=>{const r=new TRefImpl(e);return t.set(r,make$1j(r,!0)),r}),get$u=e=>e.modify(e=>[e,e]),eae=dual(2,(e,t)=>e.modify(()=>[void 0,t])),tae=dual(2,(e,t)=>e.modify(e=>[e,t])),rae=dual(2,(e,t)=>e.modify(e=>[e,t(e)])),nae=dual(2,(e,t)=>e.modify(e=>qt(t(e),{onNone:()=>[e,e],onSome:t=>[e,t]}))),iae=dual(2,(e,t)=>e.modify(()=>[t,t])),sae=dual(2,(e,t)=>e.modify(t)),oae=dual(3,(e,t,r)=>e.modify(e=>qt(r(e),{onNone:()=>[t,e],onSome:e=>e}))),aae=dual(2,(e,t)=>e.modify(e=>[void 0,t(e)])),uae=dual(2,(e,t)=>e.modify(e=>{const r=t(e);return[r,r]})),cae=dual(2,(e,t)=>e.modify(e=>[void 0,qt(t(e),{onNone:()=>e,onSome:e=>e})])),lae=dual(2,(e,t)=>e.modify(e=>qt(t(e),{onNone:()=>[e,e],onSome:e=>[e,e]}))),getOrMakeEntry=(e,t)=>{if(t.has(e))return t.get(e);const r=make$1j(e,!1);return t.set(e,r),r},pae=dual(2,(e,t)=>unsafeGet$5(getOrMakeEntry(e,t))),fae=dual(3,(e,t,r)=>{const n=getOrMakeEntry(e,r);unsafeSet$3(n,t)}),hae=Symbol.for("effect/TQueue/TEnqueue"),dae=Symbol.for("effect/TQueue/TDequeue"),mae={_tag:Use},gae={_tag:$se},yae={_tag:Bse},bae={_Out:e=>e},Sae={_In:e=>e};class TQueueImpl{ref;requestedCapacity;strategy;[dae]=bae;[hae]=Sae;constructor(e,t,r){this.ref=e,this.requestedCapacity=t,this.strategy=r}capacity(){return this.requestedCapacity}size=withSTMRuntime(e=>{const t=pae(this.ref,e.journal);return void 0===t?interruptAs$1(e.fiberId):succeed$c(t.length)});isFull=Fse(this.size,e=>e===this.requestedCapacity);isEmpty=Fse(this.size,e=>0===e);shutdown=withSTMRuntime(e=>(fae(this.ref,void 0,e.journal),Voe));isShutdown=effect(e=>void 0===pae(this.ref,e));awaitShutdown=Ase(this.isShutdown,e=>e?Voe:Nse);offer(e){return withSTMRuntime(t=>{const r=pipe(this.ref,pae(t.journal));if(void 0===r)return interruptAs$1(t.fiberId);if(r.length<this.requestedCapacity)return r.push(e),fae(this.ref,r,t.journal),succeed$c(!0);switch(this.strategy._tag){case Use:return Nse;case $se:return succeed$c(!1);case Bse:return 0===r.length||(r.shift(),r.push(e),fae(this.ref,r,t.journal)),succeed$c(!0)}})}offerAll(e){return withSTMRuntime(t=>{const r=Array.from(e),n=pae(this.ref,t.journal);if(void 0===n)return interruptAs$1(t.fiberId);if(n.length+r.length<=this.requestedCapacity)return fae(this.ref,[...n,...r],t.journal),succeed$c(!0);switch(this.strategy._tag){case Use:return Nse;case $se:{const e=r.slice(0,this.requestedCapacity-n.length);return fae(this.ref,[...n,...e],t.journal),succeed$c(!1)}case Bse:{const e=r.slice(0,this.requestedCapacity-n.length),i=n.length+e.length-this.requestedCapacity,s=n.slice(i);return fae(this.ref,[...s,...e],t.journal),succeed$c(!0)}}})}peek=withSTMRuntime(e=>{const t=pae(this.ref,e.journal);return void 0===t?interruptAs$1(e.fiberId):0===t.length?Nse:succeed$c(t[0])});peekOption=withSTMRuntime(e=>{const t=pae(this.ref,e.journal);return void 0===t?interruptAs$1(e.fiberId):succeed$c(fromNullable$3(t[0]))});take=withSTMRuntime(e=>{const t=pae(this.ref,e.journal);if(void 0===t)return interruptAs$1(e.fiberId);if(0===t.length)return Nse;const r=t.shift();return fae(this.ref,t,e.journal),succeed$c(r)});takeAll=withSTMRuntime(e=>{const t=pae(this.ref,e.journal);return void 0===t?interruptAs$1(e.fiberId):(fae(this.ref,[],e.journal),succeed$c(t))});takeUpTo(e){return withSTMRuntime(t=>{const r=pae(this.ref,t.journal);if(void 0===r)return interruptAs$1(t.fiberId);const[n,i]=bC(unsafeFromArray(r),e);return fae(this.ref,Array.from(i),t.journal),succeed$c(Array.from(n))})}}const isTEnqueue$1=e=>C(e,hae),isTDequeue$1=e=>C(e,dae),vae=dual(2,(e,t)=>e.offer(t)),_ae=dual(2,(e,t)=>e.offerAll(t)),wae=dual(2,(e,t)=>seekLoop(e,t)),seekLoop=(e,t)=>Ase(e.take,r=>t(r)?succeed$c(r):seekLoop(e,t)),shutdown$3=e=>e.shutdown,kae=dual(3,(e,t,r)=>suspend$8(()=>{const takeRemainder=(t,r,n)=>r<t?succeed$c(n):pipe(e.takeUpTo(r),Ase(i=>{const s=t-i.length;return 1===s?pipe(e.take,Fse(e=>pipe(n,eC(unsafeFromArray(i)),GA(e)))):s>1?pipe(e.take,Ase(e=>takeRemainder(s-1,r-i.length-1,pipe(n,eC(unsafeFromArray(i)),GA(e))))):succeed$c(pipe(n,eC(unsafeFromArray(i))))}));return Fse(takeRemainder(t,r,empty$R()),e=>Array.from(e))})),xae=dual(2,(e,t)=>pipe(e,kae(t,t))),Iae=dual(2,(e,t)=>e.takeUpTo(t)),makeQueue=(e,t)=>Fse(make$1h([]),r=>new TQueueImpl(r,e,t)),Tae=Symbol.for("effect/TPubSub"),Oae=Symbol.for("effect/TPubSub/AbsentValue"),makeNode=(e,t,r)=>({head:e,subscribers:t,tail:r});class TPubSubImpl{pubsubSize;publisherHead;publisherTail;requestedCapacity;strategy;subscriberCount;subscribers;[Tae]={_A:e=>e};[hae]=Sae;constructor(e,t,r,n,i,s,o){this.pubsubSize=e,this.publisherHead=t,this.publisherTail=r,this.requestedCapacity=n,this.strategy=i,this.subscriberCount=s,this.subscribers=o}isShutdown=effect(e=>void 0===pae(this.publisherTail,e));awaitShutdown=Ase(this.isShutdown,e=>e?Voe:Nse);capacity(){return this.requestedCapacity}size=withSTMRuntime(e=>void 0===pae(this.publisherTail,e.journal)?interruptAs$1(e.fiberId):succeed$c(pae(this.pubsubSize,e.journal)));isEmpty=Fse(this.size,e=>0===e);isFull=Fse(this.size,e=>e===this.capacity());offer(e){return withSTMRuntime(t=>{const r=pae(this.publisherTail,t.journal);if(void 0===r)return interruptAs$1(t.fiberId);const n=pae(this.subscriberCount,t.journal);if(0===n)return succeed$c(!0);const i=pae(this.pubsubSize,t.journal);if(i<this.requestedCapacity){const s=new TRefImpl(void 0),o=makeNode(e,n,s);return fae(r,o,t.journal),fae(this.publisherTail,s,t.journal),fae(this.pubsubSize,i+1,t.journal),succeed$c(!0)}switch(this.strategy._tag){case Use:return Nse;case $se:return succeed$c(!1);case Bse:{if(this.requestedCapacity>0){let e=pae(this.publisherHead,t.journal),r=!0;for(;r;){const n=pae(e,t.journal);if(void 0===n)return Nse;const i=n.head,s=n.tail;if(i!==Oae){const i=makeNode(Oae,n.subscribers,n.tail);fae(e,i,t.journal),fae(this.publisherHead,s,t.journal),r=!1}else e=s}}const i=new TRefImpl(void 0),s=makeNode(e,n,i);return fae(r,s,t.journal),fae(this.publisherTail,i,t.journal),succeed$c(!0)}}})}offerAll(e){return Fse(coe(e,e=>this.offer(e)),vs(identity$5))}shutdown=effect(e=>{if(void 0!==pae(this.publisherTail,e)){fae(this.publisherTail,void 0,e);const t=pae(this.subscribers,e);jF(t,t=>{fae(t,void 0,e)}),fae(this.subscribers,IF(),e)}})}class TPubSubSubscriptionImpl{pubsubSize;publisherHead;requestedCapacity;subscriberHead;subscriberCount;subscribers;[Tae]=Tae;[dae]=bae;constructor(e,t,r,n,i,s){this.pubsubSize=e,this.publisherHead=t,this.requestedCapacity=r,this.subscriberHead=n,this.subscriberCount=i,this.subscribers=s}isShutdown=effect(e=>void 0===pae(this.subscriberHead,e));awaitShutdown=Ase(this.isShutdown,e=>e?Voe:Nse);capacity(){return this.requestedCapacity}size=withSTMRuntime(e=>{let t=pae(this.subscriberHead,e.journal);if(void 0===t)return interruptAs$1(e.fiberId);let r=!0,n=0;for(;r;){const i=pae(t,e.journal);if(void 0===i)r=!1;else{const e=i.head,s=i.tail;e!==Oae&&(n+=1,n>=Number.MAX_SAFE_INTEGER&&(r=!1)),t=s}}return succeed$c(n)});isEmpty=Fse(this.size,e=>0===e);isFull=Fse(this.size,e=>e===this.capacity());peek=withSTMRuntime(e=>{let t=pae(this.subscriberHead,e.journal);if(void 0===t)return interruptAs$1(e.fiberId);let r=Oae,n=!0;for(;n;){const i=pae(t,e.journal);if(void 0===i)return Nse;const s=i.head,o=i.tail;s!==Oae?(r=s,n=!1):t=o}return succeed$c(r)});peekOption=withSTMRuntime(e=>{let t=pae(this.subscriberHead,e.journal);if(void 0===t)return interruptAs$1(e.fiberId);let r=none$c(),n=!0;for(;n;){const i=pae(t,e.journal);if(void 0===i)r=none$c(),n=!1;else{const e=i.head,s=i.tail;e!==Oae?(r=Ut(e),n=!1):t=s}}return succeed$c(r)});shutdown=effect(e=>{let t=pae(this.subscriberHead,e);if(void 0!==t){fae(this.subscriberHead,void 0,e);let r=!0;for(;r;){const n=pae(t,e);if(void 0===n)r=!1;else{const r=n.head,i=n.tail;if(r!==Oae){const s=n.subscribers;if(1===s){const r=pae(this.pubsubSize,e),n=makeNode(Oae,0,i);fae(t,n,e),fae(this.publisherHead,i,e),fae(this.pubsubSize,r-1,e)}else{const n=makeNode(r,s-1,i);fae(t,n,e)}}t=i}}const n=pae(this.subscriberCount,e);fae(this.subscriberCount,n-1,e),fae(this.subscribers,CF(pae(this.subscribers,e),this.subscriberHead),e)}});take=withSTMRuntime(e=>{let t=pae(this.subscriberHead,e.journal);if(void 0===t)return interruptAs$1(e.fiberId);let r=Oae,n=!0;for(;n;){const i=pae(t,e.journal);if(void 0===i)return Nse;const s=i.head,o=i.tail;if(s!==Oae){const a=i.subscribers;if(1===a){const r=pae(this.pubsubSize,e.journal),n=makeNode(Oae,0,o);fae(t,n,e.journal),fae(this.publisherHead,o,e.journal),fae(this.pubsubSize,r-1,e.journal)}else{const r=makeNode(s,a-1,o);fae(t,r,e.journal)}fae(this.subscriberHead,o,e.journal),r=s,n=!1}else t=o}return succeed$c(r)});takeAll=this.takeUpTo(1/0);takeUpTo(e){return withSTMRuntime(t=>{let r=pae(this.subscriberHead,t.journal);if(void 0===r)return interruptAs$1(t.fiberId);const n=[];let i=0;for(;i!==e;){const s=pae(r,t.journal);if(void 0===s)i=e;else{const e=s.head,o=s.tail;if(e!==Oae){const a=s.subscribers;if(1===a){const e=pae(this.pubsubSize,t.journal),n=makeNode(Oae,0,o);fae(r,n,t.journal),fae(this.publisherHead,o,t.journal),fae(this.pubsubSize,e-1,t.journal)}else{const n=makeNode(e,a-1,o);fae(r,n,t.journal)}n.push(e),i+=1}r=o}}return fae(this.subscriberHead,r,t.journal),succeed$c(n)})}}const makeTPubSub=(e,t)=>pipe(all$3([make$1h(void 0),make$1h(0)]),Ase(([r,n])=>pipe(all$3([make$1h(r),make$1h(r),make$1h(0),make$1h(IF())]),Fse(([r,i,s,o])=>new TPubSubImpl(n,r,i,e,t,s,o))))),subscribe$1=e=>{return t=e.pubsubSize,r=e.publisherHead,n=e.publisherTail,i=e.requestedCapacity,s=e.subscriberCount,o=e.subscribers,pipe(get$u(n),Ase(e=>pipe(all$3([make$1h(e),get$u(s),get$u(o)]),zoe(([e,t])=>pipe(s,eae(t+1))),zoe(([e,t,r])=>pipe(o,eae(pipe(r,AF(e))))),Fse(([e])=>new TPubSubSubscriptionImpl(t,r,i,e,s,o)))));var t,r,n,i,s,o},Eae=dual(2,(e,t)=>e.offer(t)),Aae=subscribe$1,subscribeScoped=e=>U3(subscribe$1(e),e=>shutdown$3(e)),unbounded$1=()=>makeTPubSub(Number.MAX_SAFE_INTEGER,gae);var Cae=Object.freeze({__proto__:null,TPubSubTypeId:Tae,awaitShutdown:e=>e.awaitShutdown,bounded:e=>makeTPubSub(e,mae),capacity:e=>e.capacity(),dropping:e=>makeTPubSub(e,gae),isEmpty:e=>e.isEmpty,isFull:e=>e.isFull,isShutdown:e=>e.isShutdown,publish:Eae,publishAll:dual(2,(e,t)=>e.offerAll(t)),shutdown:e=>e.shutdown,size:e=>e.size,sliding:e=>makeTPubSub(e,yae),subscribe:Aae,subscribeScoped,unbounded:unbounded$1});const Mae=dae,isShutdown=e=>e.isShutdown,Fae=vae,Pae=shutdown$3,take$6=e=>e.take,unbounded=()=>makeQueue(Number.MAX_SAFE_INTEGER,gae);var Nae=Object.freeze({__proto__:null,TDequeueTypeId:Mae,TEnqueueTypeId:hae,awaitShutdown:e=>e.awaitShutdown,bounded:e=>makeQueue(e,mae),capacity:e=>e.capacity(),dropping:e=>makeQueue(e,gae),isEmpty:e=>e.isEmpty,isFull:e=>e.isFull,isShutdown,isTDequeue:isTDequeue$1,isTEnqueue:isTEnqueue$1,isTQueue:e=>isTEnqueue$1(e)&&isTDequeue$1(e),offer:Fae,offerAll:_ae,peek:e=>e.peek,peekOption:e=>e.peekOption,poll:e=>pipe(e.takeUpTo(1),Fse(fi)),seek:wae,shutdown:Pae,size:e=>e.size,sliding:e=>makeQueue(e,yae),take:take$6,takeAll:e=>e.takeAll,takeBetween:kae,takeN:xae,takeUpTo:Iae,unbounded});class RingBuffer{capacity;array;size=0;current=0;constructor(e){this.capacity=e,this.array=Array.from({length:e},s)}head(){return fromNullable$3(this.array[this.current])}lastOrNull(){if(0===this.size)return;const e=0===this.current?this.array.length-1:this.current-1;return this.array[e]??void 0}put(e){this.array[this.current]=e,this.increment()}dropLast(){this.size>0&&(this.decrement(),this.array[this.current]=void 0)}toChunk(){const e=this.current-this.size,t=e<0?[...this.array.slice(this.capacity+e,this.capacity),...this.array.slice(0,this.current)]:this.array.slice(e,this.current);return fromIterable$u(t)}increment(){this.size<this.capacity&&(this.size+=1),this.current=(this.current+1)%this.capacity}decrement(){this.size-=1,this.current>0?this.current-=1:this.current=this.capacity-1}}const jae="NotStarted",Rae="Previous",Dae="Current",Lae={_tag:jae},make$1g=e=>{const t={chunk(e){return this(G4(e))},die(e){return this(z4(e))},dieMessage(e){return this(q4(e))},done(e){return this(H4(()=>MU(e,{onFailure:Ut,onSuccess:of$5})))},end(){return this(L4(none$c()))},fail(e){return this(L4(Ut(e)))},fromEffect(e){return this(j3(e,{onFailure:Ut,onSuccess:of$5}))},fromEffectChunk(e){return this(pipe(e,R3(Ut)))},halt(e){return this($4(pipe(e,XQ(Ut))))},single(e){return this(G4(of$5(e)))}};return Object.assign(e,t)},Uae=Symbol.for("effect/Stream/Handoff"),$ae="Empty",Bae="Full",handoffStateEmpty=e=>({_tag:$ae,notifyConsumer:e}),handoffStateFull=(e,t)=>({_tag:Bae,value:e,notifyProducer:t}),handoffStateMatch=(e,t)=>r=>{switch(r._tag){case $ae:return e(r.notifyConsumer);case Bae:return t(r.value,r.notifyProducer)}},zae={_A:e=>e},make$1f=()=>pipe(fU(),h7(e=>Nz(handoffStateEmpty(e))),P3(e=>({[Uae]:zae,ref:e}))),qae=dual(2,(e,t)=>h7(fU(),r=>m7(Uz(e.ref,n=>pipe(n,handoffStateMatch(e=>[j8(yU(e,void 0),hU(r)),handoffStateFull(t,r)],(r,i)=>[h7(hU(i),()=>pipe(e,qae(t))),n])))))),take$5=e=>h7(fU(),t=>m7(Uz(e.ref,r=>pipe(r,handoffStateMatch(t=>[h7(hU(t),()=>take$5(e)),r],(e,r)=>[E3(yU(r,void 0),e),handoffStateEmpty(t)]))))),Wae="Emit",Vae="Halt",Kae="End",emit=e=>({_tag:Wae,elements:e}),halt=e=>({_tag:Vae,cause:e}),end$3=e=>({_tag:Kae,reason:e}),Gae=Symbol.for("effect/Take"),Jae={_A:e=>e,_E:e=>e};class TakeImpl{exit;[Gae]=Jae;constructor(e){this.exit=e}pipe(){return pipeArguments(this,arguments)}}const chunk$3=e=>new TakeImpl(NU(e)),done$5=e=>H4(()=>e.exit),Hae=new TakeImpl(TU(none$c())),failCause$6=e=>new TakeImpl(OU(pipe(e,XQ(Ut)))),fromPull$3=e=>q7(e,{onFailure:e=>qt(flipCauseOption(e),{onNone:()=>Hae,onSome:failCause$6}),onSuccess:chunk$3}),Zae=dual(2,(e,{onEnd:t,onFailure:r,onSuccess:n})=>FU(e.exit,{onFailure:e=>qt(flipCauseOption(e),{onNone:t,onSome:r}),onSuccess:n})),Qae=dual(2,(e,{onEnd:t,onFailure:r,onSuccess:n})=>PU(e.exit,{onFailure:e=>qt(flipCauseOption(e),{onNone:()=>t,onSome:r}),onSuccess:n})),Yae=dual(2,(e,t)=>new TakeImpl(pipe(e.exit,CU(fC(t))))),of$1=e=>new TakeImpl(NU(of$5(e))),Xae=dual(2,(e,t)=>pipe(e.exit,EU(t),C3)),end$1=()=>L4(none$c()),failCause$5=e=>R3($4(e),Ut),eue="ScheduleEnd",tue="UpstreamEnd",rue={_tag:eue},nue={_tag:tue},iue="DrainLeft",sue="DrainRight",oue="PullBoth",aue="PullLeft",uue="PullRight",cue={_tag:iue},lue={_tag:sue},pue={_tag:oue},PullLeft$1=e=>({_tag:aue,rightChunk:e}),PullRight$1=e=>({_tag:uue,leftChunk:e}),fue="PullBoth",hue="PullLet",due="PullRight",mue={_tag:fue},PullLeft=e=>({_tag:hue,rightChunk:e}),PullRight=e=>({_tag:due,leftChunk:e}),gue=Symbol.for("effect/Stream"),yue={_R:e=>e,_E:e=>e,_A:e=>e};class StreamImpl{channel;[gue]=yue;constructor(e){this.channel=e}pipe(){return pipeArguments(this,arguments)}}const isStream=e=>C(e,gue)||c4(e),accumulateChunks$1=e=>{const accumulator=e=>readWith$1({onInput:t=>{const r=eC(e,t);return Zte(write$1(r),()=>accumulator(r))},onFailure:fail$f,onDone:()=>ere});return new StreamImpl(Yte(toChannel$4(e),accumulator(empty$R())))},acquireRelease$1=(e,t)=>scoped$2(U3(e,t)),bue=dual(2,(e,t)=>Sue(e,t,Cie)),Sue=dual(3,(e,t,r)=>hce(vue(e,t,r),e=>ot(e,{onLeft:none$c,onRight:Ut}))),vue=dual(3,(e,t,r)=>{const n=d4([make$1f(),Nz(rue),Nz(empty$R()),Aie(r),Nz(!1),Nz(!1)]);return fromEffect$7(n).pipe(Sce(([r,n,i,s,o,a])=>{const u=readWithCause$1({onInput:e=>Zte(fromEffect$b(pipe(r,qae(emit(e)),c7(()=>isNonEmpty$8(e)))),()=>u),onFailure:e=>fromEffect$b(qae(r,halt(e))),onDone:()=>fromEffect$b(qae(r,end$3(nue)))}),c=pipe(Rz(i,empty$R()),h7(e=>isNonEmpty$8(e)?pipe(Bz(o,!0),j8(G4(pipe(write$1(e),Zte(()=>c))))):pipe(take$5(r),P3(e=>{switch(e._tag){case Wae:return pipe(fromEffect$b(Bz(o,!0)),_ne(write$1(e.elements)),_ne(fromEffect$b(jz(a))),Zte(e=>e?ere:c));case Vae:return failCause$8(e.cause);case Kae:return e.reason._tag===eue?pipe(jz(o),P3(e=>e?fromEffect$b(pipe(Bz(n,rue),j8(Bz(a,!0)))):pipe(fromEffect$b(pipe(Bz(n,rue),j8(Bz(a,!0)))),Zte(()=>c))),unwrap$8):pipe(Bz(n,e.reason),j8(Bz(a,!0)),fromEffect$b)}}))),unwrap$8),timeout=e=>s.next(e),scheduledAggregator=(e,s,u)=>{const l=pipe(Bz(o,!1),j8(Bz(a,!1)),j8(pipe(c,fne(toChannel$5(t)),collectElements,run$7,c5(u)))),handleSide=(e,t,r)=>pipe(Bz(i,oC(e)),j8(P3(jz(n),e=>{switch(e._tag){case eue:return pipe(d4([jz(o),l,pipe(timeout(Ut(t)),c5(u))]),P3(([e,n,i])=>{const s=pipe(r,qt({onNone:()=>of$5(Ge(t)),onSome:e=>make$2d(Ge(t),He(e))}));return e?pipe(write$1(s),Zte(()=>scheduledAggregator(n,i,u))):scheduledAggregator(n,i,u)}),unwrap$8);case tue:return pipe(jz(o),P3(e=>e?write$1(of$5(Ge(t))):ere),unwrap$8)}})),unwrap$8);return unwrap$8(b7(vX(e),vX(s),{onSelfDone:(e,t)=>pipe(yX(s),j8(pipe(H4(()=>e),P3(([e,t])=>handleSide(e,t,none$c()))))),onOtherDone:(t,n)=>W7(H4(()=>t),{onFailure:t=>ot(YQ(t),{onLeft:()=>pipe(r,qae(end$3(rue)),a5,j8(pipe(vX(e),P3(([e,t])=>handleSide(e,t,none$c()))))),onRight:t=>pipe(r,qae(halt(t)),a5,j8(pipe(vX(e),P3(([e,t])=>handleSide(e,t,none$c())))))}),onSuccess:t=>pipe(r,qae(end$3(rue)),a5,j8(pipe(vX(e),P3(([e,r])=>handleSide(e,r,Ut(t))))))})}))};return unwrapScopedWith$3(r=>Yte(toChannel$4(e),u).pipe(run$7,c5(r),j8(fne(c,toChannel$5(t)).pipe(collectElements,run$7,c5(r),h7(e=>timeout(none$c()).pipe(c5(r),P3(t=>new StreamImpl(scheduledAggregator(e,t,r)))))))))}))}),_ue=dual(2,(e,t)=>Dce(e,()=>t)),queueFromBufferOptions=e=>{if("unbounded"===e)return ote();if("number"==typeof e||void 0===e)return bounded$4(e??16);switch(e.strategy){case"dropping":return dropping$4(e.bufferSize??16);case"sliding":return sliding$6(e.bufferSize??16);default:return bounded$4(e.bufferSize??16)}},asyncPush$1=(e,t)=>U3((e=>"unbounded"===e?.bufferSize||void 0===e?.bufferSize&&void 0===e?.strategy?ote():"sliding"===e?.strategy?sliding$6(e.bufferSize??16):dropping$4(e?.bufferSize??16))(t),shutdown$4).pipe(v7(t=>f9(m9,r=>e(((e,t)=>{let r=!1,n=[],i=!1;function array(e){if(r)return!1;if(e.length<=5e4)n.push.apply(n,e);else for(let t=0;t<e.length;t++)n.push(e[0]);return i||(i=!0,t.scheduleTask(flush,0)),!0}function flush(){i=!1,n.length>0&&(e.unsafeOffer(n),n=[])}function done(t){r||(r=!0,"Success"===t._tag&&n.push(t.value),flush(),e.unsafeOffer("Success"===t._tag?jU:t))}return{single:e=>!r&&(n.push(e),i||(i=!0,t.scheduleTask(flush,0)),!0),array,chunk:e=>array(toReadonlyArray$1(e)),done,end(){r||(r=!0,flush(),e.unsafeOffer(jU))},halt:e=>done(OU(e)),fail:e=>done(TU(e)),die:e=>done(IU(e)),dieMessage:e=>done(IU(Error(e)))}})(t,r)))),P3(e=>{const t=Zte(cte(e),e=>_U(e)?kU(e)?ere:failCause$8(e.cause):_ne(write$1(unsafeFromArray(e)),t));return t}),unwrapScoped$5,fromChannel$2),wue=dual(3,(e,t,r)=>suspend$7(()=>{const buffering=e=>readWith$1({onInput:r=>{if(e.length+r.length>=t){const[n,i]=pipe(r,bC(t-e.length));return running(pipe(e,eC(n)),i)}return buffering(pipe(e,eC(r)))},onFailure:fail$f,onDone:()=>running(e,empty$R())}),running=(e,t)=>Yte(_ne(write$1(t),identityChannel()),toChannel$4(r(e)));return new StreamImpl(pipe(toChannel$4(e),fne(buffering(empty$R()))))})),kue=dual(3,(e,t,r)=>pipe(e,Tue(t,r),P3(e=>e.map(e=>flattenTake$1(fromQueue$3(e,{shutdown:!0})))))),xue=dual(2,(e,t)=>P3(Lpe(e,t),e=>flattenTake$1(fromPubSub$3(e)))),Iue=dual(2,(e,t)=>P3(make$1l({acquire:xue(e,t),idleTimeToLive:t.idleTimeToLive}),e=>unwrapScoped$3(yie(e)))),Tue=dual(3,(e,t,r)=>h7(pubsubFromOptions(r),r=>pipe(d4(Array.from({length:t},()=>subscribe$2(r))),v7(()=>l5(spe(e,r)))))),Oue=dual(2,(e,t)=>P3(Lpe(e,t),subscribe$2)),Eue=dual(2,(e,t)=>{if("unbounded"===t.capacity)return bufferUnbounded(e);if("dropping"===t.strategy)return Fue(e,t.capacity);if("sliding"===t.strategy)return Pue(e,t.capacity);const r=$pe(e,t);return new StreamImpl(unwrapScoped$5(P3(r,e=>{const t=pipe(fromEffect$b(cte(e)),Zte(FU({onFailure:e=>pipe(flipCauseOption(e),qt({onNone:()=>ere,onSome:failCause$8})),onSuccess:e=>Zte(write$1(of$5(e)),()=>t)})));return t})))}),Aue=dual(2,(e,t)=>{if("dropping"===t.strategy)return Cue(e,t.capacity);if("sliding"===t.strategy)return Mue(e,t.capacity);const r=Upe(e,t);return new StreamImpl(unwrapScoped$5(P3(r,e=>{const t=pipe(fromEffect$b(cte(e)),Zte(Zae({onEnd:()=>ere,onFailure:failCause$8,onSuccess:e=>pipe(write$1(e),Zte(()=>t))})));return t})))}),Cue=dual(2,(e,t)=>{const r=U3(dropping$4(t),e=>shutdown$4(e));return new StreamImpl(bufferSignal(r,toChannel$4(e)))}),Mue=dual(2,(e,t)=>{const r=U3(sliding$6(t),e=>shutdown$4(e));return new StreamImpl(bufferSignal(r,toChannel$4(e)))}),Fue=dual(2,(e,t)=>{const r=U3(dropping$4(t),e=>shutdown$4(e));return new StreamImpl(bufferSignal(r,toChannel$4(Ple(1)(e))))}),Pue=dual(2,(e,t)=>{const r=U3(sliding$6(t),e=>shutdown$4(e));return new StreamImpl(bufferSignal(r,toChannel$4(pipe(e,Ple(1)))))}),bufferUnbounded=e=>{const t=Upe(e,{strategy:"unbounded"});return new StreamImpl(unwrapScoped$5(P3(t,e=>{const t=pipe(fromEffect$b(cte(e)),Zte(Zae({onEnd:()=>ere,onFailure:failCause$8,onSuccess:e=>Zte(write$1(e),()=>t)})));return t})))},bufferSignal=(e,t)=>{const producer=(e,t)=>{const terminate=r=>pipe(jz(t),v7(hU),j8(fU()),h7(n=>pipe(ate(e,[r,n]),j8(Bz(t,n)),j8(hU(n)))),C3,fromEffect$b);return readWithCause$1({onInput:r=>pipe(fU(),h7(n=>pipe(ate(e,[chunk$3(r),n]),h7(e=>pipe(Bz(t,n),c7(()=>e))))),C3,fromEffect$b,Zte(()=>producer(e,t))),onFailure:e=>terminate(failCause$6(e)),onDone:()=>terminate(Hae)})};return unwrapScoped$5(pipe(e,h7(e=>pipe(fU(),v7(start=>yU(start,void 0)),h7(start=>pipe(Nz(start),h7(r=>pipe(t,Yte(producer(e,r)),runScoped$3,l5)),E3((e=>{const t=pipe(fromEffect$b(cte(e)),Zte(([e,r])=>_ne(fromEffect$b(yU(r,void 0)),Zae(e,{onEnd:()=>ere,onFailure:failCause$8,onSuccess:e=>pipe(write$1(e),Zte(()=>t))}))));return t})(e))))))))},Nue=dual(2,(e,t)=>jue(e,e=>ot(YQ(e),{onLeft:t,onRight:failCause$4}))),jue=dual(2,(e,t)=>new StreamImpl(pipe(toChannel$4(e),Vte(e=>toChannel$4(t(e)))))),Rue=dual(2,(e,t)=>pipe(e,Nue(e=>pipe(t(e),Kt(()=>fail$a(e)))))),Due=dual(2,(e,t)=>pipe(e,jue(e=>pipe(t(e),Kt(()=>failCause$4(e)))))),Lue=dual(3,(e,t,r)=>Nue(e,e=>"_tag"in e&&e._tag===t?r(e):fail$a(e))),Uue=dual(2,(e,t)=>Nue(e,e=>"_tag"in e&&Object.keys(t).includes(e._tag)?t[e._tag](e):fail$a(e))),$ue=dual(2,(e,t)=>{const writer=e=>readWithCause$1({onInput:r=>{const[n,i]=qC(r,[e,empty$R()],([e,r],n)=>zt(e)&&t(e.value,n)?[Ut(n),r]:[Ut(n),pipe(r,GA(n))]);return Zte(write$1(i),()=>writer(n))},onFailure:failCause$8,onDone:()=>ere});return new StreamImpl(pipe(toChannel$4(e),Yte(writer(none$c()))))}),Bue=dual(2,(e,t)=>{const writer=e=>readWithCause$1({onInput:r=>pipe(r,O4([e,empty$R()],([e,r],n)=>zt(e)?pipe(t(e.value,n),P3(e=>e?[Ut(n),r]:[Ut(n),pipe(r,GA(n))])):G4([Ut(n),pipe(r,GA(n))])),fromEffect$b,Zte(([e,t])=>pipe(write$1(t),Zte(()=>writer(e))))),onFailure:failCause$8,onDone:()=>ere});return new StreamImpl(pipe(toChannel$4(e),Yte(writer(none$c()))))}),chunks$1=e=>pipe(e,Bce(of$5)),zue=dual(2,(e,t)=>flattenChunks$1(t(chunks$1(e)))),unsome$1=e=>e3(A3(e),e=>"None"===e._tag?J4:L4(e.value)),que=dual(4,(e,t,r,n)=>{function producer(e,t){return fromEffect$b(take$5(t)).pipe(_ne(readWithCause$1({onInput:r=>Zte(fromEffect$b(qae(e,NU(r))),()=>producer(e,t)),onFailure:t=>fromEffect$b(qae(e,OU(pipe(t,XQ(Ut))))),onDone:()=>Zte(fromEffect$b(qae(e,TU(none$c()))),()=>producer(e,t))})))}return new StreamImpl(unwrapScopedWith$5(i=>d4([make$1f(),make$1f(),make$1f(),make$1f()]).pipe(v7(([t,r,n])=>toChannel$4(e).pipe(Ure(writeChunk$1),Yte(producer(t,n)),gre(i),c5(i))),v7(([,e,r,n])=>toChannel$4(t).pipe(Ure(writeChunk$1),Yte(producer(e,n)),gre(i),c5(i))),P3(([e,t,i,s])=>{const o=qae(i,void 0).pipe(j8(take$5(e).pipe(h7(identity$5)))),a=qae(s,void 0).pipe(j8(take$5(t).pipe(h7(identity$5))));return toChannel$4(unfoldEffect$1(r,e=>h7(n(e,o,a),unsome$1)))}))))}),Wue=dual(4,(e,t,r,n)=>{const producer=(e,t)=>_ne(fromEffect$b(take$5(t)),readWithCause$1({onInput:r=>Zte(fromEffect$b(pipe(e,qae(chunk$3(r)))),()=>producer(e,t)),onFailure:t=>fromEffect$b(qae(e,failCause$6(t))),onDone:()=>fromEffect$b(qae(e,Hae))}));return new StreamImpl(unwrapScopedWith$5(i=>d4([make$1f(),make$1f(),make$1f(),make$1f()]).pipe(v7(([t,r,n])=>Yte(toChannel$4(e),producer(t,n)).pipe(gre(i),c5(i))),v7(([e,r,n,s])=>Yte(toChannel$4(t),producer(r,s)).pipe(gre(i),c5(i))),P3(([e,t,i,s])=>{const o=qae(i,void 0).pipe(j8(take$5(e).pipe(h7(done$5)))),a=qae(s,void 0).pipe(j8(take$5(t).pipe(h7(done$5))));return toChannel$4(unfoldChunkEffect$1(r,e=>h7(n(e,o,a),unsome$1)))}))))}),Vue=dual(2,(e,t)=>new StreamImpl(pipe(toChannel$4(e),_ne(toChannel$4(t))))),Kue=dual(2,(e,t)=>pipe(e,Hue(t,(e,t)=>[e,t]))),Gue=dual(2,(e,t)=>pipe(e,Hue(t,(e,t)=>e))),Jue=dual(2,(e,t)=>Sce(e,()=>t)),Hue=dual(3,(e,t,r)=>pipe(e,Sce(e=>pipe(t,Dce(t=>r(e,t)))))),Zue=dual(2,(e,t)=>unwrapScopedWith$3(r=>V4(function*(){const n=yield*make$1f();function enqueue(e){return sleep$4(t).pipe(E3(e),c5(r),P3(e=>consumer((e=>({_tag:Rae,fiber:e}))(e))))}const i=readWithCause$1({onInput:e=>qt(last$5(e),{onNone:()=>i,onSome:e=>fromEffect$b(qae(n,emit(of$5(e)))).pipe(Zte(()=>i))}),onFailure:e=>fromEffect$b(qae(n,halt(e))),onDone:()=>fromEffect$b(qae(n,end$3(nue)))});function consumer(e){switch(e._tag){case jae:return unwrap$8(take$5(n).pipe(P3(e=>{switch(e._tag){case Wae:return unwrap$8(enqueue(e.elements));case Vae:return failCause$8(e.cause);case Kae:return ere}})));case Rae:return unwrap$8(take$5(n).pipe(c5(r),h7(t=>b7(vX(e.fiber),vX(t),{onSelfDone:(e,r)=>FU(e,{onFailure:e=>yX(r).pipe(E3(failCause$8(e))),onSuccess:e=>yX(r).pipe(j8(G4(write$1(e).pipe(Zte(()=>consumer({_tag:Dae,fiber:t}))))))}),onOtherDone:(e,t)=>FU(e,{onFailure:e=>yX(t).pipe(E3(failCause$8(e))),onSuccess:e=>{switch(e._tag){case Wae:return yX(t).pipe(j8(enqueue(e.elements)));case Vae:return yX(t).pipe(E3(failCause$8(e.cause)));case Kae:return vX(t).pipe(P3(e=>write$1(e).pipe(_ne(ere))))}}})}))));case Dae:return unwrap$8(vX(e.fiber).pipe(P3(e=>{switch(e._tag){case Wae:return unwrap$8(enqueue(e.elements));case Vae:return failCause$8(e.cause);case Kae:return ere}})))}}return scopedWith$2(t=>Yte(toChannel$4(e),i).pipe(gre(t),c5(t))).pipe(Jue(new StreamImpl(consumer(Lae))))}))),die$4=e=>fromEffect$7(z4(e)),Que=dual(2,(e,t)=>pipe(fU(),h7(r=>pipe(e,Xue({maximumLag:t.maximumLag,decide:e=>h7(hU(r),t=>t(e))}),h7(e=>pipe(d4(fC(range$2(0,t.size-1),t=>P3(e,([e,r])=>[[e,t],r]))),P3(unsafeFromArray),h7(e=>{const[n,i]=WC(e,[new Map,empty$R()],([e,t],[r,n])=>[e.set(r[0],r[1]),pipe(t,JA(n))]);return pipe(yU(r,e=>P3(t.decide(e),e=>t=>e(n.get(t)))),E3(Array.from(i)))}))))))),Yue={ref:0},newDistributedWithDynamicId=()=>{const e=Yue.ref;return Yue.ref=e+1,e},Xue=dual(2,(e,t)=>ece(e,t.maximumLag,t.decide,()=>Q4)),ece=dual(4,(e,t,r,n)=>pipe(U3(Nz(new Map),(e,t)=>pipe(jz(e),h7(e=>pipe(e.values(),x4(shutdown$4))))),h7(i=>V4(function*(){const s=yield*makeSemaphore(1),o=yield*Nz(pipe(bounded$4(t),h7(e=>{const t=newDistributedWithDynamicId();return pipe(qz(i,r=>r.set(t,e)),E3([t,e]))}))),finalize=e=>s.withPermits(1)(pipe(Bz(o,pipe(bounded$4(1),v7(t=>ate(t,e)),h7(e=>{const t=newDistributedWithDynamicId();return pipe(qz(i,r=>r.set(t,e)),E3(make$2j(t,e)))}))),j8(pipe(jz(i),h7(t=>pipe(fromIterable$u(t.values()),x4(t=>pipe(ate(t,e),s3(e=>HQ(e)?Ut(Q4):none$c()))))))),j8(n(e)),C3));return yield*pipe(e,tpe(e=>pipe(r(e),h7(t=>pipe(jz(i),h7(r=>pipe(r.entries(),O4(empty$R(),(r,[n,i])=>t(n)?pipe(ate(i,NU(e)),W7({onFailure:e=>HQ(e)?G4(pipe(r,JA(n))):$4(e),onSuccess:()=>G4(r)})):G4(r)),h7(e=>isNonEmpty$8(e)?qz(i,t=>{for(const r of e)t.delete(r);return t}):Q4))))),C3)),W7({onFailure:e=>finalize(OU(pipe(e,XQ(Ut)))),onSuccess:()=>finalize(TU(none$c()))}),l5),s.withPermits(1)(m7(jz(o)))})))),drain$3=e=>new StreamImpl(drain$5(toChannel$4(e))),tce=dual(2,(e,t)=>fromEffect$7(fU()).pipe(Sce(r=>scopedWith$2(e=>toChannel$4(t).pipe(drain$5,gre(e),t3(e=>gU(r,e)),c5(e))).pipe(Jue(Rce(e,r)))))),rce=dual(2,(e,t)=>{const loop=e=>readWith$1({onInput:t=>{const r=pipe(t,ZA(e)),n=Math.max(0,e-t.length);return isEmpty$t(t)||n>0?loop(n):pipe(write$1(r),_ne(identityChannel()))},onFailure:fail$f,onDone:()=>ere});return new StreamImpl(pipe(toChannel$4(e),fne(loop(t))))}),nce=dual(2,(e,t)=>t<=0?identityStream():suspend$7(()=>{const r=new RingBuffer(t),n=readWith$1({onInput:e=>{const t=pipe(e,tC(e=>{const t=r.head();return r.put(e),t}));return pipe(write$1(t),Zte(()=>n))},onFailure:fail$f,onDone:()=>ere});return new StreamImpl(pipe(toChannel$4(e),fne(n)))})),ice=dual(2,(e,t)=>rce(oce(e,e=>!t(e)),1)),sce=dual(2,(e,t)=>{const r=readWith$1({onInput:e=>pipe(m4(e,t),P3(unsafeFromArray),P3(e=>isEmpty$t(e)?suspend$b(()=>r):pipe(write$1(e),_ne(identityChannel()))),unwrap$8),onFailure:fail$f,onDone:()=>ere});return new StreamImpl(pipe(toChannel$4(e),fne(r)))}),oce=dual(2,(e,t)=>{const r=readWith$1({onInput:e=>{const n=YA(e,t);return isEmpty$t(n)?suspend$b(()=>r):_ne(write$1(n),identityChannel())},onFailure:fail$f,onDone:succeedNow});return new StreamImpl(fne(toChannel$4(e),r))}),ace=dual(2,(e,t)=>{const r=readWith$1({onInput:e=>pipe(g4(e,t),P3(unsafeFromArray),P3(e=>isEmpty$t(e)?suspend$b(()=>r):_ne(write$1(e),identityChannel())),unwrap$8),onFailure:fail$f,onDone:()=>ere});return new StreamImpl(fne(toChannel$4(e),r))}),uce=new StreamImpl(ere),cce=dual(2,(e,t)=>new StreamImpl(pipe(toChannel$4(e),Gre(t)))),lce=dual(2,(e,t)=>new StreamImpl(Hte(toChannel$4(e),t))),context$4=()=>fromEffect$7(R5()),contextWithStream$1=e=>pipe(context$4(),Sce(e)),execute$1=e=>drain$3(fromEffect$7(e)),fail$a=e=>fromEffectOption$1(L4(Ut(e))),failSync$4=e=>fromEffectOption$1(U4(()=>Ut(e()))),failCause$4=e=>fromEffect$7($4(e)),pce=dual(2,(e,t)=>Bce(e,rC(t))),fce=dual(2,(e,t)=>{const loop=e=>{const r=e.next();return r.done?readWithCause$1({onInput:e=>loop(e[Symbol.iterator]()),onFailure:failCause$8,onDone:succeed$g}):pipe(t(r.value),P3(t=>t?pipe(write$1(of$5(r.value)),Zte(()=>loop(e))):loop(e)),unwrap$8)};return new StreamImpl(suspend$b(()=>pipe(toChannel$4(e),Yte(loop(empty$R()[Symbol.iterator]())))))}),hce=dual(2,(e,t)=>Bce(e,tC(t))),dce=dual(2,(e,t)=>suspend$7(()=>{const loop=e=>{const r=e.next();return r.done?readWithCause$1({onInput:e=>loop(e[Symbol.iterator]()),onFailure:failCause$8,onDone:succeed$g}):pipe(t(r.value),qt({onNone:()=>Z4(()=>loop(e)),onSome:P3(t=>Zte(write$1(of$5(t)),()=>loop(e)))}),unwrap$8)};return new StreamImpl(pipe(toChannel$4(e),Yte(loop(empty$R()[Symbol.iterator]()))))})),mce=dual(2,(e,t)=>{const r=readWith$1({onInput:e=>{const n=nC(e,t);return n.length===e.length?pipe(write$1(n),Zte(()=>r)):write$1(n)},onFailure:fail$f,onDone:succeed$g});return new StreamImpl(pipe(toChannel$4(e),fne(r)))}),gce=dual(2,(e,t)=>suspend$7(()=>{const loop=e=>{const r=e.next();return r.done?readWithCause$1({onInput:e=>loop(e[Symbol.iterator]()),onFailure:failCause$8,onDone:succeed$g}):unwrap$8(qt(t(r.value),{onNone:()=>G4(ere),onSome:P3(t=>Zte(write$1(of$5(t)),()=>loop(e)))}))};return new StreamImpl(pipe(toChannel$4(e),fne(loop(empty$R()[Symbol.iterator]()))))})),yce=dual(2,(e,t)=>{const r=readWith$1({onInput:e=>qt(RC(e,t),{onNone:()=>r,onSome:e=>write$1(of$5(e))}),onFailure:fail$f,onDone:()=>ere});return new StreamImpl(pipe(toChannel$4(e),Yte(r)))}),bce=dual(2,(e,t)=>{const r=readWith$1({onInput:e=>pipe(k4(e,t),P3(qt({onNone:()=>r,onSome:e=>write$1(of$5(e))})),unwrap$8),onFailure:fail$f,onDone:()=>ere});return new StreamImpl(pipe(toChannel$4(e),Yte(r)))}),Sce=dual(e=>isStream(e[0]),(e,t,r)=>{const n=r?.bufferSize??16;return r?.switch?matchConcurrency(r?.concurrency,()=>vce(e,1,n,t),r=>vce(e,r,n,t)):matchConcurrency(r?.concurrency,()=>new StreamImpl(Ure(toChannel$4(e),e=>pipe(e,fC(e=>toChannel$4(t(e))),qC(ere,(e,t)=>pipe(e,_ne(t)))))),n=>new StreamImpl(pipe(toChannel$4(e),Ure(writeChunk$1),ine(e=>toChannel$4(t(e)),r))))}),matchConcurrency=(e,t,r)=>{switch(e){case void 0:return t();case"unbounded":return r(Number.MAX_SAFE_INTEGER);default:return e>1?r(e):t()}},vce=dual(4,(e,t,r,n)=>new StreamImpl(pipe(toChannel$4(e),Ure(writeChunk$1),ine(e=>toChannel$4(n(e)),{concurrency:t,mergeStrategy:BufferSliding$1(),bufferSize:r})))),_ce=dual(e=>isStream(e[0]),(e,t)=>Sce(e,identity$5,t)),flattenChunks$1=e=>{const t=readWithCause$1({onInput:e=>Zte(writeChunk$1(e),()=>t),onFailure:failCause$8,onDone:()=>ere});return new StreamImpl(pipe(toChannel$4(e),Yte(t)))},wce=dual(e=>isStream(e[0]),(e,t)=>t?.unordered?Sce(e,e=>fromEffect$7(e),{concurrency:t.concurrency}):matchConcurrency(t?.concurrency,()=>Gce(e,identity$5),t=>new StreamImpl(pipe(toChannel$4(e),Ure(writeChunk$1),nne(identity$5,t),tne(of$5))))),flattenExitOption$1=e=>{const t=readWithCause$1({onInput:e=>((e,t)=>{const[r,n]=pipe(e,_C(e=>!kU(e))),i=pipe(cC(n),qt({onNone:()=>t,onSome:FU({onFailure:e=>qt(flipCauseOption(e),{onNone:()=>ere,onSome:failCause$8}),onSuccess:()=>ere})}));return pipe(write$1(pipe(r,tC(e=>kU(e)?Ut(e.value):none$c()))),Zte(()=>i))})(e,t),onFailure:e=>failCause$8(e),onDone:()=>ere});return new StreamImpl(pipe(toChannel$4(e),Yte(t)))},flattenTake$1=e=>flattenChunks$1(flattenExitOption$1(pipe(e,Dce(e=>e.exit)))),forever$1=e=>new StreamImpl(repeated$2(toChannel$4(e))),fromChannel$2=e=>new StreamImpl(e),toChannel$4=e=>{if("channel"in e)return e.channel;if(c4(e))return toChannel$4(fromEffect$7(e));throw new TypeError("Expected a Stream.")},fromChunk$1=e=>new StreamImpl(isEmpty$t(e)?ere:write$1(e)),fromChunkQueue$1=(e,t)=>pipe(cte(e),t3(t=>pipe(isShutdown$4(e),h7(e=>e&&HQ(t)?end$1():failCause$5(t)))),repeatEffectChunkOption$1,t?.shutdown?cce(shutdown$4(e)):identity$5),fromEffect$7=e=>pipe(e,R3(Ut),fromEffectOption$1),fromEffectOption$1=e=>new StreamImpl(unwrap$8(z7(e,{onFailure:qt({onNone:()=>ere,onSome:fail$f}),onSuccess:e=>write$1(of$5(e))}))),fromPubSub$3=(e,t)=>{const r=t?.maxChunkSize??4096;if(t?.scoped){const n=P3(subscribe$2(e),e=>fromQueue$3(e,{maxChunkSize:r,shutdown:!0}));return t.shutdown?P3(n,cce(shutdown$5(e))):n}const n=Sce(scoped$2(subscribe$2(e)),e=>fromQueue$3(e,{maxChunkSize:r}));return t?.shutdown?cce(n,shutdown$5(e)):n},fromIterable$g=e=>suspend$7(()=>isChunk(e)?fromChunk$1(e):fromIteratorSucceed$1(e[Symbol.iterator]())),fromIteratorSucceed$1=(e,t=4096)=>pipe(Z4(()=>{let r=[];const loop=e=>pipe(Z4(()=>{let n=e.next();if(1===t)return n.done?ere:pipe(write$1(of$5(n.value)),Zte(()=>loop(e)));r=[];let i=0;for(;!1===n.done&&(r.push(n.value),i+=1,!(i>=t));)n=e.next();return i>0?pipe(write$1(unsafeFromArray(r)),Zte(()=>loop(e))):ere}),unwrap$8);return new StreamImpl(loop(e))}),unwrap$6),fromPull$2=e=>pipe(e,P3(repeatEffectChunkOption$1),unwrapScoped$3),fromQueue$3=(e,t)=>pipe(pte(e,1,t?.maxChunkSize??4096),t3(t=>pipe(isShutdown$4(e),h7(e=>e&&HQ(t)?end$1():failCause$5(t)))),repeatEffectChunkOption$1,t?.shutdown?cce(shutdown$4(e)):identity$5),fromTQueue$1=e=>pipe(take$6(e),P3(of$5),t3(t=>pipe(isShutdown(e),h7(e=>e&&HQ(t)?end$1():failCause$5(t)))),repeatEffectChunkOption$1),kce=Symbol.for("effect/Stream/EOF"),xce=dual(2,(e,t)=>{const groupAdjacent=e=>readWithCause$1({onInput:r=>{const[n,i]=((e,r)=>{if(isEmpty$t(r))return[e,empty$R()];const n=[];let i,s=0,o=0,a=empty$R();switch(e._tag){case"Some":{const u=e.value;i=u[0];let c=!0;for(;c&&o<r.length;){const e=KA(r,o),a=t(e);if(!equals$4(i,a)){const e=u[1],t=unsafeFromArray(Array.from(r).slice(s,o)),l=eC(e,t);n.push([i,l]),i=a,s=o,c=!1}o+=1}c&&(a=u[1]);break}case"None":i=t(KA(r,o)),o+=1}for(;o<r.length;){const e=KA(r,o),a=t(e);equals$4(i,a)||(n.push([i,unsafeFromArray(Array.from(r).slice(s,o))]),i=a,s=o),o+=1}const u=eC(a,unsafeFromArray(Array.from(r).slice(s,o))),c=unsafeFromArray(n);return[Ut([i,u]),c]})(e,r);return isEmpty$t(i)?groupAdjacent(n):Zte(write$1(i),()=>groupAdjacent(n))},onFailure:t=>qt(e,{onNone:()=>failCause$8(t),onSome:e=>Zte(write$1(of$5(e)),()=>failCause$8(t))}),onDone:t=>qt(e,{onNone:()=>succeedNow(t),onSome:e=>Zte(write$1(of$5(e)),()=>succeedNow(t))})});return new StreamImpl(fne(toChannel$4(e),groupAdjacent(none$c())))}),Ice=dual(2,(e,t)=>pipe(e,Ple(t),chunks$1)),Tce=dual(3,(e,t,r)=>Sue(e,collectAllN$1(t),spaced(r))),Oce=dual(2,(e,t)=>{const writer=e=>pipe(poll$8(e),P3(qt({onNone:()=>readWith$1({onInput:t=>Zte(write$1(t),()=>writer(e)),onFailure:fail$f,onDone:()=>ere}),onSome:FU({onFailure:failCause$8,onSuccess:()=>ere})})),unwrap$8);return new StreamImpl(unwrapScopedWith$5(r=>t.pipe(c5(r),P3(t=>toChannel$4(e).pipe(Yte(writer(t)))))))}),Ece=dual(2,(e,t)=>pipe(e,Oce(sleep$4(t)))),Ace=dual(2,(e,t)=>{const r=pipe(poll$b(t),P3(qt({onNone:()=>readWith$1({onInput:e=>pipe(write$1(e),Zte(()=>r)),onFailure:fail$f,onDone:()=>ere}),onSome:e=>unwrap$8(z7(e,{onFailure:fail$f,onSuccess:()=>ere}))})),unwrap$8);return new StreamImpl(pipe(toChannel$4(e),Yte(r)))}),identityStream=()=>new StreamImpl(identityChannel()),Cce=dual(2,(e,t)=>pipe(e,Mce(t,forever$1(make$1d(!0,!1))))),Mce=dual(3,(e,t,r)=>{const producer=e=>readWithCause$1({onInput:t=>Zte(fromEffect$b(qae(e,of$1(t))),()=>producer(e)),onFailure:t=>fromEffect$b(qae(e,failCause$6(t))),onDone:()=>fromEffect$b(qae(e,Hae))});return new StreamImpl(unwrapScopedWith$5(n=>pipe(make$1f(),P8(make$1f()),v7(([t])=>toChannel$4(e).pipe(Ure(writeChunk$1),Yte(producer(t)),gre(n),c5(n))),v7(([e,r])=>toChannel$4(t).pipe(Ure(writeChunk$1),Yte(producer(r)),gre(n),c5(n))),P3(([e,t])=>{const process=(r,n)=>readWithCause$1({onInput:i=>i&&!r?pipe(fromEffect$b(take$5(e)),Zte(Zae({onEnd:()=>n?ere:process(!0,n),onFailure:failCause$8,onSuccess:e=>pipe(write$1(e),Zte(()=>process(r,n)))}))):i||n?process(r,n):pipe(fromEffect$b(take$5(t)),Zte(Zae({onEnd:()=>r?ere:process(r,!0),onFailure:failCause$8,onSuccess:e=>pipe(write$1(e),Zte(()=>process(r,n)))}))),onFailure:failCause$8,onDone:()=>ere});return pipe(toChannel$4(r),Ure(writeChunk$1),Yte(process(!1,!1)))}))))}),Fce=dual(2,(e,t)=>new StreamImpl(pipe(toChannel$4(e),fne(suspend$b(()=>{const writer=e=>readWithCause$1({onInput:r=>{const n=[];let i=e;for(const e of r)i?(i=!1,n.push(e)):(n.push(t),n.push(e));return pipe(write$1(unsafeFromArray(n)),Zte(()=>writer(i)))},onFailure:failCause$8,onDone:()=>ere});return writer(!0)}))))),Pce=dual(2,(e,{end:t,middle:r,start})=>pipe(make$1d(start),Vue(pipe(e,Fce(r))),Vue(make$1d(t)))),Nce=dual(2,(e,t)=>pipe(e,jce(sleep$4(t)))),jce=dual(2,(e,t)=>new StreamImpl(pipe(toChannel$4(e),Hre(t)))),Rce=dual(2,(e,t)=>new StreamImpl(pipe(toChannel$4(e),Zre(t)))),make$1d=(...e)=>fromIterable$g(e),Dce=dual(2,(e,t)=>new StreamImpl(pipe(toChannel$4(e),tne(fC(t))))),Lce=dual(3,(e,t,r)=>{const accumulator=e=>readWith$1({onInput:t=>{const[n,i]=hC(t,e,r);return Zte(write$1(i),()=>accumulator(n))},onFailure:fail$f,onDone:()=>ere});return new StreamImpl(pipe(toChannel$4(e),Yte(accumulator(t))))}),Uce=dual(3,(e,t,r)=>suspend$7(()=>{const accumulator=e=>readWith$1({onInput:t=>pipe(H4(()=>{const n=[];return pipe(t,O4(e,(e,t)=>pipe(r(e,t),h7(([e,t])=>{return pipe((r=t,Z4(()=>{n.push(r)})),E3(e));var r}))),z7({onFailure:e=>0!==n.length?_ne(write$1(unsafeFromArray(n)),fail$f(e)):fail$f(e),onSuccess:e=>Zte(write$1(unsafeFromArray(n)),()=>accumulator(e))}))}),unwrap$8),onFailure:fail$f,onDone:()=>ere});return new StreamImpl(pipe(toChannel$4(e),fne(accumulator(t))))})),$ce=dual(2,(e,t)=>pipe(e,Hce(t.onFailure),Dce(t.onSuccess))),Bce=dual(2,(e,t)=>new StreamImpl(pipe(toChannel$4(e),tne(t)))),zce=dual(2,(e,t)=>new StreamImpl(pipe(toChannel$4(e),rne(t)))),qce=dual(2,(e,t)=>pipe(e,Wce(e=>fromIterable$u(t(e))))),Wce=dual(2,(e,t)=>pipe(e,Bce(iC(t)))),Vce=dual(2,(e,t)=>pipe(e,Gce(t),Wce(identity$5))),Kce=dual(2,(e,t)=>pipe(e,Gce(e=>pipe(t(e),P3(fromIterable$u))),Wce(identity$5))),Gce=dual(2,(e,t)=>{const loop=e=>{const r=e.next();if(r.done)return readWithCause$1({onInput:e=>loop(e[Symbol.iterator]()),onFailure:failCause$8,onDone:succeed$g});{const n=r.value;return unwrap$8(P3(t(n),t=>Zte(write$1(of$5(t)),()=>loop(e))))}};return new StreamImpl(pipe(toChannel$4(e),Yte(suspend$b(()=>loop(empty$R()[Symbol.iterator]())))))}),Jce=dual(3,(e,t,r)=>new StreamImpl(pipe(toChannel$4(e),Ure(writeChunk$1),nne(r,t),tne(of$5)))),Hce=dual(2,(e,t)=>new StreamImpl(pipe(toChannel$4(e),Xre(t)))),Zce=dual(2,(e,t)=>new StreamImpl(pipe(toChannel$4(e),ene(t)))),Qce=dual(e=>isStream(e[1]),(e,t,r)=>nle(e,t,{onSelf:identity$5,onOther:identity$5,haltStrategy:r?.haltStrategy})),Yce=dual(e=>Symbol.iterator in e[0],(e,t)=>_ce(fromIterable$g(e),t)),Xce=dual(2,(e,t)=>{const r=Object.keys(e).map(t=>e[t].pipe(Dce(e=>({_tag:t,value:e}))));return Yce(r,t)}),ele=dual(2,(e,t)=>nle(e,t,{onSelf:He,onOther:Ge})),tle=dual(2,(e,t)=>pipe(e,Qce(drain$3(t)))),rle=dual(2,(e,t)=>pipe(drain$3(e),Qce(t))),nle=dual(3,(e,t,r)=>{const n=r.haltStrategy?fromInput$2(r.haltStrategy):zie,handler=e=>t=>e||!kU(t)?lie(H4(()=>t)):pie(e=>H4(()=>e));return new StreamImpl(ane(toChannel$4(Dce(e,r.onSelf)),{other:toChannel$4(Dce(t,r.onOther)),onSelfDone:handler("Either"===n._tag||"Left"===n._tag),onOtherDone:handler("Either"===n._tag||"Right"===n._tag)}))}),ile=fromEffect$7(K4),sle=dual(2,(e,t)=>Vue(e,drain$3(fromEffect$7(t)))),ole=dual(2,(e,t)=>pipe(e,jue(e=>fromEffect$7(pipe(t(e),j8($4(e))))))),ale=dual(2,(e,t)=>new StreamImpl(pipe(toChannel$4(e),Hte(e=>kU(e)?t():Q4)))),ule=dual(2,(e,t)=>unwrap$6(E3(t,e))),cle=dual(2,(e,t)=>new StreamImpl(pipe(toChannel$4(e),lne(t)))),lle=dual(2,(e,t)=>new StreamImpl(pipe(toChannel$4(e),pne(()=>toChannel$4(t()))))),ple=dual(2,(e,t)=>pipe(e,Dce(He),lle(()=>pipe(t(),Dce(Ge))))),fle=dual(2,(e,t)=>pipe(e,lle(()=>failSync$4(t)))),hle=dual(2,(e,t)=>pipe(e,dle(()=>of$5(t())))),dle=dual(2,(e,t)=>pipe(e,mle(()=>new StreamImpl(write$1(t()))))),mle=dual(2,(e,t)=>{const r=readWith$1({onInput:e=>isEmpty$t(e)?suspend$b(()=>r):pipe(write$1(e),_ne(identityChannel())),onFailure:fail$f,onDone:()=>suspend$b(()=>toChannel$4(t()))});return new StreamImpl(pipe(toChannel$4(e),Yte(r)))}),gle=dual(2,(e,t)=>pipe(e,lle(()=>sync$8(t)))),paginateChunk$1=(e,t)=>{const loop=e=>{const r=t(e);return qt(r[1],{onNone:()=>_ne(write$1(r[0]),ere),onSome:e=>Zte(write$1(r[0]),()=>loop(e))})};return new StreamImpl(suspend$b(()=>loop(e)))},paginateChunkEffect$1=(e,t)=>{const loop=e=>unwrap$8(P3(t(e),([e,t])=>qt(t,{onNone:()=>_ne(write$1(e),ere),onSome:t=>Zte(write$1(e),()=>loop(t))})));return new StreamImpl(suspend$b(()=>loop(e)))},paginateEffect$1=(e,t)=>paginateChunkEffect$1(e,e=>pipe(t(e),P3(([e,t])=>[of$5(e),t]))),yle=dual(2,(e,t)=>{const r="Emit",n="Halt";return pipe(fU(),h7(i=>pipe(make$1f(),P3(s=>{const o=$ne(collectLeftover$1(t),{onFailure:e=>sie(fromEffect$9(mU(i,e)),fail$e(e)),onSuccess:([e,t])=>{const o=readWithCause$1({onInput:e=>Zte(fromEffect$b(qae(s,{_tag:r,elements:e})),()=>o),onFailure:e=>_ne(fromEffect$b(qae(s,{_tag:n,cause:e})),failCause$8(e)),onDone:e=>_ne(fromEffect$b(qae(s,{_tag:"End"})),ere)});return fromChannel$3(pipe(fromEffect$b(yU(i,e)),_ne(fromEffect$b(pipe(s,qae({_tag:r,elements:t})))),_ne(o)))}}),a=pipe(take$5(s),P3(e=>{switch(e._tag){case r:return pipe(write$1(e.elements),Zte(()=>a));case n:return failCause$8(e.cause);case"End":return ere}}),unwrap$8);return pipe(e,Cpe(e=>gU(i,e)),qle(o),l5,j8(hU(i)),P3(e=>[e,new StreamImpl(a)]))}))),m7)}),ble=dual(e=>"function"==typeof e[1],(e,t,r)=>Sle(e,e=>G4(t(e)?Ge(e):He(e)),r)),Sle=dual(e=>"function"==typeof e[1],(e,t,r)=>pipe(Gce(e,t),Que({size:2,maximumLag:r?.bufferSize??16,decide:ot({onLeft:()=>G4(e=>0===e),onRight:()=>G4(e=>1===e)})}),h7(([e,t])=>G4([hce(flattenExitOption$1(fromQueue$3(e,{shutdown:!0})),e=>ot(e,{onLeft:Ut,onRight:none$c})),hce(flattenExitOption$1(fromQueue$3(t,{shutdown:!0})),e=>ot(e,{onLeft:none$c,onRight:Ut}))])))),vle=dual(2,(e,t)=>new StreamImpl(pipe(toChannel$4(e),fne(toChannel$5(t))))),_le=dual(2,(e,t)=>new StreamImpl(Yte(toChannel$4(e),t))),wle=dual(2,(e,t)=>new StreamImpl(pipe(toChannel$4(e),fne(t)))),kle=dual(2,(e,t)=>new StreamImpl(_ne(write$1(t),toChannel$4(e)))),xle=dual(2,(e,t)=>new StreamImpl(pipe(toChannel$4(e),Xte(t)))),Ile=dual(2,(e,t)=>Cle(e,LA(t))),Tle=dual(2,(e,t)=>new StreamImpl(unwrapScopedWith$5(r=>$9(t,r).pipe(P3(t=>pipe(toChannel$4(e),Xte(t))))))),Ole=dual(3,(e,t,r)=>Ele(e,t,G4(r))),Ele=dual(3,(e,t,r)=>Ale(e,t,fromEffect$7(r))),Ale=dual(3,(e,t,r)=>contextWithStream$1(n=>Sce(r,r=>pipe(e,xle(NA(n,t,r)))))),Cle=dual(2,(e,t)=>contextWithStream$1(r=>pipe(e,xle(t(r))))),Mle=dual(2,(e,t)=>pipe(e,Tle(pipe(q9(),see(t))))),Fle=dual(2,(e,t)=>raceAll$1(e,t)),raceAll$1=(...e)=>fU().pipe(P3(t=>{let r=null;return Yce(e.map((e,n)=>e.pipe(Tpe(()=>null===r?(r=n,SU(t,jU),!0):r===n),jce(hU(t).pipe(h7(()=>r===n?K4:Q4))))),{concurrency:e.length})}),unwrap$6),Ple=dual(2,(e,t)=>suspend$7(()=>{const r=Math.max(t,1),n=rechunkProcess(new StreamRechunker(r),r);return new StreamImpl(pipe(toChannel$4(e),Yte(n)))})),rechunkProcess=(e,t)=>readWithCause$1({onInput:r=>{if(r.length===t&&e.isEmpty())return Zte(write$1(r),()=>rechunkProcess(e,t));if(r.length>0){const n=[];let i,s=0;for(;s<r.length;){for(;s<r.length&&void 0===i;)i=e.write(pipe(r,KA(s))),s+=1;void 0!==i&&(n.push(i),i=void 0)}return Zte(writeAll$1(...n),()=>rechunkProcess(e,t))}return suspend$b(()=>rechunkProcess(e,t))},onFailure:t=>_ne(e.emitIfNotEmpty(),failCause$8(t)),onDone:()=>e.emitIfNotEmpty()});class StreamRechunker{n;builder=[];pos=0;constructor(e){this.n=e}isEmpty(){return 0===this.pos}write(e){if(this.builder.push(e),this.pos+=1,this.pos===this.n){const e=unsafeFromArray(this.builder);return this.builder=[],this.pos=0,e}}emitIfNotEmpty(){return 0!==this.pos?write$1(unsafeFromArray(this.builder)):ere}}const Nle=dual(2,(e,t)=>pipe(e,jle(t,identity$5))),jle=dual(3,(e,t,r)=>new StreamImpl(Lre(toChannel$4(e),e=>qt(t(e),{onNone:()=>failCause$8(qQ(r(e))),onSome:fail$f})))),Rle=dual(2,(e,t)=>hce(Dle(e,t),e=>ot(e,{onLeft:none$c,onRight:Ut}))),repeatEffectChunkOption$1=e=>unfoldChunkEffect$1(e,e=>pipe(P3(e,t=>Ut([t,e])),e3(qt({onNone:()=>G4(none$c()),onSome:L4})))),repeatEffectOption$1=e=>repeatEffectChunkOption$1(pipe(e,P3(of$5))),Dle=dual(2,(e,t)=>$le(e,t,{onElement:e=>Ge(e),onSchedule:He})),Lle=dual(2,(e,t)=>hce(Ule(e,t,{onElement:e=>Ut(e),onSchedule:none$c}),identity$5)),Ule=dual(3,(e,t,r)=>{const n=pipe(Aie(t),P3(e=>{const feed=e=>qt(cC(e),{onNone:()=>t,onSome:t=>_ne(write$1(of$5(r.onElement(t))),step(pipe(e,ZA(1)),t))}),step=(t,n)=>{const i=pipe(e.next(n),E3(pipe(write$1(of$5(r.onElement(n))),Zte(()=>step(t,n))))),s=pipe(e.last,i8,h7(n=>pipe(e.reset,P3(()=>pipe(write$1(of$5(r.onSchedule(n))),_ne(feed(t)))))));return pipe(i,o8(()=>s),unwrap$8)},t=readWith$1({onInput:feed,onFailure:fail$f,onDone:()=>ere});return t}),unwrap$8);return new StreamImpl(pipe(toChannel$4(e),Yte(n)))}),$le=dual(3,(e,t,r)=>pipe(Aie(t),P3(t=>{const n=Ele(Mie,jz(t.iterationMeta)),i=pipe(e,n,Dce(r.onElement),toChannel$4),s=unwrap$8(z7(t.next(void 0),{onFailure:()=>ere,onSuccess:e=>Zte(i,()=>_ne(write$1(of$5(r.onSchedule(e))),s))}));return new StreamImpl(_ne(i,s))}),unwrap$6)),repeatEffectWithSchedule$1=(e,t)=>Sce(fromEffect$7(P8(e,Aie(t))),([t,r])=>{const n=B5(Mie,jz(r.iterationMeta));return Vue(succeed$b(t),unfoldEffect$1(t,t=>V7(r.next(t),{onFailure:G4,onSuccess:()=>P3(n(e),e=>Ut([e,e]))})))}),Ble=dual(2,(e,t)=>Aie(t).pipe(P3(t=>{const r=Ele(Mie,jz(t.iterationMeta)),n=toChannel$4(r(e)).pipe(rne(e=>E3(t.reset,e)),Lre(e=>t.next(e).pipe(z7({onFailure:()=>fail$f(e),onSuccess:()=>n}),unwrap$8)));return n}),unwrap$8,fromChannel$2)),zle=dual(e=>isStream(e[0]),(e,t,r)=>suspend$7(()=>{const n=r?.preventFallbackOnPartialStream??!1;let i=0,s=none$c();const o=suspend$7(()=>{const r=t.steps[i++];if(!r)return fail$a(Xt(s));let a=FA(r.provide)?Ile(e,r.provide):Mle(e,r.provide),u=!1;if(zt(s)){const e=s.value;let t=!1;const n=a;a=suspend$7(()=>t?n:(t=!0,fail$a(e))),a=scheduleDefectRefail(Ble(a,scheduleFromStep(r,!1)))}else{const e=scheduleFromStep(r,!0);a=e?scheduleDefectRefail(Ble(a,e)):a}return Nue(n?Bce(a,e=>(u=!0,e)):a,e=>n&&u?fail$a(e):(s=Ut(e),o))});return o})),scheduleDefectRefail=e=>jue(e,e=>failCause$4(scheduleDefectRefailCause(e))),qle=dual(2,(e,t)=>toChannel$4(e).pipe(fne(toChannel$5(t)),runDrain$3)),Wle=dual(3,(e,t,n)=>Jle(e,t,r,n)),Vle=dual(3,(e,t,n)=>Hle(e,t,r,n)),Kle=dual(3,(e,t,n)=>pipe(e,Zle(t,r,n))),Gle=dual(3,(e,t,n)=>pipe(e,Qle(t,r,n))),Jle=dual(4,(e,t,r,n)=>qle(e,fold$1(t,r,n))),Hle=dual(4,(e,t,r,n)=>qle(e,foldEffect$1(t,r,n))),Zle=dual(4,(e,t,r,n)=>pipe(e,cpe(fold$1(t,r,n)))),Qle=dual(4,(e,t,r,n)=>pipe(e,cpe(foldEffect$1(t,r,n)))),Yle=dual(2,(e,t)=>qle(e,forEach$b(t))),Xle=dual(2,(e,t)=>qle(e,forEachChunk$1(t))),epe=dual(2,(e,t)=>pipe(e,cpe(forEachChunk$1(t)))),tpe=dual(2,(e,t)=>pipe(e,cpe(forEach$b(t)))),rpe=dual(2,(e,t)=>qle(e,forEachWhile$1(t))),npe=dual(2,(e,t)=>pipe(e,cpe(forEachWhile$1(t)))),ipe=dual(2,(e,t)=>pipe(e,ope(t))),spe=dual(2,(e,t)=>pipe(e,upe(t))),ope=dual(2,(e,t)=>pipe(e,upe(t),Q3)),ape=dual(2,(e,t)=>{const r=readWithCause$1({onInput:e=>Zte(fromEffect$b(ute(t,fC(e,NU))),()=>r),onFailure:e=>fromEffect$b(ate(t,OU(XQ(e,Ut)))),onDone:()=>fromEffect$b(ate(t,TU(none$c())))});return pipe(Yte(toChannel$4(e),r),drain$5,runScoped$3,C3)}),upe=dual(2,(e,t)=>{const r=readWithCause$1({onInput:e=>Zte(write$1(chunk$3(e)),()=>r),onFailure:e=>write$1(failCause$6(e)),onDone:()=>write$1(Hae)});return pipe(Yte(toChannel$4(e),r),rne(e=>ate(t,e)),drain$5,runScoped$3,C3)}),cpe=dual(2,(e,t)=>pipe(toChannel$4(e),fne(toChannel$5(t)),drain$5,runScoped$3)),lpe=dual(3,(e,t,r)=>pipe(e,mpe(t,(e,t)=>G4(r(e,t))))),ppe=dual(2,(e,t)=>pipe(e,fpe((e,r)=>G4(t(e,r))))),fpe=dual(2,(e,t)=>pipe(e,Uce(none$c(),(e,r)=>{switch(e._tag){case"None":return G4([Ut(r),r]);case"Some":return pipe(t(e.value,r),P3(e=>[Ut(e),e]))}}))),hpe=dual(2,(e,t)=>hce(dpe(e,t,{onElement:Ut,onSchedule:none$c}),identity$5)),dpe=dual(3,(e,t,r)=>{const loop=(e,t)=>{const n=t.next();return n.done?readWithCause$1({onInput:t=>loop(e,t[Symbol.iterator]()),onFailure:failCause$8,onDone:succeedNow}):unwrap$8(V7(e.next(n.value),{onFailure:()=>pipe(e.last,i8,P3(i=>pipe(write$1(make$2d(r.onElement(n.value),r.onSchedule(i))),Zte(()=>loop(e,t)))),N8(e.reset)),onSuccess:()=>G4(pipe(write$1(of$5(r.onElement(n.value))),Zte(()=>loop(e,t))))}))};return new StreamImpl(pipe(fromEffect$b(Aie(t)),Zte(t=>pipe(toChannel$4(e),Yte(loop(t,empty$R()[Symbol.iterator]()))))))}),mpe=dual(3,(e,t,r)=>new StreamImpl(pipe(write$1(of$5(t)),Zte(()=>toChannel$4(pipe(e,Uce(t,(e,t)=>pipe(r(e,t),P3(e=>[e,e]))))))))),scoped$2=e=>new StreamImpl(Gre(scoped$3(pipe(e,P3(of$5))),Q4)),scopedWith$2=e=>new StreamImpl(scopedWith$3(t=>e(t).pipe(P3(of$5)))),gpe=dual(2,(e,t)=>pipe(e,Dce(Kt(t)))),ype=dual(2,(e,t)=>Gce(e,qt({onNone:()=>U4(t),onSome:G4}))),bpe=dual(2,(e,t)=>Spe(e,t,1)),Spe=dual(3,(e,t,r)=>t<=0||r<=0?die$4(new tY("Invalid bounds - `chunkSize` and `stepSize` must be greater than zero")):new StreamImpl(suspend$b(()=>{const n=new RingBuffer(t),emitOnStreamEnd=(e,i)=>{if(e<t){const e=n.toChunk(),t=isEmpty$t(e)?empty$R():of$5(e);return pipe(write$1(t),Zte(()=>i))}const s=e-(e-t)%r;if(s===e)return i;const o=e-(s-t+r),a=pipe(n.toChunk(),wC(o)),u=isEmpty$t(a)?empty$R():of$5(a);return pipe(write$1(u),Zte(()=>i))},reader=e=>readWithCause$1({onInput:i=>Zte(write$1(tC(i,(i,s)=>{n.put(i);const o=e+s+1;return o<t||(o-t)%r>0?none$c():Ut(n.toChunk())})),()=>reader(e+i.length)),onFailure:t=>emitOnStreamEnd(e,failCause$8(t)),onDone:()=>emitOnStreamEnd(e,ere)});return pipe(toChannel$4(e),Yte(reader(0)))}))),vpe=dual(2,(e,t)=>{const split=(e,r)=>{const[n,i]=pipe(e,eC(r),_C(t));return isEmpty$t(n)||isEmpty$t(i)?loop(pipe(n,eC(pipe(i,ZA(1))))):pipe(write$1(of$5(n)),Zte(()=>split(empty$R(),pipe(i,ZA(1)))))},loop=e=>readWith$1({onInput:t=>split(e,t),onFailure:fail$f,onDone:()=>isEmpty$t(e)?ere:Bt(pipe(e,RC(t)))?_ne(write$1(of$5(e)),ere):_ne(split(empty$R(),e),ere)});return new StreamImpl(pipe(toChannel$4(e),Yte(loop(empty$R()))))}),_pe=dual(2,(e,t)=>{const next=(e,r)=>readWithCause$1({onInput:n=>{let i;const[s,o]=pipe(n,qC([pipe(e,Kt(()=>empty$R())),r],([e,r],n)=>{const s=pipe(e,GA(n));return r<t.length&&equals$4(n,pipe(t,KA(r)))?r+1===t.length?(void 0===i&&(i=[]),i.push(pipe(s,HA(s.length-t.length))),[empty$R(),0]):[s,r+1]:[s,equals$4(n,pipe(t,KA(0)))?1:0]})),a=void 0===i?empty$R():unsafeFromArray(i);return Zte(write$1(a),()=>next(isNonEmpty$8(s)?Ut(s):none$c(),o))},onFailure:t=>qt(e,{onNone:()=>failCause$8(t),onSome:e=>_ne(write$1(of$5(e)),failCause$8(t))}),onDone:t=>qt(e,{onNone:()=>succeed$g(t),onSome:e=>_ne(write$1(of$5(e)),succeed$g(t))})});return new StreamImpl(pipe(toChannel$4(e),Yte(next(none$c(),0))))}),succeed$b=e=>fromChunk$1(of$5(e)),sync$8=e=>suspend$7(()=>fromChunk$1(of$5(e()))),suspend$7=e=>new StreamImpl(suspend$b(()=>toChannel$4(e()))),wpe=dual(2,(e,t)=>{if(!Number.isInteger(t))return die$4(new tY(t+" must be an integer"));const loop=e=>readWith$1({onInput:t=>{const r=pipe(t,HA(Math.min(e,1/0))),n=Math.max(0,e-r.length);return n>0?pipe(write$1(r),Zte(()=>loop(n))):write$1(r)},onFailure:fail$f,onDone:succeed$g});return new StreamImpl(pipe(toChannel$4(e),fne(0<t?loop(t):ere)))}),kpe=dual(2,(e,t)=>t<=0?uce:new StreamImpl(pipe(G4(new RingBuffer(t)),P3(t=>{const r=readWith$1({onInput:e=>{for(const r of e)t.put(r);return r},onFailure:fail$f,onDone:()=>pipe(write$1(t.toChunk()),_ne(ere))});return pipe(toChannel$4(e),Yte(r))}),unwrap$8))),xpe=dual(2,(e,t)=>{const r=readWith$1({onInput:e=>{const n=pipe(e,kC(e=>!t(e))),i=pipe(e,ZA(n.length),HA(1));return isEmpty$t(i)?pipe(write$1(n),Zte(()=>r)):write$1(pipe(n,eC(i)))},onFailure:fail$f,onDone:succeed$g});return new StreamImpl(pipe(toChannel$4(e),fne(r)))}),Ipe=dual(2,(e,t)=>{const loop=e=>{const r=e.next();return r.done?readWithCause$1({onInput:e=>loop(e[Symbol.iterator]()),onFailure:failCause$8,onDone:succeed$g}):pipe(t(r.value),P3(t=>t?write$1(of$5(r.value)):pipe(write$1(of$5(r.value)),Zte(()=>loop(e)))),unwrap$8)};return new StreamImpl(pipe(toChannel$4(e),Yte(loop(empty$R()[Symbol.iterator]()))))}),Tpe=dual(2,(e,t)=>{const r=readWith$1({onInput:e=>{const n=pipe(e,kC(t));return n.length===e.length?pipe(write$1(n),Zte(()=>r)):write$1(n)},onFailure:fail$f,onDone:succeed$g});return new StreamImpl(pipe(toChannel$4(e),fne(r)))}),Ope=dual(2,(e,t)=>Gce(e,e=>E3(t(e),e))),Epe=dual(2,(e,t)=>pipe(e,Ape(t.onFailure),Ope(t.onSuccess))),Ape=dual(2,(e,t)=>Nue(e,e=>fromEffect$7(j8(t(e),L4(e))))),Cpe=dual(2,(e,t)=>{const r=readWithCause$1({onInput:e=>Zte(write$1(e),()=>r),onFailure:e=>fromEffect$b(j8(t(e),$4(e))),onDone:succeedNow});return new StreamImpl(pipe(toChannel$4(e),Yte(r)))}),Mpe=dual(2,(e,t)=>pipe(fromEffect$7(d4([bounded$4(1),fU()])),Sce(([r,n])=>{const i=flattenTake$1(fromQueue$3(r,{maxChunkSize:1})),s=readWithCause$1({onInput:e=>pipe(fromEffect$b(ate(r,chunk$3(e))),Qte({onFailure:()=>Zte(write$1(e),()=>identityChannel()),onSuccess:()=>Zte(write$1(e),()=>s)})),onFailure:e=>pipe(fromEffect$b(ate(r,failCause$6(e))),Qte({onFailure:()=>failCause$8(e),onSuccess:()=>failCause$8(e)})),onDone:()=>pipe(fromEffect$b(ate(r,Hae)),Qte({onFailure:()=>ere,onSuccess:()=>ere}))});return pipe(new StreamImpl(pipe(Yte(toChannel$4(e),s),Gre(j8(a5(ate(r,Hae)),hU(n))))),Qce(execute$1(pipe(qle(i,t),q3(j8(shutdown$4(r),yU(n,void 0)))))))}))),Fpe=dual(2,(e,t)=>Ppe(e,{...t,cost:e=>G4(t.cost(e))})),Ppe=dual(2,(e,t)=>"enforce"===t.strategy?throttleEnforceEffect(e,t.cost,t.units,t.duration,t.burst??0):throttleShapeEffect(e,t.cost,t.units,t.duration,t.burst??0)),throttleEnforceEffect=(e,t,r,n,i)=>{const loop=(e,s)=>readWithCause$1({onInput:o=>pipe(t(o),P8(_B),P3(([t,a])=>{const u=(a-s)/toMillis(n),c=e+u*r,l=r+i<0?1/0:r+i,p=c<0?l:Math.min(c,l);return t<=p?pipe(write$1(o),Zte(()=>loop(p-t,a))):loop(e,s)}),unwrap$8),onFailure:failCause$8,onDone:()=>ere}),s=pipe(_B,P3(e=>loop(r,e)),unwrap$8);return new StreamImpl(pipe(toChannel$4(e),fne(s)))},throttleShapeEffect=(e,t,r,n,i)=>{const loop=(e,s)=>readWithCause$1({onInput:o=>pipe(t(o),P8(_B),P3(([t,a])=>{const u=(a-s)/toMillis(n),c=e+u*r,l=r+i<0?1/0:r+i,p=(c<0?l:Math.min(c,l))-t,d=millis(Math.max(0,(p>=0?0:-p/r)*toMillis(n)));return kM(d,iM)?pipe(fromEffect$b(sleep$4(d)),_ne(write$1(o)),Zte(()=>loop(p,a))):Zte(write$1(o),()=>loop(p,a))}),unwrap$8),onFailure:failCause$8,onDone:()=>ere}),s=pipe(_B,P3(e=>loop(r,e)),unwrap$8);return new StreamImpl(pipe(toChannel$4(e),fne(s)))},Npe=dual(2,(e,t)=>pipe(toPull$2(e),P3(C5({onTimeout:()=>none$c(),duration:t})),fromPull$2)),jpe=dual(3,(e,t,r)=>pipe(e,Dpe(r,failSync$4(t)))),Rpe=dual(3,(e,t,r)=>pipe(toPull$2(e),P3(M5({onTimeout:()=>XQ(t(),Ut),duration:r})),fromPull$2)),Dpe=dual(3,(e,t,r)=>{const n=new nY("Stream Timeout");return pipe(e,Rpe(()=>qQ(n),t),Due(e=>JQ(e)&&isRuntimeException(e.defect)&&void 0!==e.defect.message&&"Stream Timeout"===e.defect.message?Ut(r):none$c()))}),pubsubFromOptions=e=>{if("number"==typeof e)return bounded$5(e);if("unbounded"===e.capacity)return unbounded$5({replay:e.replay});switch(e.strategy){case"dropping":return dropping$5(e);case"sliding":return sliding$7(e);default:return bounded$5(e)}},Lpe=dual(2,(e,t)=>pipe(U3(pubsubFromOptions(t),e=>shutdown$5(e)),v7(t=>pipe(e,spe(t),l5)))),toPull$2=e=>P3(toPull$3(toChannel$4(e)),e=>pipe(e,R3(Ut),h7(ot({onLeft:()=>L4(none$c()),onRight:G4})))),Upe=dual(e=>isStream(e[0]),(e,t)=>v7(U3("unbounded"===t?.strategy?ote():"dropping"===t?.strategy?dropping$4(t.capacity??2):"sliding"===t?.strategy?sliding$6(t.capacity??2):bounded$4(t?.capacity??2),e=>shutdown$4(e)),t=>l5(upe(e,t)))),$pe=dual(e=>isStream(e[0]),(e,t)=>v7(U3(bounded$4(t?.capacity??2),e=>shutdown$4(e)),t=>l5(ape(e,t)))),Bpe=dual(e=>isStream(e[0]),(e,t)=>qpe(e,Iie,t)),zpe=dual(e=>isStream(e[0]),(e,t)=>P3(h8(),r=>qpe(e,r,t))),qpe=dual(e=>isStream(e[0]),(e,t,r)=>{const n=Sie(t);let i,s;const o=x8(!1);return new ReadableStream({start(t){s=n(Xle(e,e=>0===e.length?Q4:o.whenOpen(Z4(()=>{o.unsafeClose();for(const r of e)t.enqueue(r);i(),i=void 0})))),s.addObserver(e=>{try{"Failure"===e._tag?t.error(squash(e.cause)):t.close()}catch{}})},pull:()=>new Promise(e=>{i=e,A8(o.open)}),cancel(){if(s)return O8(C3(yX(s)))}},r?.strategy)}),Wpe=dual(2,(e,t)=>{const r=suspend$b(()=>{const r={ref:empty$R()},n={ref:!1},i=suspend$b(()=>{const e=r.ref;return isEmpty$t(e)?readWith$1({onInput:e=>pipe(write$1(e),Zte(()=>i)),onFailure:fail$f,onDone:succeedNow}):(r.ref=empty$R(),pipe(writeChunk$1(e),Zte(()=>i)))}),concatAndGet=e=>{const t=r.ref,n=eC(t,rC(e,e=>0!==e.length));return r.ref=n,n},s=readWith$1({onInput:e=>Zte(write$1(e),()=>s),onFailure:fail$f,onDone:e=>_ne(sync$c(()=>{n.ref=!0}),succeedNow(e))}),o=pipe(t,toChannel$5,collectElements,Zte(([e,t])=>pipe(succeed$g([n.ref,concatAndGet(e)]),Zte(([e,r])=>{const n=e&&isEmpty$t(r)?ere:o;return pipe(write$1(of$5(t)),Zte(()=>n))}))));return pipe(toChannel$4(e),Yte(s),Yte(i),fne(o))});return new StreamImpl(r)}),Vpe=dual(e=>isStream(e[0]),(e,t)=>{const r=Sie(t);return{[Symbol.asyncIterator](){let t,n,i;const s=x8(!1);let o=!1;return{next:()=>(i||(i=r(Yle(e,e=>s.whenOpen(Z4(()=>{s.unsafeClose(),t({done:!1,value:e}),t=n=void 0})))),i.addObserver(e=>{o||(i=I8(s.whenOpen(Z4(()=>{"Failure"===e._tag?n(squash(e.cause)):t({done:!0,value:void 0}),t=n=void 0}))))})),new Promise((e,r)=>{t=e,n=r,s.unsafeOpen()})),return:()=>(o=!0,i?O8(E3(yX(i),{done:!0,value:void 0})):Promise.resolve({done:!0,value:void 0}))}}}}),unfold$1=(e,t)=>unfoldChunk$1(e,e=>pipe(t(e),er(([e,t])=>[of$5(e),t]))),unfoldChunk$1=(e,t)=>{const loop=e=>qt(t(e),{onNone:()=>ere,onSome:([e,t])=>Zte(write$1(e),()=>loop(t))});return new StreamImpl(suspend$b(()=>loop(e)))},unfoldChunkEffect$1=(e,t)=>suspend$7(()=>{const loop=e=>unwrap$8(P3(t(e),qt({onNone:()=>ere,onSome:([e,t])=>Zte(write$1(e),()=>loop(t))})));return new StreamImpl(loop(e))}),unfoldEffect$1=(e,t)=>unfoldChunkEffect$1(e,e=>pipe(t(e),P3(er(([e,t])=>[of$5(e),t])))),Kpe=succeed$b(void 0),unwrap$6=e=>_ce(fromEffect$7(e)),unwrapScoped$3=e=>_ce(scoped$2(e)),unwrapScopedWith$3=e=>_ce(scopedWith$2(t=>e(t))),Gpe=dual(3,(e,t,r)=>pipe(e,Cle(e=>pipe(e,NA(t,r(pipe(e,RA(t)))))))),Jpe=dual(2,(e,t)=>pipe(e,Zpe(Z4(t)))),Hpe=dual(2,(e,t)=>pipe(fromEffect$7(e),Sce(e=>pipe(t(e),Kt(()=>uce))))),Zpe=dual(2,(e,t)=>pipe(fromEffect$7(t),Sce(t=>t?e:uce))),Qpe=dual(2,(e,t)=>pipe(e,pfe(t,(e,t)=>[e,t]))),Ype=dual(2,(e,t)=>pipe(e,pfe(t,(e,t)=>[...e,t]))),Xpe=dual(2,(e,t)=>ofe(e,{other:t.other,onSelf:e=>[e,t.defaultOther],onOther:e=>[t.defaultSelf,e],onBoth:(e,t)=>[e,t]})),efe=dual(3,(e,t,r)=>ofe(e,{other:t,onSelf:identity$5,onOther:()=>r,onBoth:e=>e})),tfe=dual(3,(e,t,r)=>ofe(e,{other:t,onSelf:()=>r,onOther:identity$5,onBoth:(e,t)=>t})),rfe=dual(2,(e,t)=>sfe(e,{other:t.other,onSelf:e=>[e,t.defaultOther],onOther:e=>[t.defaultSelf,e],onBoth:(e,t)=>[e,t],order:t.order})),nfe=dual(2,(e,t)=>sfe(e,{other:t.other,onSelf:identity$5,onOther:()=>t.defaultSelf,onBoth:e=>e,order:t.order})),ife=dual(2,(e,t)=>sfe(e,{other:t.other,onSelf:()=>t.defaultOther,onOther:identity$5,onBoth:(e,t)=>t,order:t.order})),sfe=dual(2,(e,t)=>{const pull=(e,r,n)=>{switch(e._tag){case iue:return pipe(r,z7({onFailure:TU,onSuccess:e=>NU([fC(e,([e,r])=>[e,t.onSelf(r)]),cue])}));case sue:return pipe(n,z7({onFailure:TU,onSuccess:e=>NU([fC(e,([e,r])=>[e,t.onOther(r)]),lue])}));case oue:return pipe(unsome$1(r),P8(unsome$1(n),{concurrent:!0}),V7({onFailure:e=>G4(TU(Ut(e))),onSuccess:([e,i])=>zt(e)&&zt(i)?isEmpty$t(e.value)&&isEmpty$t(i.value)?pull(pue,r,n):isEmpty$t(e.value)?pull(PullLeft$1(i.value),r,n):isEmpty$t(i.value)?pull(PullRight$1(e.value),r,n):G4(NU(merge(e.value,i.value))):zt(e)&&Bt(i)?isEmpty$t(e.value)?pull(cue,r,n):G4(NU([pipe(e.value,fC(([e,r])=>[e,t.onSelf(r)])),cue])):Bt(e)&&zt(i)?isEmpty$t(i.value)?pull(lue,r,n):G4(NU([pipe(i.value,fC(([e,r])=>[e,t.onOther(r)])),lue])):G4(TU(none$c()))}));case aue:return V7(r,{onFailure:qt({onNone:()=>G4(NU([pipe(e.rightChunk,fC(([e,r])=>[e,t.onOther(r)])),lue])),onSome:e=>G4(TU(Ut(e)))}),onSuccess:t=>isEmpty$t(t)?pull(PullLeft$1(e.rightChunk),r,n):G4(NU(merge(t,e.rightChunk)))});case uue:return V7(n,{onFailure:qt({onNone:()=>G4(NU([fC(e.leftChunk,([e,r])=>[e,t.onSelf(r)]),cue])),onSome:e=>G4(TU(Ut(e)))}),onSuccess:t=>isEmpty$t(t)?pull(PullRight$1(e.leftChunk),r,n):G4(NU(merge(e.leftChunk,t)))})}},merge=(e,r)=>{const hasNext=(e,t)=>t<e.length-1,n=[];let i,s=0,o=0,a=pipe(e,KA(s)),u=pipe(r,KA(o)),c=a[0],l=a[1],p=u[0],d=u[1],m=!0;for(;m;){const g=t.order(c,p);if(0===g)n.push([c,t.onBoth(l,d)]),hasNext(e,s)&&hasNext(r,o)?(s+=1,o+=1,a=pipe(e,KA(s)),u=pipe(r,KA(o)),c=a[0],l=a[1],p=u[0],d=u[1]):hasNext(e,s)?(i=PullRight$1(pipe(e,ZA(s+1))),m=!1):hasNext(r,o)?(i=PullLeft$1(pipe(r,ZA(o+1))),m=!1):(i=pue,m=!1);else if(g<0)if(n.push([c,t.onSelf(l)]),hasNext(e,s))s+=1,a=pipe(e,KA(s)),c=a[0],l=a[1];else{const e=[];for(e.push(u);hasNext(r,o);)o+=1,u=pipe(r,KA(o)),e.push(u);i=PullLeft$1(unsafeFromArray(e)),m=!1}else if(n.push([p,t.onOther(d)]),hasNext(r,o))o+=1,u=pipe(r,KA(o)),p=u[0],d=u[1];else{const t=[];for(t.push(a);hasNext(e,s);)s+=1,a=pipe(e,KA(s)),t.push(a);i=PullRight$1(unsafeFromArray(t)),m=!1}}return[unsafeFromArray(n),i]};return Wue(e,t.other,pue,pull)}),ofe=dual(2,(e,t)=>{const pull=(e,r,n)=>{switch(e._tag){case iue:return V7(r,{onFailure:e=>G4(TU(e)),onSuccess:e=>G4(NU([fC(e,t.onSelf),cue]))});case sue:return V7(n,{onFailure:e=>G4(TU(e)),onSuccess:e=>G4(NU([fC(e,t.onOther),lue]))});case oue:return pipe(unsome$1(r),P8(unsome$1(n),{concurrent:!0}),V7({onFailure:e=>G4(TU(Ut(e))),onSuccess:([e,i])=>zt(e)&&zt(i)?isEmpty$t(e.value)&&isEmpty$t(i.value)?pull(pue,r,n):isEmpty$t(e.value)?pull(PullLeft$1(i.value),r,n):isEmpty$t(i.value)?pull(PullRight$1(e.value),r,n):G4(NU(zip(e.value,i.value,t.onBoth))):zt(e)&&Bt(i)?G4(NU([fC(e.value,t.onSelf),cue])):Bt(e)&&zt(i)?G4(NU([fC(i.value,t.onOther),lue])):G4(TU(none$c()))}));case aue:return V7(r,{onFailure:qt({onNone:()=>G4(NU([fC(e.rightChunk,t.onOther),lue])),onSome:e=>G4(TU(Ut(e)))}),onSuccess:i=>isEmpty$t(i)?pull(PullLeft$1(e.rightChunk),r,n):isEmpty$t(e.rightChunk)?pull(PullRight$1(i),r,n):G4(NU(zip(i,e.rightChunk,t.onBoth)))});case uue:return V7(n,{onFailure:qt({onNone:()=>G4(NU([fC(e.leftChunk,t.onSelf),cue])),onSome:e=>G4(TU(Ut(e)))}),onSuccess:i=>isEmpty$t(i)?pull(PullRight$1(e.leftChunk),r,n):isEmpty$t(e.leftChunk)?pull(PullLeft$1(i),r,n):G4(NU(zip(e.leftChunk,i,t.onBoth)))})}},zip=(e,t,r)=>{const[n,i]=zipChunks(e,t,r);switch(i._tag){case"Left":return isEmpty$t(i.left)?[n,pue]:[n,PullRight$1(i.left)];case"Right":return isEmpty$t(i.right)?[n,pue]:[n,PullLeft$1(i.right)]}};return Wue(e,t.other,pue,pull)}),afe=dual(2,(e,t)=>pipe(e,ufe(t,(e,t)=>[e,t]))),zipLatestAll$1=(...e)=>{if(0===e.length)return uce;if(1===e.length)return Dce(e[0],e=>[e]);const[t,...r]=e;return ufe(t,zipLatestAll$1(...r),(e,t)=>[e,...t])},ufe=dual(3,(e,t,r)=>{const pullNonEmpty=e=>pipe(e,h7(t=>isEmpty$t(t)?pullNonEmpty(e):G4(t)));return pipe(toPull$2(e),P3(pullNonEmpty),P8(pipe(toPull$2(t),P3(pullNonEmpty))),h7(([e,t])=>pipe(fromEffectOption$1(b7(e,t,{onSelfDone:(e,t)=>pipe(H4(()=>e),R8(vX(t),(e,t)=>[e,t,!0])),onOtherDone:(e,t)=>pipe(H4(()=>e),R8(vX(t),(e,t)=>[t,e,!1]))})),Sce(([n,i,s])=>pipe(fromEffect$7(Nz([unsafeLast$1(n),unsafeLast$1(i)])),Sce(o=>pipe(fromChunk$1(s?pipe(i,fC(e=>r(unsafeLast$1(n),e))):pipe(n,fC(e=>r(e,unsafeLast$1(i))))),Vue(pipe(repeatEffectOption$1(e),ele(repeatEffectOption$1(t)),Gce(ot({onLeft:e=>Uz(o,([t,n])=>[pipe(e,fC(e=>r(e,n))),[unsafeLast$1(e),n]]),onRight:e=>Uz(o,([t,n])=>[pipe(e,fC(e=>r(t,e))),[t,unsafeLast$1(e)]])})),Sce(fromChunk$1))))))),toPull$2)),fromPull$2)}),cfe=dual(2,(e,t)=>pipe(e,ffe(t,(e,t)=>e.length>t.length?[pipe(e,HA(t.length)),He(pipe(e,HA(t.length)))]:[e,Ge(pipe(t,ZA(e.length)))]))),lfe=dual(2,(e,t)=>pipe(e,ffe(t,(e,t)=>e.length>t.length?[t,He(pipe(e,HA(t.length)))]:[pipe(t,HA(e.length)),Ge(pipe(t,ZA(e.length)))]))),pfe=dual(3,(e,t,r)=>pipe(e,ffe(t,(e,t)=>zipChunks(e,t,r)))),ffe=dual(3,(e,t,r)=>{const pull=(e,t,r)=>{switch(e._tag){case fue:return pipe(unsome$1(t),P8(unsome$1(r),{concurrent:!0}),V7({onFailure:e=>G4(TU(Ut(e))),onSuccess:([e,n])=>zt(e)&&zt(n)?isEmpty$t(e.value)&&isEmpty$t(n.value)?pull(mue,t,r):isEmpty$t(e.value)?pull(PullLeft(n.value),t,r):isEmpty$t(n.value)?pull(PullRight(e.value),t,r):G4(NU(zip(e.value,n.value))):G4(TU(none$c()))}));case hue:return V7(t,{onFailure:e=>G4(TU(e)),onSuccess:n=>isEmpty$t(n)?pull(PullLeft(e.rightChunk),t,r):isEmpty$t(e.rightChunk)?pull(PullRight(n),t,r):G4(NU(zip(n,e.rightChunk)))});case due:return V7(r,{onFailure:e=>G4(TU(e)),onSuccess:n=>isEmpty$t(n)?pull(PullRight(e.leftChunk),t,r):isEmpty$t(e.leftChunk)?pull(PullLeft(n),t,r):G4(NU(zip(e.leftChunk,n)))})}},zip=(e,t)=>{const[n,i]=r(e,t);switch(i._tag){case"Left":return isEmpty$t(i.left)?[n,mue]:[n,PullRight(i.left)];case"Right":return isEmpty$t(i.right)?[n,mue]:[n,PullLeft(i.right)]}};return pipe(e,Wue(t,mue,pull))}),zipWithIndex$1=e=>pipe(e,Lce(0,(e,t)=>[e+1,[t,e]])),zipWithNext$1=e=>{const process=e=>readWithCause$1({onInput:t=>{const[r,n]=hC(t,e,(e,t)=>[Ut(t),pipe(e,er(e=>[e,t]))]),i=tC(n,e=>zt(e)?Ut([e.value[0],Ut(e.value[1])]):none$c());return Zte(write$1(i),()=>process(r))},onFailure:failCause$8,onDone:()=>qt(e,{onNone:()=>ere,onSome:e=>_ne(write$1(of$5([e,none$c()])),ere)})});return new StreamImpl(pipe(toChannel$4(e),fne(process(none$c()))))},zipWithPrevious$1=e=>pipe(e,Lce(none$c(),(e,t)=>[Ut(t),[e,t]])),zipChunks=(e,t,r)=>e.length>t.length?[pipe(e,HA(t.length),IC(t,r)),He(pipe(e,ZA(t.length)))]:[pipe(e,IC(pipe(t,HA(e.length)),r)),Ge(pipe(t,ZA(e.length)))],hfe=succeed$b({}),dfe=dual(e=>"string"!=typeof e[0],(e,t,r,n)=>Sce(e,e=>Dce(r(e),r=>({...e,[t]:r})),n)),mfe=bindTo$a(Dce),gfe=let_$a(Dce),yfe=dual(e=>isStream(e[0]),(e,t="utf-8")=>suspend$7(()=>{const r=new TextDecoder(t);return Dce(e,e=>r.decode(e))}));var bfe=Object.freeze({__proto__:null,ChannelException:ChannelException$1,ChannelExceptionTypeId:wne,ChannelTypeId:zte,acquireReleaseOut:Wte,acquireUseRelease:acquireUseRelease$3,as:Dre,asVoid:e=>Qre(e,o),buffer:buffer$3,bufferChunk:bufferChunk$1,catchAll:Lre,catchAllCause:Vte,collect:$re,concatAll:concatAll$3,concatAllWith:concatAllWith$1,concatMap:Ure,concatMapWith:Kte,concatMapWithCustom:Gte,concatOut:e=>concatAll$3(e),context:context$7,contextWith:e=>Qre(context$7(),e),contextWithChannel:contextWithChannel$1,contextWithEffect:e=>Yre(context$7(),e),doneCollect:doneCollect$1,drain:drain$5,embedInput:Jte,emitCollect:e=>Zte(doneCollect$1(e),write$1),ensuring:Gre,ensuringWith:Hte,fail:fail$f,failCause:failCause$8,failCauseSync:failCauseSync$5,failSync:failSync$7,flatMap:Zte,flatten:flatten$5,foldCauseChannel:Qte,foldChannel:Jre,fromEffect:fromEffect$b,fromEither:e=>suspend$b(()=>ot(e,{onLeft:fail$f,onRight:succeed$g})),fromInput:fromInput$3,fromOption:e=>suspend$b(()=>qt(e,{onNone:()=>fail$f(none$c()),onSome:succeed$g})),fromPubSub:e=>unwrapScoped$5(P3(subscribe$2(e),fromQueue$5)),fromPubSubScoped:e=>P3(subscribe$2(e),fromQueue$5),fromQueue:fromQueue$5,identity:identityChannel,interruptWhen:Hre,interruptWhenDeferred:Zre,isChannel:isChannel$1,isChannelException:isChannelException$1,map:Qre,mapEffect:Yre,mapError:Xre,mapErrorCause:ene,mapInput:Bre,mapInputContext:mne,mapInputEffect:zre,mapInputError:qre,mapInputErrorEffect:Wre,mapInputIn:Vre,mapInputInEffect:Kre,mapOut:tne,mapOutEffect:rne,mapOutEffectPar:nne,mergeAll:mergeAll$5,mergeAllUnbounded:e=>mergeAllWith$1({concurrency:"unbounded"})(e,o),mergeAllUnboundedWith:(e,t)=>mergeAllWith$1({concurrency:"unbounded"})(e,t),mergeAllWith:mergeAllWith$1,mergeMap:ine,mergeOut:sne,mergeOutWith:one,mergeWith:ane,never:une,orDie:cne,orDieWith:lne,orElse:pne,pipeTo:Yte,pipeToOrFail:fne,provideContext:Xte,provideLayer:dne,provideService:hne,provideSomeLayer:gne,read:()=>readOrFail$1(none$c()),readOrFail:readOrFail$1,readWith:readWith$1,readWithCause:readWithCause$1,repeated:repeated$2,run:run$7,runCollect:e=>run$7(collectElements(e)),runDrain:runDrain$3,runScoped:runScoped$3,scoped:scoped$3,scopedWith:scopedWith$3,splitLines:splitLines$3,succeed:succeed$g,suspend:suspend$b,sync:sync$c,toPubSub:toPubSub$3,toPull:toPull$3,toPullIn:yne,toQueue:toQueue$3,toSink:e=>new SinkImpl(e),toStream:e=>new StreamImpl(e),unwrap:unwrap$8,unwrapScoped:unwrapScoped$5,unwrapScopedWith:unwrapScopedWith$5,updateService:bne,void:ere,withSpan:withSpan$3,write:write$1,writeAll:writeAll$1,writeChunk:writeChunk$1,zip:Sne,zipLeft:vne,zipRight:_ne});var Sfe=Object.freeze({__proto__:null,ChildExecutorDecisionTypeId:yte,Close:e=>{const t=Object.create(bte);return t._tag=mte,t.value=e,t},Continue:Continue$1,Yield:e=>{const t=Object.create(bte);return t._tag=gte,t},isChildExecutorDecision:e=>C(e,yte),isClose:e=>e._tag===mte,isContinue:e=>e._tag===dte,isYield:e=>e._tag===gte,match:Ste});const vfe=InvalidData$1,isMissingDataOnly=e=>k$(e,void 0,w$);var _fe=Object.freeze({__proto__:null,And:And$1,ConfigErrorTypeId:S$,InvalidData:vfe,MissingData:MissingData$1,Or:Or$1,SourceUnavailable:SourceUnavailable$1,Unsupported:Unsupported$1,isAnd:e=>e._op===h$,isConfigError:e=>C(e,S$),isInvalidData:e=>e._op===m$,isMissingData:e=>e._op===g$,isMissingDataOnly,isOr:e=>e._op===d$,isSourceUnavailable:e=>e._op===y$,isUnsupported:e=>e._op===b$,prefixed:_$,reduceWithContext:k$});const wfe="effect/Redacted",kfe=globalValue("effect/Redacted/redactedRegistry",()=>new WeakMap),xfe=Symbol.for(wfe),Ife={[xfe]:{_A:e=>e},pipe(){return pipeArguments(this,arguments)},toString:()=>"<redacted>",toJSON:()=>"<redacted>",[ee]:()=>"<redacted>",[Z](){return pipe(hash$3(wfe),combine$h(hash$3(kfe.get(this))),cached$2(this))},[Y](e){return isRedacted$1(e)&&equals$4(kfe.get(this),kfe.get(e))}},isRedacted$1=e=>C(e,xfe),make$1c=e=>{const t=Object.create(Ife);return kfe.set(t,e),t},Tfe=Symbol.for("effect/Secret"),Ofe={...Ife,[Tfe]:Tfe},make$1b=e=>{const t=Object.create(Ofe);return Object.defineProperty(t,"toString",{enumerable:!1,value:()=>"Secret(<redacted>)"}),Object.defineProperty(t,"toJSON",{enumerable:!1,value:()=>"<redacted>"}),Object.defineProperty(t,"raw",{enumerable:!1,value:e}),kfe.set(t,e.map(e=>String.fromCharCode(e)).join("")),t},fromString$1=e=>make$1b(e.split("").map(e=>e.charCodeAt(0))),Efe=Symbol.for("effect/Config"),Afe={...Me,[Efe]:{_A:e=>e},commit(){return e=this,configProviderWith$1(t=>t.load(e));var e}},chunk$2=(e,name)=>Cfe(void 0===name?repeat$2(e):Pfe(repeat$2(e),name),unsafeFromArray),Cfe=dual(2,(e,t)=>Ffe(e,e=>Ge(t(e)))),Mfe=dual(2,(e,t)=>Ffe(e,e=>{try{return Ge(t(e))}catch(e){return He(InvalidData$1([],e instanceof Error?e.message:""+e))}})),Ffe=dual(2,(e,t)=>{const r=Object.create(Afe);return r._tag=j$,r.original=e,r.mapOrFail=t,r}),Pfe=dual(2,(e,name)=>{const t=Object.create(Afe);return t._tag=R$,t.name=name,t.config=e,t}),Nfe=dual(2,(e,t)=>{const n=Object.create(Afe);return n._tag=F$,n.first=e,n.second=suspend$5(t),n.condition=r,n}),jfe=dual(2,(e,t)=>{const r=Object.create(Afe);return r._tag=F$,r.first=e,r.second=suspend$5(t.orElse),r.condition=t.if,r}),primitive$1=(description,e)=>{const t=Object.create(Afe);return t._tag=D$,t.description=description,t.parse=e,t},repeat$2=e=>{const t=Object.create(Afe);return t._tag=L$,t.config=e,t},Rfe=dual(2,(e,t)=>{const r=isConfig$1(e)?e:string$2(e);return Ffe(r,e=>t.either(e).pipe(it(e=>InvalidData$1([],e.map(e=>e.message).join("\n")))))}),string$2=name=>{const e=primitive$1("a text property",Ge);return void 0===name?e:Pfe(e,name)},struct=e=>{const t=Object.entries(e);let r=pipe(t[0][1],Cfe(e=>({[t[0][0]]:e})));if(1===t.length)return r;const n=t.slice(1);for(const[e,t]of n)r=pipe(r,Bfe(t,(t,r)=>({...t,[e]:r})));return r},succeed$9=e=>{const t=Object.create(Afe);return t._tag=C$,t.value=e,t.parse=()=>Ge(e),t},suspend$5=e=>{const t=Object.create(Afe);return t._tag=N$,t.config=e,t},isConfig$1=e=>C(e,Efe),tuple=e=>{if(0===e.length)return succeed$9([]);if(1===e.length)return Cfe(e[0],e=>[e]);let t=Cfe(e[0],e=>[e]);for(let r=1;r<e.length;r++){const n=e[r];t=pipe(t,Bfe(n,(e,t)=>[...e,t]))}return t},unwrap$4=e=>isConfig$1(e)?e:struct(Object.fromEntries(Object.entries(e).map(([e,t])=>[e,unwrap$4(t)]))),Dfe=dual(2,(e,{message:t,validation:r})=>Ffe(e,e=>r(e)?Ge(e):He(InvalidData$1([],t)))),Lfe=dual(2,(e,t)=>jfe(e,{orElse:()=>succeed$9(t),if:isMissingDataOnly})),Ufe=dual(2,(e,description)=>{const t=Object.create(Afe);return t._tag=P$,t.config=e,t.description=description,t}),$fe=dual(2,(e,t)=>Bfe(e,t,(e,t)=>[e,t])),Bfe=dual(3,(e,t,r)=>{const n=Object.create(Afe);return n._tag=$$,n.left=e,n.right=t,n.zip=r,n}),zfe=Ffe,qfe=string$2;var Wfe=Object.freeze({__proto__:null,ConfigTypeId:Efe,all:e=>Array.isArray(e)?tuple(e):Symbol.iterator in e?tuple([...e]):struct(e),array:(e,name)=>pipe(chunk$2(e,name),Cfe(toArray$9)),boolean:name=>{const e=primitive$1("a boolean property",e=>{switch(e){case"true":case"yes":case"on":case"1":return Ge(!0);case"false":case"no":case"off":case"0":return Ge(!1);default:{const t=InvalidData$1([],"Expected a boolean value but received "+e);return He(t)}}});return void 0===name?e:Pfe(e,name)},branded:Rfe,chunk:chunk$2,date:name=>{const e=primitive$1("a date property",e=>{const t=Date.parse(e);return Number.isNaN(t)?He(InvalidData$1([],"Expected a Date value but received "+e)):Ge(new Date(t))});return void 0===name?e:Pfe(e,name)},duration:name=>{const e=Ffe(string$2(),e=>{const t=eM(e);return Qe(t,()=>InvalidData$1([],"Expected a duration but received "+e))});return void 0===name?e:Pfe(e,name)},fail:e=>{const t=Object.create(Afe);return t._tag=M$,t.message=e,t.parse=()=>He(Unsupported$1([],e)),t},hashMap:(e,name)=>{const t=Object.create(Afe);return t._tag=U$,t.valueConfig=e,void 0===name?t:Pfe(t,name)},hashSet:(e,name)=>{const t=Cfe(chunk$2(e),fromIterable$r);return void 0===name?t:Pfe(t,name)},integer:name=>{const e=primitive$1("an integer property",e=>{const t=Number(e);return Number.isInteger(t)?Ge(t):He(InvalidData$1([],"Expected an integer value but received "+e))});return void 0===name?e:Pfe(e,name)},isConfig:isConfig$1,literal:(...e)=>name=>{const t=e.map(String).join(", "),r=primitive$1(`one of (${t})`,r=>{const n=e.find(e=>e+""===r);return void 0===n?He(InvalidData$1([],`Expected one of (${t}) but received ${r}`)):Ge(n)});return void 0===name?r:Pfe(r,name)},logLevel:name=>{const e=Ffe(string$2(),e=>{const t=e.toUpperCase(),r=wD.find(e=>e.label===t);return void 0===r?He(InvalidData$1([],"Expected a log level but received "+e)):Ge(r)});return void 0===name?e:Pfe(e,name)},map:Cfe,mapAttempt:Mfe,mapOrFail:zfe,nested:Pfe,nonEmptyString:name=>{const e=primitive$1("a non-empty text property",at(e=>e.length>0,()=>MissingData$1([],"Expected a non-empty string")));return void 0===name?e:Pfe(e,name)},number:name=>{const e=primitive$1("a number property",e=>{const t=Number(e);return Number.isNaN(t)?He(InvalidData$1([],"Expected a number value but received "+e)):Ge(t)});return void 0===name?e:Pfe(e,name)},option:e=>pipe(e,Cfe(Ut),jfe({orElse:()=>succeed$9(none$c()),if:isMissingDataOnly})),orElse:Nfe,orElseIf:jfe,port:name=>{const e=primitive$1("a network port property",e=>{const t=Number(e);return Number.isNaN(t)||t.toString()!==e.toString()||!Number.isInteger(t)||t<1||t>65535?He(InvalidData$1([],"Expected a network port value but received "+e)):Ge(t)});return void 0===name?e:Pfe(e,name)},primitive:primitive$1,redacted:e=>{const t=isConfig$1(e)?e:string$2(e);return Cfe(t,make$1c)},repeat:repeat$2,secret:name=>{const e=primitive$1("a secret property",e=>Ge(fromString$1(e)));return void 0===name?e:Pfe(e,name)},string:qfe,succeed:succeed$9,suspend:suspend$5,sync:e=>suspend$5(()=>succeed$9(e())),unwrap:unwrap$4,url:name=>{const e=primitive$1("an URL property",e=>try_$5({try:()=>new URL(e),catch:t=>InvalidData$1([],"Expected an URL value but received "+e)}));return void 0===name?e:Pfe(e,name)},validate:Dfe,withDefault:Lfe,withDescription:Ufe,zip:$fe,zipWith:Bfe});var Vfe=Object.freeze({__proto__:null,ConfigProvider:W$,ConfigProviderTypeId:q$,FlatConfigProviderTypeId:V$,constantCase:e=>K$(e,constantCase$2),fromEnv:fromEnv$1,fromFlat:fromFlat$1,fromJson:e=>{const t=as((e=>{const loopAny=(e,t)=>"string"==typeof t?make$2i([e,t]):"number"==typeof t||"boolean"==typeof t?make$2i([e,t+""]):oi(t)?loopArray(e,t):"object"==typeof t&&null!==t?loopObject(e,t):[],loopArray=(e,t)=>Qn(t,{onEmpty:()=>make$2i([e,"<nil>"]),onNonEmpty:us((t,r)=>loopAny(ri(e,(e=>({_tag:"KeyIndex",index:e}))(r)),t))}),loopObject=(e,t)=>Object.entries(t).filter(([,e])=>isNotNullable(e)).flatMap(([t,r])=>{const n=ri(e,{_tag:"KeyName",name:t}),i=loopAny(n,r);return ai(i)?make$2i([n,""]):i});return loopObject([],e)})(e),([e,t])=>[configPathToString(e).join("\ufeff"),t]);return fromMap$1(new Map(t),{pathDelim:"\ufeff",seqDelim:"\ufeff"})},fromMap:fromMap$1,kebabCase:e=>K$(e,kebabCase$2),lowerCase:e=>K$(e,lowerCase$2),make:make$1V,makeFlat:makeFlat$1,mapInputPath:K$,nested:G$,orElse:H$,snakeCase:e=>K$(e,snakeCase$2),unnested:J$,upperCase:e=>K$(e,upperCase$2),within:Z$}),Kfe=Object.freeze({__proto__:null,andThen:I$,empty:x$,mapName:T$,nested:O$,unnested:E$});var Gfe=Object.freeze({__proto__:null,Console:eB,TypeId:X$,assert:(e,...t)=>consoleWith$2(r=>r.assert(e,...t)),clear:q0,consoleWith:consoleWith$2,count:e=>consoleWith$2(t=>t.count(e)),countReset:e=>consoleWith$2(t=>t.countReset(e)),debug:(...e)=>consoleWith$2(t=>t.debug(...e)),dir:(e,t)=>consoleWith$2(r=>r.dir(e,t)),dirxml:(...e)=>consoleWith$2(t=>t.dirxml(...e)),error:(...e)=>consoleWith$2(t=>t.error(...e)),group:e=>consoleWith$2(t=>eQ(t.group(e),()=>t.groupEnd)),info:(...e)=>consoleWith$2(t=>t.info(...e)),log:(...e)=>consoleWith$2(t=>t.log(...e)),setConsole:e=>scopedDiscard$1(OQ(pB,NA(eB,e))),table:(e,t)=>consoleWith$2(r=>r.table(e,t)),time:e=>consoleWith$2(t=>eQ(t.time(e),()=>t.timeEnd(e))),timeLog:(e,...t)=>consoleWith$2(r=>r.timeLog(e,...t)),trace:(...e)=>consoleWith$2(t=>t.trace(...e)),warn:(...e)=>consoleWith$2(t=>t.warn(...e)),withConsole:z0,withGroup:W0,withTime:V0});const Jfe=Q0,Hfe=Y0,Zfe=isDateTime$1,Qfe=isTimeZone$1,isTimeZoneOffset=e=>isTimeZone$1(e)&&"Offset"===e._tag,Yfe=isTimeZoneNamed$1,isUtc=e=>"Utc"===e._tag,Xfe=isZoned$1,ehe=s1,the=o1,rhe=a1,nhe=unsafeFromDate$1,ihe=unsafeMake$9,she=unsafeMakeZoned$1,ohe=u1,ahe=c1,makeZonedFromString=e=>{const t=l1.exec(e);if(null===t){const t=parseOffset(e);return null!==t?u1(e,{timeZone:t}):none$c()}const[,r,n]=t;return u1(r,{timeZone:n})},uhe=p1,che=f1,lhe=unsafeNow$1,phe=h1,fhe=d1,hhe=zoneUnsafeMakeNamed$1,dhe=zoneMakeOffset$1,mhe=y1,ghe=zoneMakeNamedEffect$1,zoneMakeLocal=()=>zoneMakeIntl(new Intl.DateTimeFormat("en-US",g1)),yhe=zoneFromString$1,zoneToString=e=>"Offset"===e._tag?offsetToString(e.offset):e.id,bhe=S1,She=v1,vhe=_1,_he=w1,whe=k1,khe=x1,xhe=I1,Ihe=T1,The=O1,Ohe=E1,Ehe=A1,Ahe=C1,Che=toDateUtc$1,Mhe=toDate$1,Fhe=zonedOffset$1,Phe=zonedOffsetIso$1,Nhe=toEpochMillis$1,jhe=toParts$1,Rhe=toPartsUtc$1,Dhe=M1,Lhe=F1,Uhe=P1,$he=N1;class CurrentTimeZone extends(Tag$3("effect/DateTime/CurrentTimeZone")()){}const setZoneCurrent=e=>P3(CurrentTimeZone,t=>phe(e,t)),Bhe=dual(2,(e,t)=>$5(e,CurrentTimeZone,t)),zhe=dual(2,(e,t)=>$5(e,CurrentTimeZone,dhe(t))),qhe=dual(2,(e,t)=>B5(e,CurrentTimeZone,ghe(t))),Whe=h7(uhe,setZoneCurrent),Vhe=D1,Khe=L1,Ghe=U1,Jhe=$1,Hhe=B1,Zhe=z1,Qhe=W1,Yhe=K1,Xhe=G1,ede=H1,formatIso=e=>toDateUtc$1(e).toISOString(),tde=formatIsoZoned$1;var rde=Object.freeze({__proto__:null,CurrentTimeZone,Equivalence:ehe,Order:the,TimeZoneTypeId:Hfe,TypeId:Jfe,add:V1,addDuration:q1,between:Ahe,clamp:rhe,distance:vhe,distanceDuration:whe,distanceDurationEither:_he,endOf:J1,format:Z1,formatIntl:X1,formatIso,formatIsoDate:e=>toDate$1(e).toISOString().slice(0,10),formatIsoDateUtc:e=>toDateUtc$1(e).toISOString().slice(0,10),formatIsoOffset:formatIsoOffset$1,formatIsoZoned:tde,formatLocal:Q1,formatUtc:Y1,getPart:Lhe,getPartUtc:Dhe,greaterThan:Ihe,greaterThanOrEqualTo:The,isDateTime:Zfe,isFuture:e=>qR(p1,E1(e)),isPast:e=>qR(p1,T1(e)),isTimeZone:Qfe,isTimeZoneNamed:Yfe,isTimeZoneOffset,isUtc,isZoned:Xfe,layerCurrentZone:e=>yee(CurrentTimeZone,e),layerCurrentZoneLocal:vee(CurrentTimeZone,zoneMakeLocal),layerCurrentZoneNamed:e=>V9(CurrentTimeZone,zoneMakeNamedEffect$1(e)),layerCurrentZoneOffset:e=>yee(CurrentTimeZone,zoneMakeOffset$1(e)),lessThan:Ohe,lessThanOrEqualTo:Ehe,make:ahe,makeZoned:ohe,makeZonedFromString,mapEpochMillis:Ghe,match:Zhe,max:xhe,min:khe,mutate:Vhe,mutateUtc:Khe,nearest:ede,now:uhe,nowAsDate:che,nowInCurrentZone:Whe,removeTime:e=>$1(e,e=>(e.setUTCHours(0,0,0,0),makeUtc(e.getTime()))),setParts:Uhe,setPartsUtc:$he,setZone:phe,setZoneCurrent,setZoneNamed:bhe,setZoneOffset:fhe,startOf:Xhe,subtract:Yhe,subtractDuration:Qhe,toDate:Mhe,toDateUtc:Che,toEpochMillis:Nhe,toParts:jhe,toPartsUtc:Rhe,toUtc:e=>makeUtc(e.epochMillis),unsafeFromDate:nhe,unsafeIsFuture:e=>E1(unsafeNow$1(),e),unsafeIsPast:e=>T1(unsafeNow$1(),e),unsafeMake:ihe,unsafeMakeZoned:she,unsafeNow:lhe,unsafeSetZoneNamed:She,withCurrentZone:Bhe,withCurrentZoneLocal:e=>B5(e,CurrentTimeZone,Z4(zoneMakeLocal)),withCurrentZoneNamed:qhe,withCurrentZoneOffset:zhe,withDate:Jhe,withDateUtc:Hhe,zoneFromString:yhe,zoneMakeLocal,zoneMakeNamed:mhe,zoneMakeNamedEffect:ghe,zoneMakeOffset:dhe,zoneToString,zoneUnsafeMakeNamed:hhe,zonedOffset:Fhe,zonedOffsetIso:Phe}),nde=Object.freeze({__proto__:null,currentServices:pB,liveServices:lB});const ide=Symbol.for("effect/Encoding/errors/Decode"),DecodeException$1=(e,t)=>{const r={_tag:"DecodeException",[ide]:ide,input:e};return isString$1(t)&&(r.message=t),r},sde=Symbol.for("effect/Encoding/errors/Encode"),ode=new TextEncoder,ade=new TextDecoder,encode$4=e=>{const t=e.length;let r,n="";for(r=2;r<t;r+=3)n+=ude[e[r-2]>>2],n+=ude[(3&e[r-2])<<4|e[r-1]>>4],n+=ude[(15&e[r-1])<<2|e[r]>>6],n+=ude[63&e[r]];return r===t+1&&(n+=ude[e[r-2]>>2],n+=ude[(3&e[r-2])<<4],n+="=="),r===t&&(n+=ude[e[r-2]>>2],n+=ude[(3&e[r-2])<<4|e[r-1]>>4],n+=ude[(15&e[r-1])<<2],n+="="),n},decode$4=e=>{const t=stripCrlf(e),r=t.length;if(r%4!=0)return He(DecodeException$1(t,"Length must be a multiple of 4, but is "+r));const n=t.indexOf("=");if(-1!==n&&(n<r-2||n===r-2&&"="!==t[r-1]))return He(DecodeException$1(t,"Found a '=' character, but it is not at the end"));try{const e=t.endsWith("==")?2:t.endsWith("=")?1:0,n=new Uint8Array(r/4*3-e);for(let e=0,i=0;e<r;e+=4,i+=3){const r=getBase64Code(t.charCodeAt(e))<<18|getBase64Code(t.charCodeAt(e+1))<<12|getBase64Code(t.charCodeAt(e+2))<<6|getBase64Code(t.charCodeAt(e+3));n[i]=r>>16,n[i+1]=r>>8&255,n[i+2]=255&r}return Ge(n)}catch(e){return He(DecodeException$1(t,e instanceof Error?e.message:"Invalid input"))}},stripCrlf=e=>e.replace(/[\n\r]/g,"");function getBase64Code(e){if(e>=cde.length)throw new TypeError("Invalid character "+String.fromCharCode(e));const t=cde[e];if(255===t)throw new TypeError("Invalid character "+String.fromCharCode(e));return t}const ude=["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","0","1","2","3","4","5","6","7","8","9","+","/"],cde=[255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,62,255,255,255,63,52,53,54,55,56,57,58,59,60,61,255,255,255,0,255,255,255,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,255,255,255,255,255,255,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51],lde=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"],fromHexChar=e=>{if(48<=e&&e<=57)return e-48;if(97<=e&&e<=102)return e-97+10;if(65<=e&&e<=70)return e-65+10;throw new TypeError("Invalid input")},encodeBase64=e=>encode$4("string"==typeof e?ode.encode(e):e),decodeBase64=e=>decode$4(e),decodeBase64String=e=>st(decodeBase64(e),e=>ade.decode(e)),encodeBase64Url=e=>{return t="string"==typeof e?ode.encode(e):e,encode$4(t).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_");var t},decodeBase64Url=e=>(e=>{const t=stripCrlf(e),r=t.length;if(r%4==1)return He(DecodeException$1(t,"Length should be a multiple of 4, but is "+r));if(!/^[-_A-Z0-9]*?={0,2}$/i.test(t))return He(DecodeException$1(t,"Invalid input"));let n=r%4==2?t+"==":r%4==3?t+"=":t;return n=n.replace(/-/g,"+").replace(/_/g,"/"),decode$4(n)})(e),decodeBase64UrlString=e=>st(decodeBase64Url(e),e=>ade.decode(e)),encodeHex=e=>(e=>{let t="";for(let r=0;r<e.length;++r)t+=lde[e[r]];return t})("string"==typeof e?ode.encode(e):e),decodeHex=e=>(e=>{const t=(new TextEncoder).encode(e);if(t.length%2!=0)return He(DecodeException$1(e,"Length must be a multiple of 2, but is "+t.length));try{const e=t.length/2,r=new Uint8Array(e);for(let n=0;n<e;n++){const e=fromHexChar(t[2*n]),i=fromHexChar(t[2*n+1]);r[n]=e<<4|i}return Ge(r)}catch(t){return He(DecodeException$1(e,t instanceof Error?t.message:"Invalid input"))}})(e),decodeHexString=e=>st(decodeHex(e),e=>ade.decode(e)),encodeUriComponent=e=>try_$5({try:()=>encodeURIComponent(e),catch:t=>EncodeException(e,t instanceof Error?t.message:"Invalid input")}),decodeUriComponent=e=>try_$5({try:()=>decodeURIComponent(e),catch:t=>pde(e,t instanceof Error?t.message:"Invalid input")}),pde=DecodeException$1,EncodeException=(e,t)=>{const r={_tag:"EncodeException",[sde]:sde,input:e};return isString$1(t)&&(r.message=t),r};var fde=Object.freeze({__proto__:null,DecodeException:pde,DecodeExceptionTypeId:ide,EncodeException,EncodeExceptionTypeId:sde,decodeBase64,decodeBase64String,decodeBase64Url,decodeBase64UrlString,decodeHex,decodeHexString,decodeUriComponent,encodeBase64,encodeBase64Url,encodeHex,encodeUriComponent,isDecodeException:e=>C(e,ide),isEncodeException:e=>C(e,sde)});const hde=G6,dde={[hde]:hde,get withRequirements(){const e=this;return contextWith$8(t=>makeProto(e.steps.map(e=>({...e,provide:j9(e.provide)?Tee(e.provide,bee(t)):e.provide}))))},pipe(){return pipeArguments(this,arguments)}},makeProto=e=>{const t=Object.create(dde);return t.steps=e,t};var mde=Object.freeze({__proto__:null,TypeId:hde,isExecutionPlan:e=>C(e,G6),make:(...e)=>makeProto(e.map((e,t)=>{if(e.attempts&&e.attempts<1)throw Error(`ExecutionPlan.make: step[${t}].attempts must be greater than 0`);return{schedule:e.schedule,attempts:e.attempts,while:e.while?t=>H4(()=>{const r=e.while(t);return"boolean"==typeof r?G4(r):r}):void 0,provide:e.provide}})),merge:(...e)=>makeProto(e.flatMap(e=>e.steps))});const gde=Symbol.for("effect/FiberHandle"),isFiberHandle=e=>C(e,gde),yde={[gde]:gde,toString(){return format$6(this.toJSON())},toJSON(){return{_id:"FiberHandle",state:this.state}},[ee](){return this.toJSON()},pipe(){return pipeArguments(this,arguments)}},make$17=()=>U3(P3(fU(),e=>(e=>{const t=Object.create(yde);return t.state={_tag:"Open",fiber:void 0},t.deferred=e,t})(e)),e=>D4(t=>{const r=e.state;return"Closed"===r._tag?Q4:(e.state={_tag:"Closed"},r.fiber?X5(C3(bX(r.fiber,cP(t.id(),bde))),e.deferred):dU(e.deferred,jU))})),bde=make$25(-1,0),Sde=eY(void 0,{emptyCase:n,failCase:n,dieCase:n,interruptCase:(e,t)=>TF(pP(t),-1),sequentialCase:(e,t,r)=>t||r,parallelCase:(e,t,r)=>t||r}),vde=dual(e=>isFiberHandle(e[0]),(e,t,r)=>{if("Closed"!==e.state._tag){if(void 0!==e.state.fiber){if(!0===r?.onlyIfMissing)return void t.unsafeInterruptAsFork(cP(r?.interruptAs??aP,bde));if(e.state.fiber===t)return;e.state.fiber.unsafeInterruptAsFork(cP(r?.interruptAs??aP,bde)),e.state.fiber=void 0}e.state.fiber=t,t.addObserver(n=>{"Open"===e.state._tag&&t===e.state.fiber&&(e.state.fiber=void 0),!wU(n)||(!0===r?.propagateInterruption?Sde(n.cause):ZQ(n.cause))||SU(e.deferred,n)})}else t.unsafeInterruptAsFork(cP(r?.interruptAs??aP,bde))}),_de=dual(e=>isFiberHandle(e[0]),(e,t,r)=>s5(n=>Z4(()=>vde(e,t,{interruptAs:n,onlyIfMissing:r?.onlyIfMissing,propagateInterruption:r?.propagateInterruption})))),unsafeGet$3=e=>"Closed"===e.state._tag?none$c():fromNullable$3(e.state.fiber),wde=function(){let e;return()=>(void 0===e&&(e=I8(v3)),e)}(),runImpl$2=(e,t,r)=>s5(n=>"Closed"===e.state._tag?v3:void 0!==e.state.fiber&&!0===r?.onlyIfMissing?Z4(wde):v7(a5(t),t=>vde(e,t,{...r,interruptAs:n}))),runtime$2=e=>()=>P3(h8(),t=>{const r=Sie(t);return(t,n)=>{if("Closed"===e.state._tag)return wde();if(void 0!==e.state.fiber&&!0===n?.onlyIfMissing)return wde();const i=r(t,n);return vde(e,i,n),i}}),runtimePromise$2=e=>()=>P3(runtime$2(e)(),e=>(t,r)=>new Promise((n,i)=>e(t,r).addObserver(e=>{kU(e)?n(e.value):i(squash(e.cause))})));var kde=Object.freeze({__proto__:null,TypeId:gde,awaitEmpty:e=>H4(()=>"Closed"===e.state._tag||void 0===e.state.fiber?Q4:mX(e.state.fiber)),clear:e=>T3(t=>D4(r=>"Closed"===e.state._tag||void 0===e.state.fiber?Q4:j8(t(bX(e.state.fiber,cP(r.id(),bde))),Z4(()=>{"Open"===e.state._tag&&(e.state.fiber=void 0)})))),get:e=>H4(()=>unsafeGet$3(e)),isFiberHandle,join:e=>hU(e.deferred),make:make$17,makeRuntime:()=>h7(make$17(),e=>runtime$2(e)()),makeRuntimePromise:()=>h7(make$17(),e=>runtimePromise$2(e)()),run:function(){const e=arguments[0];if(c4(arguments[1]))return runImpl$2(e,arguments[1],arguments[2]);const t=arguments[1];return r=>runImpl$2(e,r,t)},runtime:runtime$2,runtimePromise:runtimePromise$2,set:_de,unsafeGet:unsafeGet$3,unsafeSet:vde});const xde=Symbol.for("effect/FiberMap"),isFiberMap=e=>C(e,xde),Ide={[xde]:xde,[Symbol.iterator](){return"Closed"===this.state._tag?empty$W():this.state.backing[Symbol.iterator]()},toString(){return format$6(this.toJSON())},toJSON(){return{_id:"FiberMap",state:this.state}},[ee](){return this.toJSON()},pipe(){return pipeArguments(this,arguments)}},make$16=()=>U3(P3(fU(),e=>((e,t)=>{const r=Object.create(Ide);return r.state={_tag:"Open",backing:e},r.deferred=t,r})(empty$B(),e)),e=>D4(t=>{const r=e.state;return"Closed"===r._tag?Q4:(e.state={_tag:"Closed"},SX(tn(r.backing,([,e])=>e),cP(t.id(),Tde)).pipe(X5(e.deferred)))})),Tde=make$25(-1,0),Ode=eY(void 0,{emptyCase:n,failCase:n,dieCase:n,interruptCase:(e,t)=>TF(pP(t),-1),sequentialCase:(e,t,r)=>t||r,parallelCase:(e,t,r)=>t||r}),Ede=dual(e=>isFiberMap(e[0]),(e,t,r,n)=>{if("Closed"===e.state._tag)return void r.unsafeInterruptAsFork(cP(n?.interruptAs??aP,Tde));const i=zU(e.state.backing,t);if("Some"===i._tag){if(!0===n?.onlyIfMissing)return void r.unsafeInterruptAsFork(cP(n?.interruptAs??aP,Tde));if(i.value===r)return;i.value.unsafeInterruptAsFork(cP(n?.interruptAs??aP,Tde))}WU(e.state.backing,t,r),r.addObserver(i=>{if("Closed"===e.state._tag)return;const s=zU(e.state.backing,t);zt(s)&&r===s.value&&GU(e.state.backing,t),!wU(i)||(!0===n?.propagateInterruption?Ode(i.cause):ZQ(i.cause))||SU(e.deferred,i)})}),Ade=dual(e=>isFiberMap(e[0]),(e,t,r,n)=>s5(i=>Z4(()=>Ede(e,t,r,{...n,interruptAs:i})))),Cde=dual(2,(e,t)=>"Closed"===e.state._tag?none$c():zU(e.state.backing,t)),Mde=dual(2,(e,t)=>H4(()=>Cde(e,t))),Fde=dual(2,(e,t)=>"Closed"!==e.state._tag&&qU(e.state.backing,t)),Pde=dual(2,(e,t)=>Z4(()=>Fde(e,t))),Nde=dual(2,(e,t)=>D4(r=>{if("Closed"===e.state._tag)return Q4;const n=zU(e.state.backing,t);return"None"===n._tag?Q4:bX(n.value,cP(r.id(),Tde))})),jde=function(){let e;return()=>(void 0===e&&(e=I8(v3)),e)}(),runImpl$1=(e,t,r,n)=>s5(i=>"Closed"===e.state._tag?v3:!0===n?.onlyIfMissing&&Fde(e,t)?Z4(jde):v7(a5(r),r=>Ede(e,t,r,{...n,interruptAs:i}))),runtime$1=e=>()=>P3(h8(),t=>{const r=Sie(t);return(t,n,i)=>{if("Closed"===e.state._tag)return jde();if(!0===i?.onlyIfMissing&&Fde(e,t))return jde();const s=r(n,i);return Ede(e,t,s,i),s}}),runtimePromise$1=e=>()=>P3(runtime$1(e)(),e=>(t,r,n)=>new Promise((i,s)=>e(t,r,n).addObserver(e=>{kU(e)?i(e.value):s(squash(e.cause))})));var Rde=Object.freeze({__proto__:null,TypeId:xde,awaitEmpty:e=>N7({while:()=>"Open"===e.state._tag&&size$t(e.state.backing)>0,body:()=>mX(unsafeHead$2(e)[1]),step:o}),clear:e=>D4(t=>"Closed"===e.state._tag?Q4:x4(e.state.backing,([,e])=>bX(e,cP(t.id(),Tde)))),get:Mde,has:Pde,isFiberMap,join:e=>hU(e.deferred),make:make$16,makeRuntime:()=>h7(make$16(),e=>runtime$1(e)()),makeRuntimePromise:()=>h7(make$16(),e=>runtimePromise$1(e)()),remove:Nde,run:function(){const e=arguments[0];if(c4(arguments[2]))return runImpl$1(e,arguments[1],arguments[2],arguments[3]);const t=arguments[1],r=arguments[2];return n=>runImpl$1(e,t,n,r)},runtime:runtime$1,runtimePromise:runtimePromise$1,set:Ade,size:e=>Z4(()=>"Closed"===e.state._tag?0:size$t(e.state.backing)),unsafeGet:Cde,unsafeHas:Fde,unsafeSet:Ede});const Dde=Symbol.for("effect/FiberSet"),isFiberSet=e=>C(e,Dde),Lde={[Dde]:Dde,[Symbol.iterator](){return"Closed"===this.state._tag?empty$W():this.state.backing[Symbol.iterator]()},toString(){return format$6(this.toJSON())},toJSON(){return{_id:"FiberMap",state:this.state}},[ee](){return this.toJSON()},pipe(){return pipeArguments(this,arguments)}},make$15=()=>U3(P3(fU(),e=>((e,t)=>{const r=Object.create(Lde);return r.state={_tag:"Open",backing:e},r.deferred=t,r})(new Set,e)),e=>D4(t=>{const r=e.state;if("Closed"===r._tag)return Q4;e.state={_tag:"Closed"};const n=r.backing;return SX(n,cP(t.id(),Ude)).pipe(X5(e.deferred))})),Ude=make$25(-1,0),$de=eY(void 0,{emptyCase:n,failCase:n,dieCase:n,interruptCase:(e,t)=>TF(pP(t),-1),sequentialCase:(e,t,r)=>t||r,parallelCase:(e,t,r)=>t||r}),Bde=dual(e=>isFiberSet(e[0]),(e,t,r)=>{"Closed"!==e.state._tag?e.state.backing.has(t)||(e.state.backing.add(t),t.addObserver(n=>{"Closed"!==e.state._tag&&(e.state.backing.delete(t),!wU(n)||(!0===r?.propagateInterruption?$de(n.cause):ZQ(n.cause))||SU(e.deferred,n))})):t.unsafeInterruptAsFork(cP(r?.interruptAs??aP,Ude))}),zde=dual(e=>isFiberSet(e[0]),(e,t,r)=>s5(n=>Z4(()=>Bde(e,t,{...r,interruptAs:n})))),qde=function(){let e;return()=>(void 0===e&&(e=I8(v3)),e)}(),runImpl=(e,t,r)=>s5(n=>"Closed"===e.state._tag?Z4(qde):v7(a5(t),t=>Bde(e,t,{...r,interruptAs:n}))),runtime=e=>()=>P3(h8(),t=>{const r=Sie(t);return(t,n)=>{if("Closed"===e.state._tag)return qde();const i=r(t,n);return Bde(e,i),i}}),runtimePromise=e=>()=>P3(runtime(e)(),e=>(t,r)=>new Promise((n,i)=>e(t,r).addObserver(e=>{kU(e)?n(e.value):i(squash(e.cause))})));var Wde=Object.freeze({__proto__:null,TypeId:Dde,add:zde,awaitEmpty:e=>N7({while:()=>"Open"===e.state._tag&&e.state.backing.size>0,body:()=>mX(unsafeHead$2(e)),step:o}),clear:e=>D4(t=>"Closed"===e.state._tag?Q4:x4(e.state.backing,e=>bX(e,cP(t.id(),Ude)))),isFiberSet,join:e=>hU(e.deferred),make:make$15,makeRuntime:()=>h7(make$15(),e=>runtime(e)()),makeRuntimePromise:()=>h7(make$15(),e=>runtimePromise(e)()),run:function(){const e=arguments[0];if(!c4(arguments[1])){const t=arguments[1];return r=>runImpl(e,r,t)}return runImpl(e,arguments[1],arguments[2])},runtime,runtimePromise,size:e=>Z4(()=>"Closed"===e.state._tag?0:e.state.backing.size),unsafeAdd:Bde});const getMapSafe=(e,t)=>e.has(t)?Ut(e.get(t)):none$c(),Vde="~effect/Graph";class Edge extends G0{}const Kde={[Vde]:Vde,[Symbol.iterator](){return this.nodes[Symbol.iterator]()},[ee](){return this.toJSON()},[Y](e){if(isGraph(e)){if(this.nodes.size!==e.nodes.size||this.edges.size!==e.edges.size||this.type!==e.type)return!1;for(const[t,r]of this.nodes){if(!e.nodes.has(t))return!1;if(!equals$4(r,e.nodes.get(t)))return!1}for(const[t,r]of this.edges){if(!e.edges.has(t))return!1;if(!equals$4(r,e.edges.get(t)))return!1}return!0}return!1},[Z](){let e=string$6("Graph");e^=string$6(this.type),e^=number$4(this.nodes.size),e^=number$4(this.edges.size);for(const[t,r]of this.nodes)e^=hash$3(t)+hash$3(r);for(const[t,r]of this.edges)e^=hash$3(t)+hash$3(r);return e},toJSON(){return{_id:"Graph",nodeCount:this.nodes.size,edgeCount:this.edges.size,type:this.type}},toString(){return format$6(this)},pipe(){return pipeArguments(this,arguments)}},isGraph=e=>"object"==typeof e&&null!==e&&Vde in e,beginMutation=e=>{const t=new Map,r=new Map;for(const[r,n]of e.adjacency)t.set(r,[...n]);for(const[t,n]of e.reverseAdjacency)r.set(t,[...n]);const n=Object.create(Kde);return n.type=e.type,n.nodes=new Map(e.nodes),n.edges=new Map(e.edges),n.adjacency=t,n.reverseAdjacency=r,n.nextNodeIndex=e.nextNodeIndex,n.nextEdgeIndex=e.nextEdgeIndex,n.isAcyclic=e.isAcyclic,n.mutable=!0,n},endMutation=e=>{const t=Object.create(Kde);return t.type=e.type,t.nodes=new Map(e.nodes),t.edges=new Map(e.edges),t.adjacency=e.adjacency,t.reverseAdjacency=e.reverseAdjacency,t.nextNodeIndex=e.nextNodeIndex,t.nextEdgeIndex=e.nextEdgeIndex,t.isAcyclic=e.isAcyclic,t.mutable=!1,t},Gde=dual(2,(e,t)=>{const r=beginMutation(e);return t(r),endMutation(r)}),getNode=(e,t)=>getMapSafe(e.nodes,t),hasNode=(e,t)=>e.nodes.has(t),invalidateCycleFlagOnRemoval=e=>{zt(e.isAcyclic)&&!1===e.isAcyclic.value&&(e.isAcyclic=none$c())},removeNode=(e,t)=>{if(!e.nodes.has(t))return;const r=[],n=getMapSafe(e.adjacency,t);if(zt(n))for(const e of n.value)r.push(e);const i=getMapSafe(e.reverseAdjacency,t);if(zt(i))for(const e of i.value)r.push(e);for(const t of r)removeEdgeInternal(e,t);e.nodes.delete(t),e.adjacency.delete(t),e.reverseAdjacency.delete(t),invalidateCycleFlagOnRemoval(e)},removeEdge=(e,t)=>{removeEdgeInternal(e,t)&&invalidateCycleFlagOnRemoval(e)},removeEdgeInternal=(e,t)=>{const r=getMapSafe(e.edges,t);if(Bt(r))return!1;const{source:n,target:i}=r.value,s=getMapSafe(e.adjacency,n);if(zt(s)){const e=s.value.indexOf(t);-1!==e&&s.value.splice(e,1)}const o=getMapSafe(e.reverseAdjacency,i);if(zt(o)){const e=o.value.indexOf(t);-1!==e&&o.value.splice(e,1)}if("undirected"===e.type){const r=getMapSafe(e.adjacency,i);if(zt(r)){const e=r.value.indexOf(t);-1!==e&&r.value.splice(e,1)}const s=getMapSafe(e.reverseAdjacency,n);if(zt(s)){const e=s.value.indexOf(t);-1!==e&&s.value.splice(e,1)}}return e.edges.delete(t),!0},neighbors=(e,t)=>{const r=getMapSafe(e.adjacency,t);if(Bt(r))return[];const n=[];for(const t of r.value){const r=getMapSafe(e.edges,t);zt(r)&&n.push(r.value.target)}return n},neighborsDirected=(e,t,r)=>{const n="incoming"===r?e.reverseAdjacency:e.adjacency,i=getMapSafe(n,t);if(Bt(i))return[];const s=[];for(const t of i.value){const n=getMapSafe(e.edges,t);if(zt(n)){const e="incoming"===r?n.value.source:n.value.target;s.push(e)}}return s},isAcyclic=e=>{if(zt(e.isAcyclic))return e.isAcyclic.value;const t=new Set,r=new Set;for(const n of e.nodes.keys()){if(t.has(n))continue;const i=[[n,[],0,!0]];for(;i.length>0;){const[n,s,o,a]=i[i.length-1];if(a){if(r.has(n))return e.isAcyclic=Ut(!1),!1;if(t.has(n)){i.pop();continue}t.add(n),r.add(n);const s=Array.from(neighborsDirected(e,n,"outgoing"));i[i.length-1]=[n,s,0,!1];continue}if(o<s.length){const a=s[o];if(i[i.length-1]=[n,s,o+1,!1],r.has(a))return e.isAcyclic=Ut(!1),!1;t.has(a)||i.push([a,[],0,!0])}else r.delete(n),i.pop()}}return e.isAcyclic=Ut(!0),!0},getUndirectedNeighbors=(e,t)=>{const r=new Set,n=getMapSafe(e.adjacency,t);if(zt(n))for(const i of n.value){const n=getMapSafe(e.edges,i);if(zt(n)){const e=n.value.source===t?n.value.target:n.value.source;r.add(e)}}return Array.from(r)};class Walker{[Symbol.iterator];visit;constructor(e){this.visit=e,this[Symbol.iterator]=e((e,t)=>[e,t])[Symbol.iterator]}}var Jde=Object.freeze({__proto__:null,Edge,TypeId:Vde,Walker,addEdge:(e,t,r,n)=>{if(!e.nodes.has(t))throw Error(`Source node ${t} does not exist`);if(!e.nodes.has(r))throw Error(`Target node ${r} does not exist`);const i=e.nextEdgeIndex,s=new Edge({source:t,target:r,data:n});e.edges.set(i,s);const o=getMapSafe(e.adjacency,t);zt(o)&&o.value.push(i);const a=getMapSafe(e.reverseAdjacency,r);if(zt(a)&&a.value.push(i),"undirected"===e.type){const n=getMapSafe(e.adjacency,r);zt(n)&&n.value.push(i);const s=getMapSafe(e.reverseAdjacency,t);zt(s)&&s.value.push(i)}return e.nextEdgeIndex=e.nextEdgeIndex+1,(e=>{zt(e.isAcyclic)&&!0===e.isAcyclic.value&&(e.isAcyclic=none$c())})(e),i},addNode:(e,t)=>{const r=e.nextNodeIndex;return e.nodes.set(r,t),e.adjacency.set(r,[]),e.reverseAdjacency.set(r,[]),e.nextNodeIndex=e.nextNodeIndex+1,r},astar:(e,t,r,n,i)=>{if(!e.nodes.has(t))throw Error(`Source node ${t} does not exist`);if(!e.nodes.has(r))throw Error(`Target node ${r} does not exist`);if(t===r)return Ut({path:[t],distance:0,edgeWeights:[]});const s=getMapSafe(e.nodes,r);if(Bt(s))throw Error(`Target node ${r} data not found`);const o=new Map,a=new Map,u=new Map,c=new Set;for(const r of e.nodes.keys())o.set(r,r===t?0:1/0),a.set(r,1/0),u.set(r,null);const l=getMapSafe(e.nodes,t);if(zt(l)){const e=i(l.value,s.value);a.set(t,e)}const p=[{node:t,fScore:a.get(t)}];for(;p.length>0;){let t=0;for(let e=1;e<p.length;e++)p[e].fScore<p[t].fScore&&(t=e);const l=p.splice(t,1)[0].node;if(c.has(l))continue;if(c.add(l),l===r)break;const d=o.get(l),m=getMapSafe(e.adjacency,l);if(zt(m))for(const t of m.value){const r=getMapSafe(e.edges,t);if(zt(r)){const t=r.value.target,m=n(r.value.data);if(m<0)throw Error("A* algorithm requires non-negative edge weights, found "+m);const g=d+m;if(g<o.get(t)){o.set(t,g),u.set(t,{node:l,edgeData:r.value.data});const n=getMapSafe(e.nodes,t);if(zt(n)){const e=g+i(n.value,s.value);a.set(t,e),c.has(t)||p.push({node:t,fScore:e})}}}}}const d=o.get(r);if(d===1/0)return none$c();const m=[],g=[];let y=r;for(;null!==y;){m.unshift(y);const e=u.get(y);null!==e?(g.unshift(e.edgeData),y=e.node):y=null}return Ut({path:m,distance:d,edgeWeights:g})},beginMutation,bellmanFord:(e,t,r,n)=>{if(!e.nodes.has(t))throw Error(`Source node ${t} does not exist`);if(!e.nodes.has(r))throw Error(`Target node ${r} does not exist`);if(t===r)return Ut({path:[t],distance:0,edgeWeights:[]});const i=new Map,s=new Map;for(const r of e.nodes.keys())i.set(r,r===t?0:1/0),s.set(r,null);const o=[];for(const[,t]of e.edges){const e=n(t.data);o.push({source:t.source,target:t.target,weight:e,edgeData:t.data})}const a=e.nodes.size;for(let e=0;e<a-1;e++){let e=!1;for(const t of o){const r=i.get(t.source),n=i.get(t.target);r!==1/0&&r+t.weight<n&&(i.set(t.target,r+t.weight),s.set(t.target,{node:t.source,edgeData:t.edgeData}),e=!0)}if(!e)break}for(const t of o){const n=i.get(t.source),s=i.get(t.target);if(n!==1/0&&n+t.weight<s){const n=new Set,i=[t.target];for(;i.length>0;){const t=i.shift();if(n.has(t))continue;n.add(t);const r=getMapSafe(e.adjacency,t);if(zt(r))for(const t of r.value){const r=getMapSafe(e.edges,t);zt(r)&&i.push(r.value.target)}}if(n.has(r))return none$c()}}const u=i.get(r);if(u===1/0)return none$c();const c=[],l=[];let p=r;for(;null!==p;){c.unshift(p);const e=s.get(p);null!==e?(l.unshift(e.edgeData),p=e.node):p=null}return Ut({path:c,distance:u,edgeWeights:l})},bfs:(e,t={})=>{const r=t.startNodes??[],n=t.direction??"outgoing";for(const t of r)if(!hasNode(e,t))throw Error(`Start node ${t} does not exist`);return new Walker(t=>({[Symbol.iterator]:()=>{const i=[...r],s=new Set,nextMapped=()=>{for(;i.length>0;){const r=i.shift();if(!s.has(r)){s.add(r);const o=neighborsDirected(e,r,n);for(const e of o)s.has(e)||i.push(e);const a=getNode(e,r);return zt(a)?{done:!1,value:t(r,a.value)}:nextMapped()}}return{done:!0,value:void 0}};return{next:nextMapped}}}))},connectedComponents:e=>{const t=new Set,r=[];for(const n of e.nodes.keys())if(!t.has(n)){const i=[],s=[n];for(;s.length>0;){const r=s.pop();if(!t.has(r)){t.add(r),i.push(r);const n=getUndirectedNeighbors(e,r);for(const e of n)t.has(e)||s.push(e)}}r.push(i)}return r},dfs:(e,t={})=>{const r=t.startNodes??[],n=t.direction??"outgoing";for(const t of r)if(!hasNode(e,t))throw Error(`Start node ${t} does not exist`);return new Walker(t=>({[Symbol.iterator]:()=>{const i=[...r],s=new Set;return{next:()=>{for(;i.length>0;){const r=i.pop();if(s.has(r))continue;s.add(r);const o=getMapSafe(e.nodes,r);if(Bt(o))continue;const a=neighborsDirected(e,r,n);for(let e=a.length-1;e>=0;e--){const t=a[e];s.has(t)||i.push(t)}return{done:!1,value:t(r,o.value)}}return{done:!0,value:void 0}}}}}))},dfsPostOrder:(e,t={})=>{const r=t.startNodes??[],n=t.direction??"outgoing";for(const t of r)if(!hasNode(e,t))throw Error(`Start node ${t} does not exist`);return new Walker(t=>({[Symbol.iterator]:()=>{const i=[],s=new Set,o=new Set;for(let e=r.length-1;e>=0;e--)i.push({node:r[e],visitedChildren:!1});const nextMapped=()=>{for(;i.length>0;){const r=i[i.length-1];if(s.has(r.node)||(s.add(r.node),r.visitedChildren=!1),r.visitedChildren){const r=i.pop().node;if(!o.has(r)){o.add(r);const n=getNode(e,r);return zt(n)?{done:!1,value:t(r,n.value)}:nextMapped()}}else{r.visitedChildren=!0;const t=neighborsDirected(e,r.node,n);for(let e=t.length-1;e>=0;e--){const r=t[e];s.has(r)||o.has(r)||i.push({node:r,visitedChildren:!1})}}}return{done:!0,value:void 0}};return{next:nextMapped}}}))},dijkstra:(e,t,r,n)=>{if(!e.nodes.has(t))throw Error(`Source node ${t} does not exist`);if(!e.nodes.has(r))throw Error(`Target node ${r} does not exist`);if(t===r)return Ut({path:[t],distance:0,edgeWeights:[]});const i=new Map,s=new Map,o=new Set;for(const r of e.nodes.keys())i.set(r,r===t?0:1/0),s.set(r,null);const a=[{node:t,distance:0}];for(;a.length>0;){let t=0;for(let e=1;e<a.length;e++)a[e].distance<a[t].distance&&(t=e);const u=a.splice(t,1)[0].node;if(o.has(u))continue;if(o.add(u),u===r)break;const c=i.get(u),l=getMapSafe(e.adjacency,u);if(zt(l))for(const t of l.value){const r=getMapSafe(e.edges,t);if(zt(r)){const e=r.value.target,t=n(r.value.data);if(t<0)throw Error("Dijkstra's algorithm requires non-negative edge weights, found "+t);const l=c+t;l<i.get(e)&&(i.set(e,l),s.set(e,{node:u,edgeData:r.value.data}),o.has(e)||a.push({node:e,distance:l}))}}}const u=i.get(r);if(u===1/0)return none$c();const c=[],l=[];let p=r;for(;null!==p;){c.unshift(p);const e=s.get(p);null!==e?(l.unshift(e.edgeData),p=e.node):p=null}return Ut({path:c,distance:u,edgeWeights:l})},directed:e=>{const t=Object.create(Kde);if(t.type="directed",t.nodes=new Map,t.edges=new Map,t.adjacency=new Map,t.reverseAdjacency=new Map,t.nextNodeIndex=0,t.nextEdgeIndex=0,t.isAcyclic=Ut(!0),t.mutable=!1,e){const r=beginMutation(t);return e(r),endMutation(r)}return t},edgeCount:e=>e.edges.size,edges:e=>new Walker(t=>({[Symbol.iterator](){const r=e.edges.entries();return{next(){const e=r.next();if(e.done)return{done:!0,value:void 0};const[n,i]=e.value;return{done:!1,value:t(n,i)}}}}})),endMutation,entries:e=>e.visit((e,t)=>[e,t]),externals:(e,t={})=>{const r=t.direction??"outgoing";return new Walker(t=>({[Symbol.iterator]:()=>{const n=e.nodes,i="incoming"===r?e.reverseAdjacency:e.adjacency,s=n.entries();return{next:()=>{let e=s.next();for(;!e.done;){const[r,n]=e.value,o=getMapSafe(i,r);if(Bt(o)||0===o.value.length)return{done:!1,value:t(r,n)};e=s.next()}return{done:!0,value:void 0}}}}}))},filterEdges:(e,t)=>{const r=[];for(const[n,i]of e.edges)t(i.data)||r.push(n);for(const t of r)removeEdge(e,t)},filterMapEdges:(e,t)=>{const r=[];for(const[n,i]of e.edges){const s=t(i.data);zt(s)?e.edges.set(n,{...i,data:s.value}):r.push(n)}for(const t of r)removeEdge(e,t)},filterMapNodes:(e,t)=>{const r=[];for(const[n,i]of e.nodes){const s=t(i);zt(s)?e.nodes.set(n,s.value):r.push(n)}for(const t of r)removeNode(e,t)},filterNodes:(e,t)=>{const r=[];for(const[n,i]of e.nodes)t(i)||r.push(n);for(const t of r)removeNode(e,t)},findEdge:(e,t)=>{for(const[r,n]of e.edges)if(t(n.data,n.source,n.target))return Ut(r);return none$c()},findEdges:(e,t)=>{const r=[];for(const[n,i]of e.edges)t(i.data,i.source,i.target)&&r.push(n);return r},findNode:(e,t)=>{for(const[r,n]of e.nodes)if(t(n))return Ut(r);return none$c()},findNodes:(e,t)=>{const r=[];for(const[n,i]of e.nodes)t(i)&&r.push(n);return r},floydWarshall:(e,t)=>{const r=Array.from(e.nodes.keys()),n=new Map,i=new Map,s=new Map;for(const e of r){n.set(e,new Map),i.set(e,new Map),s.set(e,new Map);for(const t of r)n.get(e).set(t,e===t?0:1/0),i.get(e).set(t,null),s.get(e).set(t,null)}for(const[,r]of e.edges){const e=t(r.data),o=r.source,a=r.target;e<n.get(o).get(a)&&(n.get(o).set(a,e),i.get(o).set(a,a),s.get(o).set(a,r.data))}for(const e of r)for(const t of r)for(const s of r){const r=n.get(t).get(e),o=n.get(e).get(s),a=n.get(t).get(s);r!==1/0&&o!==1/0&&r+o<a&&(n.get(t).set(s,r+o),i.get(t).set(s,i.get(t).get(e)))}for(const e of r)if(n.get(e).get(e)<0)throw Error("Negative cycle detected involving node "+e);const o=new Map,a=new Map;for(const e of r){o.set(e,new Map),a.set(e,new Map);for(const t of r)if(e===t)o.get(e).set(t,[e]),a.get(e).set(t,[]);else if(n.get(e).get(t)===1/0)o.get(e).set(t,null),a.get(e).set(t,[]);else{const r=[],n=[];let u=e;for(r.push(u);u!==t;){const e=i.get(u).get(t);if(null===e)break;const o=s.get(u).get(e);null!==o&&n.push(o),u=e,r.push(u)}o.get(e).set(t,r),a.get(e).set(t,n)}}return{distances:n,paths:o,edgeWeights:a}},getEdge:(e,t)=>getMapSafe(e.edges,t),getNode,hasEdge:(e,t,r)=>{const n=getMapSafe(e.adjacency,t);if(Bt(n))return!1;for(const t of n.value){const n=getMapSafe(e.edges,t);if(zt(n)&&n.value.target===r)return!0}return!1},hasNode,indices:e=>e.visit((e,t)=>e),isAcyclic,isBipartite:e=>{const t=new Map,r=new Set;let n=!0;for(const i of e.nodes.keys())if(!r.has(i)){const s=[i];for(t.set(i,0),r.add(i);s.length>0&&n;){const i=s.shift(),o=t.get(i),a=0===o?1:0,u=getUndirectedNeighbors(e,i);for(const e of u)if(r.has(e)){if(t.get(e)===o){n=!1;break}}else t.set(e,a),r.add(e),s.push(e)}if(!n)break}return n},isGraph,mapEdges:(e,t)=>{for(const[r,n]of e.edges){const i=t(n.data);e.edges.set(r,{...n,data:i})}},mapNodes:(e,t)=>{for(const[r,n]of e.nodes){const i=t(n);e.nodes.set(r,i)}},mutate:Gde,neighbors,neighborsDirected,nodeCount:e=>e.nodes.size,nodes:e=>new Walker(t=>({[Symbol.iterator](){const r=e.nodes.entries();return{next(){const e=r.next();if(e.done)return{done:!0,value:void 0};const[n,i]=e.value;return{done:!1,value:t(n,i)}}}}})),removeEdge,removeNode,reverse:e=>{for(const[t,r]of e.edges)e.edges.set(t,{source:r.target,target:r.source,data:r.data});e.adjacency.clear(),e.reverseAdjacency.clear();for(const[t,r]of e.edges){const n=e.adjacency.get(r.source)||[];n.push(t),e.adjacency.set(r.source,n);const i=e.reverseAdjacency.get(r.target)||[];i.push(t),e.reverseAdjacency.set(r.target,i)}e.isAcyclic=none$c()},stronglyConnectedComponents:e=>{const t=new Set,r=[];for(const n of e.nodes.keys()){if(t.has(n))continue;const i=[[n,[],0,!0]];for(;i.length>0;){const[n,s,o,a]=i[i.length-1];if(a){if(t.has(n)){i.pop();continue}t.add(n);const r=neighbors(e,n);i[i.length-1]=[n,r,0,!1];continue}if(o<s.length){const e=s[o];i[i.length-1]=[n,s,o+1,!1],t.has(e)||i.push([e,[],0,!0])}else r.push(n),i.pop()}}t.clear();const n=[];for(let i=r.length-1;i>=0;i--){const s=r[i];if(t.has(s))continue;const o=[],a=[s];for(;a.length>0;){const r=a.pop();if(t.has(r))continue;t.add(r),o.push(r);const n=getMapSafe(e.reverseAdjacency,r);if(zt(n))for(const r of n.value){const n=getMapSafe(e.edges,r);if(zt(n)){const e=n.value.source;t.has(e)||a.push(e)}}}n.push(o)}return n},toGraphViz:(e,t)=>{const{edgeLabel:r=e=>e+"",graphName:n="G",nodeLabel:i=e=>e+""}=t??{},s="directed"===e.type,o=s?"digraph":"graph",a=s?"->":"--",u=[];u.push(`${o} ${n} {`);for(const[t,r]of e.nodes){const e=i(r).replace(/"/g,'\\"');u.push(`  "${t}" [label="${e}"];`)}for(const[,t]of e.edges){const e=r(t.data).replace(/"/g,'\\"');u.push(`  "${t.source}" ${a} "${t.target}" [label="${e}"];`)}return u.push("}"),u.join("\n")},topo:(e,t={})=>{if(!isAcyclic(e))throw Error("Cannot perform topological sort on cyclic graph");const r=t.initials??[];for(const t of r)if(!hasNode(e,t))throw Error(`Initial node ${t} does not exist`);return new Walker(t=>({[Symbol.iterator]:()=>{const n=new Map,i=new Set,s=[...r];for(const[t]of e.nodes)n.set(t,0),i.add(t);for(const[,t]of e.edges){const e=n.get(t.target)||0;n.set(t.target,e+1)}if(0===r.length)for(const[e,t]of n)0===t&&s.push(e);const nextMapped=()=>{for(;s.length>0;){const r=s.shift();if(i.has(r)){i.delete(r);const o=neighborsDirected(e,r,"outgoing");for(const e of o)if(i.has(e)){const t=(n.get(e)||0)-1;n.set(e,t),0===t&&s.push(e)}const a=getNode(e,r);return zt(a)?{done:!1,value:t(r,a.value)}:nextMapped()}}return{done:!0,value:void 0}};return{next:nextMapped}}}))},undirected:e=>{const t=Object.create(Kde);if(t.type="undirected",t.nodes=new Map,t.edges=new Map,t.adjacency=new Map,t.reverseAdjacency=new Map,t.nextNodeIndex=0,t.nextEdgeIndex=0,t.isAcyclic=Ut(!0),t.mutable=!1,e){const r=beginMutation(t);return e(r),endMutation(r)}return t},updateEdge:(e,t,r)=>{if(!e.edges.has(t))return;const n=e.edges.get(t),i=r(n.data);e.edges.set(t,{...n,data:i})},updateNode:(e,t,r)=>{if(!e.nodes.has(t))return;const n=r(e.nodes.get(t));e.nodes.set(t,n)},values:e=>e.visit((e,t)=>t)});const Hde=Symbol.for("effect/GroupBy"),Zde={_R:e=>e,_E:e=>e,_K:e=>e,_V:e=>e},Qde=dual(e=>{return t=e[0],C(t,Hde);var t},(e,t,r)=>Sce(e.grouped,([e,r])=>t(e,flattenTake$1(fromQueue$3(r,{shutdown:!0}))),{concurrency:"unbounded",bufferSize:r?.bufferSize??16})),Yde=dual(2,(e,t)=>make$14(pipe(e.grouped,fce(e=>t(e[0])?pipe(G4(e),E3(!0)):pipe(shutdown$4(e[1]),E3(!1)))))),Xde=dual(2,(e,t)=>make$14(pipe(zipWithIndex$1(e.grouped),fce(e=>{const r=e[1],n=e[0][1];return r<t?pipe(G4(e),E3(!0)):pipe(shutdown$4(n),E3(!1))}),Dce(e=>e[0])))),make$14=e=>({[Hde]:Zde,pipe(){return pipeArguments(this,arguments)},grouped:e}),eme=dual(e=>isStream(e[0]),(e,t,r)=>make$14(unwrapScoped$3(V4(function*(){const n=yield*fU(),i=yield*U3(bounded$4(r?.bufferSize??16),e=>shutdown$4(e)),s=yield*Nz(new Map),o=yield*pipe(Gce(e,t),ece(r?.bufferSize??16,([e,t])=>h7(hU(n),r=>r(e,t)),e=>ate(i,e)));return yield*yU(n,(e,t)=>pipe(jz(s),P3(t=>fromNullable$3(t.get(e))),h7(qt({onNone:()=>h7(o,([t,r])=>j8(qz(s,r=>r.set(e,t)),pipe(ate(i,NU([e,mapDequeue(r,e=>new TakeImpl(pipe(e,CU(e=>of$5(e[1])))))])),E3(e=>e===t)))),onSome:e=>G4(t=>t===e)})))),flattenExitOption$1(fromQueue$3(i,{shutdown:!0}))})))),tme=dual(e=>"function"!=typeof e[0],(e,t,r)=>r?.key?Qde(nme(e,r.key,{bufferSize:r.bufferSize}),(e,r)=>Gce(r,t)):matchConcurrency(r?.concurrency,()=>Gce(e,t),n=>r?.unordered?Sce(e,e=>fromEffect$7(t(e)),{concurrency:n}):Jce(e,n,t))),rme=dual(e=>"string"!=typeof e[0],(e,t,r,n)=>tme(e,e=>P3(r(e),r=>({...e,[t]:r})),n)),mapDequeue=(e,t)=>new MapDequeue(e,t);class MapDequeue extends hz{dequeue;f;[ste]={_Out:e=>e};constructor(e,t){super(),this.dequeue=e,this.f=t}capacity(){return capacity$4(this.dequeue)}get size(){return size$j(this.dequeue)}unsafeSize(){return this.dequeue.unsafeSize()}get awaitShutdown(){return awaitShutdown$4(this.dequeue)}isActive(){return this.dequeue.isActive()}get isShutdown(){return isShutdown$4(this.dequeue)}get shutdown(){return shutdown$4(this.dequeue)}get isFull(){return isFull$4(this.dequeue)}get isEmpty(){return isEmpty$d(this.dequeue)}get take(){return pipe(cte(this.dequeue),P3(e=>this.f(e)))}get takeAll(){return pipe(takeAll$4(this.dequeue),P3(fC(e=>this.f(e))))}takeUpTo(e){return pipe(lte(this.dequeue,e),P3(fC(e=>this.f(e))))}takeBetween(e,t){return pipe(pte(this.dequeue,e,t),P3(fC(e=>this.f(e))))}takeN(e){return pipe(fte(this.dequeue,e),P3(fC(e=>this.f(e))))}poll(){return pipe(poll$6(this.dequeue),P3(er(e=>this.f(e))))}pipe(){return pipeArguments(this,arguments)}commit(){return this.take}}const nme=dual(e=>"function"!=typeof e[0],(e,t,r)=>{const loop=(e,n)=>readWithCause$1({onInput:i=>Zte(fromEffect$b(x4(ime(i,t),([t,i])=>{const s=e.get(t);return void 0===s?pipe(bounded$4(r?.bufferSize??16),h7(r=>pipe(Z4(()=>{e.set(t,r)}),j8(ate(n,of$1([t,r]))),j8(pipe(ate(r,chunk$3(i)),s3(e=>ZQ(e)?Ut(Q4):none$c())))))):s3(ate(s,chunk$3(i)),e=>ZQ(e)?Ut(Q4):none$c())},{discard:!0})),()=>loop(e,n)),onFailure:e=>fromEffect$b(ate(n,failCause$6(e))),onDone:()=>fromEffect$b(pipe(x4(e.entries(),([e,t])=>pipe(ate(t,Hae),s3(e=>ZQ(e)?Ut(Q4):none$c())),{discard:!0}),j8(ate(n,Hae))))});return make$14(unwrapScopedWith$3(t=>V4(function*(){const r=new Map,n=yield*ote();return yield*DY(t,shutdown$4(n)),yield*toChannel$4(e).pipe(Yte(loop(r,n)),drain$5,gre(t),c5(t),E3(flattenTake$1(fromQueue$3(n,{shutdown:!0}))))})))}),ime=dual(2,(e,t)=>{const r=[],n=e[Symbol.iterator](),i=new Map;let s;for(;(s=n.next())&&!s.done;){const e=s.value,n=t(e);if(i.has(n))i.get(n).push(e);else{const t=[e];r.push([n,t]),i.set(n,t)}}return unsafeFromArray(r.map(e=>[e[0],unsafeFromArray(e[1])]))});var sme=Object.freeze({__proto__:null,GroupByTypeId:Hde,evaluate:Qde,filter:Yde,first:Xde,make:make$14}),ome=Object.freeze({__proto__:null});class Pointer{path;actual;issue;_tag="Pointer";constructor(e,t,r){this.path=e,this.actual=t,this.issue=r}}class Unexpected{actual;message;_tag="Unexpected";constructor(e,t){this.actual=e,this.message=t}}class Missing{ast;message;_tag="Missing";actual=void 0;constructor(e,t){this.ast=e,this.message=t}}class Composite{ast;actual;issues;output;_tag="Composite";constructor(e,t,r,n){this.ast=e,this.actual=t,this.issues=r,this.output=n}}class Refinement{ast;actual;kind;issue;_tag="Refinement";constructor(e,t,r,n){this.ast=e,this.actual=t,this.kind=r,this.issue=n}}class Transformation{ast;actual;kind;issue;_tag="Transformation";constructor(e,t,r,n){this.ast=e,this.actual=t,this.kind=r,this.issue=n}}class Type{ast;actual;message;_tag="Type";constructor(e,t,r){this.ast=e,this.actual=t,this.message=r}}class Forbidden{ast;actual;message;_tag="Forbidden";constructor(e,t,r){this.ast=e,this.actual=t,this.message=r}}const ame=Symbol.for("effect/Schema/ParseErrorTypeId");class ParseError extends(TaggedError$1("ParseError")){[ame]=ame;get message(){return this.toString()}toString(){return Cme.formatIssueSync(this.issue)}toJSON(){return{_id:"ParseError",message:this.toString()}}[ee](){return this.toJSON()}}const parseError=e=>new ParseError({issue:e}),ume=Ge,cme=He,lme=try_$5,pme=Qe,fme=Ye,hme=dual(2,(e,t)=>fme(e)?ot(e,{onLeft:He,onRight:t}):h7(e,t)),dme=dual(2,(e,t)=>fme(e)?st(e,t):P3(e,t)),mme=dual(2,(e,t)=>fme(e)?it(e,t):R3(e,t)),gme=dual(2,(e,t)=>fme(e)?nt(e,{onLeft:t.onFailure,onRight:t.onSuccess}):j3(e,t)),yme=dual(2,(e,t)=>fme(e)?ot(e,{onLeft:t,onRight:Ge}):e3(e,t)),mergeInternalOptions=(e,t)=>void 0===t||isNumber$1(t)?e:void 0===e?t:{...e,...t},getEither=(e,t,r)=>{const n=goMemo(e,t);return(e,t)=>n(e,mergeInternalOptions(r,t))},getSync=(e,t,r)=>{const n=getEither(e,t,r);return(e,t)=>ht(n(e,t),parseError)},getOption=(e,t,r)=>{const n=getEither(e,t,r);return(e,t)=>Wt(n(e,t))},getEffect=(e,t,r)=>{const n=goMemo(e,t);return(e,t)=>n(e,{...mergeInternalOptions(r,t),isEffectAllowed:!0})},decodeUnknownSync=(e,t)=>getSync(e.ast,!0,t),decodeUnknownOption=(e,t)=>getOption(e.ast,!0,t),decodeUnknownEither$1=(e,t)=>getEither(e.ast,!0,t),decodeUnknownPromise$1=(e,t)=>{const r=decodeUnknown$1(e,t);return(e,t)=>O8(r(e,t))},decodeUnknown$1=(e,t)=>getEffect(e.ast,!0,t),encodeUnknownSync=(e,t)=>getSync(e.ast,!1,t),encodeUnknownOption=(e,t)=>getOption(e.ast,!1,t),encodeUnknownEither$1=(e,t)=>getEither(e.ast,!1,t),encodeUnknownPromise$1=(e,t)=>{const r=encodeUnknown$1(e,t);return(e,t)=>O8(r(e,t))},encodeUnknown$1=(e,t)=>getEffect(e.ast,!1,t),bme=decodeUnknownSync,Sme=decodeUnknownOption,vme=decodeUnknownEither$1,_me=decodeUnknownPromise$1,wme=decodeUnknown$1,validateSync=(e,t)=>getSync(typeAST(e.ast),!0,t),validateOption=(e,t)=>getOption(typeAST(e.ast),!0,t),validateEither$1=(e,t)=>getEither(typeAST(e.ast),!0,t),validate$1=(e,t)=>getEffect(typeAST(e.ast),!0,t),is$2=(e,t)=>{const r=goMemo(typeAST(e.ast),!0);return(e,n)=>et(r(e,{exact:!0,...mergeInternalOptions(t,n)}))},asserts=(e,t)=>{const r=goMemo(typeAST(e.ast),!0);return(e,n)=>{const i=r(e,{exact:!0,...mergeInternalOptions(t,n)});if(Xe(i))throw parseError(i.left)}},kme=encodeUnknownSync,xme=encodeUnknownOption,Ime=encodeUnknownEither$1,Tme=encodeUnknownPromise$1,Ome=encodeUnknown$1,Eme=globalValue(Symbol.for("effect/ParseResult/decodeMemoMap"),()=>new WeakMap),Ame=globalValue(Symbol.for("effect/ParseResult/encodeMemoMap"),()=>new WeakMap),goMemo=(e,t)=>{const r=t?Eme:Ame,n=r.get(e);if(n)return n;const i=go$2(e,t),s=UT(e),o=zt(s)?(e,t)=>i(e,mergeInternalOptions(t,s.value)):i,a=$T(e),u=t&&zt(a)?(t,r)=>handleForbidden(yme(o(t,r),a.value),e,t,r):o;return r.set(e,u),u},getConcurrency=e=>Qt(RT(e)),getBatching=e=>Qt(DT(e)),go$2=(e,t)=>{switch(e._tag){case"Refinement":if(t){const t=goMemo(e.from,!0);return(r,n)=>{n=n??NO;const i="all"===n?.errors,s=hme(yme(t(r,n),t=>{const s=new Refinement(e,r,"From",t);return i&&hasStableFilter(e)&&Fme(t)?qt(e.filter(r,n,e),{onNone:()=>He(s),onSome:t=>He(new Composite(e,r,[s,new Refinement(e,r,"Predicate",t)]))}):He(s)}),t=>qt(e.filter(t,n,e),{onNone:()=>Ge(t),onSome:t=>He(new Refinement(e,r,"Predicate",t))}));return handleForbidden(s,e,r,n)}}{const t=goMemo(typeAST(e),!0),r=goMemo(dropRightRefinement(e.from),!1);return(n,i)=>handleForbidden(hme(t(n,i),e=>r(e,i)),e,n,i)}case"Transformation":{const r=getFinalTransformation(e.transformation,t),n=t?goMemo(e.from,!0):goMemo(e.to,!1),i=t?goMemo(e.to,!0):goMemo(e.from,!1);return(s,o)=>handleForbidden(hme(mme(n(s,o),r=>new Transformation(e,s,t?"Encoded":"Type",r)),n=>hme(mme(r(n,o??NO,e,s),t=>new Transformation(e,s,"Transformation",t)),r=>mme(i(r,o),r=>new Transformation(e,s,t?"Type":"Encoded",r)))),e,s,o)}case"Declaration":{const r=t?e.decodeUnknown(...e.typeParameters):e.encodeUnknown(...e.typeParameters);return(t,n)=>handleForbidden(r(t,n??NO,e),e,t,n)}case"Literal":return fromRefinement(e,t=>t===e.literal);case"UniqueSymbol":return fromRefinement(e,t=>t===e.symbol);case"UndefinedKeyword":return fromRefinement(e,isUndefined);case"NeverKeyword":return fromRefinement(e,isNever);case"UnknownKeyword":case"AnyKeyword":case"VoidKeyword":return Ge;case"StringKeyword":return fromRefinement(e,isString$1);case"NumberKeyword":return fromRefinement(e,isNumber$1);case"BooleanKeyword":return fromRefinement(e,isBoolean$1);case"BigIntKeyword":return fromRefinement(e,isBigInt$1);case"SymbolKeyword":return fromRefinement(e,isSymbol$1);case"ObjectKeyword":return fromRefinement(e,isObject);case"Enums":return fromRefinement(e,t=>e.enums.some(([e,r])=>r===t));case"TemplateLiteral":{const t=getTemplateLiteralRegExp(e);return fromRefinement(e,e=>isString$1(e)&&t.test(e))}case"TupleType":{const r=e.elements.map(e=>goMemo(e.type,t)),n=e.rest.map(e=>goMemo(e.type,t));let i=e.elements.filter(e=>!e.isOptional);e.rest.length>0&&(i=i.concat(e.rest.slice(1)));const s=i.length,o=e.elements.length>0?e.elements.map((e,t)=>t).join(" | "):"never",a=getConcurrency(e),u=getBatching(e);return(t,c)=>{if(!oi(t))return He(new Type(e,t));const l="all"===c?.errors,p=[];let d=0;const m=[],g=t.length;for(let r=g;r<=s-1;r++){const n=new Pointer(r,t,new Missing(i[r-g]));if(!l)return He(new Composite(e,t,n,m));p.push([d++,n])}if(0===e.rest.length)for(let r=e.elements.length;r<=g-1;r++){const n=new Pointer(r,t,new Unexpected(t[r],"is unexpected, expected: "+o));if(!l)return He(new Composite(e,t,n,m));p.push([d++,n])}let y,b=0;for(;b<r.length;b++)if(g<b+1){if(e.elements[b].isOptional)continue}else{const n=(0,r[b])(t[b],c);if(fme(n)){if(Xe(n)){const r=new Pointer(b,t,n.left);if(l){p.push([d++,r]);continue}return He(new Composite(e,t,r,sortByIndex(m)))}m.push([d++,n.right])}else{const r=d++,i=b;y||(y=[]),y.push(({es:s,output:o})=>h7(Q5(n),n=>{if(Xe(n)){const a=new Pointer(i,t,n.left);return l?(s.push([r,a]),Q4):He(new Composite(e,t,a,sortByIndex(o)))}return o.push([r,n.right]),Q4}))}}if(ci(n)){const[r,...i]=n;for(;b<g-i.length;b++){const n=r(t[b],c);if(fme(n)){if(Xe(n)){const r=new Pointer(b,t,n.left);if(l){p.push([d++,r]);continue}return He(new Composite(e,t,r,sortByIndex(m)))}m.push([d++,n.right])}else{const r=d++,i=b;y||(y=[]),y.push(({es:s,output:o})=>h7(Q5(n),n=>{if(Xe(n)){const a=new Pointer(i,t,n.left);return l?(s.push([r,a]),Q4):He(new Composite(e,t,a,sortByIndex(o)))}return o.push([r,n.right]),Q4}))}}for(let r=0;r<i.length;r++)if(b+=r,!(g<b+1)){const n=i[r](t[b],c);if(fme(n)){if(Xe(n)){const r=new Pointer(b,t,n.left);if(l){p.push([d++,r]);continue}return He(new Composite(e,t,r,sortByIndex(m)))}m.push([d++,n.right])}else{const r=d++,i=b;y||(y=[]),y.push(({es:s,output:o})=>h7(Q5(n),n=>{if(Xe(n)){const a=new Pointer(i,t,n.left);return l?(s.push([r,a]),Q4):He(new Composite(e,t,a,sortByIndex(o)))}return o.push([r,n.right]),Q4}))}}}const computeResult=({es:r,output:n})=>ui(r)?He(new Composite(e,t,sortByIndex(r),sortByIndex(n))):Ge(sortByIndex(n));if(y&&y.length>0){const e=y;return H4(()=>{const t={es:copy$2(p),output:copy$2(m)};return h7(x4(e,e=>e(t),{concurrency:a,batching:u,discard:!0}),()=>computeResult(t))})}return computeResult({output:m,es:p})}}case"TypeLiteral":{if(0===e.propertySignatures.length&&0===e.indexSignatures.length)return fromRefinement(e,isNotNullable);const r=[],n={},i=[];for(const s of e.propertySignatures)r.push([goMemo(s.type,t),s]),n[s.name]=null,i.push(s.name);const s=e.indexSignatures.map(e=>[goMemo(e.parameter,t),goMemo(e.type,t),e.parameter]),o=EO.make(e.indexSignatures.map(e=>e.parameter).concat(i.map(e=>isSymbol$1(e)?new UniqueSymbol(e):new GT(e)))),a=goMemo(o,t),u=getConcurrency(e),c=getBatching(e);return(t,l)=>{if(!isRecord(t))return He(new Type(e,t));const p="all"===l?.errors,d=[];let m=0;const g="error"===l?.onExcessProperty,y={};let b,S;if(g||"preserve"===l?.onExcessProperty){b=Reflect.ownKeys(t);for(const r of b){const n=a(r,l);if(fme(n)&&Xe(n)){if(g){const n=new Pointer(r,t,new Unexpected(t[r],"is unexpected, expected: "+o));if(p){d.push([m++,n]);continue}return He(new Composite(e,t,n,y))}y[r]=t[r]}}}const v=!0===l?.exact;for(let n=0;n<r.length;n++){const i=r[n][1],name=i.name,s=Object.prototype.hasOwnProperty.call(t,name);if(!s){if(i.isOptional)continue;if(v){const r=new Pointer(name,t,new Missing(i));if(p){d.push([m++,r]);continue}return He(new Composite(e,t,r,y))}}const o=(0,r[n][0])(t[name],l);if(fme(o)){if(Xe(o)){const r=new Pointer(name,t,s?o.left:new Missing(i));if(p){d.push([m++,r]);continue}return He(new Composite(e,t,r,y))}y[name]=o.right}else{const r=m++,n=name;S||(S=[]),S.push(({es:a,output:u})=>h7(Q5(o),o=>{if(Xe(o)){const c=new Pointer(n,t,s?o.left:new Missing(i));return p?(a.push([r,c]),Q4):He(new Composite(e,t,c,u))}return u[n]=o.right,Q4}))}}for(let r=0;r<s.length;r++){const i=s[r],o=i[0],a=i[1],u=getKeysForIndexSignature(t,i[2]);for(const r of u){const i=o(r,l);if(fme(i)&&et(i)){const i=a(t[r],l);if(fme(i)){if(Xe(i)){const n=new Pointer(r,t,i.left);if(p){d.push([m++,n]);continue}return He(new Composite(e,t,n,y))}Object.prototype.hasOwnProperty.call(n,r)||(y[r]=i.right)}else{const s=m++,o=r;S||(S=[]),S.push(({es:a,output:u})=>h7(Q5(i),i=>{if(Xe(i)){const r=new Pointer(o,t,i.left);return p?(a.push([s,r]),Q4):He(new Composite(e,t,r,u))}return Object.prototype.hasOwnProperty.call(n,r)||(u[r]=i.right),Q4}))}}}}const computeResult=({es:r,output:n})=>{if(ui(r))return He(new Composite(e,t,sortByIndex(r),n));if("original"===l?.propertyOrder){const e=b||Reflect.ownKeys(t);for(const name of i)-1===e.indexOf(name)&&e.push(name);const r={};for(const t of e)Object.prototype.hasOwnProperty.call(n,t)&&(r[t]=n[t]);return Ge(r)}return Ge(n)};if(S&&S.length>0){const e=S;return H4(()=>{const t={es:copy$2(d),output:Object.assign({},y)};return h7(x4(e,e=>e(t),{concurrency:u,batching:c,discard:!0}),()=>computeResult(t))})}return computeResult({es:d,output:y})}}case"Union":{const r=getSearchTree(e.types,t),n=Reflect.ownKeys(r.keys),i=n.length,s=e.types.length,o=new Map;for(let r=0;r<s;r++)o.set(e.types[r],goMemo(e.types[r],t));const a=getConcurrency(e)??1,u=getBatching(e);return(t,c)=>{const l=[];let p,d=0,m=[];if(i>0)if(isRecordOrArray(t))for(let e=0;e<i;e++){const name=n[e],i=r.keys[name].buckets;if(Object.prototype.hasOwnProperty.call(t,name)){const e=t[name]+"";if(Object.prototype.hasOwnProperty.call(i,e))m=m.concat(i[e]);else{const{candidates:e,literals:n}=r.keys[name],i=EO.make(n),o=e.length===s?new TypeLiteral([new PropertySignature(name,i,!1,!0)],[]):EO.make(e);l.push([d++,new Composite(o,t,new Pointer(name,t,new Type(i,t[name])))])}}else{const{candidates:e,literals:n}=r.keys[name],i=new PropertySignature(name,EO.make(n),!1,!0),o=e.length===s?new TypeLiteral([i],[]):EO.make(e);l.push([d++,new Composite(o,t,new Pointer(name,t,new Missing(i)))])}}else{const n=r.candidates.length===s?e:EO.make(r.candidates);l.push([d++,new Type(n,t)])}r.otherwise.length>0&&(m=m.concat(r.otherwise));for(let e=0;e<m.length;e++){const r=m[e],n=o.get(r)(t,c);if(!fme(n)||p&&0!==p.length){const e=d++;p||(p=[]),p.push(t=>H4(()=>"finalResult"in t?Q4:h7(Q5(n),r=>(et(r)?t.finalResult=r:t.es.push([e,r.left]),Q4))))}else{if(et(n))return n;l.push([d++,n.left])}}const computeResult=r=>ui(r)?1===r.length&&"Type"===r[0][1]._tag?He(r[0][1]):He(new Composite(e,t,sortByIndex(r))):He(new Type(e,t));if(p&&p.length>0){const e=p;return H4(()=>{const t={es:copy$2(l)};return h7(x4(e,e=>e(t),{concurrency:a,batching:u,discard:!0}),()=>"finalResult"in t?t.finalResult:computeResult(t.es))})}return computeResult(l)}}case"Suspend":{const r=memoizeThunk(()=>goMemo(e.f(),t));return(e,t)=>r()(e,t)}}},fromRefinement=(e,t)=>r=>t(r)?Ge(r):He(new Type(e,r)),getLiterals=(e,t)=>{switch(e._tag){case"Declaration":{const r=BT(e);if(zt(r))return getLiterals(r.value,t);break}case"TypeLiteral":{const r=[];for(let n=0;n<e.propertySignatures.length;n++){const i=e.propertySignatures[n],s=t?encodedAST(i.type):typeAST(i.type);JT(s)&&!i.isOptional&&r.push([i.name,s])}return r}case"TupleType":{const r=[];for(let n=0;n<e.elements.length;n++){const i=e.elements[n],s=t?encodedAST(i.type):typeAST(i.type);JT(s)&&!i.isOptional&&r.push([n,s])}return r}case"Refinement":return getLiterals(e.from,t);case"Suspend":return getLiterals(e.f(),t);case"Transformation":return getLiterals(t?e.from:e.to,t)}return[]},getSearchTree=(e,t)=>{const r={},n=[],i=[];for(let s=0;s<e.length;s++){const o=e[s],a=getLiterals(o,t);if(a.length>0){i.push(o);for(let e=0;e<a.length;e++){const[t,n]=a[e],i=n.literal+"";r[t]=r[t]||{buckets:{},literals:[],candidates:[]};const s=r[t].buckets;if(!Object.prototype.hasOwnProperty.call(s,i)){s[i]=[o],r[t].literals.push(n),r[t].candidates.push(o);break}e<a.length-1||(s[i].push(o),r[t].literals.push(n),r[t].candidates.push(o))}}else n.push(o)}return{keys:r,otherwise:n,candidates:i}},dropRightRefinement=e=>PO(e)?dropRightRefinement(e.from):e,handleForbidden=(e,t,r,n)=>{if(!0===n?.isEffectAllowed)return e;if(fme(e))return e;const i=new SyncScheduler,s=I8(e,{scheduler:i});i.flush();const o=s.unsafePoll();if(o){if(kU(o))return Ge(o.value);const e=o.cause;return isFailType(e)?He(e.error):He(new Forbidden(t,r,iY(e)))}return He(new Forbidden(t,r,"cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"))},compare=([e],[t])=>e>t?1:e<t?-1:0;function sortByIndex(e){return e.sort(compare).map(e=>e[1])}const getFinalTransformation=(e,t)=>{switch(e._tag){case"FinalTransformation":return t?e.decode:e.encode;case"ComposeTransformation":return Ge;case"TypeLiteralTransformation":return r=>{let n=Ge(r);for(const r of e.propertySignatureTransformations){const[e,i]=t?[r.from,r.to]:[r.to,r.from],s=t?r.decode:r.encode,f=t=>{const r=s(Object.prototype.hasOwnProperty.call(t,e)?Ut(t[e]):none$c());return delete t[e],zt(r)&&(t[i]=r.value),t};n=dme(n,f)}return n}}},makeTree=(e,t=[])=>({value:e,forest:t}),Cme={formatIssue:e=>dme(formatTree(e),drawTree),formatIssueSync:e=>{const t=Cme.formatIssue(e);return fme(t)?dt(t):A8(t)},formatError:e=>Cme.formatIssue(e.issue),formatErrorSync:e=>Cme.formatIssueSync(e.issue)},drawTree=e=>e.value+draw("\n",e.forest),draw=(e,t)=>{let r="";const n=t.length;let i;for(let s=0;s<n;s++){i=t[s];const o=s===n-1;r+=e+(o?"\u2514":"\u251c")+"\u2500 "+i.value,r+=draw(e+(n>1&&!o?"\u2502  ":"   "),i.forest)}return r},formatTransformationKind=e=>{switch(e){case"Encoded":return"Encoded side transformation failure";case"Transformation":return"Transformation process failure";case"Type":return"Type side transformation failure"}},formatRefinementKind=e=>{switch(e){case"From":return"From side refinement failure";case"Predicate":return"Predicate refinement failure"}},getAnnotated=e=>"ast"in e?Ut(e.ast):none$c(),Mme=Ge(void 0),createParseIssueGuard=e=>t=>t._tag===e,Fme=createParseIssueGuard("Composite"),Pme=createParseIssueGuard("Refinement"),Nme=createParseIssueGuard("Transformation"),getMessage=e=>hme((e=>getAnnotated(e).pipe(ir(TT),qt({onNone:()=>Mme,onSome:t=>{const r=t(e);return isString$1(r)?Ge({message:r,override:!1}):c4(r)?P3(r,e=>({message:e,override:!1})):isString$1(r.message)?Ge({message:r.message,override:r.override}):P3(r.message,e=>({message:e,override:r.override}))}})))(e),t=>void 0!==t?!t.override&&(Fme(e)||Pme(e)&&"From"===e.kind||Nme(e)&&"Transformation"!==e.kind)?Nme(e)||Pme(e)?getMessage(e.issue):Mme:Ge(t.message):Mme),getParseIssueTitleAnnotation=e=>getAnnotated(e).pipe(ir(LT),or(t=>t(e)),Qt);function getRefinementExpected(e){return MT(e).pipe(Gt(()=>ET(e)),Gt(()=>AT(e)),Gt(()=>CT(e)),Kt(()=>`{ ${e.from} | filter }`))}const formatTypeMessage=e=>dme(getMessage(e),t=>t??getParseIssueTitleAnnotation(e)??function(e){return void 0!==e.message?e.message:`Expected ${PO(e.ast)?getRefinementExpected(e.ast):e.ast+""}, actual ${formatUnknown$1(e.actual)}`}(e)),getParseIssueTitle=e=>getParseIssueTitleAnnotation(e)??e.ast+"",formatForbiddenMessage=e=>e.message??"is forbidden",formatUnexpectedMessage=e=>e.message??"is unexpected",formatMissingMessage=e=>{const t=OT(e.ast);if(zt(t)){const e=t.value();return isString$1(e)?Ge(e):e}return Ge(e.message??"is missing")},formatTree=e=>{switch(e._tag){case"Type":return dme(formatTypeMessage(e),makeTree);case"Forbidden":return Ge(makeTree(getParseIssueTitle(e),[makeTree(formatForbiddenMessage(e))]));case"Unexpected":return Ge(makeTree(formatUnexpectedMessage(e)));case"Missing":return dme(formatMissingMessage(e),makeTree);case"Transformation":return hme(getMessage(e),t=>void 0!==t?Ge(makeTree(t)):dme(formatTree(e.issue),t=>makeTree(getParseIssueTitle(e),[makeTree(formatTransformationKind(e.kind),[t])])));case"Refinement":return hme(getMessage(e),t=>void 0!==t?Ge(makeTree(t)):dme(formatTree(e.issue),t=>makeTree(getParseIssueTitle(e),[makeTree(formatRefinementKind(e.kind),[t])])));case"Pointer":return dme(formatTree(e.issue),t=>makeTree(formatPath(e.path),[t]));case"Composite":return hme(getMessage(e),t=>{if(void 0!==t)return Ge(makeTree(t));const r=getParseIssueTitle(e);return isNonEmpty$9(e.issues)?dme(x4(e.issues,formatTree),e=>makeTree(r,e)):dme(formatTree(e.issues),e=>makeTree(r,[e]))})}},makeArrayFormatterIssue=(e,t,r)=>({_tag:e,path:t,message:r}),jme={formatIssue:e=>getArrayFormatterIssues(e,void 0,[]),formatIssueSync:e=>{const t=jme.formatIssue(e);return fme(t)?dt(t):A8(t)},formatError:e=>jme.formatIssue(e.issue),formatErrorSync:e=>jme.formatIssueSync(e.issue)},getArrayFormatterIssues=(e,t,r)=>{const n=e._tag;switch(n){case"Type":return dme(formatTypeMessage(e),e=>[makeArrayFormatterIssue(t??n,r,e)]);case"Forbidden":return Ge([makeArrayFormatterIssue(n,r,formatForbiddenMessage(e))]);case"Unexpected":return Ge([makeArrayFormatterIssue(n,r,formatUnexpectedMessage(e))]);case"Missing":return dme(formatMissingMessage(e),e=>[makeArrayFormatterIssue(n,r,e)]);case"Pointer":return getArrayFormatterIssues(e.issue,void 0,r.concat(e.path));case"Composite":return hme(getMessage(e),t=>void 0!==t?Ge([makeArrayFormatterIssue(n,r,t)]):isNonEmpty$9(e.issues)?dme(x4(e.issues,e=>getArrayFormatterIssues(e,void 0,r)),cs):getArrayFormatterIssues(e.issues,void 0,r));case"Refinement":return hme(getMessage(e),t=>void 0!==t?Ge([makeArrayFormatterIssue(n,r,t)]):getArrayFormatterIssues(e.issue,"Predicate"===e.kind?n:void 0,r));case"Transformation":return hme(getMessage(e),t=>void 0!==t?Ge([makeArrayFormatterIssue(n,r,t)]):getArrayFormatterIssues(e.issue,"Transformation"===e.kind?n:void 0,r))}};var Rme=Object.freeze({__proto__:null,ArrayFormatter:jme,Composite,Forbidden,Missing,ParseError,ParseErrorTypeId:ame,Pointer,Refinement,Transformation,TreeFormatter:Cme,Type,Unexpected,asserts,decode:wme,decodeEither:vme,decodeOption:Sme,decodePromise:_me,decodeSync:bme,decodeUnknown:decodeUnknown$1,decodeUnknownEither:decodeUnknownEither$1,decodeUnknownOption,decodeUnknownPromise:decodeUnknownPromise$1,decodeUnknownSync,eitherOrUndefined:e=>{if(fme(e))return e},encode:Ome,encodeEither:Ime,encodeOption:xme,encodePromise:Tme,encodeSync:kme,encodeUnknown:encodeUnknown$1,encodeUnknownEither:encodeUnknownEither$1,encodeUnknownOption,encodeUnknownPromise:encodeUnknownPromise$1,encodeUnknownSync,fail:cme,flatMap:hme,fromOption:pme,getFinalTransformation,getLiterals,getOption,getRefinementExpected,getSearchTree,is:is$2,isComposite:Fme,isParseError:e=>C(e,ame),map:dme,mapBoth:gme,mapError:mme,mergeInternalOptions,orElse:yme,parseError,succeed:ume,try:lme,validate:validate$1,validateEither:validateEither$1,validateOption,validatePromise:(e,t)=>{const r=validate$1(e,t);return(e,t)=>O8(r(e,t))},validateSync});const fromAST=(e,t)=>{const r=t.definitionPath??"#/$defs/",n=t.target??"jsonSchema7",i=t.topLevelReferenceStrategy??"keep",s=t.additionalPropertiesStrategy??"strict";return go$1(e,t.definitions,"handle-identifier",[],{getRef:e=>r+e,target:n,topLevelReferenceStrategy:i,additionalPropertiesStrategy:s},"handle-annotation","handle-errors")},Dme={$id:"/schemas/never",not:{}},Lme={$id:"/schemas/any"},Ume={$id:"/schemas/unknown"},$me={$id:"/schemas/void"},Bme={$id:"/schemas/object",anyOf:[{type:"object"},{type:"array"}]},zme={$id:"/schemas/%7B%7D",anyOf:[{type:"object"},{type:"array"}]};function getRawDescription(e){if(void 0!==e)return Qt(MT(e))}function getRawTitle(e){if(void 0!==e)return Qt(ET(e))}function getRawDefault(e){return void 0!==e?PT(e):none$c()}function getRawExamples(e){if(void 0!==e)return Qt(FT(e))}function filterBuiltIn(e,t,r){if(void 0!==t)switch(e._tag){case"StringKeyword":return t!==aO.annotations[r]?t:void 0;case"NumberKeyword":return t!==cO.annotations[r]?t:void 0;case"BooleanKeyword":return t!==pO.annotations[r]?t:void 0}return t}function pruneJsonSchemaAnnotations(e,description,t,r,n){const i={};if(void 0!==description&&(i.description=description),void 0!==t&&(i.title=t),zt(r)){const t=function(e,t){return getOption(e,!1)(t)}(e,r.value);zt(t)&&(i.default=t.value)}if(void 0!==n){const t=function(e,t){const r=getOption(e,!1),n=ls(t,e=>r(e));return n.length>0?n:void 0}(e,n);void 0!==t&&(i.examples=t)}if(0!==Object.keys(i).length)return i}function getContextJsonSchemaAnnotations(e,t){return pruneJsonSchemaAnnotations(e,getRawDescription(t),getRawTitle(t),getRawDefault(t),getRawExamples(t))}function getJsonSchemaAnnotations(e){return pruneJsonSchemaAnnotations(e,filterBuiltIn(e,getRawDescription(e),uT),filterBuiltIn(e,getRawTitle(e),oT),getRawDefault(e),getRawExamples(e))}function mergeJsonSchemaAnnotations(e,t){return t?"$ref"in e?{allOf:[e],...t}:{...e,...t}:e}const pruneUndefined$1=e=>{if(Bt(NT(e)))return pruneUndefined$2(e,pruneUndefined$1,e=>pruneUndefined$1(e.from))},isParseJsonTransformation=e=>e.annotations[rT]===VT,isOverrideAnnotation=(e,t)=>PO(e)&&e.annotations[rT]===vI?"type"in t&&"integer"!==t.type:"type"in t||"oneOf"in t||"anyOf"in t||"$ref"in t,mergeRefinements=(e,t,r)=>{const n={...e,...getJsonSchemaAnnotations(r),...t};n.allOf??=[];const handle=(name,r)=>{name in t&&name in e&&(n.allOf.unshift({[name]:e[name]}),n.allOf=n.allOf.filter(r))};return handle("minLength",e=>e.minLength>t.minLength),handle("maxLength",e=>e.maxLength<t.maxLength),handle("pattern",e=>e.pattern!==t.pattern),handle("minItems",e=>e.minItems>t.minItems),handle("maxItems",e=>e.maxItems<t.maxItems),handle("minimum",e=>e.minimum>t.minimum),handle("maximum",e=>e.maximum<t.maximum),handle("exclusiveMinimum",e=>e.exclusiveMinimum>t.exclusiveMinimum),handle("exclusiveMaximum",e=>e.exclusiveMaximum<t.exclusiveMaximum),handle("multipleOf",e=>e.multipleOf!==t.multipleOf),0===n.allOf.length&&delete n.allOf,n};function getAdditionalProperties(e){switch(e.additionalPropertiesStrategy){case"allow":return!0;case"strict":return!1}}function addASTAnnotations(e,t){return addAnnotations(e,getJsonSchemaAnnotations(t))}function addAnnotations(e,t){return void 0===t||0===Object.keys(t).length?e:"$ref"in e?{allOf:[e],...t}:{...e,...t}}function getIdentifierAnnotation(e){const t=Qt(getJSONIdentifier(e));if(void 0===t){if(MO(e))return getIdentifierAnnotation(e.f());if(RO(e)&&IO(e.from)&&KT(e.to)){const t=e.to,r=BT(t);if(zt(r))return getIdentifierAnnotation(t)}}return t}function go$1(e,t,r,n,i,s,o){if("handle-identifier"===r&&("skip"!==i.topLevelReferenceStrategy||MO(e))){const r=getIdentifierAnnotation(e);if(void 0!==r){const s=r.replace(/~/gi,"~0").replace(/\//gi,"~1"),a={$ref:i.getRef(s)};return wn(t,r)||(t[r]=a,t[r]=go$1(e,t,"ignore-identifier",n,i,"handle-annotation",o)),a}}if("handle-annotation"===s){const s=NT(e);if(zt(s)){const a=s.value;if(isOverrideAnnotation(e,a))return"Declaration"===e._tag?addASTAnnotations(a,e):a;if("Refinement"===e._tag){const s=getTransformationFrom(e);return void 0===s?mergeRefinements(go$1(e.from,t,r,n,i,"handle-annotation",o),a,e):go$1(s,t,r,n,i,"handle-annotation",o)}return{...go$1(e,t,r,n,i,"ignore-annotation",o),...a}}}const a=BT(e);if(zt(a))return go$1(a.value,t,r,n,i,"handle-annotation",o);switch(e._tag){case"Declaration":case"UndefinedKeyword":case"BigIntKeyword":case"UniqueSymbol":case"SymbolKeyword":if("ignore-errors"===o)return addASTAnnotations(Lme,e);throw Error(getJSONSchemaMissingAnnotationErrorMessage(n,e));case"Suspend":if("handle-identifier"===r){if("ignore-errors"===o)return addASTAnnotations(Lme,e);throw Error(((e,t)=>getMissingAnnotationErrorMessage('Generating a JSON Schema for this schema requires an "identifier" annotation',e,t))(n,e))}return go$1(e.f(),t,"ignore-identifier",n,i,"handle-annotation",o);case"NeverKeyword":return addASTAnnotations(Dme,e);case"VoidKeyword":return addASTAnnotations($me,e);case"UnknownKeyword":return addASTAnnotations(Ume,e);case"AnyKeyword":return addASTAnnotations(Lme,e);case"ObjectKeyword":return addASTAnnotations(Bme,e);case"StringKeyword":return addASTAnnotations({type:"string"},e);case"NumberKeyword":return addASTAnnotations({type:"number"},e);case"BooleanKeyword":return addASTAnnotations({type:"boolean"},e);case"Literal":{const t=e.literal;if(null===t)return addASTAnnotations({type:"null"},e);if(isString$1(t))return addASTAnnotations({type:"string",enum:[t]},e);if(isNumber$1(t))return addASTAnnotations({type:"number",enum:[t]},e);if(isBoolean$1(t))return addASTAnnotations({type:"boolean",enum:[t]},e);if("ignore-errors"===o)return addASTAnnotations(Lme,e);throw Error(getJSONSchemaMissingAnnotationErrorMessage(n,e))}case"Enums":{const t=e.enums.map(e=>({type:isNumber$1(e[1])?"number":"string",title:e[0],enum:[e[1]]}));return t.length>=1?addASTAnnotations({$comment:"/schemas/enums",anyOf:t},e):addASTAnnotations(Dme,e)}case"TupleType":{const r=e.elements.map((e,r)=>mergeJsonSchemaAnnotations(go$1(e.type,t,"handle-identifier",n.concat(r),i,"handle-annotation",o),getContextJsonSchemaAnnotations(e.type,e))),s=e.rest.map(e=>mergeJsonSchemaAnnotations(go$1(e.type,t,"handle-identifier",n,i,"handle-annotation",o),getContextJsonSchemaAnnotations(e.type,e))),a={type:"array"},u=e.elements.length;u>0&&(a.minItems=u-e.elements.filter(e=>e.isOptional).length,a.items=r);const c=s.length;if(c>0){const t=s[0];if(1===c&&e.elements.every(t=>t.type===e.rest[0].type)?a.items=t:a.additionalItems=t,c>1){if("ignore-errors"===o)return addASTAnnotations(Lme,e);throw Error((e=>getErrorMessage$1("Generating a JSON Schema for post-rest elements is not currently supported. You're welcome to contribute by submitting a Pull Request",void 0,e))(n))}}else u>0?a.additionalItems=!1:a.maxItems=0;return addASTAnnotations(a,e)}case"TypeLiteral":{if(0===e.propertySignatures.length&&0===e.indexSignatures.length)return addASTAnnotations(zme,e);const r={type:"object",required:[],properties:{},additionalProperties:getAdditionalProperties(i)};let s,a;for(const u of e.indexSignatures){const e=pruneUndefined$1(u.type)??u.type,c=u.parameter;switch(c._tag){case"StringKeyword":r.additionalProperties=go$1(e,t,"handle-identifier",n,i,"handle-annotation",o);break;case"TemplateLiteral":s=go$1(e,t,"handle-identifier",n,i,"handle-annotation",o),a={type:"string",pattern:getTemplateLiteralRegExp(c).source};break;case"Refinement":s=go$1(e,t,"handle-identifier",n,i,"handle-annotation",o),a=go$1(c,t,"handle-identifier",n,i,"handle-annotation",o);break;case"SymbolKeyword":{const s=n.concat("[symbol]");r.additionalProperties=go$1(e,t,"handle-identifier",s,i,"handle-annotation",o),a=go$1(c,t,"handle-identifier",s,i,"handle-annotation",o);break}}}for(let s=0;s<e.propertySignatures.length;s++){const a=e.propertySignatures[s],name=a.name;if(!isString$1(name)){if("ignore-errors"===o)return addASTAnnotations(Lme,e);throw Error(getJSONSchemaUnsupportedKeyErrorMessage(name,n))}{const e=pruneUndefined$1(a.type),s=e??a.type;r.properties[name]=mergeJsonSchemaAnnotations(go$1(s,t,"handle-identifier",n.concat(a.name),i,"handle-annotation",o),getContextJsonSchemaAnnotations(s,a)),a.isOptional||void 0!==e||r.required.push(name)}}return void 0!==s&&(delete r.additionalProperties,r.patternProperties={"":s}),void 0!==a&&(r.propertyNames=a),addASTAnnotations(r,e)}case"Union":{const r=function(e){const t=[];for(const r of e)if(!isNeverWithoutCustomAnnotations(r)){if(isAny(r)||isUnknown(r)||isVoid(r))return[r];if(isCompactableLiteral(r)&&t.length>0){const e=t[t.length-1];if(isCompactableLiteral(e)&&e.type===r.type){t[t.length-1]={type:e.type,enum:[...e.enum,...r.enum]};continue}}t.push(r)}return t}(e.types.map(e=>go$1(e,t,"handle-identifier",n,i,"handle-annotation",o)));switch(r.length){case 0:return Dme;case 1:return addASTAnnotations(r[0],e);default:return addASTAnnotations({anyOf:r},e)}}case"Refinement":return go$1(e.from,t,r,n,i,"handle-annotation",o);case"TemplateLiteral":{const t=getTemplateLiteralRegExp(e);return addASTAnnotations({type:"string",title:e+"",description:"a template literal",pattern:t.source},e)}case"Transformation":{if(isParseJsonTransformation(e.from)){const s={type:"string",contentMediaType:"application/json"};return function(e){switch(e.target){case"jsonSchema7":return!1;case"jsonSchema2019-09":case"openApi3.1":return!0}}(i)&&(s.contentSchema=go$1(e.to,t,r,n,i,"handle-annotation",o)),s}const s=go$1(e.from,t,r,n,i,"handle-annotation",o);if("TypeLiteralTransformation"===e.transformation._tag&&isJsonSchema7Object(s)){const t=go$1(e.to,{},"ignore-identifier",n,i,"handle-annotation","ignore-errors");if(isJsonSchema7Object(t))for(const r of e.transformation.propertySignatureTransformations){const e=r.to,n=r.from;if(isString$1(e)&&isString$1(n)){const r=t.properties[e];if(isRecord(r)){const e=s.properties[n];if(isRecord(e)){const t={};isString$1(r.title)&&(t.title=r.title),isString$1(r.description)&&(t.description=r.description),Array.isArray(r.examples)&&(t.examples=r.examples),Object.hasOwn(r,"default")&&(t.default=r.default),s.properties[n]=addAnnotations(e,t)}}}}}return addASTAnnotations(s,e)}}}function isJsonSchema7Object(e){return isRecord(e)&&"object"===e.type&&isRecord(e.properties)}function isNeverWithoutCustomAnnotations(e){return e===Dme||C(e,"$id")&&e.$id===Dme.$id&&3===Object.keys(e).length&&e.title===tO.annotations[oT]}function isAny(e){return"$id"in e&&e.$id===Lme.$id}function isUnknown(e){return"$id"in e&&e.$id===Ume.$id}function isVoid(e){return"$id"in e&&e.$id===$me.$id}function isCompactableLiteral(e){return C(e,"enum")&&"type"in e&&2===Object.keys(e).length}var qme=Object.freeze({__proto__:null,fromAST,make:e=>{const t={},r=RO(e.ast)&&isParseJsonTransformation(e.ast.from)?e.ast.to:e.ast,n={$schema:"http://json-schema.org/draft-07/schema#",$defs:{},...fromAST(r,{definitions:t})};return isEmptyRecord(t)?delete n.$defs:n.$defs=t,n}});const Wme=Symbol.for("effect/Pool"),Vme={_E:e=>e,_A:e=>e},makeWith$4=e=>uninterruptibleMask$2(t=>PR(context$c(),r=>{const n=jA(r,_Q),i=uU(e.acquire,e=>LA(r,e)),s=new PoolImpl(n,i,e.concurrency??1,e.min,e.max,e.strategy,Math.min(Math.max(e.targetUtilization??1,.1),1)),o=XR(forkDaemon$1(t(s.resize)),e=>n.addFinalizer(()=>interruptFiber(e))),a=XR(forkDaemon$1(t(e.strategy.run(s))),e=>n.addFinalizer(()=>interruptFiber(e)));return succeed$u(s).pipe(cD(n.addFinalizer(()=>s.shutdown)),cD(o),cD(a))})),makeWithTTL$3=e=>PR("creation"===e.timeToLiveStrategy?strategyCreationTTL(e.timeToLive):strategyUsageTTL(e.timeToLive),t=>makeWith$4({...e,strategy:t})),get$r=e=>e.get,Kme=dual(2,(e,t)=>e.invalidate(t));class PoolImpl extends hz{scope;acquire;concurrency;minSize;maxSize;strategy;targetUtilization;[Wme];isShuttingDown=!1;semaphore;items=new Set;available=new Set;availableLatch=unsafeMakeLatch$1(!1);invalidated=new Set;waiters=0;constructor(e,t,r,n,i,s,o){super(),this.scope=e,this.acquire=t,this.concurrency=r,this.minSize=n,this.maxSize=i,this.strategy=s,this.targetUtilization=o,this[Wme]=Vme,this.semaphore=unsafeMakeSemaphore$2(r*i)}allocate=IR(scopeMake(),e=>this.acquire.pipe(xQ(e),exit$2,PR(t=>{const r={exit:t,finalizer:OR(e.close(t),reportUnhandledError),refCount:0,disableReclaim:!1};return this.items.add(r),this.available.add(r),TR("Success"===t._tag?this.strategy.onAcquire(r):lD(r.finalizer,this.strategy.onAcquire(r)),r)})),(e,t)=>"Failure"===t._tag?e.close(t):tD);get currentUsage(){let e=this.waiters;for(const t of this.items)e+=t.refCount;return e}get targetSize(){if(this.isShuttingDown)return 0;const e=this.currentUsage/this.targetUtilization,t=Math.ceil(e/this.concurrency);return Math.min(Math.max(this.minSize,t),this.maxSize)}get activeSize(){return this.items.size-this.invalidated.size}resizeLoop=suspend$g(()=>{if(this.activeSize>=this.targetSize)return tD;const e=this.targetSize-this.activeSize;return this.strategy.reclaim(this).pipe(PR(qt({onNone:()=>this.allocate,onSome:succeed$u})),oQ(e,{concurrency:e}),cD(this.availableLatch.open),PR(e=>e.some(e=>"Failure"===e.exit._tag)?tD:this.resizeLoop))});resizeSemaphore=unsafeMakeSemaphore$2(1);resize=this.resizeSemaphore.withPermits(1)(this.resizeLoop);getPoolItem=uninterruptibleMask$2(e=>e(this.semaphore.take(1)).pipe(lD(_Q),PR(e=>suspend$g(()=>{if(this.waiters++,this.isShuttingDown)return BR;if(this.targetSize>this.activeSize){const e=this;return PR(this.resizeSemaphore.withPermitsIfAvailable(1)(HY(interruptible$3(this.resize),this.scope)),function loop(){return e.isShuttingDown?BR:e.available.size>0?succeed$u(unsafeHead$2(e.available)):(e.availableLatch.unsafeClose(),PR(e.availableLatch.await,loop))})}return succeed$u(unsafeHead$2(this.available))}).pipe(PQ(sync$l(()=>this.waiters--)),XR(t=>"Failure"===t.exit._tag?(this.items.delete(t),this.invalidated.delete(t),this.available.delete(t),this.semaphore.release(1)):(t.refCount++,this.available.delete(t),t.refCount<this.concurrency&&this.available.add(t),e.addFinalizer(()=>lD(suspend$g(()=>(t.refCount--,this.invalidated.has(t)?this.invalidatePoolItem(t):(this.available.add(t),UL))),this.semaphore.release(1))))),JR(()=>this.semaphore.release(1))))));commit(){return this.get}get=PR(suspend$g(()=>this.isShuttingDown?BR:this.getPoolItem),e=>e.exit);invalidate(e){return suspend$g(()=>{if(this.isShuttingDown)return tD;for(const t of this.items)if("Success"===t.exit._tag&&t.exit.value===e)return t.disableReclaim=!0,uninterruptible$2(this.invalidatePoolItem(t));return tD})}invalidatePoolItem(e){return suspend$g(()=>this.items.has(e)?0===e.refCount?(this.items.delete(e),this.available.delete(e),this.invalidated.delete(e),lD(e.finalizer,HY(interruptible$3(this.resize),this.scope))):(this.invalidated.add(e),this.available.delete(e),tD):tD)}get shutdown(){return suspend$g(()=>{if(this.isShuttingDown)return tD;this.isShuttingDown=!0;const e=this.items.size,t=unsafeMakeSemaphore$2(e);return UR(this.items,e=>e.refCount>0?(e.finalizer=cD(e.finalizer,t.release(1)),this.invalidated.add(e),t.take(1)):(this.items.delete(e),this.available.delete(e),this.invalidated.delete(e),e.finalizer)).pipe(lD(this.semaphore.releaseAll),lD(this.availableLatch.open),lD(t.take(e)))})}pipe(){return pipeArguments(this,arguments)}}const strategyCreationTTL=e=>clockWith$3(t=>qR(unbounded$7(),r=>{const n=toMillis(e),i=new WeakMap;return{run:e=>{const process=r=>suspend$g(()=>{if(!e.items.has(r)||e.invalidated.has(r))return tD;const s=t.unsafeCurrentTimeMillis(),o=i.get(r),a=n-(s-o);return a>0?dq(process(r),a):e.invalidatePoolItem(r)});return r.take.pipe(XR(process),forever$6)},onAcquire:e=>suspend$g(()=>(i.set(e,t.unsafeCurrentTimeMillis()),r.offer(e))),reclaim:e=>tW}})),strategyUsageTTL=e=>qR(unbounded$7(),t=>({run:r=>{const n=suspend$g(()=>r.activeSize-r.targetSize<=0?tD:t.take.pipe(XR(e=>r.invalidatePoolItem(e)),lD(n)));return n.pipe(dq(e),forever$6)},onAcquire:e=>t.offer(e),reclaim:e=>suspend$g(()=>{if(0===e.invalidated.size)return tW;const r=head$b(an(e.invalidated,e=>!e.disableReclaim));return"None"===r._tag?tW:(e.invalidated.delete(r.value),r.value.refCount<e.concurrency&&e.available.add(r.value),TR(t.offer(r.value),r))})})),reportUnhandledError=e=>withFiberRuntime$1(t=>{const r=t.getFiberRef(ZD);return"Some"===r._tag&&t.log("Unhandled error in pool finalizer",e,r),tD}),Gme=Symbol.for("effect/KeyedPool"),Jme=Symbol.for("effect/KeyedPool/MapValue"),Hme={_K:e=>e,_E:e=>e,_A:e=>e};class KeyedPoolImpl{getOrCreatePool;activePools;[Gme]=Hme;constructor(e,t){this.getOrCreatePool=e,this.activePools=t}get(e){return PR(this.getOrCreatePool(e),get$r)}invalidate(e){return PR(this.activePools,UR(t=>t.invalidate(e)))}pipe(){return pipeArguments(this,arguments)}}class Complete{pool;_tag="Complete";[Jme]=Jme;constructor(e){this.pool=e}[Z](){return pipe(string$6("effect/KeyedPool/Complete"),combine$h(hash$3(this.pool)),cached$2(this))}[Y](e){return isComplete(e)&&equals$4(this.pool,e.pool)}}const isComplete=e=>M(e,"Complete")&&Jme in e;class Pending{deferred;_tag="Pending";[Jme]=Jme;constructor(e){this.deferred=e}[Z](){return pipe(string$6("effect/KeyedPool/Pending"),combine$h(hash$3(this.deferred)),cached$2(this))}[Y](e){return isPending$2(e)&&equals$4(this.deferred,e.deferred)}}const isPending$2=e=>M(e,"Pending")&&Jme in e,makeImpl$2=(e,t,r,n)=>pipe(all$6([context$c(),FR,sync$l(()=>make$27(mP())),scopeMake()]),qR(([i,s,o,a])=>{const u=suspend$g(()=>LR(toValues(get$E(o)),e=>{switch(e._tag){case"Complete":return succeed$u(e.pool);case"Pending":return deferredAwait(e.deferred)}}));return new KeyedPoolImpl(u=>suspend$g(()=>{let c=Qt(yP(get$E(o),u));if(void 0===c)return uninterruptibleMask$2(l=>{const p=deferredUnsafeMake(s);let d;if(c=new Pending(p),SP(get$E(o),u)?d=Qt(yP(get$E(o),u)):VF(o,vP(u,c)),void 0===d)return pipe(l(xQ(makeWithTTL$3({acquire:oU(e(u),i),min:t(u),max:r(u),timeToLive:Kt(n(u),()=>sM)}),a)),RR({onFailure:e=>(equals$4(Qt(yP(get$E(o),u)),c)&&VF(o,IP(u)),lD(YL(p,e),failCause$j(e))),onSuccess:e=>(VF(o,vP(u,new Complete(e))),TR(nU(p,e),e))}));switch(d._tag){case"Complete":return succeed$u(d.pool);case"Pending":return l(deferredAwait(d.deferred))}});switch(c._tag){case"Complete":return succeed$u(c.pool);case"Pending":return deferredAwait(c.deferred)}}),u)}));var Zme=Object.freeze({__proto__:null,KeyedPoolTypeId:Gme,get:dual(2,(e,t)=>e.get(t)),invalidate:dual(2,(e,t)=>e.invalidate(t)),make:e=>makeImpl$2(e.acquire,()=>e.size,()=>e.size,()=>none$c()),makeWith:e=>makeImpl$2(e.acquire,e.size,e.size,()=>none$c()),makeWithTTL:e=>{const t=decode$5(e.timeToLive);return makeImpl$2(e.acquire,e.min,e.max,()=>Ut(t))},makeWithTTLBy:e=>makeImpl$2(e.acquire,e.min,e.max,t=>Ut(decode$5(e.timeToLive(t))))});const Qme=Symbol.for("effect/RcMap"),Yme={_K:identity$5,_A:identity$5,_E:identity$5};class RcMapImpl{lookup;context;scope;idleTimeToLive;capacity;[Qme];state={_tag:"Open",map:empty$B()};semaphore=unsafeMakeSemaphore$2(1);constructor(e,t,r,n,i){this.lookup=e,this.context=t,this.scope=r,this.idleTimeToLive=n,this.capacity=i,this[Qme]=Yme}pipe(){return pipeArguments(this,arguments)}}const Xme=dual(2,(e,t)=>{const r=e;return uninterruptibleMask$2(e=>ege(r,t,e))}),ege=fnUntraced$1(function*(e,t,r){if("Closed"===e.state._tag)return yield*BR;const n=e.state,i=zU(n.map,t);let s;if("Some"===i._tag)s=i.value,s.refCount++;else{if(Number.isFinite(e.capacity)&&size$t(e.state.map)>=e.capacity)return yield*fail$r(new wL("RcMap attempted to exceed capacity of "+e.capacity));s=yield*e.semaphore.withPermits(1)(tge(e,t,r))}const o=yield*_Q;return yield*o.addFinalizer(()=>s.finalizer),yield*r(deferredAwait(s.deferred))}),tge=fnUntraced$1(function*(e,t,r){const n=yield*scopeMake(),i=yield*deferredMake(),s=e.lookup(t),o=new Map(e.context.unsafeMap);yield*r(uU(s,e=>(e.unsafeMap.forEach((e,t)=>{o.set(t,e)}),o.set(_Q.key,n),MA(o)))).pipe(exit$2,PR(e=>HL(i,e)),HY(n));const a={deferred:i,scope:n,finalizer:void 0,fiber:void 0,expiresAt:0,refCount:1};return a.finalizer=release$2(e,t,a),"Open"===e.state._tag&&WU(e.state.map,t,a),a}),release$2=(e,t,r)=>fq(n=>(r.refCount--,r.refCount>0?tD:"Closed"!==e.state._tag&&qU(e.state.map,t)&&void 0!==e.idleTimeToLive?isFinite(e.idleTimeToLive)?(r.expiresAt=n.unsafeCurrentTimeMillis()+toMillis(e.idleTimeToLive),r.fiber?tD:interruptibleMask$1(function loop(i){const s=n.unsafeCurrentTimeMillis(),o=r.expiresAt-s;return o<=0?"Closed"===e.state._tag||r.refCount>0?tD:(GU(e.state.map,t),i(scopeClose(r.scope,UL))):PR(n.sleep(millis(o)),()=>loop(i))}).pipe(PQ(sync$l(()=>{r.fiber=void 0})),HY(e.scope),XR(e=>{r.fiber=e}),e.semaphore.withPermits(1))):tD:("Open"===e.state._tag&&GU(e.state.map,t),scopeClose(r.scope,UL)))),rge=dual(2,fnUntraced$1(function*(e,t){const r=e;if("Closed"===r.state._tag)return;const n=zU(r.state.map,t);if("None"===n._tag)return;const i=n.value;GU(r.state.map,t),i.refCount>0||(yield*scopeClose(i.scope,UL),i.fiber&&(yield*interruptFiber(i.fiber)))})),nge=dual(2,(e,t)=>{const r=e;return sync$l(()=>"Closed"!==r.state._tag&&qU(r.state.map,t))}),ige=dual(2,(e,t)=>fq(r=>{const n=e;if(!n.idleTimeToLive||"Closed"===n.state._tag)return tD;const i=zU(n.state.map,t);return"None"===i._tag||(i.value.expiresAt=r.unsafeCurrentTimeMillis()+toMillis(n.idleTimeToLive)),tD})),make$Z=e=>withFiberRuntime$1(t=>{const r=t.getFiberRef($D),n=jA(r,_Q),i=new RcMapImpl(e.lookup,r,n,e.idleTimeToLive?decode$5(e.idleTimeToLive):void 0,Math.max(e.capacity??1/0,0));return TR(n.addFinalizer(()=>suspend$g(()=>{if("Closed"===i.state._tag)return tD;const e=i.state.map;return i.state={_tag:"Closed"},UR(e,([,e])=>scopeClose(e.scope,UL)).pipe(XR(()=>{clear$6(e)}),i.semaphore.withPermits(1))})),i)}),sge=Xme,oge=rge;var age=Object.freeze({__proto__:null,TypeId:Qme,get:sge,has:nge,invalidate:oge,keys:e=>{const t=e;return suspend$g(()=>"Closed"===t.state._tag?BR:succeed$u(keys$a(t.state.map)))},make:make$Z,touch:ige});const uge=Symbol.for("effect/LayerMap"),cge=u9(function*(e,t){const r=yield*R5(),n=r.unsafeMap.has(N9.key)?jA(r,N9):yield*Fee,i=yield*make$Z({lookup:t=>H3(r=>t5(Pee(e(t),n,r))).pipe(P3(([e,t])=>({layer:gee(withFiberRuntime$1(r=>{const n=RA(r.currentContext,RY),i=r.getFiberRefs(),s=$W(e,r.id(),i),o=UW(s,i);return r.setFiberRefs(s),E3(LY(n,()=>(r.setFiberRefs($W(o,r.id(),r.getFiberRefs())),Q4)),t)})),runtimeEffect:D4(r=>{const n=$W(e,r.id(),r.getFiberRefs());return G4(Oie({context:t,fiberRefs:n,runtimeFlags:Iie.runtimeFlags}))})}))),idleTimeToLive:t?.idleTimeToLive});if(t?.preloadKeys)for(const e of t.preloadKeys)yield*sge(i,e);return{[uge]:uge,rcMap:i,get:e=>Cee(P3(sge(i,e),({layer:e})=>e)),runtime:e=>h7(sge(i,e),({runtimeEffect:e})=>e),invalidate:e=>oge(i,e)}}),fromRecord=(e,t)=>cge(t=>e[t],{...t,preloadKeys:t?.preload?Object.keys(e):void 0});var lge=Object.freeze({__proto__:null,Service:()=>(e,t)=>{const r=globalThis.Error,n=r.stackTraceLimit;r.stackTraceLimit=2;const i=new r;function TagClass(){}r.stackTraceLimit=n;const s=TagClass;return Object.setPrototypeOf(TagClass,Object.getPrototypeOf(GenericTag(e))),TagClass.key=e,Object.defineProperty(TagClass,"stack",{get:()=>i.stack}),s.DefaultWithoutDependencies=dee(s,"lookup"in t?cge(t.lookup,t):fromRecord(t.layers,t)),s.Default=t.dependencies&&t.dependencies.length>0?Tee(s.DefaultWithoutDependencies,t.dependencies):s.DefaultWithoutDependencies,s.get=e=>Cee(P3(s,t=>t.get(e))),s.runtime=e=>h7(s,t=>t.runtime(e)),s.invalidate=e=>h7(s,t=>t.invalidate(e)),TagClass},TypeId:uge,fromRecord,make:cge});const pge=makeLogger,fge=MG,hge=FG,dge=NG,mge=loggerWithConsoleLog,gge=jG,yge=removeLogger,bge=S9,Sge=v9,vge=_9,_ge=simple$1,wge=dual(2,(e,t)=>e.log({fiberId:nP,logLevel:bD,message:t,cause:BQ,context:empty$y(),spans:RP(),annotations:mP(),date:new Date})),kge=b9,xge=RG,Ige=DG,Tge=LG,Oge=qG,Ege=BG,Age=$G,Cge=prettyLogger$2,Mge=HG,Fge=zG,Pge=ZZ;var Nge=Object.freeze({__proto__:null,LoggerTypeId:AG,add:addLogger,addEffect:addLoggerEffect,addScoped:addLoggerScoped,batched:YZ,defaultLogger:VZ,filterLogLevel:PG,isLogger:e=>"object"==typeof e&&null!=e&&AG in e,json:bge(VZ,KZ),jsonLogger:Oge,logFmt:bge(VZ,GZ),logfmtLogger:Ege,make:pge,map:dge,mapInput:fge,mapInputOptions:hge,minimumLogLevel:e=>scopedDiscard$1(TQ(WZ,e)),none:gge,pretty:bge(VZ,JZ),prettyLogger:Cge,prettyLoggerDefault:Mge,remove:yge,replace:bge,replaceEffect:Sge,replaceScoped:vge,simple:_ge,stringLogger:Age,structured:bge(VZ,HZ),structuredLogger:Fge,succeed:e=>simple$1(()=>e),sync:e=>simple$1(e),test:wge,tracerLogger:Pge,withConsoleError:e=>makeLogger(t=>{const r=RB(t.context,pB);jA(r,eB).unsafe.error(e.log(t))}),withConsoleLog:mge,withLeveledConsole:e=>makeLogger(t=>{const r=RB(t.context,pB),n=jA(r,eB).unsafe;switch(t.logLevel._tag){case"Debug":return n.debug(e.log(t));case"Info":return n.info(e.log(t));case"Trace":return n.trace(e.log(t));case"Warning":return n.warn(e.log(t));case"Error":case"Fatal":return n.error(e.log(t));default:return n.log(e.log(t))}}),withMinimumLogLevel:kge,withSpanAnnotations:e=>FG(e,e=>{const t=ir(CB(e.context,$D),DA(oB));return"None"===t._tag?e:{...e,annotations:pipe(e.annotations,vP("effect.traceId",t.value.traceId),vP("effect.spanId",t.value.spanId),"Span"===t.value._tag?vP("effect.spanName",t.value.name):identity$5)}}),zip:xge,zipLeft:Ige,zipRight:Tge});const jge=Symbol.for("effect/Mailbox"),Rge=Symbol.for("effect/Mailbox/ReadonlyMailbox"),Dge=empty$R(),Lge=exitSucceed$1(Dge),Uge=exitSucceed$1(!1),$ge=exitSucceed$1(!0),Bge=[Dge,!0];class MailboxImpl extends hz{scheduler;capacity;strategy;[jge]=jge;[Rge]=Rge;state={_tag:"Open",takers:new Set,offers:new Set,awaiters:new Set};messages=[];messagesChunk=empty$R();constructor(e,t,r){super(),this.scheduler=e,this.capacity=t,this.strategy=r}offer(e){return suspend$g(()=>{if("Open"!==this.state._tag)return Uge;if(this.messages.length+this.messagesChunk.length>=this.capacity)switch(this.strategy){case"dropping":return Uge;case"suspend":return this.capacity<=0&&this.state.takers.size>0?(this.messages.push(e),this.releaseTaker(),$ge):this.offerRemainingSingle(e);case"sliding":return this.unsafeTake(),this.messages.push(e),$ge}return this.messages.push(e),this.scheduleReleaseTaker(),$ge})}unsafeOffer(e){return"Open"===this.state._tag&&(this.messages.length+this.messagesChunk.length>=this.capacity?"sliding"===this.strategy?(this.unsafeTake(),this.messages.push(e),!0):this.capacity<=0&&this.state.takers.size>0&&(this.messages.push(e),this.releaseTaker(),!0):(this.messages.push(e),this.scheduleReleaseTaker(),!0))}offerAll(e){return suspend$g(()=>{if("Open"!==this.state._tag)return succeed$u(fromIterable$u(e));const t=this.unsafeOfferAllArray(e);return 0===t.length?Lge:"dropping"===this.strategy?succeed$u(unsafeFromArray(t)):this.offerRemainingArray(t)})}unsafeOfferAll(e){return unsafeFromArray(this.unsafeOfferAllArray(e))}unsafeOfferAllArray(e){if("Open"!==this.state._tag)return fromIterable$v(e);if(this.capacity===1/0||"sliding"===this.strategy)return this.messages.length>0&&(this.messagesChunk=eC(this.messagesChunk,unsafeFromArray(this.messages))),"sliding"===this.strategy?this.messagesChunk=this.messagesChunk.pipe(eC(fromIterable$u(e)),wC(this.capacity)):isChunk(e)?this.messagesChunk=eC(this.messagesChunk,e):this.messages=fromIterable$v(e),this.scheduleReleaseTaker(),[];const t=this.capacity<=0?this.state.takers.size:this.capacity-this.messages.length-this.messagesChunk.length;if(0===t)return fromIterable$v(e);const r=[];let n=0;for(const i of e)n<t?this.messages.push(i):r.push(i),n++;return this.scheduleReleaseTaker(),r}fail(e){return this.done(exitFail$1(e))}failCause(e){return this.done(exitFailCause$1(e))}unsafeDone(e){return"Open"===this.state._tag&&(0===this.state.offers.size&&0===this.messages.length&&0===this.messagesChunk.length?(this.finalize(e),!0):(this.state={...this.state,_tag:"Closing",exit:e},!0))}shutdown=sync$l(()=>{if("Done"===this.state._tag)return!0;this.messages=[],this.messagesChunk=Dge;const e=this.state.offers;if(this.finalize("Open"===this.state._tag?UL:this.state.exit),e.size>0){for(const t of e)"Single"===t._tag?t.resume(Uge):t.resume(exitSucceed$1(unsafeFromArray(t.remaining.slice(t.offset))));e.clear()}return!0});done(e){return sync$l(()=>this.unsafeDone(e))}end=this.done(UL);clear=suspend$g(()=>{if("Done"===this.state._tag)return OL(this.state.exit,Dge);const e=this.unsafeTakeAll();return this.releaseCapacity(),succeed$u(e)});takeAll=suspend$g(()=>{if("Done"===this.state._tag)return OL(this.state.exit,Bge);const e=this.unsafeTakeAll();return 0===e.length?lD(this.awaitTake,this.takeAll):succeed$u([e,this.releaseCapacity()])});takeN(e){return suspend$g(()=>{if("Done"===this.state._tag)return OL(this.state.exit,Bge);if(e<=0)return succeed$u([Dge,!1]);let t;if((e=Math.min(e,this.capacity))<=this.messagesChunk.length)t=HA(this.messagesChunk,e),this.messagesChunk=ZA(this.messagesChunk,e);else{if(!(e<=this.messages.length+this.messagesChunk.length))return lD(this.awaitTake,this.takeN(e));this.messagesChunk=eC(this.messagesChunk,unsafeFromArray(this.messages)),this.messages=[],t=HA(this.messagesChunk,e),this.messagesChunk=ZA(this.messagesChunk,e)}return succeed$u([t,this.releaseCapacity()])})}unsafeTake(){if("Done"===this.state._tag)return zL(this.state.exit,exitFail$1(new rY));let e;if(this.messagesChunk.length>0)e=unsafeHead$1(this.messagesChunk),this.messagesChunk=ZA(this.messagesChunk,1);else{if(!(this.messages.length>0))return this.capacity<=0&&this.state.offers.size>0?(this.capacity=1,this.releaseCapacity(),this.capacity=0,this.messages.length>0?exitSucceed$1(this.messages.pop()):void 0):void 0;e=this.messages[0],this.messagesChunk=ZA(unsafeFromArray(this.messages),1),this.messages=[]}return this.releaseCapacity(),exitSucceed$1(e)}take=suspend$g(()=>this.unsafeTake()??lD(this.awaitTake,this.take));await=asyncInterrupt(e=>"Done"===this.state._tag?e(this.state.exit):(this.state.awaiters.add(e),sync$l(()=>{"Done"!==this.state._tag&&this.state.awaiters.delete(e)})));unsafeSize(){const e=this.messages.length+this.messagesChunk.length;return"Done"===this.state._tag?none$c():Ut(e)}size=sync$l(()=>this.unsafeSize());commit(){return this.takeAll}pipe(){return pipeArguments(this,arguments)}toJSON(){return{_id:"effect/Mailbox",state:this.state._tag,size:this.unsafeSize().toJSON()}}toString(){return format$6(this)}[ee](){return format$6(this)}offerRemainingSingle(e){return asyncInterrupt(t=>{if("Open"!==this.state._tag)return t(Uge);const r={_tag:"Single",message:e,resume:t};return this.state.offers.add(r),sync$l(()=>{"Open"===this.state._tag&&this.state.offers.delete(r)})})}offerRemainingArray(e){return asyncInterrupt(t=>{if("Open"!==this.state._tag)return t(exitSucceed$1(unsafeFromArray(e)));const r={_tag:"Array",remaining:e,offset:0,resume:t};return this.state.offers.add(r),sync$l(()=>{"Open"===this.state._tag&&this.state.offers.delete(r)})})}releaseCapacity(){if("Done"===this.state._tag)return"Success"===this.state.exit._tag;if(0===this.state.offers.size)return"Closing"===this.state._tag&&0===this.messages.length&&0===this.messagesChunk.length&&(this.finalize(this.state.exit),"Success"===this.state.exit._tag);let e=this.capacity-this.messages.length-this.messagesChunk.length;for(const t of this.state.offers){if(0===e)return!1;if("Single"===t._tag)this.messages.push(t.message),e--,t.resume($ge),this.state.offers.delete(t);else{for(;t.offset<t.remaining.length;t.offset++){if(0===e)return!1;this.messages.push(t.remaining[t.offset]),e--}t.resume(Lge),this.state.offers.delete(t)}}return!1}awaitTake=asyncInterrupt(e=>"Done"===this.state._tag?e(this.state.exit):(this.state.takers.add(e),sync$l(()=>{"Done"!==this.state._tag&&this.state.takers.delete(e)})));scheduleRunning=!1;scheduleReleaseTaker(){this.scheduleRunning||(this.scheduleRunning=!0,this.scheduler.scheduleTask(this.releaseTaker,0))}releaseTaker=()=>{if(this.scheduleRunning=!1,"Done"===this.state._tag)return;if(0===this.state.takers.size)return;const e=unsafeHead$2(this.state.takers);this.state.takers.delete(e),e(UL)};unsafeTakeAll(){if(this.messagesChunk.length>0){const e=this.messages.length>0?eC(this.messagesChunk,unsafeFromArray(this.messages)):this.messagesChunk;return this.messagesChunk=Dge,this.messages=[],e}if(this.messages.length>0){const e=unsafeFromArray(this.messages);return this.messages=[],e}return"Done"!==this.state._tag&&this.state.offers.size>0?(this.capacity=1,this.releaseCapacity(),this.capacity=0,of$5(this.messages.pop())):Dge}finalize(e){if("Done"===this.state._tag)return;const t=this.state;this.state={_tag:"Done",exit:e};for(const r of t.takers)r(e);t.takers.clear();for(const r of t.awaiters)r(e);t.awaiters.clear()}}const make$W=e=>withFiberRuntime$1(t=>succeed$u(new MailboxImpl(t.currentScheduler,"number"==typeof e?e:e?.capacity??1/0,"number"==typeof e?"suspend":e?.strategy??"suspend"))),zge=dual(2,(e,t)=>uninterruptibleMask$2(r=>RR(r(e),{onFailure:e=>t.failCause(e),onSuccess:e=>t.end}))),toChannel$3=e=>{const t=Zte(e.takeAll,([e,r])=>r?0===e.length?ere:write$1(e):_ne(write$1(e),t));return t},qge=dual(e=>isStream(e[0]),(e,t)=>XR(eQ(make$W(t),e=>e.shutdown),t=>{const r=readWithCause$1({onInput:e=>Zte(t.offerAll(e),()=>r),onFailure:e=>t.failCause(e),onDone:()=>t.end});return scopeWith$1(t=>toChannel$4(e).pipe(Yte(r),gre(t),HY(t)))})),Wge=jge,Vge=Rge;var Kge=Object.freeze({__proto__:null,ReadonlyTypeId:Vge,TypeId:Wge,fromStream:qge,into:zge,isMailbox:e=>C(e,Wge),isReadonlyMailbox:e=>C(e,Vge),make:make$W,toChannel:toChannel$3,toStream:e=>fromChannel$2(toChannel$3(e))});function provide(e,t){return PR(e.runtimeEffect,e=>withFiberRuntime$1(r=>(r.setFiberRefs(e.fiberRefs),r.currentRuntimeFlags=e.runtimeFlags,oU(t,e.context))))}const Gge={...cz,[fX]:fX,pipe(){return pipeArguments(this,arguments)},commit(){return this.runtimeEffect}};var Jge=Object.freeze({__proto__:null,TypeId:fX,isManagedRuntime:e=>C(e,fX),make:(e,t)=>{t=t??unsafeMakeMemoMap();const r=WX(scopeMake());let n;const i=withFiberRuntime$1(i=>(n||(n=BX(XR($Y(M0(e,t),r),e=>{s.cachedRuntime=e}),{scope:r,scheduler:i.currentScheduler})),flatten$c(n.await))),s=Object.assign(Object.create(Gge),{memoMap:t,scope:r,runtimeEffect:i,cachedRuntime:void 0,runtime:()=>void 0===s.cachedRuntime?zX(s.runtimeEffect):Promise.resolve(s.cachedRuntime),dispose:()=>zX(s.disposeEffect),disposeEffect:suspend$g(()=>(s.runtimeEffect=die$g("ManagedRuntime disposed"),s.cachedRuntime=void 0,UY(s.scope,UL))),runFork:(e,t)=>void 0===s.cachedRuntime?BX(provide(s,e),t):wX(s.cachedRuntime)(e,t),runSyncExit:e=>void 0===s.cachedRuntime?VX(provide(s,e)):OX(s.cachedRuntime)(e),runSync:e=>void 0===s.cachedRuntime?WX(provide(s,e)):xX(s.cachedRuntime)(e),runPromiseExit:(e,t)=>void 0===s.cachedRuntime?qX(provide(s,e),t):AX(s.cachedRuntime)(e,t),runCallback:(e,t)=>void 0===s.cachedRuntime?kX(MX)(provide(s,e),t):kX(s.cachedRuntime)(e,t),runPromise:(e,t)=>void 0===s.cachedRuntime?zX(provide(s,e),t):EX(s.cachedRuntime)(e,t)});return s}});const Hge=Symbol.for("@effect/matcher/Matcher"),Zge={[Hge]:{_input:identity$5,_filters:identity$5,_remaining:identity$5,_result:identity$5,_return:identity$5},_tag:"TypeMatcher",add(e){return makeTypeMatcher([...this.cases,e])},pipe(){return pipeArguments(this,arguments)}};function makeTypeMatcher(e){const t=Object.create(Zge);return t.cases=e,t}const Qge={[Hge]:{_input:identity$5,_filters:identity$5,_remaining:identity$5,_result:identity$5,_provided:identity$5,_return:identity$5},_tag:"ValueMatcher",add(e){return"Right"===this.value._tag?this:"When"===e._tag&&!0===e.guard(this.provided)||"Not"===e._tag&&!1===e.guard(this.provided)?makeValueMatcher(this.provided,Ge(e.evaluate(this.provided))):this},pipe(){return pipeArguments(this,arguments)}};function makeValueMatcher(e,t){const r=Object.create(Qge);return r.provided=e,r.value=t,r}const makeWhen=(e,t)=>({_tag:"When",guard:e,evaluate:t}),makePredicate=e=>{if("function"==typeof e)return e;if(Array.isArray(e)){const t=e.map(makePredicate),r=t.length;return e=>{if(!Array.isArray(e))return!1;for(let n=0;n<r;n++)if(!1===t[n](e[n]))return!1;return!0}}if(null!==e&&"object"==typeof e){const t=Object.entries(e).map(([e,t])=>[e,makePredicate(t)]),r=t.length;return e=>{if("object"!=typeof e||null===e)return!1;for(let n=0;n<r;n++){const[r,i]=t[n];if(!(r in e)||!1===i(e[r]))return!1}return!0}}return t=>t===e},Yge=dual(2,(e,t)=>rye(t)(makeTypeMatcher([]))(e)),discriminator$1=e=>(...t)=>{const r=t[t.length-1],n=t.slice(0,-1),i=1===n.length?t=>t[e]===n[0]:t=>n.includes(t[e]);return e=>e.add(makeWhen(i,r))},discriminatorStartsWith$1=e=>(t,r)=>{const pred=r=>"string"==typeof r[e]&&r[e].startsWith(t);return e=>e.add(makeWhen(pred,r))},discriminators$1=e=>t=>{const r=makeWhen(r=>null!=r&&r[e]in t,r=>t[r[e]](r));return e=>e.add(r)},discriminatorsExhaustive$1=e=>t=>{const r=discriminators$1(e)(t);return e=>exhaustive$1(r(e))},Xge=discriminator$1("_tag"),eye=discriminatorStartsWith$1("_tag"),tye=discriminators$1("_tag"),rye=discriminatorsExhaustive$1("_tag"),instanceOf$2=e=>t=>t instanceof e,orElse$4=e=>t=>{const r=either$3(t);return Ye(r)?"Right"===r._tag?r.right:e(r.left):t=>{const n=r(t);return"Right"===n._tag?n.right:e(n.left)}},either$3=e=>{if("ValueMatcher"===e._tag)return e.value;const t=e.cases.length;if(1===t){const t=e.cases[0];return e=>"When"===t._tag&&!0===t.guard(e)||"Not"===t._tag&&!1===t.guard(e)?Ge(t.evaluate(e)):He(e)}return r=>{for(let n=0;n<t;n++){const t=e.cases[n];if("When"===t._tag&&!0===t.guard(r))return Ge(t.evaluate(r));if("Not"===t._tag&&!1===t.guard(r))return Ge(t.evaluate(r))}return He(r)}},nye="effect/Match/exhaustive: absurd",exhaustive$1=e=>{const t=either$3(e);if(Ye(t)){if("Right"===t._tag)return t.right;throw Error(nye)}return e=>{const r=t(e);if("Right"===r._tag)return r.right;throw Error(nye)}},iye=Yge,sye=discriminator$1,oye=discriminatorStartsWith$1,aye=discriminators$1,uye=discriminatorsExhaustive$1,cye=Xge,lye=eye,pye=tye,fye=rye,hye=isString$1,dye=isNumber$1,mye=isBoolean$1,gye=isUndefined,yye=isNull,bye=isBigInt$1,Sye=isSymbol$1,vye=isDate,_ye=isRecord,wye=instanceOf$2,kye=instanceOf$2,xye=orElse$4,Iye=either$3,Tye=exhaustive$1;var Oye=Object.freeze({__proto__:null,MatcherTypeId:Hge,SafeRefinementId:Symbol.for("effect/SafeRefinement"),any:()=>!0,bigint:bye,boolean:mye,date:vye,defined:e=>null!=e,discriminator:sye,discriminatorStartsWith:oye,discriminators:aye,discriminatorsExhaustive:uye,either:Iye,exhaustive:Tye,instanceOf:wye,instanceOfUnsafe:kye,is:(...e)=>{const t=e.length;return r=>{for(let n=0;n<t;n++)if(r===e[n])return!0;return!1}},nonEmptyString:e=>"string"==typeof e&&e.length>0,not:(e,t)=>r=>r.add({_tag:"Not",guard:makePredicate(e),evaluate:t}),null:yye,number:dye,option:e=>{const t=either$3(e);return Ye(t)?ot(t,{onLeft:()=>none$c(),onRight:Ut}):e=>ot(t(e),{onLeft:()=>none$c(),onRight:Ut})},orElse:xye,orElseAbsurd:e=>orElse$4(()=>{throw Error("effect/Match/orElseAbsurd: absurd")})(e),record:_ye,string:hye,symbol:Sye,tag:cye,tagStartsWith:lye,tags:pye,tagsExhaustive:fye,type:()=>makeTypeMatcher([]),typeTags:()=>e=>{const t=rye(e)(makeTypeMatcher([]));return e=>t(e)},undefined:gye,value:e=>makeValueMatcher(e,He(e)),valueTags:iye,when:(e,t)=>r=>r.add(makeWhen(makePredicate(e),t)),whenAnd:(...e)=>t=>{const r=e[e.length-1],n=e.slice(0,-1);return t.add(makeWhen((e=>{const t=e.map(makePredicate),r=t.length;return e=>{for(let n=0;n<r;n++)if(!1===t[n](e))return!1;return!0}})(n),r))},whenOr:(...e)=>t=>{const r=e[e.length-1],n=e.slice(0,-1);return t.add(makeWhen((e=>{const t=e.map(makePredicate),r=t.length;return e=>{for(let n=0;n<r;n++)if(!0===t[n](e))return!0;return!1}})(n),r))},withReturnType:()=>e=>e}),Eye=Object.freeze({__proto__:null,BothRunning:BothRunning$1,LeftDone:LeftDone$1,MergeStateTypeId:Ire,RightDone:RightDone$1,isBothRunning:e=>e._tag===wre,isLeftDone:e=>e._tag===kre,isMergeState:e=>C(e,Ire),isRightDone:e=>e._tag===xre,match:Ore}),Aye=Object.freeze({__proto__:null,BackPressure:BackPressure$2,BufferSliding:BufferSliding$1,MergeStrategyTypeId:Cre,isBackPressure:e=>e._tag===Ere,isBufferSliding:e=>e._tag===Are,isMergeStrategy:e=>C(e,Cre),match:Fre});var Cye=Object.freeze({__proto__:null,MetricTypeId:LJ,counter:counter$5,fiberActive:FZ,fiberFailures:NZ,fiberLifetimes:jZ,fiberStarted:MZ,fiberSuccesses:PZ,frequency:(name,e)=>fromMetricKey$1(frequency$8(name,e)),fromMetricKey:fromMetricKey$1,gauge:(name,e)=>fromMetricKey$1(gauge$8(name,e)),globalMetricRegistry:$J,histogram:histogram$5,increment:e=>isCounterKey$1(e.keyType)?oH(e,e.keyType.bigint?BigInt(1):1):KJ(e,e.keyType.bigint?BigInt(1):1),incrementBy:qJ,make:make$1G,map:WJ,mapInput:BJ,mapType:VJ,modify:KJ,set:GJ,snapshot:uH,succeed:e=>make$1G(void 0,o,()=>e,o),summary:e=>withNow$1(summaryTimestamp$1(e)),summaryTimestamp:summaryTimestamp$1,sync:e=>make$1G(void 0,o,e,o),tagged:JJ,taggedWithLabels:ZJ,taggedWithLabelsInput:HJ,timer:(name,description)=>{const e=exponential$3({start:.5,factor:2,count:35}),t=pipe(histogram$5(name,e,description),JJ("time_unit","milliseconds"));return BJ(t,toMillis)},timerWithBoundaries:(name,e,description)=>{const t=pipe(histogram$5(name,fromIterable$m(e),description),JJ("time_unit","milliseconds"));return BJ(t,toMillis)},trackAll:QJ,trackDefect:YJ,trackDefectWith:XJ,trackDuration:eH,trackDurationWith:tH,trackError:rH,trackErrorWith:nH,trackSuccess:iH,trackSuccessWith:sH,unsafeSnapshot:unsafeSnapshot$1,update:oH,value:value$8,withConstantInput:zJ,withNow:withNow$1,zip:aH}),Mye=Object.freeze({__proto__:null,MetricBoundariesTypeId:QG,exponential:exponential$3,fromIterable:fromIterable$m,isMetricBoundaries:isMetricBoundaries$1,linear:e=>pipe(Gn(e.count-1,t=>e.start+t*e.width),unsafeFromArray,fromIterable$m)}),Fye=Object.freeze({__proto__:null,MetricHookTypeId:CJ,counter:counter$6,frequency:frequency$6,gauge:gauge$6,histogram:histogram$6,make:make$1J,onModify:FJ,onUpdate:PJ,summary:summary$6}),Pye=Object.freeze({__proto__:null,MetricKeyTypeId:fJ,counter:counter$8,frequency:frequency$8,gauge:gauge$8,histogram:histogram$8,isMetricKey:isMetricKey$1,summary:summary$8,tagged:mJ,taggedWithLabels:gJ}),Nye=Object.freeze({__proto__:null,CounterKeyTypeTypeId:eJ,FrequencyKeyTypeTypeId:rJ,GaugeKeyTypeTypeId:iJ,HistogramKeyTypeTypeId:oJ,MetricKeyTypeTypeId:YG,SummaryKeyTypeTypeId:uJ,counter:counter$9,frequency:frequency$9,gauge:gauge$9,histogram:histogram$9,isCounterKey:isCounterKey$1,isFrequencyKey:isFrequencyKey$1,isGaugeKey:isGaugeKey$1,isHistogramKey:isHistogramKey$1,isMetricKeyType:e=>C(e,YG),isSummaryKey:isSummaryKey$1,summary:summary$9}),jye=Object.freeze({__proto__:null,MetricLabelTypeId:iq,isMetricLabel:isMetricLabel$1,make:make$1L}),Rye=Object.freeze({__proto__:null,MetricPairTypeId:jJ,make:(e,t)=>({[jJ]:RJ,metricKey:e,metricState:t,pipe(){return pipeArguments(this,arguments)}}),unsafeMake:unsafeMake$a});const Dye=Symbol.for("effect/MetricPolling"),Lye=dual(2,(e,t)=>pipe(pollAndUpdate$1(e),lD(value$8(e.metric)),K6(t))),pollAndUpdate$1=e=>PR(e.poll,t=>oH(e.metric,t));var Uye=Object.freeze({__proto__:null,MetricPollingTypeId:Dye,collectAll:e=>{const t=Array.from(e);return{[Dye]:Dye,pipe(){return pipeArguments(this,arguments)},metric:make$1G(Array.of(void 0),(e,r)=>{for(let n=0;n<e.length;n++){const i=t[n],s=pipe(e,e=>e[n]);i.metric.unsafeUpdate(s,r)}},e=>Array.from(t.map(t=>t.metric.unsafeValue(e))),(e,r)=>{for(let n=0;n<e.length;n++){const i=t[n],s=pipe(e,e=>e[n]);i.metric.unsafeModify(s,r)}}),poll:LR(t,e=>e.poll)}},launch:Lye,make:(e,t)=>({[Dye]:Dye,pipe(){return pipeArguments(this,arguments)},metric:e,poll:t}),poll:e=>e.poll,pollAndUpdate:pollAndUpdate$1,retry:dual(2,(e,t)=>({[Dye]:Dye,pipe(){return pipeArguments(this,arguments)},metric:e.metric,poll:R6(e.poll,t)})),zip:dual(2,(e,t)=>({[Dye]:Dye,pipe(){return pipeArguments(this,arguments)},metric:pipe(e.metric,aH(t.metric)),poll:uD(e.poll,t.poll)}))}),$ye=Object.freeze({__proto__:null,MetricRegistryTypeId:DJ,make:make$1H}),Bye=Object.freeze({__proto__:null,CounterStateTypeId:SJ,FrequencyStateTypeId:_J,GaugeStateTypeId:kJ,HistogramStateTypeId:IJ,MetricStateTypeId:yJ,SummaryStateTypeId:OJ,counter:counter$7,frequency:frequency$7,gauge:gauge$7,histogram:histogram$7,isCounterState:isCounterState$1,isFrequencyState:isFrequencyState$1,isGaugeState:isGaugeState$1,isHistogramState:isHistogramState$1,isMetricState:e=>C(e,yJ),isSummaryState:isSummaryState$1,summary:summary$7}),zye=Object.freeze({__proto__:null,getCurrentVersion:getCurrentVersion$1,setCurrentVersion:e=>{ke=e}});const qye=Symbol.for("effect/MutableHashSet"),Wye={[qye]:qye,[Symbol.iterator](){return Array.from(this.keyMap).map(([e])=>e)[Symbol.iterator]()},toString(){return format$6(this.toJSON())},toJSON(){return{_id:"MutableHashSet",values:Array.from(this).map(toJSON)}},[ee](){return this.toJSON()},pipe(){return pipeArguments(this,arguments)}},fromHashMap=e=>{const t=Object.create(Wye);return t.keyMap=e,t},fromIterable$d=e=>fromHashMap(fromIterable$o(Array.from(e).map(e=>[e,!0])));var Vye=Object.freeze({__proto__:null,add:dual(2,(e,t)=>(WU(e.keyMap,t,!0),e)),clear:e=>(clear$6(e.keyMap),e),empty:()=>fromHashMap(empty$B()),fromIterable:fromIterable$d,has:dual(2,(e,t)=>qU(e.keyMap,t)),make:(...e)=>fromIterable$d(e),remove:dual(2,(e,t)=>(GU(e.keyMap,t),e)),size:e=>size$t(e.keyMap)}),Kye=Object.freeze({__proto__:null,unprepend:e=>{const t=e[Symbol.iterator](),r=t.next();if(r.done)throw Error("BUG: NonEmptyIterator should not be empty - please report an issue at https://github.com/Effect-TS/effect/issues");return[r.value,t]}});const Gye=dual(2,(e,{onEqual:t,onGreaterThan:r,onLessThan:n})=>-1===e?n():0===e?t():r()),Jye=dual(2,(e,t)=>0!==e?e:t),Hye=dual(2,(e,t)=>{let r=e;if(0!==r)return r;for(r of t)if(0!==r)return r;return r});var Zye=Object.freeze({__proto__:null,combine:Jye,combineAll:e=>Hye(0,e),combineMany:Hye,match:Gye,reverse:e=>-1===e?1:1===e?-1:0}),Qye=Object.freeze({__proto__:null,PoolTypeId:Wme,get:get$r,invalidate:Kme,isPool:e=>C(e,Wme),make:e=>makeWith$4({...e,min:e.size,max:e.size,strategy:{run:e=>tD,onAcquire:e=>tD,reclaim:e=>tW}}),makeWithTTL:makeWithTTL$3});const Yye=kT(hT),getMatcher=e=>t=>qt(Yye(t),{onNone:()=>e,onSome:e=>e()}),Xye=getMatcher(e=>e+""),ebe=getMatcher(e=>JSON.stringify(e)),tbe=getMatcher(formatUnknown$1),rbe={Declaration:(e,t,r)=>{const n=Yye(e);if(zt(n))return n.value(...e.typeParameters.map(e=>t(e,r)));throw Error(((e,t)=>getMissingAnnotationErrorMessage('Generating a Pretty for this schema requires a "pretty" annotation',e,t))(r,e))},VoidKeyword:getMatcher(()=>"void(0)"),NeverKeyword:getMatcher(()=>{throw Error("Cannot pretty print a `never` value")}),Literal:getMatcher(e=>"bigint"==typeof e?e+"n":JSON.stringify(e)),SymbolKeyword:Xye,UniqueSymbol:Xye,TemplateLiteral:ebe,UndefinedKeyword:Xye,UnknownKeyword:tbe,AnyKeyword:tbe,ObjectKeyword:tbe,StringKeyword:ebe,NumberKeyword:Xye,BooleanKeyword:Xye,BigIntKeyword:getMatcher(e=>e+"n"),Enums:ebe,TupleType:(e,t,r)=>{const n=Yye(e);if(zt(n))return n.value();const i=e.elements.map((e,n)=>t(e.type,r.concat(n))),s=e.rest.map(e=>t(e.type,r));return t=>{const r=[];let n=0;for(;n<i.length;n++)if(t.length<n+1){if(e.elements[n].isOptional)continue}else r.push(i[n](t[n]));if(ci(s)){const[e,...i]=s;for(;n<t.length-i.length;n++)r.push(e(t[n]));for(let e=0;e<i.length;e++)n+=e,r.push(i[e](t[n]))}return"["+r.join(", ")+"]"}},TypeLiteral:(e,t,r)=>{const n=Yye(e);if(zt(n))return n.value();const i=e.propertySignatures.map(e=>t(e.type,r.concat(e.name))),s=e.indexSignatures.map(e=>t(e.type,r)),o={};for(let t=0;t<i.length;t++)o[e.propertySignatures[t].name]=null;return t=>{const r=[];for(let n=0;n<i.length;n++){const s=e.propertySignatures[n],name=s.name;s.isOptional&&!Object.prototype.hasOwnProperty.call(t,name)||r.push(`${formatPropertyKey$1(name)}: ${i[n](t[name])}`)}if(s.length>0)for(let n=0;n<s.length;n++){const i=s[n],a=getKeysForIndexSignature(t,e.indexSignatures[n].parameter);for(const e of a)Object.prototype.hasOwnProperty.call(o,e)||r.push(`${formatPropertyKey$1(e)}: ${i(t[e])}`)}return ci(r)?"{ "+r.join(", ")+" }":"{}"}},Union:(e,t,r)=>{const n=Yye(e);if(zt(n))return n.value();const i=e.types.map(e=>[is$2({ast:e}),t(e,r)]);return t=>{const n=i.findIndex(([e])=>e(t));if(-1===n)throw Error(((e,t,r)=>getErrorMessage$1("Unexpected Error","Cannot find a matching schema for "+formatUnknown$1(e),t,r))(t,r,e));return i[n][1](t)}},Suspend:(e,t,r)=>qt(Yye(e),{onNone:()=>{const n=memoizeThunk(()=>t(e.f(),r));return e=>n()(e)},onSome:e=>e()}),Refinement:(e,t,r)=>qt(Yye(e),{onNone:()=>t(e.from,r),onSome:e=>e()}),Transformation:(e,t,r)=>qt(Yye(e),{onNone:()=>t(e.to,r),onSome:e=>e()})},nbe=getCompiler(rbe);var ibe=Object.freeze({__proto__:null,make:e=>nbe(e.ast,[]),match:rbe});const sbe=Symbol.for("effect/PrimaryKey");var obe=Object.freeze({__proto__:null,symbol:sbe,value:e=>e[sbe]()});const abe=globalValue(Symbol.for("effect/RateLimiter/currentCost"),()=>l9(1));var ube=Object.freeze({__proto__:null,make:({algorithm:e="token-bucket",interval:t,limit:r})=>{switch(e){case"fixed-window":return((e,t)=>V4(function*(){const r=yield*makeSemaphore(e),n=yield*makeSemaphore(0);yield*pipe(n.take(1),j8(T5(t)),j8(n.releaseAll),j8(r.releaseAll),T7,l5,w3);const i=T3(e=>h7(p9(abe),t=>j8(e(r.take(t)),n.release(1))));return e=>j8(i,e)}))(r,t);case"token-bucket":return((e,t)=>V4(function*(){const r=Math.ceil(toMillis(t)/e),n=yield*makeSemaphore(e),i=yield*makeSemaphore(0),s=T5(r).pipe(j8(i.releaseAll),j8(n.release(1)),h7(t=>t===e?Q4:s));yield*pipe(i.take(1),j8(s),T7,l5,w3);const o=T3(e=>h7(p9(abe),t=>j8(e(n.take(t)),i.release(1))));return e=>j8(o,e)}))(r,t)}},withCost:e=>R7(abe,e)});const cbe=isRedacted$1,lbe=make$1c,value$1=e=>{if(kfe.has(e))return kfe.get(e);throw Error("Unable to get redacted value")},getEquivalence$1=e=>make$2l((t,r)=>e(value$1(t),value$1(r)));var pbe=Object.freeze({__proto__:null,RedactedTypeId:xfe,getEquivalence:getEquivalence$1,isRedacted:cbe,make:lbe,unsafeWipe:e=>kfe.delete(e),value:value$1});const fbe=Symbol.for("effect/ScopedRef"),hbe={...Me,commit(){return get$l(this)},[fbe]:{_A:e=>e}},fromAcquire$1=e=>uninterruptible$2(scopeMake().pipe(PR(t=>e.pipe(uU(NA(_Q,t)),KR(e=>t.close(exitFail$1(e))),PR(e=>makeSynchronized([t,e]).pipe(PR(e=>{const t=Object.create(hbe);return t.ref=e,pipe(addFinalizer$2(()=>PR(get$z(t.ref),e=>e[0].close(UL))),TR(t))}))))))),get$l=e=>qR(get$z(e.ref),e=>e[1]),dbe=dual(2,(e,t)=>flatten$c(HX(e.ref,([e,r])=>uninterruptible$2(scopeClose(e,UL).pipe(lD(scopeMake()),PR(n=>exit$2(xQ(t,n)).pipe(PR(t=>DL(t,{onFailure:t=>scopeClose(n,UL).pipe(TR([failCause$j(t),[e,r]])),onSuccess:e=>succeed$u([tD,[n,e]])}))))))))),mbe=Symbol.for("effect/Reloadable"),gbe={_A:e=>e},auto$3=(e,t)=>k0(reloadableTag(e),pipe(build$1(manual$3(e,{layer:t.layer})),qR(RA(reloadableTag(e))),XR(e=>eQ(pipe(e.reload,ignoreLogged$2,U6(t.schedule),forkDaemon$1),interruptFiber)))),manual$3=(e,t)=>k0(reloadableTag(e),pipe(context$c(),PR(r=>pipe(fromAcquire$1(pipe(build$1(t.layer),qR(RA(e)))),qR(n=>({[mbe]:gbe,scopedRef:n,reload:pipe(dbe(n,pipe(build$1(t.layer),qR(RA(e)))),oU(r))})))))),reloadableTag=e=>GenericTag(`effect/Reloadable<${e.key}>`);var ybe=Object.freeze({__proto__:null,ReloadableTypeId:mbe,auto:auto$3,autoFromConfig:(e,t)=>k0(reloadableTag(e),pipe(context$c(),PR(r=>pipe(build$1(auto$3(e,{layer:t.layer,schedule:t.scheduleFromConfig(r)})),qR(RA(reloadableTag(e))))))),get:e=>PR(reloadableTag(e),e=>get$l(e.scopedRef)),manual:manual$3,reload:e=>PR(reloadableTag(e),e=>e.reload),reloadFork:e=>PR(reloadableTag(e),e=>pipe(e.reload,ignoreLogged$2,forkDaemon$1,asVoid$9)),tag:reloadableTag});var bbe=Object.freeze({__proto__:null,empty:Uj,mapRequestResolvers:(e,t)=>reduce$k(e,(e=>({emptyCase:()=>Uj,parCase:(e,t)=>par(e,t),seqCase:(e,t)=>seq(e,t),singleCase:(t,r)=>single$1(e(t),r)}))(t)),parallel:par,reduce:reduce$k,sequential:seq,single:single$1});const make$E=e=>new RequestResolverImpl(t=>e(t.map(e=>e.map(e=>e.request)))),makeBatched$1=e=>new RequestResolverImpl(t=>{if(t.length>1)return UR(t,t=>{const r=t.filter(e=>!e.state.completed).map(e=>e.request);return ui(r)?invokeWithInterrupt(e(r),t):tD});if(1===t.length){const r=t[0].filter(e=>!e.state.completed).map(e=>e.request);return ui(r)?e(r):tD}return tD}),Sbe=dual(3,(e,t,r)=>new RequestResolverImpl(n=>IR(t,()=>e.runAll(n),r),make$2d("Around",e,t,r))),vbe=dual(3,(e,t,r)=>new RequestResolverImpl(n=>{const i=n.flatMap(e=>e.map(e=>e.request));return IR(t(i),()=>e.runAll(n),e=>r(i,e))},make$2d("AroundRequests",e,t,r))),_be=dual(2,(e,t)=>new RequestResolverImpl(r=>t<1?die$g(new tY("RequestResolver.batchN: n must be at least 1")):e.runAll(Array.from(fC(ys(r,empty$R(),(e,r)=>eC(e,aC(unsafeFromArray(r),t))),e=>Array.from(e)))),make$2d("BatchN",e,t))),wbe=dual(2,(e,t)=>new RequestResolverImpl(r=>uU(e.runAll(r),e=>t(e)),make$2d("MapInputContext",e,t))),kbe=dual(3,(e,t,r)=>new RequestResolverImpl(n=>LR(n,n=>{const[i,s]=pipe(n,fs(r));return vQ(e.runAll(Array.of(i)),t.runAll(Array.of(s)),()=>{},{concurrent:!0})}),make$2d("EitherWith",e,t,r))),xbe=make$E(()=>K4).identified("Never"),Ibe=dual(2,(e,t)=>wbe(e,e=>t).identified("ProvideContext",e,t)),Tbe=Ibe;var Obe=Object.freeze({__proto__:null,RequestResolverTypeId:jD,around:Sbe,aroundRequests:vbe,batchN:_be,contextFromEffect:e=>contextWith$8(t=>Tbe(e,t)),contextFromServices:(...e)=>t=>contextWith$8(r=>Tbe(t,pick$2(...e)(r))),eitherWith:kbe,fromEffect:e=>makeBatched$1(t=>x4(t,t=>h7(Y5(e(t)),e=>fH(t,e)),{concurrency:"unbounded",discard:!0})).identified("FromEffect",e),fromEffectTagged:()=>e=>makeBatched$1(t=>{const r={},n=[];for(let e=0,i=t.length;e<i;e++)n.includes(t[e]._tag)?r[t[e]._tag].push(t[e]):(r[t[e]._tag]=[t[e]],n.push(t[e]._tag));return x4(n,t=>W7(e[t](r[t]),{onFailure:e=>x4(r[t],t=>fH(t,exitFail$1(e)),{discard:!0}),onSuccess:e=>x4(r[t],(t,r)=>fH(t,exitSucceed$1(e[r])),{discard:!0})}),{concurrency:"unbounded",discard:!0})}).identified("FromEffectTagged",e),fromFunction:e=>makeBatched$1(t=>UR(t,t=>fH(t,exitSucceed$1(e(t))))).identified("FromFunction",e),fromFunctionBatched:e=>makeBatched$1(t=>x4(e(t),(e,r)=>fH(t[r],exitSucceed$1(e)),{discard:!0})).identified("FromFunctionBatched",e),isRequestResolver:isRequestResolver$1,locally:DD,make:make$E,makeBatched:makeBatched$1,makeWithEntry:e=>new RequestResolverImpl(t=>e(t)),mapInputContext:wbe,never:xbe,provideContext:Tbe,race:dual(2,(e,t)=>new RequestResolverImpl(r=>g7(e.runAll(r),t.runAll(r))).identified("Race",e,t))});const Ebe=Symbol.for("effect/Resource"),Abe={...Me,commit(){return get$i(this)},[Ebe]:{_E:e=>e,_A:e=>e}},manual$1=e=>PR(context$c(),t=>pipe(fromAcquire$1(exit$2(e)),qR(r=>{const n=Object.create(Abe);return n.scopedRef=r,n.acquire=oU(e,t),n}))),get$i=e=>PR(get$l(e.scopedRef),identity$5),refresh$1=e=>dbe(e.scopedRef,qR(e.acquire,exitSucceed$1));var Cbe=Object.freeze({__proto__:null,ResourceTypeId:Ebe,auto:(e,t)=>XR(manual$1(e),e=>eQ(pipe(refresh$1(e),U6(t),interruptible$3,forkDaemon$1),interruptFiber)),get:get$i,manual:manual$1,refresh:refresh$1});var Mbe=Object.freeze({__proto__:null,CooperativeYielding:32,Interruption:1,None:0,OpSupervision:2,RuntimeMetrics:4,WindDown:16,cooperativeYielding:cooperativeYielding$1,diff:Mj,differ:Pj,disable:xj,disableAll:Ij,disableCooperativeYielding:O9,disableInterruption:E9,disableOpSupervision:A9,disableRuntimeMetrics:C9,disableWindDown:M9,enable:Tj,enableAll:Oj,enableCooperativeYielding:w9,enableInterruption:k9,enableOpSupervision:x9,enableRuntimeMetrics:I9,enableWindDown:T9,interruptible:interruptible$4,interruption:interruption$1,isDisabled:Ej,isEnabled:Aj,make:make$20,none:Cj,opSupervision:e=>Aj(e,2),patch:Fj,render:e=>{const t=[];return kj.forEach(r=>{Aj(e,r)&&t.push(""+print(r))}),`RuntimeFlags(${t.join(", ")})`},runtimeMetrics:runtimeMetrics$1,toSet:toSet$2,windDown:windDown$1});const Fbe=xse,Pbe=isSTM$1,Nbe=zse,jbe=all$3,Rbe=qse,Dbe=asSome$1,Lbe=asVoid$2,Ube=attempt$1,$be=Tse,Bbe=Gse,zbe=Jse,qbe=Hse,Wbe=Zse,Vbe=Qse,Kbe=commit$1,Gbe=context$5,Jbe=contextWithSTM$1,Hbe=Ose,Zbe=die$6,Qbe=dieMessage$6,Ybe=dieSync$4,Xbe=either$5,eSe=Ese,tSe=eventually$1,rSe=Yse,nSe=Xse,iSe=fail$c,sSe=failSync$5,oSe=eoe,aSe=toe,uSe=roe,cSe=noe,lSe=ioe,pSe=soe,fSe=ooe,hSe=Ase,dSe=flatten$4,mSe=flip$1,gSe=aoe,ySe=uoe,bSe=Cse,SSe=coe,vSe=fromEither$2,gen=(...e)=>suspend$8(()=>{const t=(1===e.length?e[0]:e[1].bind(e[0]))(pipe),r=t.next(),run=e=>e.done?succeed$c(e.value):Ase(yieldWrapGet(e.value),e=>run(t.next(e)));return run(r)}),_Se=loe,wSe=Mse,kSe=interruptAs$1,xSe=iterate$3,ISe=Fse,TSe=poe,OSe=foe,ESe=hoe,ASe=doe,CSe=negate$1,MSe=moe,FSe=goe,PSe=yoe,NSe=boe,jSe=Soe,RSe=voe,DSe=Pse,LSe=Uoe,USe=_oe,$Se=woe,BSe=koe,zSe=xoe,qSe=Ioe,WSe=Toe,VSe=Ooe,KSe=Eoe,GSe=Aoe,JSe=Coe,HSe=Moe,ZSe=Foe,QSe=Poe,YSe=Noe,XSe=joe,eve=Roe,tve=Nse,rve=Doe,nve=Loe,ive=succeed$c,sve=$oe,ove=succeedSome$1,ave=Boe,uve=suspend$8,cve=sync$9,lve=zoe,pve=qoe,fve=Woe,hve=Koe,dve=Goe,mve=Voe,gve=Joe,yve=Hoe,bve=Zoe,Sve=Qoe,vve=jse,_ve=Rse,wve=Dse,kve=Lse;var xve=Object.freeze({__proto__:null,Do:ive({}),STMTypeId:Fbe,acquireUseRelease:Nbe,all:jbe,as:Rbe,asSome:Dbe,asSomeError:e=>pipe(e,hoe(Ut)),asVoid:Lbe,attempt:Ube,bind:Wse,bindTo:Vse,catchAll:$be,catchSome:Bbe,catchTag:zbe,catchTags:qbe,check:e=>suspend$8(()=>e()?Voe:Nse),collect:Wbe,collectSTM:Vbe,commit:Kbe,commitEither:e=>m7(commit$1(either$5(e))),cond:(e,t,r)=>suspend$8(()=>e()?sync$9(r):failSync$5(t)),context:Gbe,contextWith:e=>Fse(context$5(),e),contextWithSTM:Jbe,die:Zbe,dieMessage:Qbe,dieSync:Ybe,either:Xbe,ensuring:eSe,eventually:tSe,every:rSe,exists:nSe,fail:iSe,failSync:sSe,fiberId:oSe,filter:aSe,filterNot:uSe,filterOrDie:cSe,filterOrDieMessage:lSe,filterOrElse:pSe,filterOrFail:fSe,firstSuccessOf:e=>uve(()=>{const t=fromIterable$u(e);return isNonEmpty$8(t)?qC(tailNonEmpty(t),lC(t),(e,t)=>FSe(e,()=>t)):Ybe(()=>new tY("Received an empty collection of effects"))}),flatMap:hSe,flatten:dSe,flip:mSe,flipWith:gSe,forEach:SSe,fromEither:vSe,fromOption:e=>qt(e,{onNone:()=>fail$c(none$c()),onSome:succeed$c}),gen,head:e=>pipe(e,Cse({onFailure:e=>fail$c(Ut(e)),onSuccess:e=>{const t=e[Symbol.iterator]().next();return t.done?fail$c(none$c()):succeed$c(t.value)}})),if:_Se,ignore:e=>uoe(e,{onFailure:()=>Voe,onSuccess:()=>Voe}),interrupt:wSe,interruptAs:kSe,isFailure:e=>uoe(e,{onFailure:r,onSuccess:n}),isSTM:Pbe,isSuccess:e=>uoe(e,{onFailure:n,onSuccess:r}),iterate:xSe,let:Kse,loop:(e,t)=>t.discard?loopDiscardLoop(e,t.while,t.step,t.body):Fse(loopLoop(e,t.while,t.step,t.body),e=>Array.from(e)),map:ISe,mapAttempt:TSe,mapBoth:OSe,mapError:ESe,mapInputContext:Hbe,match:ySe,matchSTM:bSe,merge:e=>Cse(e,{onFailure:e=>succeed$c(e),onSuccess:succeed$c}),mergeAll:ASe,negate:CSe,none:e=>Cse(e,{onFailure:e=>fail$c(Ut(e)),onSuccess:qt({onNone:()=>Voe,onSome:()=>fail$c(none$c())})}),option:e=>uoe(e,{onFailure:()=>none$c(),onSuccess:Ut}),orDie:e=>pipe(e,moe(identity$5)),orDieWith:MSe,orElse:FSe,orElseEither:PSe,orElseFail:NSe,orElseOptional:jSe,orElseSucceed:RSe,orTry:DSe,partition:LSe,provideContext:USe,provideService:BSe,provideServiceSTM:zSe,provideSomeContext:$Se,reduce:qSe,reduceAll:WSe,reduceRight:VSe,refineOrDie:KSe,refineOrDieWith:GSe,reject:JSe,rejectSTM:HSe,repeatUntil:ZSe,repeatWhile:QSe,replicate:YSe,replicateSTM:XSe,replicateSTMDiscard:eve,retry:tve,retryUntil:rve,retryWhile:nve,some:e=>Cse(e,{onFailure:e=>fail$c(Ut(e)),onSuccess:qt({onNone:()=>fail$c(none$c()),onSome:succeed$c})}),succeed:ive,succeedNone:sve,succeedSome:ove,summarized:ave,suspend:uve,sync:cve,tap:lve,tapBoth:pve,tapError:fve,try:e=>{const t="function"==typeof e?e:e.try;return suspend$8(()=>{try{return succeed$c(t())}catch(t){return fail$c("catch"in e?e.catch(t):t)}})},unless:hve,unlessSTM:dve,unsome:e=>Cse(e,{onFailure:qt({onNone:()=>succeed$c(none$c()),onSome:fail$c}),onSuccess:e=>succeed$c(Ut(e))}),validateAll:gve,validateFirst:yve,void:mve,when:bve,whenSTM:Sve,zip:vve,zipLeft:_ve,zipRight:wve,zipWith:kve});const Ive=dual(e=>isObject(e[0]),(e,...t)=>{const r={};for(const n of t)n in e&&(r[n]=e[n]);return r}),Tve=dual(e=>isObject(e[0]),(e,...t)=>{const r={...e};for(const e of t)delete r[e];return r}),Ove=struct$5,Eve=struct$3,Ave=dual(2,(e,t)=>{const r={...e};for(const n in t)Object.prototype.hasOwnProperty.call(e,n)&&(r[n]=t[n](e[n]));return r});var Cve=Object.freeze({__proto__:null,entries:e=>Object.entries(e),evolve:Ave,get:e=>t=>t[e],getEquivalence:Ove,getOrder:Eve,keys:e=>Object.keys(e),omit:Tve,pick:Ive});const Mve=Symbol.for("effect/Schema");function make$B(e){return class{[Mve]=Fve;static ast=e;static annotations(e){return make$B(mergeSchemaAnnotations(this.ast,e))}static pipe(){return pipeArguments(this,arguments)}static toString(){return e+""}static Type;static Encoded;static Context;static[Mve]=Fve}}const Fve={_A:e=>e,_I:e=>e,_R:e=>e},makeStandardResult=e=>kU(e)?e.value:makeStandardFailureResult(iY(e.cause)),makeStandardFailureResult=e=>({issues:[{message:e}]}),makeStandardFailureFromParseIssue=e=>P3(jme.formatIssue(e),e=>({issues:e.map(e=>({path:e.path,message:e.message}))})),Pve={schemaId:rT,message:nT,missingMessage:iT,identifier:sT,title:oT,description:uT,examples:cT,default:lT,documentation:mT,jsonSchema:pT,arbitrary:fT,pretty:hT,equivalence:dT,concurrency:gT,batching:yT,parseIssueTitle:bT,parseOptions:ST,decodingFallback:vT},toASTAnnotations=e=>{if(!e)return{};const t={...e};for(const r in Pve)r in e&&(t[Pve[r]]=e[r],delete t[r]);return t},mergeSchemaAnnotations=(e,t)=>annotations$2(e,toASTAnnotations(t));const format=e=>e.ast+"",encodedSchema=e=>make$B(encodedAST(e.ast)),encodedBoundSchema=e=>make$B(encodedBoundAST(e.ast)),typeSchema=e=>make$B(typeAST(e.ast)),encodeUnknown=(e,t)=>{const r=encodeUnknown$1(e,t);return(e,t)=>mme(r(e,t),parseError)},encodeUnknownEither=(e,t)=>{const r=encodeUnknownEither$1(e,t);return(e,t)=>it(r(e,t),parseError)},encodeUnknownPromise=(e,t)=>{const r=encodeUnknown(e,t);return(e,t)=>O8(r(e,t))},Nve=encodeUnknown,jve=encodeUnknownEither,Rve=encodeUnknownPromise,decodeUnknown=(e,t)=>{const r=decodeUnknown$1(e,t);return(e,t)=>mme(r(e,t),parseError)},decodeUnknownEither=(e,t)=>{const r=decodeUnknownEither$1(e,t);return(e,t)=>it(r(e,t),parseError)},decodeUnknownPromise=(e,t)=>{const r=decodeUnknown(e,t);return(e,t)=>O8(r(e,t))},Dve=decodeUnknown,Lve=decodeUnknownEither,Uve=decodeUnknownPromise,validate=(e,t)=>{const r=validate$1(e,t);return(e,t)=>mme(r(e,t),parseError)},isSchema=e=>C(e,Mve)&&isObject(e[Mve]);function makeLiteralClass(e,t=function(e){return isMembers(e)?EO.make(mapMembers(e,e=>new GT(e))):new GT(e[0])}(e)){return class extends(make$B(t)){static annotations(e){return makeLiteralClass(this.literals,mergeSchemaAnnotations(this.ast,e))}static literals=[...e]}}function Literal(...e){return ci(e)?makeLiteralClass(e):Never}const UniqueSymbolFromSelf=e=>make$B(new UniqueSymbol(e)),makeEnumsClass=(e,t=(e=>new SO(Object.keys(e).filter(t=>"number"!=typeof e[e[t]]).map(t=>[t,e[t]])))(e))=>class extends(make$B(t)){static annotations(e){return makeEnumsClass(this.enums,mergeSchemaAnnotations(this.ast,e))}static enums={...e}},TemplateLiteral=(...[e,...t])=>{const r=[];let n="",i=t;isSchema(e)?JT(e.ast)?n=e.ast.literal+"":i=[e,...i]:n=e+"";for(let e=0;e<i.length;e++){const t=i[e];if(isSchema(t)){if(e<i.length-1){const n=i[e+1];if(!isSchema(n)){r.push(new TemplateLiteralSpan(t.ast,n+"")),e++;continue}if(JT(n.ast)){r.push(new TemplateLiteralSpan(t.ast,n.ast.literal+"")),e++;continue}}r.push(new TemplateLiteralSpan(t.ast,""))}else r.push(new TemplateLiteralSpan(new GT(t),""))}return ui(r)?make$B(new _O(n,r)):make$B(new _O("",[new TemplateLiteralSpan(new GT(n),"")]))};function getTemplateLiteralParserCoercedElement(e,t){const r=e.ast;switch(r._tag){case"Literal":{const e=r.literal;if(!isString$1(e)){const r=e+"";return n_e(Literal(r),t,{strict:!0,decode:()=>e,encode:()=>r})}break}case"NumberKeyword":return Xve(NumberFromString,t);case"Union":{const e=[];let n=!1;for(const t of r.types){const r=make$B(t),i=getTemplateLiteralParserCoercedElement(encodedSchema(r),r);i&&(n=!0),e.push(i??r)}return n?Xve(Union(...e),t):t}}}function makeDeclareClass(e,t){return class extends(make$B(t)){static annotations(e){return makeDeclareClass(this.typeParameters,mergeSchemaAnnotations(this.ast,e))}static typeParameters=[...e]}}const declare=function(){return Array.isArray(arguments[0])?(t=arguments[1],r=arguments[2],makeDeclareClass(e=arguments[0],new Declaration(e.map(e=>e.ast),(...e)=>t.decode(...e.map(make$B)),(...e)=>t.encode(...e.map(make$B)),toASTAnnotations(r)))):((e,t)=>{const decodeUnknown=()=>(t,r,n)=>e(t)?ume(t):cme(new Type(n,t));return makeDeclareClass([],new Declaration([],decodeUnknown,decodeUnknown,toASTAnnotations(t)))})(arguments[0],arguments[1]);var e,t,r},$ve=Symbol.for("effect/SchemaId/Brand"),Bve=Symbol.for("effect/SchemaId/InstanceOf"),instanceOf=(e,t)=>declare(t=>t instanceof e,{title:e.name,description:"an instance of "+e.name,pretty:()=>String,schemaId:Bve,[Bve]:{constructor:e},...t});class Undefined extends(make$B(QT)){}class Null extends(make$B(HT)){}class Never extends(make$B(tO)){}class Unknown extends(make$B(nO)){}class BigIntFromSelf extends(make$B(hO)){}class SymbolFromSelf extends(make$B(mO)){}class String$ extends(make$B(aO)){}class Number$ extends(make$B(cO)){}class Boolean$ extends(make$B(pO)){}const getDefaultUnionAST=e=>EO.make(e.map(e=>e.ast));function makeUnionClass(e,t=getDefaultUnionAST(e)){return class extends(make$B(t)){static annotations(e){return makeUnionClass(this.members,mergeSchemaAnnotations(this.ast,e))}static members=[...e]}}function Union(...e){return isMembers(e)?makeUnionClass(e):ci(e)?e[0]:Never}const NullOr=e=>Union(e,Null),UndefinedOr=e=>Union(e,Undefined),NullishOr=e=>Union(e,Null,Undefined),element=e=>new ElementImpl(new OptionalType(e.ast,!1),e);class ElementImpl{ast;from;[Mve];_Token;constructor(e,t){this.ast=e,this.from=t}annotations(e){return new ElementImpl(new OptionalType(this.ast.type,this.ast.isOptional,{...this.ast.annotations,...toASTAnnotations(e)}),this.from)}toString(){return`${this.ast.type}${this.ast.isOptional?"?":""}`}}function makeTupleTypeClass(e,t,r=((e,t)=>new TupleType(e.map(e=>isSchema(e)?new OptionalType(e.ast,!1):e.ast),t.map(e=>isSchema(e)?new kO(e.ast):e.ast),!0))(e,t)){return class extends(make$B(r)){static annotations(e){return makeTupleTypeClass(this.elements,this.rest,mergeSchemaAnnotations(this.ast,e))}static elements=[...e];static rest=[...t]}}function Tuple(...e){return Array.isArray(e[0])?makeTupleTypeClass(e[0],e.slice(1)):makeTupleTypeClass(e,[])}function makeArrayClass(e,t){return class extends(makeTupleTypeClass([],[e],t)){static annotations(e){return makeArrayClass(this.value,mergeSchemaAnnotations(this.ast,e))}static value=e}}const Array$=e=>makeArrayClass(e);function makeNonEmptyArrayClass(e,t){return class extends(makeTupleTypeClass([e],[e],t)){static annotations(e){return makeNonEmptyArrayClass(this.value,mergeSchemaAnnotations(this.ast,e))}static value=e}}const NonEmptyArray=e=>makeNonEmptyArrayClass(e),formatPropertySignatureToken=e=>e?'"?:"':'":"';class PropertySignatureDeclaration extends OptionalType{isReadonly;defaultValue;_tag="PropertySignatureDeclaration";constructor(e,t,r,n,i){super(e,t,n),this.isReadonly=r,this.defaultValue=i}toString(){const e=formatPropertySignatureToken(this.isOptional),t=this.type+"";return`PropertySignature<${e}, ${t}, never, ${e}, ${t}>`}}class FromPropertySignature extends OptionalType{isReadonly;fromKey;constructor(e,t,r,n,i){super(e,t,n),this.isReadonly=r,this.fromKey=i}}class ToPropertySignature extends OptionalType{isReadonly;defaultValue;constructor(e,t,r,n,i){super(e,t,n),this.isReadonly=r,this.defaultValue=i}}class PropertySignatureTransformation{from;to;decode;encode;_tag="PropertySignatureTransformation";constructor(e,t,r,n){this.from=e,this.to=t,this.decode=r,this.encode=n}toString(){return`PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${e=this.from.fromKey,void 0===e?"never":isString$1(e)?JSON.stringify(e):e+""}, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`;var e}}const mergeSignatureAnnotations=(e,t)=>{switch(e._tag){case"PropertySignatureDeclaration":return new PropertySignatureDeclaration(e.type,e.isOptional,e.isReadonly,{...e.annotations,...t},e.defaultValue);case"PropertySignatureTransformation":return new PropertySignatureTransformation(e.from,new ToPropertySignature(e.to.type,e.to.isOptional,e.to.isReadonly,{...e.to.annotations,...t},e.to.defaultValue),e.decode,e.encode)}},zve=Symbol.for("effect/PropertySignature"),isPropertySignature=e=>C(e,zve);class PropertySignatureImpl{ast;[Mve];[zve]=null;_TypeToken;_Key;_EncodedToken;_HasDefault;constructor(e){this.ast=e}pipe(){return pipeArguments(this,arguments)}annotations(e){return new PropertySignatureImpl(mergeSignatureAnnotations(this.ast,toASTAnnotations(e)))}toString(){return this.ast+""}}const makePropertySignature=e=>new PropertySignatureImpl(e);class PropertySignatureWithFromImpl extends PropertySignatureImpl{from;constructor(e,t){super(e),this.from=t}annotations(e){return new PropertySignatureWithFromImpl(mergeSignatureAnnotations(this.ast,toASTAnnotations(e)),this.from)}}const propertySignature=e=>new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(e.ast,!1,!0,{},void 0),e),qve=dual(2,(e,t)=>{const r=e.ast;switch(r._tag){case"PropertySignatureDeclaration":return makePropertySignature(new PropertySignatureDeclaration(r.type,r.isOptional,r.isReadonly,r.annotations,t));case"PropertySignatureTransformation":return makePropertySignature(new PropertySignatureTransformation(r.from,new ToPropertySignature(r.to.type,r.to.isOptional,r.to.isReadonly,r.to.annotations,t),r.decode,r.encode))}}),applyDefaultValue=(e,t)=>qt(e,{onNone:()=>Ut(t()),onSome:e=>Ut(void 0===e?t():e)}),pruneUndefined=e=>pruneUndefined$2(e,pruneUndefined,e=>{const t=pruneUndefined(e.to);if(t)return new jO(e.from,t,e.transformation)}),Wve=dual(2,(e,t)=>{const r=e.ast;switch(r._tag){case"PropertySignatureDeclaration":{const e=typeAST(r.type);return makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(r.type,r.isOptional,r.isReadonly,r.annotations),new ToPropertySignature(pruneUndefined(e)??e,!1,!0,{},r.defaultValue),e=>applyDefaultValue(e,t),identity$5))}case"PropertySignatureTransformation":{const e=r.to.type;return makePropertySignature(new PropertySignatureTransformation(r.from,new ToPropertySignature(pruneUndefined(e)??e,!1,r.to.isReadonly,r.to.annotations,r.to.defaultValue),e=>applyDefaultValue(r.decode(e),t),r.encode))}}}),Vve=dual(2,(e,t)=>e.pipe(Wve(t.decoding),qve(t.constructor))),Kve=dual(2,(e,t)=>{const r=e.ast;switch(r._tag){case"PropertySignatureDeclaration":return makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(r.type,r.isOptional,r.isReadonly,r.annotations,t),new ToPropertySignature(typeAST(r.type),r.isOptional,r.isReadonly,{},r.defaultValue),identity$5,identity$5));case"PropertySignatureTransformation":return makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(r.from.type,r.from.isOptional,r.from.isReadonly,r.from.annotations,t),r.to,r.decode,r.encode))}}),optionalToRequired=(e,t,r)=>makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(e.ast,!0,!0,{},void 0),new ToPropertySignature(t.ast,!1,!0,{},void 0),e=>Ut(r.decode(e)),ir(r.encode))),optionalToOptional=(e,t,r)=>makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(e.ast,!0,!0,{},void 0),new ToPropertySignature(t.ast,!0,!0,{},void 0),r.decode,r.encode)),Gve=dual(e=>isSchema(e[0]),(e,t)=>new PropertySignatureWithFromImpl(((e,t)=>{const r=t?.exact,n=t?.default,i=t?.nullable,s="Option"==t?.as,o=t?.onNoneEncoding?Gt(t.onNoneEncoding):identity$5;if(r){if(n)return i?qve(optionalToRequired(NullOr(e),typeSchema(e),{decode:qt({onNone:n,onSome:e=>null===e?n():e}),encode:Ut}),n).ast:qve(optionalToRequired(e,typeSchema(e),{decode:qt({onNone:n,onSome:identity$5}),encode:Ut}),n).ast;if(s){const t=OptionFromSelf_(typeSchema(e));return i?optionalToRequired(NullOr(e),t,{decode:yr(isNotNull),encode:o}).ast:optionalToRequired(e,t,{decode:identity$5,encode:identity$5}).ast}return i?optionalToOptional(NullOr(e),typeSchema(e),{decode:yr(isNotNull),encode:identity$5}).ast:new PropertySignatureDeclaration(e.ast,!0,!0,{},void 0)}if(n)return i?qve(optionalToRequired(NullishOr(e),typeSchema(e),{decode:qt({onNone:n,onSome:e=>e??n()}),encode:Ut}),n).ast:qve(optionalToRequired(UndefinedOr(e),typeSchema(e),{decode:qt({onNone:n,onSome:e=>void 0===e?n():e}),encode:Ut}),n).ast;if(s){const t=OptionFromSelf_(typeSchema(e));return i?optionalToRequired(NullishOr(e),t,{decode:yr(e=>null!=e),encode:o}).ast:optionalToRequired(UndefinedOr(e),t,{decode:yr(isNotUndefined),encode:o}).ast}return i?optionalToOptional(NullishOr(e),UndefinedOr(typeSchema(e)),{decode:yr(isNotNull),encode:identity$5}).ast:new PropertySignatureDeclaration(UndefinedOr(e).ast,!0,!0,{},void 0)})(e,t),e)),Jve=pickAnnotations([iT]),lazilyMergeDefaults=(e,t)=>{const r=Reflect.ownKeys(e);for(const n of r){const r=e[n];if(void 0===t[n]&&isPropertySignature(r)){const e=r.ast,i="PropertySignatureDeclaration"===e._tag?e.defaultValue:e.to.defaultValue;void 0!==i&&(t[n]=i())}}return t};function makeTypeLiteralClass(e,t,r=((e,t)=>{const r=Reflect.ownKeys(e),n=[];if(r.length>0){const i=[],s=[],o=[];for(let t=0;t<r.length;t++){const a=r[t],u=e[a];if(isPropertySignature(u)){const e=u.ast;switch(e._tag){case"PropertySignatureDeclaration":{const t=e.type,r=e.isOptional,o=e.annotations;i.push(new PropertySignature(a,t,r,!0,Jve(e))),s.push(new PropertySignature(a,typeAST(t),r,!0,o)),n.push(new PropertySignature(a,t,r,!0,o));break}case"PropertySignatureTransformation":{const t=e.from.fromKey??a;i.push(new PropertySignature(t,e.from.type,e.from.isOptional,!0,e.from.annotations)),s.push(new PropertySignature(a,e.to.type,e.to.isOptional,!0,e.to.annotations)),o.push(new $O(t,a,e.decode,e.encode));break}}}else i.push(new PropertySignature(a,u.ast,!1,!0)),s.push(new PropertySignature(a,typeAST(u.ast),!1,!0)),n.push(new PropertySignature(a,u.ast,!1,!0))}if(ci(o)){const e=[],r=[];for(const n of t){const{indexSignatures:t,propertySignatures:o}=record$1(n.key.ast,n.value.ast);o.forEach(e=>{i.push(e),s.push(new PropertySignature(e.name,typeAST(e.type),e.isOptional,e.isReadonly,e.annotations))}),t.forEach(t=>{e.push(t),r.push(new IndexSignature(t.parameter,typeAST(t.type),t.isReadonly))})}return new jO(new TypeLiteral(i,e,{[aT]:"Struct (Encoded side)"}),new TypeLiteral(s,r,{[aT]:"Struct (Type side)"}),new TypeLiteralTransformation(o))}}const i=[];for(const e of t){const{indexSignatures:t,propertySignatures:r}=record$1(e.key.ast,e.value.ast);r.forEach(e=>n.push(e)),t.forEach(e=>i.push(e))}return new TypeLiteral(n,i)})(e,t)){return class extends(make$B(r)){static annotations(e){return makeTypeLiteralClass(this.fields,this.records,mergeSchemaAnnotations(this.ast,e))}static fields={...e};static records=[...t];static make=(t,r)=>{const n=lazilyMergeDefaults(e,{...t});return getDisableValidationMakeOption(r)?n:validateSync(this)(n)};static pick(...t){return Struct(Ive(e,...t))}static omit(...t){return Struct(Tve(e,...t))}}}function Struct(e,...t){return makeTypeLiteralClass(e,t)}const tag=e=>Literal(e).pipe(propertySignature,qve(()=>e)),TaggedStruct=(e,t)=>Struct({_tag:tag(e),...t});function makeRecordClass(e,t,r){return class extends(makeTypeLiteralClass({},[{key:e,value:t}],r)){static annotations(r){return makeRecordClass(e,t,mergeSchemaAnnotations(this.ast,r))}static key=e;static value=t}}const Record=e=>makeRecordClass(e.key,e.value),pick=(...e)=>t=>make$B(pick$4(t.ast,e)),Hve=dual(2,(e,t)=>{const r=getPropertyKeyIndexedAccess(typeAST(e.ast),t),n=make$B(r.isOptional?orUndefined(r.type):r.type);return n_e(e.pipe(pick(t)),n,{strict:!0,decode:e=>e[t],encode:e=>r.isOptional&&void 0===e?{}:{[t]:e}})});function makeBrandClass(e,t){return class extends(make$B(t)){static annotations(e){return makeBrandClass(this.from,mergeSchemaAnnotations(this.ast,e))}static make=(e,t)=>getDisableValidationMakeOption(t)?e:validateSync(this)(e);static from=e}}const Zve=dual(e=>isSchema(e[0]),(e,t)=>make$B(partial$1(e.ast,t))),intersectTypeLiterals=(e,t,r)=>{if(IO(e)&&IO(t)){const n=[...e.propertySignatures];for(const e of t.propertySignatures){const name=e.name,t=n.findIndex(e=>e.name===name);if(-1===t)n.push(e);else{const{isOptional:i,type:s}=n[t];n[t]=new PropertySignature(name,extendAST(s,e.type,r.concat(name)),i,!0)}}return new TypeLiteral(n,e.indexSignatures.concat(t.indexSignatures))}throw Error(getSchemaExtendErrorMessage(e,t,r))},Qve=omitAnnotations([sT]),addRefinementToMembers=(e,t)=>t.map(t=>new FO(t,e.filter,Qve(e))),extendAST=(e,t,r)=>EO.make(intersectUnionMembers([e],[t],r)),getTypes=e=>AO(e)?e.types:[e],intersectUnionMembers=(e,t,r)=>us(e,e=>us(t,t=>{switch(t._tag){case"Literal":if(isString$1(t.literal)&&uO(e)||isNumber$1(t.literal)&&lO(e)||isBoolean$1(t.literal)&&fO(e))return[t];break;case"StringKeyword":if(t===aO){if(uO(e)||JT(e)&&isString$1(e.literal))return[e];if(PO(e))return addRefinementToMembers(e,intersectUnionMembers(getTypes(e.from),[t],r))}else if(e===aO)return[t];break;case"NumberKeyword":if(t===cO){if(lO(e)||JT(e)&&isNumber$1(e.literal))return[e];if(PO(e))return addRefinementToMembers(e,intersectUnionMembers(getTypes(e.from),[t],r))}else if(e===cO)return[t];break;case"BooleanKeyword":if(t===pO){if(fO(e)||JT(e)&&isBoolean$1(e.literal))return[e];if(PO(e))return addRefinementToMembers(e,intersectUnionMembers(getTypes(e.from),[t],r))}else if(e===pO)return[t];break;case"Union":return intersectUnionMembers(getTypes(e),t.types,r);case"Suspend":return[new Suspend(()=>extendAST(e,t.f(),r))];case"Refinement":return addRefinementToMembers(t,intersectUnionMembers(getTypes(e),getTypes(t.from),r));case"TypeLiteral":switch(e._tag){case"Union":return intersectUnionMembers(e.types,[t],r);case"Suspend":return[new Suspend(()=>extendAST(e.f(),t,r))];case"Refinement":return addRefinementToMembers(e,intersectUnionMembers(getTypes(e.from),[t],r));case"TypeLiteral":return[intersectTypeLiterals(e,t,r)];case"Transformation":{const n=e.transformation,i=intersectTypeLiterals(e.from,t,r),s=intersectTypeLiterals(e.to,typeAST(t),r);switch(n._tag){case"TypeLiteralTransformation":return[new jO(i,s,new TypeLiteralTransformation(n.propertySignatureTransformations))];case"ComposeTransformation":return[new jO(i,s,LO)];case"FinalTransformation":return[new jO(i,s,new FinalTransformation((e,t,r,i)=>dme(n.decode(e,t,r,i),t=>({...e,...t})),(e,t,r,i)=>dme(n.encode(e,t,r,i),t=>({...e,...t}))))]}}}break;case"Transformation":if(!RO(e))return intersectUnionMembers([t],[e],r);if(BO(t.transformation)&&BO(e.transformation))return[new jO(intersectTypeLiterals(e.from,t.from,r),intersectTypeLiterals(e.to,t.to,r),new TypeLiteralTransformation(t.transformation.propertySignatureTransformations.concat(e.transformation.propertySignatureTransformations)))]}throw Error(getSchemaExtendErrorMessage(e,t,r))})),Yve=dual(2,(e,t)=>make$B(extendAST(e.ast,t.ast,[]))),Xve=dual(e=>isSchema(e[1]),(e,t)=>makeTransformationClass(e,t,compose$4(e.ast,t.ast))),suspend$2=e=>make$B(new Suspend(()=>e().ast)),e_e=Symbol.for("effect/SchemaId/Refine");function makeRefineClass(e,t,r){return class extends(make$B(r)){static annotations(e){return makeRefineClass(this.from,this.filter,mergeSchemaAnnotations(this.ast,e))}static[e_e]=e;static from=e;static filter=t;static make=(e,t)=>getDisableValidationMakeOption(t)?e:validateSync(this)(e)}}const fromFilterPredicateReturnTypeItem=(e,t,r)=>{if(isBoolean$1(e))return e?none$c():Ut(new Type(t,r));if(isString$1(e))return Ut(new Type(t,r,e));if(void 0!==e){if("_tag"in e)return Ut(e);const n=new Type(t,r,e.message);return Ut(ci(e.path)?new Pointer(e.path,r,n):n)}return none$c()},toFilterParseIssue=(e,t,r)=>{if(!Array.isArray(e))return fromFilterPredicateReturnTypeItem(e,t,r);if(ci(e)){const n=ls(e,e=>fromFilterPredicateReturnTypeItem(e,t,r));if(ci(n))return Ut(1===n.length?n[0]:new Composite(t,r,n))}return none$c()};function filter$3(e,t){return r=>{function filter(t,r,n){return toFilterParseIssue(e(t,r,n),n,t)}return makeRefineClass(r,filter,new FO(r.ast,filter,toASTAnnotations(t)))}}const t_e=dual(2,(e,t)=>r_e(e,typeSchema(e),{strict:!0,decode:(e,r,n)=>hme(t(e,r,n),t=>qt(toFilterParseIssue(t,n,e),{onNone:()=>ume(e),onSome:cme})),encode:e=>ume(e)}));function makeTransformationClass(e,t,r){return class extends(make$B(r)){static annotations(e){return makeTransformationClass(this.from,this.to,mergeSchemaAnnotations(this.ast,e))}static from=e;static to=t}}const r_e=dual(e=>isSchema(e[0])&&isSchema(e[1]),(e,t,r)=>makeTransformationClass(e,t,new jO(e.ast,t.ast,new FinalTransformation(r.decode,r.encode)))),n_e=dual(e=>isSchema(e[0])&&isSchema(e[1]),(e,t,r)=>r_e(e,t,{strict:!0,decode:(e,t,n,i)=>ume(r.decode(e,i)),encode:(e,t,n,i)=>ume(r.encode(e,i))}));function transformLiteral(e,t){return n_e(Literal(e),Literal(t),{strict:!0,decode:()=>t,encode:()=>e})}const i_e=dual(e=>isSchema(e[0]),(e,t,r,n)=>{const i=Yve(typeSchema(e),Struct({[t]:isSymbol$1(r)?UniqueSymbolFromSelf(r):Literal(r)})).ast;return make$B(new jO(e.ast,n?mergeSchemaAnnotations(i,n):i,new TypeLiteralTransformation([new $O(t,t,()=>Ut(r),()=>none$c())])))}),s_e=dual(2,(e,t)=>e.annotations(t)),o_e=dual(2,(e,t)=>make$B(rename$1(e.ast,t))),a_e=Symbol.for("effect/SchemaId/Trimmed"),trimmed=e=>t=>t.pipe(filter$3(e=>e===e.trim(),{schemaId:a_e,title:"trimmed",description:"a string with no leading or trailing whitespace",jsonSchema:{pattern:"^\\S[\\s\\S]*\\S$|^\\S$|^$"},...e})),u_e=MI,c_e=CI,minLength=(e,t)=>r=>r.pipe(filter$3(t=>t.length>=e,{schemaId:c_e,title:`minLength(${e})`,description:`a string at least ${e} character(s) long`,jsonSchema:{minLength:e},...t})),l_e=FI,length=(e,t)=>r=>{const n=isObject(e)?Math.max(0,Math.floor(e.min)):Math.max(0,Math.floor(e)),i=isObject(e)?Math.max(n,Math.floor(e.max)):n;return n!==i?r.pipe(filter$3(e=>e.length>=n&&e.length<=i,{schemaId:l_e,title:`length({ min: ${n}, max: ${i})`,description:`a string at least ${n} character(s) and at most ${i} character(s) long`,jsonSchema:{minLength:n,maxLength:i},...t})):r.pipe(filter$3(e=>e.length===n,{schemaId:l_e,title:`length(${n})`,description:1===n?"a single character":`a string ${n} character(s) long`,jsonSchema:{minLength:n,maxLength:n},...t}))},p_e=Symbol.for("effect/SchemaId/Pattern"),pattern=(e,t)=>r=>{const n=e.source;return r.pipe(filter$3(t=>(e.lastIndex=0,e.test(t)),{schemaId:p_e,[p_e]:{regex:e},description:"a string matching the pattern "+n,jsonSchema:{pattern:n},...t}))},f_e=Symbol.for("effect/SchemaId/StartsWith"),h_e=Symbol.for("effect/SchemaId/EndsWith"),d_e=Symbol.for("effect/SchemaId/Includes"),m_e=Symbol.for("effect/SchemaId/Lowercased"),lowercased=e=>t=>t.pipe(filter$3(e=>e===e.toLowerCase(),{schemaId:m_e,title:"lowercased",description:"a lowercase string",jsonSchema:{pattern:"^[^A-Z]*$"},...e}));class Lowercased extends(String$.pipe(lowercased({identifier:"Lowercased"}))){}const g_e=Symbol.for("effect/SchemaId/Uppercased"),uppercased=e=>t=>t.pipe(filter$3(e=>e===e.toUpperCase(),{schemaId:g_e,title:"uppercased",description:"an uppercase string",jsonSchema:{pattern:"^[^a-z]*$"},...e}));class Uppercased extends(String$.pipe(uppercased({identifier:"Uppercased"}))){}const y_e=Symbol.for("effect/SchemaId/Capitalized"),capitalized=e=>t=>t.pipe(filter$3(e=>e[0]?.toUpperCase()===e[0],{schemaId:y_e,title:"capitalized",description:"a capitalized string",jsonSchema:{pattern:"^[^a-z]?.*$"},...e}));class Capitalized extends(String$.pipe(capitalized({identifier:"Capitalized"}))){}const b_e=Symbol.for("effect/SchemaId/Uncapitalized"),uncapitalized=e=>t=>t.pipe(filter$3(e=>e[0]?.toLowerCase()===e[0],{schemaId:b_e,title:"uncapitalized",description:"a uncapitalized string",jsonSchema:{pattern:"^[^A-Z]?.*$"},...e}));class Uncapitalized extends(String$.pipe(uncapitalized({identifier:"Uncapitalized"}))){}const nonEmptyString=e=>minLength(1,{title:"nonEmptyString",description:"a non empty string",...e});class Trimmed extends(String$.pipe(trimmed({identifier:"Trimmed"}))){}class NonEmptyTrimmedString extends(Trimmed.pipe(nonEmptyString({identifier:"NonEmptyTrimmedString"}))){}const getErrorMessage=e=>e instanceof Error?e.message:e+"",parseJson=(e,t)=>{return isSchema(e)?Xve(parseJson(t),e):(r=e,r_e(String$.annotations({description:"a string to be decoded into JSON"}),Unknown,{strict:!0,decode:(e,t,n)=>lme({try:()=>JSON.parse(e,r?.reviver),catch:t=>new Type(n,e,getErrorMessage(t))}),encode:(e,t,n)=>lme({try:()=>JSON.stringify(e,r?.replacer,r?.space),catch:t=>new Type(n,e,getErrorMessage(t))})}).annotations({title:"parseJson",schemaId:VT}));var r},S_e=Symbol.for("effect/SchemaId/UUID"),v_e=/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i,__e=Symbol.for("effect/SchemaId/ULID"),w_e=/^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i;class URLFromSelf extends(instanceOf(URL,{identifier:"URLFromSelf",arbitrary:()=>e=>e.webUrl().map(e=>new URL(e)),pretty:()=>e=>e.toString()})){}const k_e=wI,finite=e=>t=>t.pipe(filter$3(Number.isFinite,{schemaId:k_e,title:"finite",description:"a finite number",jsonSchema:{},...e})),x_e=gI,greaterThan=(e,t)=>r=>r.pipe(filter$3(t=>t>e,{schemaId:x_e,title:`greaterThan(${e})`,description:0===e?"a positive number":"a number greater than "+e,jsonSchema:{exclusiveMinimum:e},...t})),I_e=yI,greaterThanOrEqualTo=(e,t)=>r=>r.pipe(filter$3(t=>t>=e,{schemaId:I_e,title:`greaterThanOrEqualTo(${e})`,description:0===e?"a non-negative number":"a number greater than or equal to "+e,jsonSchema:{minimum:e},...t})),T_e=Symbol.for("effect/SchemaId/MultipleOf"),O_e=vI,int=e=>t=>t.pipe(filter$3(e=>Number.isSafeInteger(e),{schemaId:O_e,title:"int",description:"an integer",jsonSchema:{type:"integer"},...e})),E_e=bI,lessThan=(e,t)=>r=>r.pipe(filter$3(t=>t<e,{schemaId:E_e,title:`lessThan(${e})`,description:0===e?"a negative number":"a number less than "+e,jsonSchema:{exclusiveMaximum:e},...t})),A_e=SI,lessThanOrEqualTo=(e,t)=>r=>r.pipe(filter$3(t=>t<=e,{schemaId:A_e,title:`lessThanOrEqualTo(${e})`,description:0===e?"a non-positive number":"a number less than or equal to "+e,jsonSchema:{maximum:e},...t})),C_e=xI,between=(e,t,r)=>n=>n.pipe(filter$3(r=>r>=e&&r<=t,{schemaId:C_e,title:`between(${e}, ${t})`,description:`a number between ${e} and ${t}`,jsonSchema:{minimum:e,maximum:t},...r})),M_e=_I,nonNaN=e=>t=>t.pipe(filter$3(e=>!Number.isNaN(e),{schemaId:M_e,title:"nonNaN",description:"a number excluding NaN",...e})),positive=e=>greaterThan(0,{title:"positive",...e}),negative=e=>lessThan(0,{title:"negative",...e}),nonPositive=e=>lessThanOrEqualTo(0,{title:"nonPositive",...e}),nonNegative=e=>greaterThanOrEqualTo(0,{title:"nonNegative",...e});function parseNumber(e){return r_e(e,Number$,{strict:!1,decode:(e,t,r)=>pme(parse$1(e),()=>new Type(r,e,`Unable to decode ${JSON.stringify(e)} into a number`)),encode:e=>ume(e+"")})}class NumberFromString extends(parseNumber(String$.annotations({description:"a string to be decoded into a number"})).annotations({identifier:"NumberFromString"})){}class Int extends(Number$.pipe(int({identifier:"Int"}))){}class NonNegative extends(Number$.pipe(nonNegative({identifier:"NonNegative"}))){}const F_e=kI,encodeSymbol=(e,t)=>{const r=Symbol.keyFor(e);return void 0===r?cme(new Type(t,e,`Unable to encode a unique symbol ${e+""} into a string`)):ume(r)},decodeSymbol=e=>ume(Symbol.for(e)),P_e=II,greaterThanBigInt=(e,t)=>r=>r.pipe(filter$3(t=>t>e,{schemaId:P_e,[P_e]:{min:e},title:`greaterThanBigInt(${e})`,description:0n===e?"a positive bigint":`a bigint greater than ${e}n`,...t})),N_e=TI,greaterThanOrEqualToBigInt=(e,t)=>r=>r.pipe(filter$3(t=>t>=e,{schemaId:N_e,[N_e]:{min:e},title:`greaterThanOrEqualToBigInt(${e})`,description:0n===e?"a non-negative bigint":`a bigint greater than or equal to ${e}n`,...t})),j_e=OI,lessThanBigInt=(e,t)=>r=>r.pipe(filter$3(t=>t<e,{schemaId:j_e,[j_e]:{max:e},title:`lessThanBigInt(${e})`,description:0n===e?"a negative bigint":`a bigint less than ${e}n`,...t})),R_e=EI,lessThanOrEqualToBigInt=(e,t)=>r=>r.pipe(filter$3(t=>t<=e,{schemaId:R_e,[R_e]:{max:e},title:`lessThanOrEqualToBigInt(${e})`,description:0n===e?"a non-positive bigint":`a bigint less than or equal to ${e}n`,...t})),D_e=AI,betweenBigInt=(e,t,r)=>n=>n.pipe(filter$3(r=>r>=e&&r<=t,{schemaId:D_e,[D_e]:{min:e,max:t},title:`betweenBigInt(${e}, ${t})`,description:`a bigint between ${e}n and ${t}n`,...r})),positiveBigInt=e=>greaterThanBigInt(0n,{title:"positiveBigInt",...e}),negativeBigInt=e=>lessThanBigInt(0n,{title:"negativeBigInt",...e}),nonNegativeBigInt=e=>greaterThanOrEqualToBigInt(0n,{title:"nonNegativeBigInt",...e}),nonPositiveBigInt=e=>lessThanOrEqualToBigInt(0n,{title:"nonPositiveBigInt",...e});class BigInt$ extends(r_e(String$.annotations({description:"a string to be decoded into a bigint"}),BigIntFromSelf,{strict:!0,decode:(e,t,r)=>pme(fromString$2(e),()=>new Type(r,e,`Unable to decode ${JSON.stringify(e)} into a bigint`)),encode:e=>ume(e+"")}).annotations({identifier:"BigInt"})){}const L_e=BigIntFromSelf.pipe(positiveBigInt({identifier:"PositiveBigintFromSelf"})),U_e=BigInt$.pipe(positiveBigInt({identifier:"PositiveBigint"})),$_e=BigIntFromSelf.pipe(negativeBigInt({identifier:"NegativeBigintFromSelf"})),B_e=BigInt$.pipe(negativeBigInt({identifier:"NegativeBigint"})),z_e=BigIntFromSelf.pipe(nonPositiveBigInt({identifier:"NonPositiveBigintFromSelf"})),q_e=BigInt$.pipe(nonPositiveBigInt({identifier:"NonPositiveBigint"})),W_e=BigIntFromSelf.pipe(nonNegativeBigInt({identifier:"NonNegativeBigintFromSelf"})),V_e=BigInt$.pipe(nonNegativeBigInt({identifier:"NonNegativeBigint"})),redactedArbitrary=e=>t=>e(t).map(lbe),toComposite=(e,t,r,n)=>gme(e,{onFailure:e=>new Composite(r,n,e),onSuccess:t}),redactedParse=e=>(t,r,n)=>cbe(t)?toComposite(e(value$1(t),r),lbe,n,t):cme(new Type(n,t)),RedactedFromSelf=e=>declare([e],{decode:e=>redactedParse(decodeUnknown$1(e)),encode:e=>redactedParse(encodeUnknown$1(e))},{description:"Redacted(<redacted>)",pretty:()=>()=>"Redacted(<redacted>)",arbitrary:redactedArbitrary,equivalence:getEquivalence$1});class DurationFromSelf extends(declare(isDuration,{identifier:"DurationFromSelf",pretty:()=>String,arbitrary:()=>e=>e.oneof(e.constant(sM),e.bigInt({min:0n}).map(e=>nanos(e)),e.maxSafeNat().map(e=>millis(e))),equivalence:()=>Equivalence$5})){}const K_e=NonNegative.pipe(int()).annotations({identifier:"NonNegativeInt"}),G_e=TaggedStruct("Millis",{millis:K_e}),J_e=TaggedStruct("Nanos",{nanos:BigInt$}),H_e=TaggedStruct("Infinity",{}),Z_e=H_e.make({}),Q_e=Union(G_e,J_e,H_e).annotations({identifier:"DurationValue",description:"an JSON-compatible tagged union to be decoded into a Duration"}),Y_e=Union(Tuple(element(K_e).annotations({title:"seconds"}),element(K_e).annotations({title:"nanos"})).annotations({identifier:"FiniteHRTime"}),Tuple(Literal(-1),Literal(0)).annotations({identifier:"InfiniteHRTime"})).annotations({identifier:"HRTime",description:"a tuple of seconds and nanos to be decoded into a Duration"}),X_e=Symbol.for("effect/SchemaId/LessThanDuration"),ewe=Symbol.for("effect/schema/LessThanOrEqualToDuration"),twe=Symbol.for("effect/SchemaId/GreaterThanDuration"),rwe=Symbol.for("effect/schema/GreaterThanOrEqualToDuration"),nwe=Symbol.for("effect/SchemaId/BetweenDuration"),betweenDuration=(e,t,r)=>n=>n.pipe(filter$3(r=>cM(r,{minimum:e,maximum:t}),{schemaId:nwe,[nwe]:{maximum:t,minimum:e},title:`betweenDuration(${e}, ${t})`,description:`a Duration between ${decode$5(e)} and ${decode$5(t)}`,...r}));class Uint8ArrayFromSelf extends(declare(isUint8Array,{identifier:"Uint8ArrayFromSelf",pretty:()=>e=>`new Uint8Array(${JSON.stringify(Array.from(e))})`,arbitrary:()=>e=>e.uint8Array(),equivalence:()=>Ts(equals$4)})){}class Uint8 extends(Number$.pipe(between(0,255,{identifier:"Uint8",description:"a 8-bit unsigned integer"}))){}const makeUint8ArrayTransformation=(e,t,r)=>r_e(String$.annotations({description:"a string to be decoded into a Uint8Array"}),Uint8ArrayFromSelf,{strict:!0,decode:(e,r,n)=>it(t(e),t=>new Type(n,e,t.message)),encode:e=>ume(r(e))}).annotations({identifier:e}),iwe=makeUint8ArrayTransformation("Uint8ArrayFromBase64",decodeBase64,encodeBase64),swe=makeUint8ArrayTransformation("Uint8ArrayFromBase64Url",decodeBase64Url,encodeBase64Url),owe=makeUint8ArrayTransformation("Uint8ArrayFromHex",decodeHex,encodeHex),makeEncodingTransformation=(e,t,r)=>r_e(String$.annotations({description:`A string that is interpreted as being ${e}-encoded and will be decoded into a UTF-8 string`}),String$,{strict:!0,decode:(e,r,n)=>it(t(e),t=>new Type(n,e,t.message)),encode:e=>ume(r(e))}).annotations({identifier:"StringFrom"+e}),awe=makeEncodingTransformation("Base64",decodeBase64String,encodeBase64),uwe=makeEncodingTransformation("Base64Url",decodeBase64UrlString,encodeBase64Url),cwe=makeEncodingTransformation("Hex",decodeHexString,encodeHex),lwe=r_e(String$.annotations({description:"A string that is interpreted as being UriComponent-encoded and will be decoded into a UTF-8 string"}),String$,{strict:!0,decode:(e,t,r)=>it(decodeUriComponent(e),t=>new Type(r,e,t.message)),encode:(e,t,r)=>it(encodeUriComponent(e),t=>new Type(r,e,t.message))}).annotations({identifier:"StringFromUriComponent"}),pwe=PI,fwe=NI,hwe=jI,getNumberIndexedAccess=e=>make$B(getNumberIndexedAccess$1(e.ast)),dwe=dual(e=>isSchema(e[0]),(e,t)=>r_e(e,getNumberIndexedAccess(typeSchema(e)),{strict:!0,decode:(e,r,n)=>e.length>0?ume(e[0]):t?ume(t()):cme(new Type(n,e,"Unable to retrieve the first element of an empty array")),encode:e=>ume(of$6(e))})),mwe=Symbol.for("effect/SchemaId/ValidDate"),validDate=e=>t=>t.pipe(filter$3(e=>!Number.isNaN(e.getTime()),{schemaId:mwe,[mwe]:{noInvalidDate:!0},title:"validDate",description:"a valid Date",...e})),gwe=Symbol.for("effect/SchemaId/LessThanDate"),ywe=Symbol.for("effect/schema/LessThanOrEqualToDate"),bwe=Symbol.for("effect/SchemaId/GreaterThanDate"),Swe=Symbol.for("effect/schema/GreaterThanOrEqualToDate"),vwe=Symbol.for("effect/SchemaId/BetweenDate"),_we=mI;class DateFromSelf extends(declare(isDate,{identifier:"DateFromSelf",schemaId:_we,[_we]:{noInvalidDate:!1},description:"a potentially invalid Date instance",pretty:()=>e=>`new Date(${JSON.stringify(e)})`,arbitrary:()=>e=>e.date({noInvalidDate:!1}),equivalence:()=>v})){}class DateFromString extends(n_e(String$.annotations({description:"a string to be decoded into a Date"}),DateFromSelf,{strict:!0,decode:e=>new Date(e),encode:e=>formatDate(e)}).annotations({identifier:"DateFromString"})){}class DateTimeUtcFromSelf extends(declare(e=>Zfe(e)&&isUtc(e),{identifier:"DateTimeUtcFromSelf",description:"a DateTime.Utc instance",pretty:()=>e=>e.toString(),arbitrary:()=>e=>e.date({noInvalidDate:!0}).map(e=>nhe(e)),equivalence:()=>ehe})){}const decodeDateTimeUtc=(e,t)=>lme({try:()=>ihe(e),catch:()=>new Type(t,e,`Unable to decode ${formatUnknown$1(e)} into a DateTime.Utc`)}),timeZoneOffsetArbitrary=()=>e=>e.integer({min:-432e5,max:504e5}).map(dhe);class TimeZoneOffsetFromSelf extends(declare(isTimeZoneOffset,{identifier:"TimeZoneOffsetFromSelf",description:"a TimeZone.Offset instance",pretty:()=>e=>e.toString(),arbitrary:timeZoneOffsetArbitrary})){}const timeZoneNamedArbitrary=()=>e=>e.constantFrom(...Intl.supportedValuesOf("timeZone")).map(hhe);class TimeZoneNamedFromSelf extends(declare(Yfe,{identifier:"TimeZoneNamedFromSelf",description:"a TimeZone.Named instance",pretty:()=>e=>e.toString(),arbitrary:timeZoneNamedArbitrary})){}class TimeZoneFromSelf extends(Union(TimeZoneOffsetFromSelf,TimeZoneNamedFromSelf)){}class DateTimeZonedFromSelf extends(declare(e=>Zfe(e)&&Xfe(e),{identifier:"DateTimeZonedFromSelf",description:"a DateTime.Zoned instance",pretty:()=>e=>e.toString(),arbitrary:()=>e=>e.tuple(e.integer({min:-31536e9,max:31536e9}),(e=>e.oneof(timeZoneOffsetArbitrary()(e),timeZoneNamedArbitrary()(e)))(e)).map(([e,t])=>she(e,{timeZone:t})),equivalence:()=>ehe})){}const wwe=Struct({_tag:Literal("None")}).annotations({description:"NoneEncoded"}),optionDecode=e=>"None"===e._tag?none$c():Ut(e.value),optionArbitrary=(e,t)=>r=>r.oneof(t,r.record({_tag:r.constant("None")}),r.record({_tag:r.constant("Some"),value:e(r)})).map(optionDecode),optionPretty=e=>qt({onNone:()=>"none()",onSome:t=>`some(${e(t)})`}),optionParse=e=>(t,r,n)=>$t(t)?Bt(t)?ume(none$c()):toComposite(e(t.value,r),Ut,n,t):cme(new Type(n,t)),OptionFromSelf_=e=>declare([e],{decode:e=>optionParse(decodeUnknown$1(e)),encode:e=>optionParse(encodeUnknown$1(e))},{pretty:optionPretty,arbitrary:optionArbitrary,equivalence:getEquivalence$8}),OptionFromSelf=e=>OptionFromSelf_(e).annotations({description:`Option<${format(e)}>`}),kwe={_tag:"None"},makeSomeEncoded=e=>({_tag:"Some",value:e}),rightEncoded=e=>Struct({_tag:Literal("Right"),right:e}).annotations({description:`RightEncoded<${format(e)}>`}),leftEncoded=e=>Struct({_tag:Literal("Left"),left:e}).annotations({description:`LeftEncoded<${format(e)}>`}),eitherDecode=e=>"Left"===e._tag?He(e.left):Ge(e.right),eitherArbitrary=(e,t)=>r=>r.oneof(r.record({_tag:r.constant("Left"),left:t(r)}),r.record({_tag:r.constant("Right"),right:e(r)})).map(eitherDecode),eitherPretty=(e,t)=>ot({onLeft:e=>`left(${t(e)})`,onRight:t=>`right(${e(t)})`}),eitherParse=(e,t)=>(r,n,i)=>Ye(r)?ot(r,{onLeft:e=>toComposite(t(e,n),He,i,r),onRight:t=>toComposite(e(t,n),Ge,i,r)}):cme(new Type(i,r)),EitherFromSelf=({left:e,right:t})=>declare([t,e],{decode:(e,t)=>eitherParse(decodeUnknown$1(e),decodeUnknown$1(t)),encode:(e,t)=>eitherParse(encodeUnknown$1(e),encodeUnknown$1(t))},{description:`Either<${format(t)}, ${format(e)}>`,pretty:eitherPretty,arbitrary:eitherArbitrary,equivalence:(e,t)=>getEquivalence$9({left:t,right:e})}),makeLeftEncoded=e=>({_tag:"Left",left:e}),makeRightEncoded=e=>({_tag:"Right",right:e}),mapArbitrary=(e,t,r)=>n=>{const i=n.array(n.tuple(e(n),t(n)));return(void 0!==r.depthIdentifier?n.oneof(r,n.constant([]),i):i).map(e=>new Map(e))},readonlyMapPretty=(e,t)=>r=>`new Map([${Array.from(r.entries()).map(([r,n])=>`[${e(r)}, ${t(n)}]`).join(", ")}])`,readonlyMapEquivalence=(e,t)=>{const r=Ts(make$2l(([r,n],[i,s])=>e(r,i)&&t(n,s)));return make$2l((e,t)=>r(Array.from(e.entries()),Array.from(t.entries())))},readonlyMapParse=e=>(t,r,n)=>isMap(t)?toComposite(e(Array.from(t.entries()),r),e=>new Map(e),n,t):cme(new Type(n,t)),mapFromSelf_=(e,t,description)=>declare([e,t],{decode:(e,t)=>readonlyMapParse(decodeUnknown$1(Array$(Tuple(e,t)))),encode:(e,t)=>readonlyMapParse(encodeUnknown$1(Array$(Tuple(e,t))))},{description,pretty:readonlyMapPretty,arbitrary:mapArbitrary,equivalence:readonlyMapEquivalence}),ReadonlyMapFromSelf=({key:e,value:t})=>mapFromSelf_(e,t,`ReadonlyMap<${format(e)}, ${format(t)}>`),MapFromSelf=({key:e,value:t})=>mapFromSelf_(e,t,`Map<${format(e)}, ${format(t)}>`),setArbitrary=(e,t)=>r=>{const n=r.array(e(r));return(void 0!==t.depthIdentifier?r.oneof(t,r.constant([]),n):n).map(e=>new Set(e))},readonlySetPretty=e=>t=>`new Set([${Array.from(t.values()).map(t=>e(t)).join(", ")}])`,readonlySetEquivalence=e=>{const t=Ts(e);return make$2l((e,r)=>t(Array.from(e.values()),Array.from(r.values())))},readonlySetParse=e=>(t,r,n)=>isSet(t)?toComposite(e(Array.from(t.values()),r),e=>new Set(e),n,t):cme(new Type(n,t)),setFromSelf_=(e,description)=>declare([e],{decode:e=>readonlySetParse(decodeUnknown$1(Array$(e))),encode:e=>readonlySetParse(encodeUnknown$1(Array$(e)))},{description,pretty:readonlySetPretty,arbitrary:setArbitrary,equivalence:readonlySetEquivalence}),ReadonlySetFromSelf=e=>setFromSelf_(e,`ReadonlySet<${format(e)}>`),SetFromSelf=e=>setFromSelf_(e,`Set<${format(e)}>`),bigDecimalPretty=()=>e=>`BigDecimal(${format$5(normalize$1(e))})`,bigDecimalArbitrary=()=>e=>e.tuple(e.bigInt(),e.integer({min:0,max:18})).map(([e,t])=>make$2g(e,t));class BigDecimalFromSelf extends(declare(isBigDecimal,{identifier:"BigDecimalFromSelf",pretty:bigDecimalPretty,arbitrary:bigDecimalArbitrary,equivalence:()=>TE})){}const xwe=Symbol.for("effect/SchemaId/GreaterThanBigDecimal"),Iwe=Symbol.for("effect/schema/GreaterThanOrEqualToBigDecimal"),Twe=Symbol.for("effect/SchemaId/LessThanBigDecimal"),Owe=Symbol.for("effect/schema/LessThanOrEqualToBigDecimal"),Ewe=Symbol.for("effect/schema/PositiveBigDecimal"),positiveBigDecimal=e=>t=>t.pipe(filter$3(e=>isPositive(e),{schemaId:Ewe,title:"positiveBigDecimal",description:"a positive BigDecimal",...e})),Awe=BigDecimalFromSelf.pipe(positiveBigDecimal({identifier:"PositiveBigDecimalFromSelf"})),Cwe=Symbol.for("effect/schema/NonNegativeBigDecimal"),nonNegativeBigDecimal=e=>t=>t.pipe(filter$3(e=>e.value>=0n,{schemaId:Cwe,title:"nonNegativeBigDecimal",description:"a non-negative BigDecimal",...e})),Mwe=BigDecimalFromSelf.pipe(nonNegativeBigDecimal({identifier:"NonNegativeBigDecimalFromSelf"})),Fwe=Symbol.for("effect/schema/NegativeBigDecimal"),negativeBigDecimal=e=>t=>t.pipe(filter$3(e=>isNegative(e),{schemaId:Fwe,title:"negativeBigDecimal",description:"a negative BigDecimal",...e})),Pwe=BigDecimalFromSelf.pipe(negativeBigDecimal({identifier:"NegativeBigDecimalFromSelf"})),Nwe=Symbol.for("effect/schema/NonPositiveBigDecimal"),nonPositiveBigDecimal=e=>t=>t.pipe(filter$3(e=>e.value<=0n,{schemaId:Nwe,title:"nonPositiveBigDecimal",description:"a non-positive BigDecimal",...e})),jwe=BigDecimalFromSelf.pipe(nonPositiveBigDecimal({identifier:"NonPositiveBigDecimalFromSelf"})),Rwe=Symbol.for("effect/SchemaId/BetweenBigDecimal"),betweenBigDecimal=(e,t,r)=>n=>{const i=format$5(e),s=format$5(t);return n.pipe(filter$3(r=>vE(r,{minimum:e,maximum:t}),{schemaId:Rwe,[Rwe]:{maximum:t,minimum:e},title:`betweenBigDecimal(${i}, ${s})`,description:`a BigDecimal between ${i} and ${s}`,...r}))},chunkArbitrary=(e,t)=>r=>{const n=r.array(e(r));return(void 0!==t.depthIdentifier?r.oneof(t,r.constant([]),n):n).map(fromIterable$u)},chunkPretty=e=>t=>`Chunk(${toReadonlyArray$1(t).map(e).join(", ")})`,chunkParse=e=>(t,r,n)=>isChunk(t)?isEmpty$t(t)?ume(empty$R()):toComposite(e(toReadonlyArray$1(t),r),fromIterable$u,n,t):cme(new Type(n,t)),ChunkFromSelf=e=>declare([e],{decode:e=>chunkParse(decodeUnknown$1(Array$(e))),encode:e=>chunkParse(encodeUnknown$1(Array$(e)))},{description:`Chunk<${format(e)}>`,pretty:chunkPretty,arbitrary:chunkArbitrary,equivalence:getEquivalence$4}),nonEmptyChunkArbitrary=e=>t=>Rs.array(e(t),{minLength:1}).map(e=>unsafeFromNonEmptyArray(e)),nonEmptyChunkPretty=e=>t=>`NonEmptyChunk(${toReadonlyArray$1(t).map(e).join(", ")})`,nonEmptyChunkParse=e=>(t,r,n)=>isChunk(t)&&isNonEmpty$8(t)?toComposite(e(toReadonlyArray$1(t),r),unsafeFromNonEmptyArray,n,t):cme(new Type(n,t)),NonEmptyChunkFromSelf=e=>declare([e],{decode:e=>nonEmptyChunkParse(decodeUnknown$1(NonEmptyArray(e))),encode:e=>nonEmptyChunkParse(encodeUnknown$1(NonEmptyArray(e)))},{description:`NonEmptyChunk<${format(e)}>`,pretty:nonEmptyChunkPretty,arbitrary:nonEmptyChunkArbitrary,equivalence:getEquivalence$4}),decodeData=e=>Array.isArray(e)?array$2(e):K0(e),dataArbitrary=e=>t=>e(t).map(decodeData),dataPretty=e=>t=>`Data(${e(t)})`,dataParse=e=>(t,r,n)=>isEqual(t)?toComposite(e(t,r),decodeData,n,t):cme(new Type(n,t)),DataFromSelf=e=>declare([e],{decode:e=>dataParse(decodeUnknown$1(e)),encode:e=>dataParse(encodeUnknown$1(e))},{description:`Data<${format(e)}>`,pretty:dataPretty,arbitrary:dataArbitrary}),isFields=e=>Reflect.ownKeys(e).every(t=>{return r=e[t],isSchema(r)||isPropertySignature(r);var r}),getFields=e=>"fields"in e?e.fields:getFields(e[e_e]),getSchemaFromFieldsOr=e=>isFields(e)?Struct(e):isSchema(e)?e:Struct(getFields(e)),getFieldsFromFieldsOr=e=>isFields(e)?e:getFields(e),getClassTag=e=>qve(propertySignature(Literal(e)),()=>e),extendFields=(e,t)=>{const r={...e};for(const n of Reflect.ownKeys(t)){if(n in e)throw Error(getASTDuplicatePropertySignatureErrorMessage(n));r[n]=t[n]}return r};function getDisableValidationMakeOption(e){return isBoolean$1(e)?e:e?.disableValidation??!1}const Dwe=globalValue("effect/Schema/astCache",()=>new WeakMap),makeClass=({Base:e,annotations:t,disableToString:r,fields:n,identifier:i,kind:s,schema:o})=>{const a=Symbol.for(`effect/Schema/${s}/${i}`),[u,c,l]=(e=>void 0===e?[]:Array.isArray(e)?e:[e])(t),p=typeSchema(o),d=p.annotations({identifier:i,...u}),m=p.annotations({[aT]:i+" (Type side)",...u}),g=o.annotations({[aT]:i+" (Constructor)",...u}),y=o.annotations({[aT]:i+" (Encoded side)",...l}),b=o.annotations({...l,...u,...c}),S=class extends e{constructor(e={},t=!1){e={...e},"Class"!==s&&delete e._tag,e=lazilyMergeDefaults(n,e),getDisableValidationMakeOption(t)||(e=validateSync(g)(e)),super(e,!0)}static[Mve]=Fve;static get ast(){let e=Dwe.get(this);if(e)return e;const t=declare([o],{decode:()=>(e,t,r)=>{return e instanceof this||C(n=e,a)&&is$2(m)(n)?ume(e):cme(new Type(r,e));var n},encode:()=>(e,t)=>e instanceof this?ume(e):dme(encodeUnknown$1(m)(e,t),e=>new this(e,!0))},{identifier:i,pretty:e=>t=>`${i}(${e(t)})`,arbitrary:e=>t=>e(t).map(e=>new this(e)),equivalence:identity$5,[_T]:d.ast,...u});return e=n_e(y,t,{strict:!0,decode:e=>new this(e,!0),encode:identity$5}).annotations({[_T]:b.ast,...c}).ast,Dwe.set(this,e),e}static pipe(){return pipeArguments(this,arguments)}static annotations(e){return make$B(this.ast).annotations(e)}static toString(){return`(${y+""} <-> ${i})`}static make(...e){return new this(...e)}static fields={...n};static identifier=i;static extend(e){return(t,r)=>{const i=getFieldsFromFieldsOr(t),a=getSchemaFromFieldsOr(t),u=extendFields(n,i);return makeClass({kind:s,identifier:e,schema:Yve(o,a),fields:u,Base:this,annotations:r})}}static transformOrFail(e){return(t,r,i)=>{const a=extendFields(n,t);return makeClass({kind:s,identifier:e,schema:r_e(o,typeSchema(Struct(a)),r),fields:a,Base:this,annotations:i})}}static transformOrFailFrom(e){return(t,r,i)=>{const a=extendFields(n,t);return makeClass({kind:s,identifier:e,schema:r_e(encodedSchema(o),Struct(a),r),fields:a,Base:this,annotations:i})}}get[a](){return a}};return!0!==r&&Object.defineProperty(S.prototype,"toString",{value(){return`${i}({ ${Reflect.ownKeys(n).map(e=>`${formatPropertyKey$1(e)}: ${formatUnknown$1(this[e])}`).join(", ")} })`},configurable:!0,writable:!0}),S},Lwe=Union(Struct({_tag:Literal("None")}).annotations({identifier:"FiberIdNoneEncoded"}),Struct({_tag:Literal("Runtime"),id:Int,startTimeMillis:Int}).annotations({identifier:"FiberIdRuntimeEncoded"}),Struct({_tag:Literal("Composite"),left:suspend$2(()=>Lwe),right:suspend$2(()=>Lwe)}).annotations({identifier:"FiberIdCompositeEncoded"})).annotations({identifier:"FiberIdEncoded"}),fiberIdArbitrary=e=>e.letrec(t=>({None:e.record({_tag:e.constant("None")}),Runtime:e.record({_tag:e.constant("Runtime"),id:e.integer(),startTimeMillis:e.integer()}),Composite:e.record({_tag:e.constant("Composite"),left:t("FiberId"),right:t("FiberId")}),FiberId:e.oneof(t("None"),t("Runtime"),t("Composite"))})).FiberId.map(fiberIdDecode),fiberIdPretty=e=>{switch(e._tag){case"None":return"FiberId.none";case"Runtime":return`FiberId.runtime(${e.id}, ${e.startTimeMillis})`;case"Composite":return`FiberId.composite(${fiberIdPretty(e.right)}, ${fiberIdPretty(e.left)})`}};class FiberIdFromSelf extends(declare(uP,{identifier:"FiberIdFromSelf",pretty:()=>fiberIdPretty,arbitrary:()=>fiberIdArbitrary})){}const fiberIdDecode=e=>{switch(e._tag){case"None":return aP;case"Runtime":return runtime$5(e.id,e.startTimeMillis);case"Composite":return composite(fiberIdDecode(e.left),fiberIdDecode(e.right))}},fiberIdEncode=e=>{switch(e._tag){case"None":return{_tag:"None"};case"Runtime":return{_tag:"Runtime",id:e.id,startTimeMillis:e.startTimeMillis};case"Composite":return{_tag:"Composite",left:fiberIdEncode(e.left),right:fiberIdEncode(e.right)}}},Uwe=Struct({_tag:Literal("Empty")}),$we=Struct({_tag:Literal("Interrupt"),fiberId:Lwe});let Bwe=0;const causeEncoded=(e,t)=>{const r=e,n=t,i=suspend$2(()=>s),s=Union(Uwe,(e=>Struct({_tag:Literal("Fail"),error:e}))(r),(e=>Struct({_tag:Literal("Die"),defect:e}))(n),$we,Struct({_tag:Literal("Sequential"),left:i,right:i}),Struct({_tag:Literal("Parallel"),left:i,right:i})).annotations({title:`CauseEncoded<${format(e)}>`,[qT]:"CauseEncoded"+Bwe++});return s},causeArbitrary=(e,t)=>r=>r.letrec(n=>({Empty:r.record({_tag:r.constant("Empty")}),Fail:r.record({_tag:r.constant("Fail"),error:e(r)}),Die:r.record({_tag:r.constant("Die"),defect:t(r)}),Interrupt:r.record({_tag:r.constant("Interrupt"),fiberId:fiberIdArbitrary(r)}),Sequential:r.record({_tag:r.constant("Sequential"),left:n("Cause"),right:n("Cause")}),Parallel:r.record({_tag:r.constant("Parallel"),left:n("Cause"),right:n("Cause")}),Cause:r.oneof(n("Empty"),n("Fail"),n("Die"),n("Interrupt"),n("Sequential"),n("Parallel"))})).Cause.map(causeDecode),causePretty=e=>t=>{const f=t=>{switch(t._tag){case"Empty":return"Cause.empty";case"Fail":return`Cause.fail(${e(t.error)})`;case"Die":return`Cause.die(${iY(t)})`;case"Interrupt":return`Cause.interrupt(${fiberIdPretty(t.fiberId)})`;case"Sequential":return`Cause.sequential(${f(t.left)}, ${f(t.right)})`;case"Parallel":return`Cause.parallel(${f(t.left)}, ${f(t.right)})`}};return f(t)},causeParse=e=>(t,r,n)=>GQ(t)?toComposite(e(causeEncode(t),r),causeDecode,n,t):cme(new Type(n,t)),CauseFromSelf=({defect:e,error:t})=>declare([t,e],{decode:(e,t)=>causeParse(decodeUnknown$1(causeEncoded(e,t))),encode:(e,t)=>causeParse(encodeUnknown$1(causeEncoded(e,t)))},{title:`Cause<${t.ast}>`,pretty:causePretty,arbitrary:causeArbitrary});function causeDecode(e){switch(e._tag){case"Empty":return BQ;case"Fail":return zQ(e.error);case"Die":return qQ(e.defect);case"Interrupt":return WQ(fiberIdDecode(e.fiberId));case"Sequential":return KQ(causeDecode(e.left),causeDecode(e.right));case"Parallel":return VQ(causeDecode(e.left),causeDecode(e.right))}}function causeEncode(e){switch(e._tag){case"Empty":return{_tag:"Empty"};case"Fail":return{_tag:"Fail",error:e.error};case"Die":return{_tag:"Die",defect:e.defect};case"Interrupt":return{_tag:"Interrupt",fiberId:e.fiberId};case"Sequential":return{_tag:"Sequential",left:causeEncode(e.left),right:causeEncode(e.right)};case"Parallel":return{_tag:"Parallel",left:causeEncode(e.left),right:causeEncode(e.right)}}}class Defect extends(n_e(Unknown,Unknown,{strict:!0,decode:e=>{if(isObject(e)&&"message"in e&&"string"==typeof e.message){const t=Error(e.message,{cause:e});return"name"in e&&"string"==typeof e.name&&(t.name=e.name),t.stack="stack"in e&&"string"==typeof e.stack?e.stack:"",t}return prettyErrorMessage(e)},encode:e=>e instanceof Error?{name:e.name,message:e.message}:prettyErrorMessage(e)}).annotations({identifier:"Defect"})){}const exitDecode=e=>{switch(e._tag){case"Failure":return OU(causeDecode(e.cause));case"Success":return NU(e.value)}},exitArbitrary=(e,t,r)=>n=>n.oneof(n.record({_tag:n.constant("Failure"),cause:causeArbitrary(t,r)(n)}),n.record({_tag:n.constant("Success"),value:e(n)})).map(exitDecode),exitPretty=(e,t)=>r=>"Failure"===r._tag?`Exit.failCause(${causePretty(t)(r.cause)})`:`Exit.succeed(${e(r.value)})`,exitParse=(e,t)=>(r,n,i)=>_U(r)?FU(r,{onFailure:e=>toComposite(t(e,n),OU,i,r),onSuccess:t=>toComposite(e(t,n),NU,i,r)}):cme(new Type(i,r)),ExitFromSelf=({defect:e,failure:t,success:r})=>declare([r,t,e],{decode:(e,t,r)=>exitParse(decodeUnknown$1(e),decodeUnknown$1(CauseFromSelf({error:t,defect:r}))),encode:(e,t,r)=>exitParse(encodeUnknown$1(e),encodeUnknown$1(CauseFromSelf({error:t,defect:r})))},{title:`Exit<${r.ast}, ${t.ast}>`,pretty:exitPretty,arbitrary:exitArbitrary}),Exit=({defect:e,failure:t,success:r})=>{const n=r,i=t,s=e;return n_e(((e,t,r)=>Union(((e,t)=>Struct({_tag:Literal("Failure"),cause:causeEncoded(e,t)}))(t,r),(e=>Struct({_tag:Literal("Success"),value:e}))(e)).annotations({title:`ExitEncoded<${format(e)}, ${format(t)}, ${format(r)}>`}))(n,i,s),ExitFromSelf({failure:typeSchema(i),success:typeSchema(n),defect:typeSchema(s)}),{strict:!1,decode:e=>exitDecode(e),encode:e=>"Failure"===e._tag?{_tag:"Failure",cause:e.cause}:{_tag:"Success",value:e.value}})},hashSetArbitrary=(e,t)=>r=>{const n=r.array(e(r));return(void 0!==t.depthIdentifier?r.oneof(t,r.constant([]),n):n).map(fromIterable$r)},hashSetPretty=e=>t=>`HashSet(${Array.from(t).map(t=>e(t)).join(", ")})`,hashSetEquivalence=e=>{const t=Ts(e);return make$2l((e,r)=>t(Array.from(e),Array.from(r)))},hashSetParse=e=>(t,r,n)=>xF(t)?toComposite(e(Array.from(t),r),fromIterable$r,n,t):cme(new Type(n,t)),HashSetFromSelf=e=>declare([e],{decode:e=>hashSetParse(decodeUnknown$1(Array$(e))),encode:e=>hashSetParse(encodeUnknown$1(Array$(e)))},{description:`HashSet<${format(e)}>`,pretty:hashSetPretty,arbitrary:hashSetArbitrary,equivalence:hashSetEquivalence}),hashMapArbitrary=(e,t,r)=>n=>{const i=n.array(n.tuple(e(n),t(n)));return(void 0!==r.depthIdentifier?n.oneof(r,n.constant([]),i):i).map(gP)},hashMapPretty=(e,t)=>r=>`HashMap([${Array.from(r).map(([r,n])=>`[${e(r)}, ${t(n)}]`).join(", ")}])`,hashMapEquivalence=(e,t)=>{const r=Ts(make$2l(([r,n],[i,s])=>e(r,i)&&t(n,s)));return make$2l((e,t)=>r(Array.from(e),Array.from(t)))},hashMapParse=e=>(t,r,n)=>dP(t)?toComposite(e(Array.from(t),r),gP,n,t):cme(new Type(n,t)),HashMapFromSelf=({key:e,value:t})=>declare([e,t],{decode:(e,t)=>hashMapParse(decodeUnknown$1(Array$(Tuple(e,t)))),encode:(e,t)=>hashMapParse(encodeUnknown$1(Array$(Tuple(e,t))))},{description:`HashMap<${format(e)}, ${format(t)}>`,pretty:hashMapPretty,arbitrary:hashMapArbitrary,equivalence:hashMapEquivalence}),listArbitrary=(e,t)=>r=>{const n=r.array(e(r));return(void 0!==t.depthIdentifier?r.oneof(t,r.constant([]),n):n).map(fromIterable$p)},listPretty=e=>t=>`List(${Array.from(t).map(t=>e(t)).join(", ")})`,listEquivalence=e=>{const t=Ts(e);return make$2l((e,r)=>t(Array.from(e),Array.from(r)))},listParse=e=>(t,r,n)=>isList(t)?toComposite(e(Array.from(t),r),fromIterable$p,n,t):cme(new Type(n,t)),ListFromSelf=e=>declare([e],{decode:e=>listParse(decodeUnknown$1(Array$(e))),encode:e=>listParse(encodeUnknown$1(Array$(e)))},{description:`List<${format(e)}>`,pretty:listPretty,arbitrary:listArbitrary,equivalence:listEquivalence}),sortedSetPretty=e=>t=>`new SortedSet([${Array.from(values$6(t)).map(t=>e(t)).join(", ")}])`,sortedSetParse=(e,t)=>(r,n,i)=>isSortedSet(r)?toComposite(e(Array.from(values$6(r)),n),e=>eZ(e,t),i,r):cme(new Type(i,r)),SortedSetFromSelf=(e,t,r)=>declare([e],{decode:e=>sortedSetParse(decodeUnknown$1(Array$(e)),t),encode:e=>sortedSetParse(encodeUnknown$1(Array$(e)),r)},{description:`SortedSet<${format(e)}>`,pretty:sortedSetPretty,arbitrary:(e,r)=>((e,t,r)=>n=>{const i=n.array(e(n));return(void 0!==r.depthIdentifier?n.oneof(r,n.constant([]),i):i).map(e=>eZ(e,t))})(e,t,r),equivalence:()=>getEquivalence$2()}),zwe=Symbol.for("effect/Schema/Serializable/symbol"),qwe=dual(2,(e,t)=>decodeUnknown(e[zwe])(t)),Wwe=Symbol.for("effect/Schema/Serializable/symbolResult"),failureSchema=e=>e[Wwe].failure,successSchema=e=>e[Wwe].success,Vwe=globalValue("effect/Schema/Serializable/exitSchemaCache",()=>new WeakMap),exitSchema=e=>{const t=Object.getPrototypeOf(e);if(!(Wwe in t))return Exit({failure:failureSchema(e),success:successSchema(e),defect:Defect});let r=Vwe.get(t);return void 0===r&&(r=Exit({failure:failureSchema(e),success:successSchema(e),defect:Defect}),Vwe.set(t,r)),r},Kwe=dual(2,(e,t)=>Nve(e[Wwe].failure)(t)),Gwe=dual(2,(e,t)=>decodeUnknown(e[Wwe].failure)(t)),Jwe=dual(2,(e,t)=>Nve(e[Wwe].success)(t)),Hwe=dual(2,(e,t)=>decodeUnknown(e[Wwe].success)(t)),Zwe=dual(2,(e,t)=>Nve(exitSchema(e))(t)),Qwe=dual(2,(e,t)=>decodeUnknown(exitSchema(e))(t)),Ywe=kT(dT),go=(e,t)=>{const r=Ywe(e);if(zt(r))switch(e._tag){case"Declaration":return r.value(...e.typeParameters.map(e=>go(e,t)));case"Refinement":return r.value(go(e.from,t));default:return r.value()}switch(e._tag){case"NeverKeyword":throw Error(((e,t)=>getUnsupportedSchemaErrorMessage("Cannot build an Equivalence",t,e))(e,t));case"Transformation":return go(e.to,t);case"Declaration":case"Literal":case"StringKeyword":case"TemplateLiteral":case"UniqueSymbol":case"SymbolKeyword":case"UnknownKeyword":case"AnyKeyword":case"NumberKeyword":case"BooleanKeyword":case"BigIntKeyword":case"UndefinedKeyword":case"VoidKeyword":case"Enums":case"ObjectKeyword":return equals$4;case"Refinement":return go(e.from,t);case"Suspend":{const r=memoizeThunk(()=>go(e.f(),t));return(e,t)=>r()(e,t)}case"TupleType":{const r=e.elements.map((e,r)=>go(e.type,t.concat(r))),n=e.rest.map(e=>go(e.type,t));return make$2l((t,i)=>{if(!Array.isArray(t)||!Array.isArray(i))return!1;const s=t.length;if(s!==i.length)return!1;let o=0;for(;o<Math.min(s,e.elements.length);o++)if(!r[o](t[o],i[o]))return!1;if(ci(n)){const[e,...r]=n;for(;o<s-r.length;o++)if(!e(t[o],i[o]))return!1;for(let e=0;e<r.length;e++)if(o+=e,!r[e](t[o],i[o]))return!1}return!0})}case"TypeLiteral":{if(0===e.propertySignatures.length&&0===e.indexSignatures.length)return equals$4;const r=e.propertySignatures.map(e=>go(e.type,t.concat(e.name))),n=e.indexSignatures.map(e=>go(e.type,t));return make$2l((t,i)=>{if(!isRecord(t)||!isRecord(i))return!1;const s=Object.keys(t),o=Object.getOwnPropertySymbols(t);for(let n=0;n<r.length;n++){const s=e.propertySignatures[n],name=s.name,o=Object.prototype.hasOwnProperty.call(t,name),a=Object.prototype.hasOwnProperty.call(i,name);if(s.isOptional&&o!==a)return!1;if(o&&a&&!r[n](t[name],i[name]))return!1}let a,u;for(let r=0;r<n.length;r++){const c=e.indexSignatures[r],l=getEncodedParameter(c.parameter),p=gO(l);if(p){if(a=a||Object.getOwnPropertySymbols(i),o.length!==a.length)return!1}else if(u=u||Object.keys(i),s.length!==u.length)return!1;const d=p?o:s;for(let e=0;e<d.length;e++){const s=d[e];if(!Object.prototype.hasOwnProperty.call(i,s)||!n[r](t[s],i[s]))return!1}}return!0})}case"Union":{const r=getSearchTree(e.types,!0),n=Reflect.ownKeys(r.keys),i=n.length;return make$2l((e,s)=>{let o=[];if(i>0&&isRecordOrArray(e))for(let t=0;t<i;t++){const name=n[t],i=r.keys[name].buckets;if(Object.prototype.hasOwnProperty.call(e,name)){const t=e[name]+"";Object.prototype.hasOwnProperty.call(i,t)&&(o=o.concat(i[t]))}}r.otherwise.length>0&&(o=o.concat(r.otherwise));const a=o.map(e=>[go(e,t),is$2({ast:e})]);for(let t=0;t<a.length;t++){const[r,n]=a[t];if(n(e)&&n(s)&&r(e,s))return!0}return!1})}}},Xwe=TaggedStruct("symbol",{key:String$}).annotations({description:"an object to be decoded into a globally shared symbol"}),eke=r_e(Xwe,SymbolFromSelf,{strict:!0,decode:e=>decodeSymbol(e.key),encode:(e,t,r)=>dme(encodeSymbol(e,r),e=>Xwe.make({key:e}))});class PropertyKey$ extends(Union(String$,Number$,eke).annotations({identifier:"PropertyKey"})){}var tke=Object.freeze({__proto__:null,Any:class extends(make$B(sO)){},Array:Array$,ArrayEnsure:function(e){return n_e(Union(e,Array$(e)),Array$(typeSchema(e)),{strict:!0,decode:e=>ensure(e),encode:e=>1===e.length?e[0]:e})},ArrayFormatterIssue:class extends(Struct({_tag:propertySignature(Literal("Pointer","Unexpected","Missing","Composite","Refinement","Transformation","Type","Forbidden")).annotations({description:"The tag identifying the type of parse issue"}),path:propertySignature(Array$(PropertyKey$)).annotations({description:"The path to the property where the issue occurred"}),message:propertySignature(String$).annotations({description:"A descriptive message explaining the issue"})}).annotations({identifier:"ArrayFormatterIssue",description:"Represents an issue returned by the ArrayFormatter formatter"})){},BetweenBigDecimalSchemaId:Rwe,BetweenBigIntSchemaId:D_e,BetweenDateSchemaId:vwe,BetweenDurationSchemaId:nwe,BetweenSchemaId:C_e,BigDecimal:class extends(r_e(String$.annotations({description:"a string to be decoded into a BigDecimal"}),BigDecimalFromSelf,{strict:!0,decode:(e,t,r)=>fromString$3(e).pipe(qt({onNone:()=>cme(new Type(r,e,`Unable to decode ${JSON.stringify(e)} into a BigDecimal`)),onSome:e=>ume(normalize$1(e))})),encode:e=>ume(format$5(normalize$1(e)))}).annotations({identifier:"BigDecimal"})){},BigDecimalFromNumber:class extends(n_e(Number$.annotations({description:"a number to be decoded into a BigDecimal"}),BigDecimalFromSelf,{strict:!0,decode:e=>unsafeFromNumber(e),encode:e=>unsafeToNumber(e)}).annotations({identifier:"BigDecimalFromNumber"})){},BigDecimalFromSelf,BigInt:BigInt$,BigIntFromNumber:class extends(r_e(Number$.annotations({description:"a number to be decoded into a bigint"}),BigIntFromSelf.pipe(betweenBigInt(BigInt(Number.MIN_SAFE_INTEGER),BigInt(Number.MAX_SAFE_INTEGER))),{strict:!0,decode:(e,t,r)=>pme(fromNumber(e),()=>new Type(r,e,`Unable to decode ${e} into a bigint`)),encode:(e,t,r)=>pme(toNumber(e),()=>new Type(r,e,`Unable to encode ${e}n into a number`))}).annotations({identifier:"BigIntFromNumber"})){},BigIntFromSelf,Boolean:Boolean$,BooleanFromString:class extends(n_e(Literal("true","false").annotations({description:"a string to be decoded into a boolean"}),Boolean$,{strict:!0,decode:e=>"true"===e,encode:e=>e?"true":"false"}).annotations({identifier:"BooleanFromString"})){},BooleanFromUnknown:class extends(n_e(Unknown,Boolean$,{strict:!0,decode:e=>isTruthy(e),encode:identity$5}).annotations({identifier:"BooleanFromUnknown"})){},BrandSchemaId:$ve,Capitalize:class extends(n_e(String$.annotations({description:"a string that will be converted to a capitalized format"}),Capitalized,{strict:!0,decode:e=>capitalize(e),encode:identity$5}).annotations({identifier:"Capitalize"})){},Capitalized,CapitalizedSchemaId:y_e,Cause:({defect:e,error:t})=>{const r=t,n=e;return n_e(causeEncoded(r,n),CauseFromSelf({error:typeSchema(r),defect:typeSchema(n)}),{strict:!1,decode:e=>causeDecode(e),encode:e=>causeEncode(e)})},CauseFromSelf,Char:class extends(String$.pipe(length(1,{identifier:"Char"}))){},Chunk:function(e){return n_e(Array$(e),ChunkFromSelf(typeSchema(e)),{strict:!0,decode:e=>0===e.length?empty$R():fromIterable$u(e),encode:e=>toReadonlyArray$1(e)})},ChunkFromSelf,Class:e=>(t,r)=>makeClass({kind:"Class",identifier:e,schema:getSchemaFromFieldsOr(t),fields:getFieldsFromFieldsOr(t),Base:G0,annotations:r}),Config:(name,e)=>{const t=decodeUnknownEither$1(e);return qfe(name).pipe(zfe(e=>t(e).pipe(it(e=>vfe([],Cme.formatIssueSync(e))))))},Data:e=>n_e(e,DataFromSelf(typeSchema(e)),{strict:!1,decode:e=>decodeData(e),encode:e=>Array.isArray(e)?Array.from(e):Object.assign({},e)}),DataFromSelf,Date:class extends(DateFromString.pipe(validDate({identifier:"Date"}))){},DateFromNumber:class extends(n_e(Number$.annotations({description:"a number to be decoded into a Date"}),DateFromSelf,{strict:!0,decode:e=>new Date(e),encode:e=>e.getTime()}).annotations({identifier:"DateFromNumber"})){},DateFromSelf,DateFromSelfSchemaId:_we,DateFromString,DateTimeUtc:class extends(r_e(String$.annotations({description:"a string to be decoded into a DateTime.Utc"}),DateTimeUtcFromSelf,{strict:!0,decode:(e,t,r)=>decodeDateTimeUtc(e,r),encode:e=>ume(formatIso(e))}).annotations({identifier:"DateTimeUtc"})){},DateTimeUtcFromDate:class extends(r_e(DateFromSelf.annotations({description:"a Date to be decoded into a DateTime.Utc"}),DateTimeUtcFromSelf,{strict:!0,decode:(e,t,r)=>decodeDateTimeUtc(e,r),encode:e=>ume(Che(e))}).annotations({identifier:"DateTimeUtcFromDate"})){},DateTimeUtcFromNumber:class extends(r_e(Number$.annotations({description:"a number to be decoded into a DateTime.Utc"}),DateTimeUtcFromSelf,{strict:!0,decode:(e,t,r)=>decodeDateTimeUtc(e,r),encode:e=>ume(Nhe(e))}).annotations({identifier:"DateTimeUtcFromNumber"})){},DateTimeUtcFromSelf,DateTimeZoned:class extends(r_e(String$.annotations({description:"a string to be decoded into a DateTime.Zoned"}),DateTimeZonedFromSelf,{strict:!0,decode:(e,t,r)=>qt(makeZonedFromString(e),{onNone:()=>cme(new Type(r,e,`Unable to decode ${JSON.stringify(e)} into a DateTime.Zoned`)),onSome:ume}),encode:e=>ume(tde(e))}).annotations({identifier:"DateTimeZoned"})){},DateTimeZonedFromSelf,Defect,Duration:class extends(n_e(Union(Q_e,Y_e),DurationFromSelf,{strict:!0,decode:e=>{if("object"==typeof e)switch(e._tag){case"Millis":return millis(e.millis);case"Nanos":return nanos(e.nanos);case"Infinity":return sM}const[t,r]=e;return-1===t?sM:nanos(BigInt(t)*BigInt(1e9)+BigInt(r))},encode:e=>{switch(e.value._tag){case"Millis":return G_e.make({millis:e.value.millis});case"Nanos":return J_e.make({nanos:e.value.nanos});case"Infinity":return Z_e}}}).annotations({identifier:"Duration"})){},DurationFromMillis:class extends(n_e(NonNegative.annotations({description:"a non-negative number to be decoded into a Duration"}),DurationFromSelf,{strict:!0,decode:e=>millis(e),encode:e=>toMillis(e)}).annotations({identifier:"DurationFromMillis"})){},DurationFromNanos:class extends(r_e(W_e.annotations({description:"a bigint to be decoded into a Duration"}),DurationFromSelf.pipe(filter$3(e=>isFinite(e),{description:"a finite duration"})),{strict:!0,decode:e=>ume(nanos(e)),encode:(e,t,r)=>qt(toNanos(e),{onNone:()=>cme(new Type(r,e,`Unable to encode ${e} into a bigint`)),onSome:e=>ume(e)})}).annotations({identifier:"DurationFromNanos"})){},DurationFromSelf,Either:({left:e,right:t})=>{const r=t,n=e,i=n_e(((e,t)=>Union(rightEncoded(e),leftEncoded(t)).annotations({description:`EitherEncoded<${format(t)}, ${format(e)}>`}))(r,n),EitherFromSelf({left:typeSchema(n),right:typeSchema(r)}),{strict:!0,decode:e=>eitherDecode(e),encode:e=>ot(e,{onLeft:makeLeftEncoded,onRight:makeRightEncoded})});return i},EitherFromSelf,EitherFromUnion:({left:e,right:t})=>{const r=t,n=e,i=typeSchema(r),s=typeSchema(n),o=n_e(r,rightEncoded(i),{strict:!0,decode:e=>makeRightEncoded(e),encode:e=>e.right}),a=n_e(n,leftEncoded(s),{strict:!0,decode:e=>makeLeftEncoded(e),encode:e=>e.left});return n_e(Union(o,a),EitherFromSelf({left:s,right:i}),{strict:!0,decode:e=>"Left"===e._tag?He(e.left):Ge(e.right),encode:e=>ot(e,{onLeft:makeLeftEncoded,onRight:makeRightEncoded})})},EndsWithSchemaId:h_e,Enums:e=>makeEnumsClass(e),Exit,ExitFromSelf,FiberId:class extends(n_e(Lwe,FiberIdFromSelf,{strict:!0,decode:e=>fiberIdDecode(e),encode:e=>fiberIdEncode(e)}).annotations({identifier:"FiberId"})){},FiberIdFromSelf,Finite:class extends(Number$.pipe(finite({identifier:"Finite"}))){},FiniteSchemaId:k_e,FromPropertySignature,GreaterThanBigDecimalSchemaId:xwe,GreaterThanBigIntSchemaId:P_e,GreaterThanDateSchemaId:bwe,GreaterThanDurationSchemaId:twe,GreaterThanOrEqualToBigDecimalSchemaId:Iwe,GreaterThanOrEqualToBigIntSchemaId:N_e,GreaterThanOrEqualToDateSchemaId:Swe,GreaterThanOrEqualToDurationSchemaId:rwe,GreaterThanOrEqualToSchemaId:I_e,GreaterThanSchemaId:x_e,HashMap:({key:e,value:t})=>n_e(Array$(Tuple(e,t)),HashMapFromSelf({key:typeSchema(e),value:typeSchema(t)}),{strict:!0,decode:e=>gP(e),encode:e=>Array.from(e)}),HashMapFromSelf,HashSet:function(e){return n_e(Array$(e),HashSetFromSelf(typeSchema(e)),{strict:!0,decode:e=>fromIterable$r(e),encode:e=>Array.from(e)})},HashSetFromSelf,IncludesSchemaId:d_e,InstanceOfSchemaId:Bve,Int,IntSchemaId:O_e,ItemsCountSchemaId:hwe,JsonNumber:class extends(Number$.pipe(finite({schemaId:F_e,identifier:"JsonNumber"}))){},JsonNumberSchemaId:F_e,LengthSchemaId:l_e,LessThanBigDecimalSchemaId:Twe,LessThanBigIntSchemaId:j_e,LessThanDateSchemaId:gwe,LessThanDurationSchemaId:X_e,LessThanOrEqualToBigDecimalSchemaId:Owe,LessThanOrEqualToBigIntSchemaId:R_e,LessThanOrEqualToDateSchemaId:ywe,LessThanOrEqualToDurationSchemaId:ewe,LessThanOrEqualToSchemaId:A_e,LessThanSchemaId:E_e,List:function(e){return n_e(Array$(e),ListFromSelf(typeSchema(e)),{strict:!0,decode:e=>fromIterable$p(e),encode:e=>Array.from(e)})},ListFromSelf,Literal,Lowercase:class extends(n_e(String$.annotations({description:"a string that will be converted to lowercase"}),Lowercased,{strict:!0,decode:e=>e.toLowerCase(),encode:identity$5}).annotations({identifier:"Lowercase"})){},Lowercased,LowercasedSchemaId:m_e,Map:function({key:e,value:t}){return n_e(Array$(Tuple(e,t)),MapFromSelf({key:typeSchema(e),value:typeSchema(t)}),{strict:!0,decode:e=>new Map(e),encode:e=>Array.from(e.entries())})},MapFromRecord:({key:e,value:t})=>n_e(Record({key:encodedBoundSchema(e),value:t}).annotations({description:"a record to be decoded into a Map"}),MapFromSelf({key:e,value:typeSchema(t)}),{strict:!0,decode:e=>new Map(Object.entries(e)),encode:e=>Object.fromEntries(e)}),MapFromSelf,MaxItemsSchemaId:fwe,MaxLengthSchemaId:u_e,MinItemsSchemaId:pwe,MinLengthSchemaId:c_e,MultipleOfSchemaId:T_e,Negative:class extends(Number$.pipe(negative({identifier:"Negative"}))){},NegativeBigDecimalFromSelf:Pwe,NegativeBigDecimalSchemaId:Fwe,NegativeBigInt:B_e,NegativeBigIntFromSelf:$_e,Never,NonEmptyArray,NonEmptyArrayEnsure:function(e){return n_e(Union(e,NonEmptyArray(e)),NonEmptyArray(typeSchema(e)),{strict:!0,decode:e=>ci(e)?e:of$6(e),encode:e=>1===e.length?e[0]:e})},NonEmptyChunk:function(e){return n_e(NonEmptyArray(e),NonEmptyChunkFromSelf(typeSchema(e)),{strict:!0,decode:e=>unsafeFromNonEmptyArray(e),encode:e=>toReadonlyArray$1(e)})},NonEmptyChunkFromSelf,NonEmptyString:class extends(String$.pipe(nonEmptyString({identifier:"NonEmptyString"}))){},NonEmptyTrimmedString,NonNaN:class extends(Number$.pipe(nonNaN({identifier:"NonNaN"}))){},NonNaNSchemaId:M_e,NonNegative,NonNegativeBigDecimalFromSelf:Mwe,NonNegativeBigDecimalSchemaId:Cwe,NonNegativeBigInt:V_e,NonNegativeBigIntFromSelf:W_e,NonNegativeInt:K_e,NonPositive:class extends(Number$.pipe(nonPositive({identifier:"NonPositive"}))){},NonPositiveBigDecimalFromSelf:jwe,NonPositiveBigDecimalSchemaId:Nwe,NonPositiveBigInt:q_e,NonPositiveBigIntFromSelf:z_e,Not:class extends(n_e(Boolean$.annotations({description:"a boolean that will be negated"}),Boolean$,{strict:!0,decode:e=>not$2(e),encode:e=>not$2(e)})){},Null,NullOr,NullishOr,Number:Number$,NumberFromString,Object:class extends(make$B(yO)){},Option:function(e){const t=e;return n_e((e=>Union(wwe,(e=>Struct({_tag:Literal("Some"),value:e}).annotations({description:`SomeEncoded<${format(e)}>`}))(e)).annotations({description:`OptionEncoded<${format(e)}>`}))(t),OptionFromSelf(typeSchema(t)),{strict:!0,decode:e=>optionDecode(e),encode:e=>qt(e,{onNone:()=>kwe,onSome:makeSomeEncoded})})},OptionFromNonEmptyTrimmedString:class extends(n_e(String$,OptionFromSelf(NonEmptyTrimmedString),{strict:!0,decode:e=>yr(Ut(e.trim()),isNonEmpty$3),encode:e=>Kt(e,()=>"")})){},OptionFromNullOr:function(e){return n_e(NullOr(e),OptionFromSelf(typeSchema(e)),{strict:!0,decode:e=>fromNullable$3(e),encode:e=>Zt(e)})},OptionFromNullishOr:function(e,t){return n_e(NullishOr(e),OptionFromSelf(typeSchema(e)),{strict:!0,decode:e=>fromNullable$3(e),encode:null===t?e=>Zt(e):e=>Qt(e)})},OptionFromSelf,OptionFromUndefinedOr:function(e){return n_e(UndefinedOr(e),OptionFromSelf(typeSchema(e)),{strict:!0,decode:e=>fromNullable$3(e),encode:e=>Qt(e)})},PatternSchemaId:p_e,Positive:class extends(Number$.pipe(positive({identifier:"Positive"}))){},PositiveBigDecimalFromSelf:Awe,PositiveBigDecimalSchemaId:Ewe,PositiveBigInt:U_e,PositiveBigIntFromSelf:L_e,PropertyKey:PropertyKey$,PropertySignatureDeclaration,PropertySignatureTransformation,PropertySignatureTypeId:zve,ReadonlyMap:function({key:e,value:t}){return n_e(Array$(Tuple(e,t)),ReadonlyMapFromSelf({key:typeSchema(e),value:typeSchema(t)}),{strict:!0,decode:e=>new Map(e),encode:e=>Array.from(e.entries())})},ReadonlyMapFromRecord:({key:e,value:t})=>n_e(Record({key:encodedBoundSchema(e),value:t}).annotations({description:"a record to be decoded into a ReadonlyMap"}),ReadonlyMapFromSelf({key:e,value:typeSchema(t)}),{strict:!0,decode:e=>new Map(Object.entries(e)),encode:e=>Object.fromEntries(e)}),ReadonlyMapFromSelf,ReadonlySet:function(e){return n_e(Array$(e),ReadonlySetFromSelf(typeSchema(e)),{strict:!0,decode:e=>new Set(e),encode:e=>Array.from(e)})},ReadonlySetFromSelf,Record,Redacted:function(e){return n_e(e,RedactedFromSelf(typeSchema(e)),{strict:!0,decode:e=>lbe(e),encode:e=>value$1(e)})},RedactedFromSelf,RefineSchemaId:e_e,Set:function(e){return n_e(Array$(e),SetFromSelf(typeSchema(e)),{strict:!0,decode:e=>new Set(e),encode:e=>Array.from(e)})},SetFromSelf,SortedSet:function(e,t){const r=typeSchema(e);return n_e(Array$(e),SortedSetFromSelf(r,t,t),{strict:!0,decode:e=>eZ(e,t),encode:e=>Array.from(values$6(e))})},SortedSetFromSelf,StartsWithSchemaId:f_e,String:String$,StringFromBase64:awe,StringFromBase64Url:uwe,StringFromHex:cwe,StringFromUriComponent:lwe,Struct,Symbol:class extends(r_e(String$.annotations({description:"a string to be decoded into a globally shared symbol"}),SymbolFromSelf,{strict:!1,decode:e=>decodeSymbol(e),encode:(e,t,r)=>encodeSymbol(e,r)}).annotations({identifier:"Symbol"})){},SymbolFromSelf,TaggedClass:e=>(t,r,n)=>{const i=getFieldsFromFieldsOr(r),s=getSchemaFromFieldsOr(r),o={_tag:getClassTag(t)},a=extendFields(o,i);return class extends(makeClass({kind:"TaggedClass",identifier:e??t,schema:Yve(s,Struct(o)),fields:a,Base:G0,annotations:n})){static _tag=t}},TaggedError:e=>(t,r,n)=>{class Base extends H0{}Base.prototype.name=t;const i=getFieldsFromFieldsOr(r),s=getSchemaFromFieldsOr(r),o={_tag:getClassTag(t)},a=extendFields(o,i),u="message"in a;class TaggedErrorClass extends(makeClass({kind:"TaggedError",identifier:e??t,schema:Yve(s,Struct(o)),fields:a,Base,annotations:n,disableToString:!0})){static _tag=t}return u||Object.defineProperty(TaggedErrorClass.prototype,"message",{get(){return`{ ${Reflect.ownKeys(i).map(e=>`${formatPropertyKey$1(e)}: ${formatUnknown$1(this[e])}`).join(", ")} }`},enumerable:!1,configurable:!0}),TaggedErrorClass},TaggedRequest:e=>(t,r,n)=>{const i=extendFields({_tag:getClassTag(t)},r.payload);return class extends(makeClass({kind:"TaggedRequest",identifier:e??t,schema:Struct(i),fields:i,Base:e4,annotations:n})){static _tag=t;static success=r.success;static failure=r.failure;get[zwe](){return this.constructor}get[Wwe](){return{failure:r.failure,success:r.success}}}},TaggedStruct,TemplateLiteral,TemplateLiteralParser:(...e)=>{const t=[],r=[],n=[];let i=!1;for(let s=0;s<e.length;s++){const o=e[s],a=isSchema(o)?o:Literal(o);n.push(a);const u=encodedSchema(a);t.push(u);const c=getTemplateLiteralParserCoercedElement(u,a);c?(r.push(c),i=!0):r.push(a)}const s=TemplateLiteral(...t),o=getTemplateLiteralCapturingRegExp(s.ast);let a=Tuple(...r);return i&&(a=a.annotations({[aT]:format(Tuple(...n))})),class extends(r_e(s,a,{strict:!1,decode:(t,r,n)=>{const i=o.exec(t);return i?ume(i.slice(1,e.length+1)):cme(new Type(n,t,`${o.source}: no match for ${JSON.stringify(t)}`))},encode:e=>ume(e.join(""))})){static params=e.slice()}},TimeZone:class extends(r_e(String$.annotations({description:"a string to be decoded into a TimeZone"}),TimeZoneFromSelf,{strict:!0,decode:(e,t,r)=>qt(yhe(e),{onNone:()=>cme(new Type(r,e,`Unable to decode ${JSON.stringify(e)} into a TimeZone`)),onSome:ume}),encode:e=>ume(zoneToString(e))}).annotations({identifier:"TimeZone"})){},TimeZoneFromSelf,TimeZoneNamed:class extends(r_e(String$.annotations({description:"a string to be decoded into a TimeZone.Named"}),TimeZoneNamedFromSelf,{strict:!0,decode:(e,t,r)=>lme({try:()=>hhe(e),catch:()=>new Type(r,e,`Unable to decode ${JSON.stringify(e)} into a TimeZone.Named`)}),encode:e=>ume(e.id)}).annotations({identifier:"TimeZoneNamed"})){},TimeZoneNamedFromSelf,TimeZoneOffset:class extends(n_e(Number$.annotations({description:"a number to be decoded into a TimeZone.Offset"}),TimeZoneOffsetFromSelf,{strict:!0,decode:e=>dhe(e),encode:e=>e.offset}).annotations({identifier:"TimeZoneOffset"})){},TimeZoneOffsetFromSelf,ToPropertySignature,Trim:class extends(n_e(String$.annotations({description:"a string that will be trimmed"}),Trimmed,{strict:!0,decode:e=>e.trim(),encode:identity$5}).annotations({identifier:"Trim"})){},Trimmed,TrimmedSchemaId:a_e,Tuple,TypeId:Mve,ULID:class extends(String$.pipe(pattern(w_e,{schemaId:__e,identifier:"ULID",description:"a Universally Unique Lexicographically Sortable Identifier",arbitrary:()=>e=>e.ulid()}))){},ULIDSchemaId:__e,URL:class extends(r_e(String$.annotations({description:"a string to be decoded into a URL"}),URLFromSelf,{strict:!0,decode:(e,t,r)=>lme({try:()=>new URL(e),catch:t=>new Type(r,e,`Unable to decode ${JSON.stringify(e)} into a URL. ${getErrorMessage(t)}`)}),encode:e=>ume(e.toString())}).annotations({identifier:"URL",pretty:()=>e=>e.toString()})){},URLFromSelf,UUID:class extends(String$.pipe(pattern(v_e,{schemaId:S_e,identifier:"UUID",jsonSchema:{format:"uuid",pattern:v_e.source},description:"a Universally Unique Identifier",arbitrary:()=>e=>e.uuid()}))){},UUIDSchemaId:S_e,Uint8,Uint8Array:class extends(n_e(Array$(Uint8).annotations({description:"an array of 8-bit unsigned integers to be decoded into a Uint8Array"}),Uint8ArrayFromSelf,{strict:!0,decode:e=>Uint8Array.from(e),encode:e=>Array.from(e)}).annotations({identifier:"Uint8Array"})){},Uint8ArrayFromBase64:iwe,Uint8ArrayFromBase64Url:swe,Uint8ArrayFromHex:owe,Uint8ArrayFromSelf,Uncapitalize:class extends(n_e(String$.annotations({description:"a string that will be converted to an uncapitalized format"}),Uncapitalized,{strict:!0,decode:e=>uncapitalize(e),encode:identity$5}).annotations({identifier:"Uncapitalize"})){},Uncapitalized,UncapitalizedSchemaId:b_e,Undefined,UndefinedOr,Union,UniqueSymbolFromSelf,Unknown,Uppercase:class extends(n_e(String$.annotations({description:"a string that will be converted to uppercase"}),Uppercased,{strict:!0,decode:e=>e.toUpperCase(),encode:identity$5}).annotations({identifier:"Uppercase"})){},Uppercased,UppercasedSchemaId:g_e,ValidDateFromSelf:class extends(DateFromSelf.pipe(validDate({identifier:"ValidDateFromSelf",description:"a valid Date instance"}))){},ValidDateSchemaId:mwe,Void:class extends(make$B(XT)){},annotations:s_e,asSchema:function(e){return e},asSerializable:e=>e,asSerializableWithResult:e=>e,asWithResult:e=>e,asserts,attachPropertySignature:i_e,between,betweenBigDecimal,betweenBigInt,betweenDate:(e,t,r)=>n=>n.pipe(filter$3(r=>r<=t&&r>=e,{schemaId:vwe,[vwe]:{max:t,min:e},title:`betweenDate(${formatDate(e)}, ${formatDate(t)})`,description:`a date between ${formatDate(e)} and ${formatDate(t)}`,...r})),betweenDuration,brand:(e,t)=>r=>{const n=qt(xT(r.ast),{onNone:()=>[e],onSome:t=>[...t,e]});return makeBrandClass(r,annotations$2(r.ast,toASTAnnotations({[tT]:n,...t})))},capitalized,clamp:(e,t)=>r=>n_e(r,typeSchema(r).pipe(between(e,t)),{strict:!1,decode:r=>HI(r,{minimum:e,maximum:t}),encode:identity$5}),clampBigDecimal:(e,t)=>r=>n_e(r,r.pipe(typeSchema,betweenBigDecimal(e,t)),{strict:!1,decode:r=>_E(r,{minimum:e,maximum:t}),encode:identity$5}),clampBigInt:(e,t)=>r=>n_e(r,r.pipe(typeSchema,betweenBigInt(e,t)),{strict:!1,decode:r=>QE(r,{minimum:e,maximum:t}),encode:identity$5}),clampDuration:(e,t)=>r=>n_e(r,r.pipe(typeSchema,betweenDuration(e,t)),{strict:!1,decode:r=>mM(r,{minimum:e,maximum:t}),encode:identity$5}),compose:Xve,declare,decode:Dve,decodeEither:Lve,decodeOption:Sme,decodePromise:Uve,decodeSync:bme,decodeUnknown,decodeUnknownEither,decodeUnknownOption,decodeUnknownPromise,decodeUnknownSync,deserialize:qwe,deserializeExit:Qwe,deserializeFailure:Gwe,deserializeSuccess:Hwe,element,encode:Nve,encodeEither:jve,encodeOption:xme,encodePromise:Rve,encodeSync:kme,encodeUnknown,encodeUnknownEither,encodeUnknownOption,encodeUnknownPromise,encodeUnknownSync,encodedBoundSchema,encodedSchema,endsWith:(e,t)=>r=>{const n=JSON.stringify(e);return r.pipe(filter$3(t=>t.endsWith(e),{schemaId:h_e,[h_e]:{endsWith:e},title:`endsWith(${n})`,description:"a string ending with "+n,jsonSchema:{pattern:`^.*${e}$`},...t}))},equivalence:e=>go(e.ast,[]),exitSchema,extend:Yve,failureSchema,filter:filter$3,filterEffect:t_e,finite,format,fromBrand:(e,t)=>r=>{const n=makeBrandClass(r,new FO(r.ast,function(t,r,n){const i=e.either(t);return Xe(i)?Ut(new Type(n,t,i.left.map(e=>e.message).join(", "))):none$c()},toASTAnnotations({schemaId:$ve,[$ve]:{constructor:e},...t})));return n},fromKey:Kve,getClassTag,getNumberIndexedAccess,greaterThan,greaterThanBigDecimal:(e,t)=>r=>{const n=format$5(e);return r.pipe(filter$3(t=>bE(t,e),{schemaId:xwe,[xwe]:{min:e},title:`greaterThanBigDecimal(${n})`,description:"a BigDecimal greater than "+n,...t}))},greaterThanBigInt,greaterThanDate:(e,t)=>r=>r.pipe(filter$3(t=>t>e,{schemaId:bwe,[bwe]:{min:e},title:`greaterThanDate(${formatDate(e)})`,description:"a date after "+formatDate(e),...t})),greaterThanDuration:(e,t)=>r=>r.pipe(filter$3(t=>kM(t,e),{schemaId:twe,[twe]:{min:e},title:`greaterThanDuration(${e})`,description:"a Duration greater than "+decode$5(e),...t})),greaterThanOrEqualTo,greaterThanOrEqualToBigDecimal:(e,t)=>r=>{const n=format$5(e);return r.pipe(filter$3(t=>SE(t,e),{schemaId:Iwe,[Iwe]:{min:e},title:`greaterThanOrEqualToBigDecimal(${n})`,description:"a BigDecimal greater than or equal to "+n,...t}))},greaterThanOrEqualToBigInt,greaterThanOrEqualToDate:(e,t)=>r=>r.pipe(filter$3(t=>t>=e,{schemaId:Swe,[Swe]:{min:e},title:`greaterThanOrEqualToDate(${formatDate(e)})`,description:"a date after or equal to "+formatDate(e),...t})),greaterThanOrEqualToDuration:(e,t)=>r=>r.pipe(filter$3(t=>xM(t,e),{schemaId:rwe,[rwe]:{min:e},title:`greaterThanOrEqualToDuration(${e})`,description:"a Duration greater than or equal to "+decode$5(e),...t})),head:function(e){return n_e(e,OptionFromSelf(getNumberIndexedAccess(typeSchema(e))),{strict:!1,decode:e=>fi(e),encode:e=>qt(e,{onNone:()=>[],onSome:of$6})})},headNonEmpty:function(e){return n_e(e,getNumberIndexedAccess(typeSchema(e)),{strict:!1,decode:e=>hi(e),encode:e=>of$6(e)})},headOrElse:dwe,includes:(e,t)=>r=>{const n=JSON.stringify(e);return r.pipe(filter$3(t=>t.includes(e),{schemaId:d_e,[d_e]:{includes:e},title:`includes(${n})`,description:"a string including "+n,jsonSchema:{pattern:`.*${e}.*`},...t}))},instanceOf,int,is:is$2,isPropertySignature,isSchema,itemsCount:(e,t)=>r=>{const n=Math.floor(e);if(n<0)throw Error(getInvalidArgumentErrorMessage("Expected an integer greater than or equal to 0, actual "+e));return r.pipe(filter$3(e=>e.length===n,{schemaId:hwe,title:`itemsCount(${n})`,description:`an array of exactly ${n} item(s)`,jsonSchema:{minItems:n,maxItems:n},[wT]:!0,...t}))},keyof:e=>make$B(keyof$1(e.ast)),length,lessThan,lessThanBigDecimal:(e,t)=>r=>{const n=format$5(e);return r.pipe(filter$3(t=>gE(t,e),{schemaId:Twe,[Twe]:{max:e},title:`lessThanBigDecimal(${n})`,description:"a BigDecimal less than "+n,...t}))},lessThanBigInt,lessThanDate:(e,t)=>r=>r.pipe(filter$3(t=>t<e,{schemaId:gwe,[gwe]:{max:e},title:`lessThanDate(${formatDate(e)})`,description:"a date before "+formatDate(e),...t})),lessThanDuration:(e,t)=>r=>r.pipe(filter$3(t=>_M(t,e),{schemaId:X_e,[X_e]:{max:e},title:`lessThanDuration(${e})`,description:"a Duration less than "+decode$5(e),...t})),lessThanOrEqualTo,lessThanOrEqualToBigDecimal:(e,t)=>r=>{const n=format$5(e);return r.pipe(filter$3(t=>yE(t,e),{schemaId:Owe,[Owe]:{max:e},title:`lessThanOrEqualToBigDecimal(${n})`,description:"a BigDecimal less than or equal to "+n,...t}))},lessThanOrEqualToBigInt,lessThanOrEqualToDate:(e,t)=>r=>r.pipe(filter$3(t=>t<=e,{schemaId:ywe,[ywe]:{max:e},title:`lessThanOrEqualToDate(${formatDate(e)})`,description:"a date before or equal to "+formatDate(e),...t})),lessThanOrEqualToDuration:(e,t)=>r=>r.pipe(filter$3(t=>wM(t,e),{schemaId:X_e,[X_e]:{max:e},title:`lessThanOrEqualToDuration(${e})`,description:"a Duration less than or equal to "+decode$5(e),...t})),lowercased,make:make$B,makePropertySignature,maxItems:(e,t)=>r=>{const n=Math.floor(e);if(n<1)throw Error(getInvalidArgumentErrorMessage("Expected an integer greater than or equal to 1, actual "+e));return r.pipe(filter$3(e=>e.length<=n,{schemaId:fwe,title:`maxItems(${n})`,description:`an array of at most ${n} item(s)`,jsonSchema:{maxItems:n},[wT]:!0,...t}))},maxLength:(e,t)=>r=>r.pipe(filter$3(t=>t.length<=e,{schemaId:u_e,title:`maxLength(${e})`,description:`a string at most ${e} character(s) long`,jsonSchema:{maxLength:e},...t})),minItems:(e,t)=>r=>{const n=Math.floor(e);if(n<1)throw Error(getInvalidArgumentErrorMessage("Expected an integer greater than or equal to 1, actual "+e));return r.pipe(filter$3(e=>e.length>=n,{schemaId:pwe,title:`minItems(${n})`,description:`an array of at least ${n} item(s)`,jsonSchema:{minItems:n},[wT]:!0,...t}))},minLength,multipleOf:(e,t)=>r=>{const n=Math.abs(e);return r.pipe(filter$3(t=>0===YI(t,e),{schemaId:T_e,title:`multipleOf(${n})`,description:"a number divisible by "+n,jsonSchema:{multipleOf:n},...t}))},mutable:e=>make$B(mutable$1(e.ast)),negative,negativeBigDecimal,negativeBigInt,nonEmptyString,nonNaN,nonNegative,nonNegativeBigDecimal,nonNegativeBigInt,nonPositive,nonPositiveBigDecimal,nonPositiveBigInt,omit:(...e)=>t=>make$B(omit$4(t.ast,e)),optional:e=>{const t=e.ast===QT||e.ast===tO?QT:UndefinedOr(e).ast;return new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(t,!0,!0,{},void 0),e)},optionalElement:e=>new ElementImpl(new OptionalType(e.ast,!0),e),optionalToOptional,optionalToRequired,optionalWith:Gve,parseJson,parseNumber,partial:e=>make$B(partial$1(e.ast)),partialWith:Zve,pattern,pick,pickLiteral:(...e)=>t=>Literal(...e),pluck:Hve,positive,positiveBigDecimal,positiveBigInt,propertySignature,rename:o_e,required:e=>make$B(required$1(e.ast)),requiredToOptional:(e,t,r)=>makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(e.ast,!1,!0,{},void 0),new ToPropertySignature(t.ast,!0,!0,{},void 0),ir(r.decode),e=>Ut(r.encode(e)))),serializableSchema:e=>e[zwe],serialize:e=>encodeUnknown(e[zwe])(e),serializeExit:Zwe,serializeFailure:Kwe,serializeSuccess:Jwe,split:e=>n_e(String$.annotations({description:"a string that will be split"}),Array$(String$),{strict:!0,decode:t=>t.split(e),encode:t=>t.join(e)}),standardSchemaV1:(e,t)=>{const r=decodeUnknown$1(e,{errors:"all"});return class extends(make$B(e.ast)){static"~standard"={version:1,vendor:"effect",validate(e){const n=new SyncScheduler,i=I8(V7(r(e,t),{onFailure:makeStandardFailureFromParseIssue,onSuccess:e=>G4({value:e})}),{scheduler:n});n.flush();const s=i.unsafePoll();return s?makeStandardResult(s):new Promise(e=>{i.addObserver(t=>{e(makeStandardResult(t))})})}}}},startsWith:(e,t)=>r=>{const n=JSON.stringify(e);return r.pipe(filter$3(t=>t.startsWith(e),{schemaId:f_e,[f_e]:{startsWith:e},title:`startsWith(${n})`,description:"a string starting with "+n,jsonSchema:{pattern:"^"+e},...t}))},successSchema,suspend:suspend$2,symbolSerializable:zwe,symbolWithResult:Wwe,tag,transform:n_e,transformLiteral,transformLiterals:function(...e){return Union(...e.map(([e,t])=>transformLiteral(e,t)))},transformOrFail:r_e,trimmed,typeSchema,uncapitalized,uppercased,validDate,validate,validateEither:(e,t)=>{const r=validateEither$1(e,t);return(e,t)=>it(r(e,t),parseError)},validateOption,validatePromise:(e,t)=>{const r=validate(e,t);return(e,t)=>O8(r(e,t))},validateSync,withConstructorDefault:qve,withDecodingDefault:Wve,withDefaults:Vve});const complete=(e,t,r,n,i)=>K0({_tag:"Complete",key:e,exit:t,ownerCount:r,entryStats:n,timeToLive:i}),pending$2=(e,t)=>K0({_tag:"Pending",key:e,scoped:t}),toScoped=e=>PU(e.exit,{onFailure:e=>failCause$j(e),onSuccess:([t])=>eQ(TR(sync$l(()=>incrementAndGet(e.ownerCount)),t),()=>releaseOwner(e))}),releaseOwner=e=>PU(e.exit,{onFailure:()=>tD,onSuccess:([,t])=>PR(sync$l(()=>decrementAndGet(e.ownerCount)),e=>SW(t(jU),()=>0===e))}),rke=Symbol.for("effect/ScopedCache"),nke={_Key:e=>e,_Error:e=>e,_Value:e=>e};class ScopedCacheImpl{capacity;scopedLookup;clock;timeToLive;context;[rke]=nke;cacheState;constructor(e,t,r,n,i){this.capacity=e,this.scopedLookup=t,this.clock=r,this.timeToLive=n,this.context=i,this.cacheState={map:empty$B(),keys:makeKeySet(),accesses:unbounded$8(),updating:make$27(!1),hits:0,misses:0}}pipe(){return pipeArguments(this,arguments)}get cacheStats(){return sync$l(()=>({hits:this.cacheState.hits,misses:this.cacheState.misses,size:size$t(this.cacheState.map)}))}getOption(e){return suspend$g(()=>qt(zU(this.cacheState.map,e),{onNone:()=>tW,onSome:e=>flatten$c(this.resolveMapValue(e))}))}getOptionComplete(e){return suspend$g(()=>qt(zU(this.cacheState.map,e),{onNone:()=>tW,onSome:e=>flatten$c(this.resolveMapValue(e,!0))}))}contains(e){return sync$l(()=>qU(this.cacheState.map,e))}entryStats(e){return sync$l(()=>{const t=Qt(zU(this.cacheState.map,e));if(void 0===t)return none$c();switch(t._tag){case"Complete":return Ut(makeEntryStats$1(t.entryStats.loadedMillis));case"Pending":return none$c();case"Refreshing":return Ut(makeEntryStats$1(t.complete.entryStats.loadedMillis))}})}get(e){return pipe(this.lookupValueOf(e),memoize$2,PR(t=>suspend$g(()=>{let r,n=Qt(zU(this.cacheState.map,e));return void 0===n&&(r=makeMapKey(e),qU(this.cacheState.map,e)?n=Qt(zU(this.cacheState.map,e)):WU(this.cacheState.map,e,pending$2(r,t))),void 0===n?(this.trackMiss(),lD(this.ensureMapSizeNotExceeded(r),t)):qR(this.resolveMapValue(n),PR(qt({onNone:()=>{const t=n;return equals$4(Qt(zU(this.cacheState.map,e)),n)&&GU(this.cacheState.map,e),pipe(this.ensureMapSizeNotExceeded(t.key),lD(releaseOwner(t)),lD(this.get(e)))},onSome:succeed$u})))})),flatten$c)}invalidate(e){return suspend$g(()=>{if(qU(this.cacheState.map,e)){const t=Qt(zU(this.cacheState.map,e));switch(GU(this.cacheState.map,e),t._tag){case"Complete":return releaseOwner(t);case"Pending":return tD;case"Refreshing":return releaseOwner(t.complete)}}return tD})}get invalidateAll(){return forEachConcurrentDiscard(fromIterable$r(Array.from(this.cacheState.map).map(([e])=>e)),e=>this.invalidate(e),!1,!1)}refresh(e){return pipe(this.lookupValueOf(e),memoize$2,PR(t=>{let r,n,i=Qt(zU(this.cacheState.map,e));if(void 0===i&&(r=makeMapKey(e),qU(this.cacheState.map,e)?i=Qt(zU(this.cacheState.map,e)):WU(this.cacheState.map,e,pending$2(r,t))),void 0===i)n=lD(this.ensureMapSizeNotExceeded(r),t);else switch(i._tag){case"Complete":if(this.hasExpired(i.timeToLive))n=succeed$u(this.get(e));else if(equals$4(Qt(zU(this.cacheState.map,e)),i)){const r=((e,t)=>K0({_tag:"Refreshing",scoped:e,complete:t}))(t,i);WU(this.cacheState.map,e,r),n=t}else n=succeed$u(this.get(e));break;case"Pending":case"Refreshing":n=i.scoped}return PR(n,e=>scopedEffect(asVoid$9(e)))}))}get size(){return sync$l(()=>size$t(this.cacheState.map))}resolveMapValue(e,t=!1){switch(e._tag){case"Complete":return this.trackHit(),this.hasExpired(e.timeToLive)?succeed$u(tW):TR(this.ensureMapSizeNotExceeded(e.key),asSome$4(toScoped(e)));case"Pending":return this.trackHit(),t?succeed$u(tW):lD(this.ensureMapSizeNotExceeded(e.key),qR(e.scoped,asSome$4));case"Refreshing":return this.trackHit(),this.hasExpired(e.complete.timeToLive)?t?succeed$u(tW):lD(this.ensureMapSizeNotExceeded(e.complete.key),qR(e.scoped,asSome$4)):TR(this.ensureMapSizeNotExceeded(e.complete.key),asSome$4(toScoped(e.complete)))}}lookupValueOf(e){return pipe(JR(PR(zY(),t=>pipe(this.scopedLookup(e),oU(pipe(this.context,NA(RY,t))),exit$2,qR(e=>[e,e=>UY(t,e)]))),()=>sync$l(()=>GU(this.cacheState.map,e))),PR(([t,r])=>{const n=this.clock.unsafeCurrentTimeMillis(),i=n+toMillis(this.timeToLive(t));switch(t._tag){case"Success":{const s=NU([t.value,r]),o=complete(makeMapKey(e),s,make$27(1),makeEntryStats$1(n),i);let a;return qU(this.cacheState.map,e)&&(a=Qt(zU(this.cacheState.map,e))),WU(this.cacheState.map,e,o),sync$l(()=>flatten$c(TR(this.cleanMapValue(a),toScoped(o))))}case"Failure":{const s=complete(makeMapKey(e),t,make$27(0),makeEntryStats$1(n),i);let o;return qU(this.cacheState.map,e)&&(o=Qt(zU(this.cacheState.map,e))),WU(this.cacheState.map,e,s),lD(r(t),sync$l(()=>flatten$c(TR(this.cleanMapValue(o),toScoped(s)))))}}}),memoize$2,flatten$c)}hasExpired(e){return this.clock.unsafeCurrentTimeMillis()>e}trackHit(){this.cacheState.hits=this.cacheState.hits+1}trackMiss(){this.cacheState.misses=this.cacheState.misses+1}trackAccess(e){const t=[];if(n$(this.cacheState.accesses,e),$F(this.cacheState.updating,!1,!0)){let e=!0;for(;e;){const t=s$(this.cacheState.accesses,t$);t===t$?e=!1:this.cacheState.keys.add(t)}let r=size$t(this.cacheState.map);for(e=r>this.capacity;e;){const n=this.cacheState.keys.remove();if(void 0===n)e=!1;else if(qU(this.cacheState.map,n.current)){const i=Qt(zU(this.cacheState.map,n.current));GU(this.cacheState.map,n.current),r-=1,t.push(i),e=r>this.capacity}}qF(this.cacheState.updating,!1)}return t}cleanMapValue(e){if(void 0===e)return tD;switch(e._tag){case"Complete":return releaseOwner(e);case"Pending":return tD;case"Refreshing":return releaseOwner(e.complete)}}ensureMapSizeNotExceeded(e){return forEachConcurrentDiscard(this.trackAccess(e),e=>this.cleanMapValue(e),!1,!1)}}const makeWith$1=e=>PR(hq,t=>buildWith(e.capacity,e.lookup,t,t=>decode$5(e.timeToLive(t)))),buildWith=(e,t,r,n)=>eQ(PR(context$c(),i=>sync$l(()=>new ScopedCacheImpl(e,t,r,n,i))),e=>e.invalidateAll);var ike=Object.freeze({__proto__:null,ScopedCacheTypeId:rke,make:e=>{const t=decode$5(e.timeToLive);return makeWith$1({capacity:e.capacity,lookup:e.lookup,timeToLive:()=>t})},makeWith:makeWith$1});var ske=Object.freeze({__proto__:null,ScopedRefTypeId:fbe,fromAcquire:fromAcquire$1,get:get$l,make:e=>fromAcquire$1(sync$l(e)),set:dbe});var oke=Object.freeze({__proto__:null,SecretTypeId:Tfe,fromIterable:e=>make$1b(fromIterable$v(e).map(e=>e.charCodeAt(0))),fromString:fromString$1,isSecret:e=>C(e,Tfe),make:make$1b,unsafeWipe:e=>{for(let t=0;t<e.raw.length;t++)e.raw[t]=0;kfe.delete(e)},value:e=>e.raw.map(e=>String.fromCharCode(e)).join("")}),ake=Object.freeze({__proto__:null,make:make$1n});var uke=Object.freeze({__proto__:null,SinkTypeId:kne,as:Ine,collectAll:collectAll$3,collectAllFrom:e=>Tne(e,{initial:empty$R(),while:r,body:(e,t)=>pipe(e,GA(t))}),collectAllN:collectAllN$1,collectAllToMap:(e,t)=>foldLeftChunks$1(mP(),(r,n)=>pipe(n,qC(r,(r,n)=>{const i=e(n),s=pipe(r,SP(i))?t(pipe(r,bP(i)),n):n;return pipe(r,vP(i,s))}))),collectAllToMapN:(e,t,r)=>foldWeighted$1({initial:mP(),maxCost:e,cost:(e,r)=>pipe(e,SP(t(r)))?0:1,body:(e,n)=>{const i=t(n),s=pipe(e,SP(i))?r(pipe(e,bP(i)),n):n;return pipe(e,vP(i,s))}}),collectAllToSet:()=>foldLeftChunks$1(IF(),(e,t)=>pipe(t,qC(e,(e,t)=>pipe(e,AF(t))))),collectAllToSetN:e=>foldWeighted$1({initial:IF(),maxCost:e,cost:(e,t)=>TF(e,t)?0:1,body:(e,t)=>AF(e,t)}),collectAllUntil:e=>pipe(fold$1([empty$R(),!0],e=>e[1],([t,r],n)=>[pipe(t,GA(n)),!e(n)]),zne(e=>e[0])),collectAllUntilEffect:e=>pipe(foldEffect$1([empty$R(),!0],e=>e[1],([t,r],n)=>pipe(e(n),P3(e=>[pipe(t,GA(n)),!e]))),zne(e=>e[0])),collectAllWhile:e=>fromChannel$3(collectAllWhileReader(e,empty$R())),collectAllWhileEffect:e=>fromChannel$3(collectAllWhileEffectReader(e,empty$R())),collectAllWhileWith:Tne,collectLeftover:collectLeftover$1,context:context$6,contextWith:e=>pipe(context$6(),zne(e)),contextWithEffect:e=>pipe(context$6(),qne(e)),contextWithSink:e=>new SinkImpl(unwrap$8(contextWith$8(t=>toChannel$5(e(t))))),count:aie,die:e=>failCause$7(qQ(e)),dieMessage:e=>failCause$7(qQ(new nY(e))),dieSync:e=>failCauseSync$4(()=>qQ(e())),dimap:Mne,dimapChunks:Pne,dimapChunksEffect:Nne,dimapEffect:Fne,drain:jne,drop:drop$3,dropUntil:e=>new SinkImpl(pipe(toChannel$5(dropWhile$3(t=>!e(t))),fne(toChannel$5(drop$3(1))))),dropUntilEffect:e=>suspend$a(()=>new SinkImpl(dropUntilEffectReader(e))),dropWhile:dropWhile$3,dropWhileEffect:e=>suspend$a(()=>new SinkImpl(dropWhileEffectReader(e))),ensuring:Rne,ensuringWith:Dne,every:e=>fold$1(!0,identity$5,(t,r)=>t&&e(r)),fail:fail$e,failCause:failCause$7,failCauseSync:failCauseSync$4,failSync:e=>new SinkImpl(failSync$7(e)),filterInput:e=>t=>pipe(t,Ane(rC(e))),filterInputEffect:Lne,findEffect:Une,flatMap:Bne,fold:fold$1,foldChunks:foldChunks$1,foldChunksEffect:foldChunksEffect$1,foldEffect:foldEffect$1,foldLeft:(e,t)=>ignoreLeftover$1(fold$1(e,r,t)),foldLeftChunks:foldLeftChunks$1,foldLeftChunksEffect:(e,t)=>ignoreLeftover$1(foldChunksEffect$1(e,r,t)),foldLeftEffect:(e,t)=>foldEffect$1(e,r,t),foldSink:$ne,foldUntil:(e,t,r)=>pipe(fold$1([e,0],e=>e[1]<t,([e,t],n)=>[r(e,n),t+1]),zne(e=>e[0])),foldUntilEffect:(e,t,r)=>pipe(foldEffect$1([e,0],e=>e[1]<t,([e,t],n)=>pipe(r(e,n),P3(e=>[e,t+1]))),zne(e=>e[0])),foldWeighted:foldWeighted$1,foldWeightedDecompose:foldWeightedDecompose$1,foldWeightedDecomposeEffect:foldWeightedDecomposeEffect$1,foldWeightedEffect:e=>foldWeightedDecomposeEffect$1({...e,decompose:e=>G4(of$5(e))}),forEach:forEach$b,forEachChunk:forEachChunk$1,forEachChunkWhile:e=>{const t=readWith$1({onInput:r=>pipe(fromEffect$b(e(r)),Zte(e=>e?t:ere)),onFailure:fail$f,onDone:()=>ere});return new SinkImpl(t)},forEachWhile:forEachWhile$1,fromChannel:fromChannel$3,fromEffect:fromEffect$9,fromPubSub:(e,t)=>fromQueue$4(e,t),fromPush:e=>new SinkImpl(unwrapScoped$5(pipe(e,P3(fromPushPull)))),fromQueue:fromQueue$4,head:head$4,ignoreLeftover:ignoreLeftover$1,last:last$1,leftover:e=>new SinkImpl(suspend$b(()=>write$1(e))),map:zne,mapEffect:qne,mapError:Wne,mapInput:One,mapInputChunks:Ane,mapInputChunksEffect:Cne,mapInputEffect:Ene,mapLeftover:Vne,mkString:uie,never:Kne,orElse:Gne,provideContext:Jne,race:Hne,raceBoth:Zne,raceWith:Qne,refineOrDie:Yne,refineOrDieWith:Xne,some:e=>fold$1(!1,e=>!e,(t,r)=>t||e(r)),splitWhere:eie,succeed:e=>new SinkImpl(succeed$g(e)),sum:tie,summarized:rie,suspend:suspend$a,sync:e=>new SinkImpl(sync$c(e)),take:e=>pipe(foldChunks$1(empty$R(),t=>t.length<e,(e,t)=>pipe(e,eC(t))),Bne(t=>{const[r,n]=pipe(t,bC(e));return new SinkImpl(pipe(write$1(n),_ne(succeedNow(r))))})),timed:cie,toChannel:toChannel$5,unwrap:e=>new SinkImpl(unwrap$8(pipe(e,P3(e=>toChannel$5(e))))),unwrapScoped:unwrapScoped$4,unwrapScopedWith:unwrapScopedWith$4,withDuration:withDuration$1,zip:nie,zipLeft:iie,zipRight:sie,zipWith:oie});const cke=Symbol.for("effect/SortedMap"),lke={[cke]:{_K:e=>e,_V:e=>e},[Z](){return pipe(hash$3(this.tree),combine$h(hash$3("effect/SortedMap")),cached$2(this))},[Y](e){return isSortedMap(e)&&equals$4(this.tree,e.tree)},[Symbol.iterator](){return this.tree[Symbol.iterator]()},toString(){return format$6(this.toJSON())},toJSON(){return{_id:"SortedMap",values:Array.from(this).map(toJSON)}},[ee](){return this.toJSON()},pipe(){return pipeArguments(this,arguments)}},makeImpl$1=e=>{const t=Object.create(lke);return t.tree=e,t},isSortedMap=e=>C(e,cke),empty$c=e=>makeImpl$1(qH(e)),pke=dual(2,(e,t)=>makeImpl$1(WH(e,t))),isEmpty$8=e=>0===size$b(e),isNonEmpty$2=e=>size$b(e)>0,fke=dual(2,(e,t)=>VH(e.tree,t)),getOrder=e=>getOrder$2(e.tree),hke=dual(2,(e,t)=>zt(fke(e,t))),headOption$2=e=>first$2(e.tree),dke=dual(2,(e,t)=>mke(e,empty$c(getOrder$2(e.tree)),(e,r,n)=>yke(e,n,t(r,n)))),mke=dual(3,(e,t,r)=>HH(e.tree,t,r)),gke=dual(2,(e,t)=>makeImpl$1(ZH(e.tree,t))),yke=dual(3,(e,t,r)=>KH(e.tree,t)?makeImpl$1(GH(ZH(e.tree,t),t,r)):makeImpl$1(GH(e.tree,t,r))),size$b=e=>size$r(e.tree),entries$2=e=>{const t=e.tree[Symbol.iterator]();return t[Symbol.iterator]=()=>entries$2(e),t},bke=dual(2,(e,t)=>{const r=getOrder$2(e.tree);let n=empty$c(r),i=empty$c(r);for(const r of e)t(r[0])?n=yke(n,r[0],r[1]):i=yke(i,r[0],r[1]);return[i,n]});var Ske=Object.freeze({__proto__:null,empty:empty$c,entries:entries$2,fromIterable:pke,get:fke,getOrder,has:hke,headOption:headOption$2,isEmpty:isEmpty$8,isNonEmpty:isNonEmpty$2,isSortedMap,keys:e=>keys$8(e.tree),lastOption:e=>last$2(e.tree),make:e=>(...t)=>pke(e)(t),map:dke,partition:bke,reduce:mke,remove:gke,set:yke,size:size$b,values:e=>values$7(e.tree)});const vke=gue,_ke=toChannel$4,wke=Dce,kke=tme,xke=unwrap$6;var Ike=Object.freeze({__proto__:null,DefaultChunkSize:4096,Do:hfe,StreamTypeId:vke,accumulate:e=>chunks$1(accumulateChunks$1(e)),accumulateChunks:accumulateChunks$1,acquireRelease:acquireRelease$1,aggregate:bue,aggregateWithin:Sue,aggregateWithinEither:vue,as:_ue,async:(e,t)=>U3(queueFromBufferOptions(t),e=>shutdown$4(e)).pipe(h7(t=>h8().pipe(h7(r=>Z4(()=>{const n=xie(r),i=e(make$1g(e=>fromPull$3(e).pipe(h7(e=>ate(t,e)),C3,n).then(e=>{if(wU(e)&&!HQ(e.cause))throw squash(e.cause)})));return i})),P3(e=>{const r=cte(t).pipe(h7(e=>done$5(e)),z7({onFailure:e=>fromEffect$b(shutdown$4(t)).pipe(_ne(qt(e,{onNone:()=>ere,onSome:e=>fail$f(e)}))),onSuccess:e=>write$1(e).pipe(Zte(()=>r))}),unwrap$8);return fromChannel$2(r).pipe(cce(e??Q4))}))),unwrapScoped$3),asyncEffect:(e,t)=>pipe(U3(queueFromBufferOptions(t),e=>shutdown$4(e)),h7(t=>pipe(h8(),h7(r=>pipe(e(make$1g(e=>pipe(fromPull$3(e),h7(e=>ate(t,e)),C3,xie(r)).then(e=>{if(wU(e)&&!HQ(e.cause))throw squash(e.cause)}))),P3(()=>{const e=pipe(cte(t),h7(done$5),z7({onFailure:e=>pipe(fromEffect$b(shutdown$4(t)),_ne(qt(e,{onNone:()=>ere,onSome:fail$f}))),onSuccess:t=>pipe(write$1(t),Zte(()=>e))}),unwrap$8);return e}))))),unwrapScoped$5,fromChannel$2),asyncPush:asyncPush$1,asyncScoped:(e,t)=>pipe(U3(queueFromBufferOptions(t),e=>shutdown$4(e)),h7(t=>pipe(h8(),h7(r=>pipe(e(make$1g(e=>pipe(fromPull$3(e),h7(e=>ate(t,e)),C3,xie(r)).then(e=>{if(wU(e)&&!HQ(e.cause))throw squash(e.cause)}))),j8(Nz(!1)),h7(e=>pipe(jz(e),P3(r=>r?end$1():pipe(cte(t),h7(done$5),W3(()=>pipe(Bz(e,!0),j8(shutdown$4(t)))))))))))),scoped$2,Sce(repeatEffectChunkOption$1)),bind:dfe,bindEffect:rme,bindTo:mfe,branchAfter:wue,broadcast:kue,broadcastDynamic:xue,broadcastedQueues:Tue,broadcastedQueuesDynamic:Oue,buffer:Eue,bufferChunks:Aue,catchAll:Nue,catchAllCause:jue,catchSome:Rue,catchSomeCause:Due,catchTag:Lue,catchTags:Uue,changes:e=>pipe(e,$ue((e,t)=>equals$4(t)(e))),changesWith:$ue,changesWithEffect:Bue,chunks:chunks$1,chunksWith:zue,combine:que,combineChunks:Wue,concat:Vue,concatAll:e=>suspend$7(()=>pipe(e,qC(uce,(e,t)=>Vue(t)(e)))),context:context$4,contextWith:e=>pipe(context$4(),Dce(e)),contextWithEffect:e=>pipe(context$4(),Gce(e)),contextWithStream:contextWithStream$1,cross:Kue,crossLeft:Gue,crossRight:Jue,crossWith:Hue,debounce:Zue,decodeText:yfe,die:die$4,dieMessage:e=>fromEffect$7(q4(e)),dieSync:e=>fromEffect$7(W4(e)),distributedWith:Que,distributedWithDynamic:Xue,drain:drain$3,drainFork:tce,drop:rce,dropRight:nce,dropUntil:ice,dropUntilEffect:sce,dropWhile:oce,dropWhileEffect:ace,either:e=>pipe(e,Dce(Ge),Nue(e=>make$1d(He(e)))),empty:uce,encodeText:e=>suspend$7(()=>{const t=new TextEncoder;return Dce(e,e=>t.encode(e))}),ensuring:cce,ensuringWith:lce,execute:execute$1,fail:fail$a,failCause:failCause$4,failCauseSync:e=>fromEffect$7(B4(e)),failSync:failSync$4,filter:pce,filterEffect:fce,filterMap:hce,filterMapEffect:dce,filterMapWhile:mce,filterMapWhileEffect:gce,finalizer:e=>acquireRelease$1(Q4,()=>e),find:yce,findEffect:bce,flatMap:Sce,flatten:_ce,flattenChunks:flattenChunks$1,flattenEffect:wce,flattenExitOption:flattenExitOption$1,flattenIterables:e=>pipe(e,Dce(fromIterable$u),flattenChunks$1),flattenTake:flattenTake$1,forever:forever$1,fromAsyncIterable:(e,t)=>pipe(U3(Z4(()=>e[Symbol.asyncIterator]()),e=>e.return?promise(async()=>e.return()):Q4),P3(e=>repeatEffectOption$1(pipe(b3({try:async()=>e.next(),catch:e=>Ut(t(e))}),h7(e=>e.done?L4(none$c()):G4(e.value))))),unwrapScoped$3),fromChannel:fromChannel$2,fromChunk:fromChunk$1,fromChunkPubSub:(e,t)=>{if(t?.scoped){const r=P3(subscribe$2(e),fromChunkQueue$1);return t.shutdown?P3(r,cce(shutdown$5(e))):r}const r=Sce(scoped$2(subscribe$2(e)),fromChunkQueue$1);return t?.shutdown?cce(r,shutdown$5(e)):r},fromChunkQueue:fromChunkQueue$1,fromChunks:(...e)=>pipe(fromIterable$g(e),Sce(fromChunk$1)),fromEffect:fromEffect$7,fromEffectOption:fromEffectOption$1,fromEventListener:(e,t,r)=>asyncPush$1(n=>U3(Z4(()=>e.addEventListener(t,n.single,r)),()=>Z4(()=>e.removeEventListener(t,n.single,r))),{bufferSize:"object"==typeof r?r.bufferSize:void 0}),fromIterable:fromIterable$g,fromIterableEffect:e=>pipe(e,P3(fromIterable$g),unwrap$6),fromIteratorSucceed:fromIteratorSucceed$1,fromPubSub:fromPubSub$3,fromPull:fromPull$2,fromQueue:fromQueue$3,fromReadableStream:(...e)=>{const t=1===e.length?e[0].evaluate:e[0],r=1===e.length?e[0].onError:e[1],n=1===e.length&&!0===e[0].releaseLockOnEnd;return unwrapScoped$3(P3(U3(Z4(()=>t().getReader()),e=>n?Z4(()=>e.releaseLock()):promise(()=>e.cancel())),e=>repeatEffectOption$1(h7(b3({try:()=>e.read(),catch:e=>Ut(r(e))}),({done:e,value:t})=>e?L4(none$c()):G4(t)))))},fromReadableStreamByob:(...e)=>{const t=1===e.length?e[0].evaluate:e[0],r=1===e.length?e[0].onError:e[1],n=(1===e.length?e[0].bufferSize:e[2])??4096,i=1===e.length&&!0===e[0].releaseLockOnEnd;return unwrapScoped$3(P3(U3(Z4(()=>t().getReader({mode:"byob"})),e=>i?Z4(()=>e.releaseLock()):promise(()=>e.cancel())),e=>Nue(forever$1(((e,t,r)=>{const n=new ArrayBuffer(r);return paginateEffect$1(0,r=>h7(b3({try:()=>e.read(new Uint8Array(n,r,n.byteLength-r)),catch:e=>t(e)}),({done:e,value:t})=>{if(e)return L4(kce);const i=r+t.byteLength;return G4([t,i>=n.byteLength?none$c():Ut(i)])}))})(e,r,n)),e=>e===kce?uce:fail$a(e))))},fromSchedule:e=>pipe(Aie(e),P3(e=>repeatEffectOption$1(e.next(void 0))),unwrap$6),fromTPubSub:e=>unwrapScoped$3(P3(subscribeScoped(e),e=>fromTQueue$1(e))),fromTQueue:fromTQueue$1,groupAdjacentBy:xce,groupBy:eme,groupByKey:nme,grouped:Ice,groupedWithin:Tce,haltAfter:Ece,haltWhen:Oce,haltWhenDeferred:Ace,identity:identityStream,interleave:Cce,interleaveWith:Mce,interruptAfter:Nce,interruptWhen:jce,interruptWhenDeferred:Rce,intersperse:Fce,intersperseAffixes:Pce,iterate:(e,t)=>unfold$1(e,e=>Ut([e,t(e)])),let:gfe,make:make$1d,map:wke,mapAccum:Lce,mapAccumEffect:Uce,mapBoth:$ce,mapChunks:Bce,mapChunksEffect:zce,mapConcat:qce,mapConcatChunk:Wce,mapConcatChunkEffect:Vce,mapConcatEffect:Kce,mapEffect:kke,mapError:Hce,mapErrorCause:Zce,mapInputContext:Cle,merge:Qce,mergeAll:Yce,mergeEither:ele,mergeLeft:tle,mergeRight:rle,mergeWith:nle,mergeWithTag:Xce,mkString:e=>qle(e,uie),never:ile,onDone:ale,onEnd:sle,onError:ole,onStart:ule,orDie:e=>pipe(e,cle(identity$5)),orDieWith:cle,orElse:lle,orElseEither:ple,orElseFail:fle,orElseIfEmpty:hle,orElseIfEmptyChunk:dle,orElseIfEmptyStream:mle,orElseSucceed:gle,paginate:(e,t)=>paginateChunk$1(e,e=>{const r=t(e);return[of$5(r[0]),r[1]]}),paginateChunk:paginateChunk$1,paginateChunkEffect:paginateChunkEffect$1,paginateEffect:paginateEffect$1,partition:ble,partitionEither:Sle,peel:yle,pipeThrough:vle,pipeThroughChannel:_le,pipeThroughChannelOrFail:wle,prepend:kle,provideContext:xle,provideLayer:Tle,provideService:Ole,provideServiceEffect:Ele,provideServiceStream:Ale,provideSomeContext:Ile,provideSomeLayer:Mle,race:Fle,raceAll:raceAll$1,range:(e,t,r=4096)=>suspend$7(()=>{if(e>t)return uce;const go=(e,t,r)=>{const n=t-e+1;return n>r?pipe(write$1(range$2(e,e+r-1)),Zte(()=>go(e+r,t,r))):write$1(range$2(e,e+n-1))};return new StreamImpl(go(e,t,r))}),rechunk:Ple,refineOrDie:Nle,refineOrDieWith:jle,repeat:Rle,repeatEffect:e=>repeatEffectOption$1(pipe(e,R3(Ut))),repeatEffectChunk:e=>repeatEffectChunkOption$1(pipe(e,R3(Ut))),repeatEffectChunkOption:repeatEffectChunkOption$1,repeatEffectOption:repeatEffectOption$1,repeatEffectWithSchedule:repeatEffectWithSchedule$1,repeatEither:Dle,repeatElements:Lle,repeatElementsWith:Ule,repeatValue:e=>new StreamImpl(repeated$2(write$1(of$5(e)))),repeatWith:$le,retry:Ble,run:qle,runCollect:e=>qle(e,collectAll$3()),runCount:e=>qle(e,aie),runDrain:e=>qle(e,jne),runFold:Wle,runFoldEffect:Vle,runFoldScoped:Kle,runFoldScopedEffect:Gle,runFoldWhile:Jle,runFoldWhileEffect:Hle,runFoldWhileScoped:Zle,runFoldWhileScopedEffect:Qle,runForEach:Yle,runForEachChunk:Xle,runForEachChunkScoped:epe,runForEachScoped:tpe,runForEachWhile:rpe,runForEachWhileScoped:npe,runHead:e=>qle(e,head$4()),runIntoPubSub:ipe,runIntoPubSubScoped:spe,runIntoQueue:ope,runIntoQueueElementsScoped:ape,runIntoQueueScoped:upe,runLast:e=>qle(e,last$1()),runScoped:cpe,runSum:e=>qle(e,tie),scan:lpe,scanEffect:mpe,scanReduce:ppe,scanReduceEffect:fpe,schedule:hpe,scheduleWith:dpe,scoped:scoped$2,scopedWith:scopedWith$2,share:Iue,sliding:bpe,slidingSize:Spe,some:e=>pipe(e,Hce(Ut),ype(()=>none$c())),someOrElse:gpe,someOrFail:ype,split:vpe,splitLines:e=>_le(e,splitLines$3()),splitOnChunk:_pe,succeed:succeed$b,suspend:suspend$7,sync:sync$8,take:wpe,takeRight:kpe,takeUntil:xpe,takeUntilEffect:Ipe,takeWhile:Tpe,tap:Ope,tapBoth:Epe,tapError:Ape,tapErrorCause:Cpe,tapSink:Mpe,throttle:Fpe,throttleEffect:Ppe,tick:e=>{return t=spaced(e),repeatEffectWithSchedule$1(G4(void 0),t);var t},timeout:Npe,timeoutFail:jpe,timeoutFailCause:Rpe,timeoutTo:Dpe,toAsyncIterable:e=>Vpe(e,Iie),toAsyncIterableEffect:e=>P3(h8(),t=>Vpe(e,t)),toAsyncIterableRuntime:Vpe,toChannel:_ke,toPubSub:Lpe,toPull:toPull$2,toQueue:Upe,toQueueOfElements:$pe,toReadableStream:Bpe,toReadableStreamEffect:zpe,toReadableStreamRuntime:qpe,transduce:Wpe,unfold:unfold$1,unfoldChunk:unfoldChunk$1,unfoldChunkEffect:unfoldChunkEffect$1,unfoldEffect:unfoldEffect$1,unwrap:xke,unwrapScoped:unwrapScoped$3,unwrapScopedWith:unwrapScopedWith$3,updateService:Gpe,void:Kpe,when:Jpe,whenCase:(e,t)=>Hpe(t)(Z4(e)),whenCaseEffect:Hpe,whenEffect:Zpe,withExecutionPlan:zle,withSpan:function(){const e="string"!=typeof arguments[0],name=e?arguments[1]:arguments[0],t=addSpanStackTrace(e?arguments[2]:arguments[1]);return e?new StreamImpl(withSpan$3(toChannel$4(arguments[0]),name,t)):e=>new StreamImpl(withSpan$3(toChannel$4(e),name,t))},zip:Qpe,zipAll:Xpe,zipAllLeft:efe,zipAllRight:tfe,zipAllSortedByKey:rfe,zipAllSortedByKeyLeft:nfe,zipAllSortedByKeyRight:ife,zipAllSortedByKeyWith:sfe,zipAllWith:ofe,zipFlatten:Ype,zipLatest:afe,zipLatestAll:zipLatestAll$1,zipLatestWith:ufe,zipLeft:cfe,zipRight:lfe,zipWith:pfe,zipWithChunks:ffe,zipWithIndex:zipWithIndex$1,zipWithNext:zipWithNext$1,zipWithPrevious:zipWithPrevious$1,zipWithPreviousAndNext:e=>pipe(zipWithNext$1(zipWithPrevious$1(e)),Dce(([[e,t],r])=>[e,t,pipe(r,er(e=>e[1]))]))}),Tke=Object.freeze({__proto__:null});const Oke={_R:e=>e,_E:e=>e,_A:e=>e};var Eke=Object.freeze({__proto__:null,Class:class{[vke]=Oke;pipe(){return pipeArguments(this,arguments)}get channel(){return _ke(this.toStream())}}});const Ake=Symbol.for("effect/Subscribable"),Cke={[mz]:mz,[Ake]:Ake,pipe(){return pipeArguments(this,arguments)}},make$t=e=>Object.assign(Object.create(Cke),e),Mke=dual(2,(e,t)=>make$t({get:P3(e.get,t),changes:wke(e.changes,t)})),Fke=dual(2,(e,t)=>make$t({get:h7(e.get,t),changes:kke(e.changes,t)}));var Pke=Object.freeze({__proto__:null,TypeId:Ake,isSubscribable:e=>C(e,Ake),make:make$t,map:Mke,mapEffect:Fke,unwrap:e=>make$t({get:h7(e,e=>e.get),changes:xke(P3(e,e=>e.changes))})});const Nke=iX,jke=KX,Rke=GX,Dke=ZX,Lke=QX,Uke=YX,$ke=XX,Bke=oX;var zke=Object.freeze({__proto__:null,SynchronizedRefTypeId:Nke,get:get$z,getAndSet:kz,getAndUpdate:xz,getAndUpdateEffect:jke,getAndUpdateSome:Iz,getAndUpdateSomeEffect:Rke,make:makeSynchronized,modify:JX,modifyEffect:HX,modifySome:Ez,modifySomeEffect:Dke,set:wz,setAndGet:Tz,unsafeMake:unsafeMakeSynchronized,update:Az,updateAndGet:Cz,updateAndGetEffect:Uke,updateEffect:Lke,updateSome:Mz,updateSomeAndGet:Fz,updateSomeAndGetEffect:Bke,updateSomeEffect:$ke});const qke=Symbol.for("effect/SubscriptionRef"),Wke={_A:e=>e};class SubscriptionRefImpl extends hz{ref;pubsub;semaphore;[mz]=mz;[Ake]=Ake;[Pz]=_z;[Nke]=sX;[qke]=Wke;constructor(e,t,r){super(),this.ref=e,this.pubsub=t,this.semaphore=r,this.get=jz(this.ref)}commit(){return this.get}get;get changes(){return pipe(jz(this.ref),h7(e=>P3(fromPubSub$3(this.pubsub,{scoped:!0}),t=>Vue(make$1d(e),t))),this.semaphore.withPermits(1),unwrapScoped$3)}modify(e){return this.modifyEffect(t=>G4(e(t)))}modifyEffect(e){return pipe(jz(this.ref),h7(e),h7(([e,t])=>pipe(Bz(this.ref,t),E3(e),N8(nte(this.pubsub,t)))),this.semaphore.withPermits(1))}}var Vke=Object.freeze({__proto__:null,SubscriptionRefTypeId:qke,get:e=>jz(e.ref),getAndSet:Rz,getAndUpdate:Dz,getAndUpdateEffect:jke,getAndUpdateSome:Lz,getAndUpdateSomeEffect:Rke,make:e=>pipe(d4([unbounded$5(),Nz(e),makeSemaphore(1)]),P3(([e,t,r])=>new SubscriptionRefImpl(t,e,r))),modify:dual(2,(e,t)=>e.modify(t)),modifyEffect:dual(2,(e,t)=>e.modifyEffect(t)),modifySome:$z,modifySomeEffect:Dke,set:dual(2,(e,t)=>pipe(Bz(e.ref,t),N8(nte(e.pubsub,t)),e.semaphore.withPermits(1))),setAndGet:zz,update:qz,updateAndGet:Wz,updateAndGetEffect:Uke,updateEffect:Lke,updateSome:Vz,updateSomeAndGet:Kz,updateSomeAndGetEffect:Bke,updateSomeEffect:$ke});const Kke=yZ,Gke=fromEffect$e,Jke=vZ,Hke=SZ,Zke=unsafeTrack$1;var Qke=Object.freeze({__proto__:null,AbstractSupervisor:class{onStart(e,t,r,n){}onEnd(e,t){}onEffect(e,t){}onSuspend(e){}onResume(e){}map(e){return new ProxySupervisor(this,qR(this.value,e))}zip(e){return new Zip(this,e)}onRun(e,t){return e()}[Kke]=bZ},SupervisorTypeId:Kke,addSupervisor:e=>scopedDiscard$1(OQ(AQ,t=>new Zip(t,e))),fibersIn:e=>sync$l(()=>new FibersIn(e)),fromEffect:Gke,none:Jke,track:Hke,unsafeTrack:Zke}),Yke=Object.freeze({__proto__:null,Equivalence:g,isSymbol:isSymbol$1});const Xke=Symbol.for("effect/TArray"),exe={_A:e=>e};class TArrayImpl{chunk;[Xke]=exe;constructor(e){this.chunk=e}}const txe=dual(2,(e,t)=>rxe(e,e=>pipe(t(e),er(succeed$c)))),rxe=dual(2,(e,t)=>withSTMRuntime(r=>{let n=0,i=none$c();for(;Bt(i)&&n<e.chunk.length;){const s=pipe(e.chunk[n],pae(r.journal)),o=t(s);zt(o)&&(i=o),n+=1}return pipe(i,qt({onNone:()=>$oe,onSome:Fse(Ut)}))})),nxe=dual(2,(e,t)=>Exe(e,e=>equals$4(e)(t))),ixe=dual(2,(e,t)=>xxe(e,0,(e,r)=>t(r)?e+1:e)),sxe=dual(2,(e,t)=>Oxe(e,0,(e,r)=>Fse(t(r),t=>t?e+1:e))),oxe=dual(2,(e,t)=>negate$1(Exe(e,e=>!t(e)))),axe=dual(2,(e,t)=>Fse(sxe(e,t),t=>t===e.chunk.length)),uxe=dual(2,(e,t)=>txe(e,e=>t(e)?Ut(e):none$c())),cxe=dual(2,(e,t)=>lxe(e,t,0)),lxe=dual(3,(e,t,r)=>fxe(e,e=>equals$4(e)(t),r)),pxe=dual(2,(e,t)=>fxe(e,t,0)),fxe=dual(3,(e,t,r)=>r<0?$oe:effect(n=>{let i=r,s=!1;for(;!s&&i<e.chunk.length;){const r=pae(e.chunk[i],n);s=t(r),i+=1}return s?Ut(i-1):none$c()})),hxe=dual(2,(e,t)=>dxe(e,t,0)),dxe=dual(3,(e,t,r)=>{const forIndex=r=>r<e.chunk.length?pipe(get$u(e.chunk[r]),Ase(t),Ase(e=>e?succeed$c(Ut(r)):forIndex(r+1))):$oe;return r<0?$oe:forIndex(r)}),mxe=dual(2,(e,t)=>{const r=[none$c(),0];return Fse(iterate$3(r,{while:t=>Bt(t[0])&&t[1]<e.chunk.length-1,body:r=>{const n=r[1];return pipe(get$u(e.chunk[n]),Ase(e=>Fse(t(e),t=>[t?Ut(e):none$c(),n+1])))}}),e=>e[0])}),gxe=dual(2,(e,t)=>effect(r=>{let n=e.chunk.length-1,i=none$c();for(;Bt(i)&&n>=0;){const s=pae(e.chunk[n],r);t(s)&&(i=Ut(s)),n-=1}return i})),yxe=dual(2,(e,t)=>bxe(e,t,e.chunk.length-1)),bxe=dual(3,(e,t,r)=>r>=e.chunk.length?$oe:effect(n=>{let i=r,s=!1;for(;!s&&i>=0;)s=equals$4(pae(e.chunk[i],n))(t),i-=1;return s?Ut(i+1):none$c()})),Sxe=dual(2,(e,t)=>{const r=[none$c(),e.chunk.length-1];return Fse(iterate$3(r,{while:e=>Bt(e[0])&&e[1]>=0,body:r=>{const n=r[1];return pipe(get$u(e.chunk[n]),Ase(e=>Fse(t(e),t=>[t?Ut(e):none$c(),n-1])))}}),e=>e[0])}),vxe=dual(2,(e,t)=>Oxe(e,void 0,(e,r)=>t(r))),fromIterable$9=e=>Fse(coe(e,make$1h),e=>new TArrayImpl(e)),_xe=dual(2,(e,t)=>t<0||t>=e.chunk.length?dieMessage$6("Index out of bounds"):get$u(e.chunk[t])),wxe=dual(2,(e,t)=>{const r=greaterThan$a(t);return Ixe(e,(e,t)=>r(e)(t)?t:e)}),kxe=dual(2,(e,t)=>{const r=lessThan$e(t);return Ixe(e,(e,t)=>r(e)(t)?t:e)}),xxe=dual(3,(e,t,r)=>effect(n=>{let i=0,s=t;for(;i<e.chunk.length;){const t=pae(e.chunk[i],n);s=r(s,t),i+=1}return s})),Ixe=dual(2,(e,t)=>effect(r=>{let n,i=0;for(;i<e.chunk.length;){const s=pae(e.chunk[i],r);n=void 0===n?s:t(n,s),i+=1}return fromNullable$3(n)})),Txe=dual(2,(e,t)=>Oxe(e,none$c(),(e,r)=>zt(e)?Fse(t(e.value,r),Ut):succeedSome$1(r))),Oxe=dual(3,(e,t,r)=>Ase(toArray$7(e),Ioe(t,r))),Exe=dual(2,(e,t)=>Fse(uxe(e,t),zt)),Axe=dual(2,(e,t)=>Fse(sxe(e,t),e=>e>0)),toArray$7=e=>coe(e.chunk,get$u),Cxe=dual(2,(e,t)=>effect(r=>{let n=0;for(;n<e.chunk.length;){const i=e.chunk[n];fae(i,t(pae(i,r)),r),n+=1}})),Mxe=dual(2,(e,t)=>Ase(coe(e.chunk,e=>Ase(get$u(e),t)),t=>effect(r=>{const n=t[Symbol.iterator]();let i,s=0;for(;(i=n.next())&&!i.done;)fae(e.chunk[s],i.value,r),s+=1}))),Fxe=dual(3,(e,t,r)=>t<0||t>=e.chunk.length?dieMessage$6("Index out of bounds"):aae(e.chunk[t],r)),Pxe=dual(3,(e,t,r)=>t<0||t>=e.chunk.length?dieMessage$6("Index out of bounds"):pipe(get$u(e.chunk[t]),Ase(r),Ase(r=>eae(e.chunk[t],r))));var Nxe=Object.freeze({__proto__:null,TArrayTypeId:Xke,collectFirst:txe,collectFirstSTM:rxe,contains:nxe,count:ixe,countSTM:sxe,empty:()=>fromIterable$9([]),every:oxe,everySTM:axe,findFirst:uxe,findFirstIndex:cxe,findFirstIndexFrom:lxe,findFirstIndexWhere:pxe,findFirstIndexWhereFrom:fxe,findFirstIndexWhereFromSTM:dxe,findFirstIndexWhereSTM:hxe,findFirstSTM:mxe,findLast:gxe,findLastIndex:yxe,findLastIndexFrom:bxe,findLastSTM:Sxe,forEach:vxe,fromIterable:fromIterable$9,get:_xe,headOption:e=>0===e.chunk.length?succeed$c(none$c()):Fse(get$u(e.chunk[0]),Ut),lastOption:e=>0===e.chunk.length?$oe:Fse(get$u(e.chunk[e.chunk.length-1]),Ut),make:(...e)=>fromIterable$9(e),maxOption:wxe,minOption:kxe,reduce:xxe,reduceOption:Ixe,reduceOptionSTM:Txe,reduceSTM:Oxe,size:e=>e.chunk.length,some:Exe,someSTM:Axe,toArray:toArray$7,transform:Cxe,transformSTM:Mxe,update:Fxe,updateSTM:Pxe});const jxe=Symbol.for("effect/TDeferred"),Rxe={_A:e=>e,_E:e=>e};class TDeferredImpl{ref;[jxe]=Rxe;constructor(e){this.ref=e}}const Dxe=dual(2,(e,t)=>Ase(get$u(e.ref),qt({onNone:()=>Dse(eae(e.ref,Ut(t)),succeed$c(!0)),onSome:()=>succeed$c(!1)}))),Lxe=dual(2,(e,t)=>Dxe(e,He(t))),Uxe=dual(2,(e,t)=>Dxe(e,Ge(t)));var $xe=Object.freeze({__proto__:null,TDeferredTypeId:jxe,await:e=>flatten$4(Zse(get$u(e.ref),e=>zt(e)?Ut(fromEither$2(e.value)):none$c())),done:Dxe,fail:Lxe,make:()=>Fse(make$1h(none$c()),e=>new TDeferredImpl(e)),poll:e=>get$u(e.ref),succeed:Uxe});const Bxe=Symbol.for("effect/TMap"),zxe={_K:e=>e,_V:e=>e};class TMapImpl{tBuckets;tSize;[Bxe]=zxe;constructor(e,t){this.tBuckets=e,this.tSize=t}}const isTMap=e=>C(e,Bxe),indexOf=(e,t)=>(e=>{const t=hash$3(e);return t^t>>>16})(e)&t-1,qxe=dual(2,(e,t)=>Wxe(e,(e,r)=>{const n=t(e,r);return zt(n)?succeed$c(n.value):fail$c(none$c())})),Wxe=dual(2,(e,t)=>Xxe(e,none$c(),(e,r,n)=>Bt(e)?Cse(t(n,r),{onFailure:qt({onNone:()=>$oe,onSome:fail$c}),onSuccess:succeedSome$1}):ive(e))),Vxe=dual(2,(e,t)=>Kxe(e,(e,r)=>{const n=t(e,r);return zt(n)?succeed$c(n.value):fail$c(none$c())})),Kxe=dual(2,(e,t)=>Fse(Xxe(e,empty$R(),(e,r,n)=>Cse(t(n,r),{onFailure:qt({onNone:()=>succeed$c(e),onSome:fail$c}),onSuccess:t=>succeed$c(GA(e,t))})),e=>Array.from(e))),Gxe=dual(2,(e,t)=>Xxe(e,void 0,(e,r,n)=>asVoid$2(t(n,r)))),fromIterable$7=e=>suspend$8(()=>{const t=fromIterable$u(e);return((e,t)=>{const r=Array.from({length:e},()=>empty$R()),n=new Map(t);let i=0;for(const t of n){const n=indexOf(t[0],e);r[n]=pipe(r[n],JA(t)),i+=1}return pipe(fromIterable$9(r),Ase(e=>pipe(make$1h(e),Ase(e=>pipe(make$1h(i),Fse(t=>new TMapImpl(e,t)))))))})(t.length<16?16:(e=>{const t=-1>>>Math.clz32(e-1);return t<0?1:t+1})(t.length),t)}),Jxe=dual(2,(e,t)=>effect(r=>{const n=pae(e.tBuckets,r),i=indexOf(t,n.chunk.length),s=pae(n.chunk[i],r);return pipe(RC(s,e=>equals$4(e[0])(t)),er(e=>e[1]))})),Hxe=dual(3,(e,t,r)=>Fse(Jxe(e,t),Kt(r))),Zxe=dual(2,(e,t)=>Fse(Jxe(e,t),zt)),isEmpty$7=e=>Fse(get$u(e.tSize),e=>0===e),keys$3=e=>Fse(toReadonlyArray(e),as(e=>e[0])),Qxe=dual(4,(e,t,r,n)=>Ase(Jxe(e,t),qt({onNone:()=>qse(iIe(e,t,r),r),onSome:i=>{const s=n(i,r);return qse(iIe(e,t,s),s)}}))),Yxe=dual(3,(e,t,r)=>effect(n=>{const i=pae(e.tBuckets,n);let s=t,o=0;for(;o<i.chunk.length;){const e=i.chunk[o],t=pae(e,n);s=qC(t,s,(e,t)=>r(e,t[1],t[0])),o+=1}return s})),Xxe=dual(3,(e,t,r)=>Ase(toReadonlyArray(e),Ioe(t,(e,t)=>r(e,t[1],t[0])))),eIe=dual(2,(e,t)=>effect(r=>{const n=pae(e.tBuckets,r),i=indexOf(t,n.chunk.length),s=pae(n.chunk[i],r),[o,a]=dC(s,e=>equals$4(e[1],t));if(isNonEmpty$8(o)){const t=pae(e.tSize,r);fae(n.chunk[i],a,r),fae(e.tSize,t-1,r)}})),tIe=dual(2,(e,t)=>effect(r=>{const n=t[Symbol.iterator]();let i;for(;(i=n.next())&&!i.done;){const t=pae(e.tBuckets,r),n=indexOf(i.value,t.chunk.length),s=pae(t.chunk[n],r),[o,a]=dC(s,e=>equals$4(i.value)(e[0]));if(isNonEmpty$8(o)){const i=pae(e.tSize,r);fae(t.chunk[n],a,r),fae(e.tSize,i-1,r)}}})),rIe=dual(e=>isTMap(e[0]),(e,t,r)=>effect(n=>{const i=!0===r?.discard,s=pae(e.tBuckets,n),o=s.chunk.length,a=[];let u=0,c=0;for(;u<o;){const e=pae(s.chunk[u],n)[Symbol.iterator]();let r,o=empty$R();for(;(r=e.next())&&!r.done;){const[e,n]=r.value;t(e,n)?i||a.push([e,n]):(o=JA(o,r.value),c+=1)}fae(s.chunk[u],o,n),u+=1}if(fae(e.tSize,c,n),!i)return a})),nIe=dual(e=>isTMap(e[0]),(e,t,r)=>rIe(e,(e,r)=>!t(e,r),r)),iIe=dual(3,(e,t,r)=>effect(n=>{const i=pae(e.tBuckets,n),s=i.chunk.length,o=indexOf(t,s),a=pae(i.chunk[o],n);if(BC(a,e=>equals$4(t)(e[0]))){const e=fC(a,e=>equals$4(t)(e[0])?[t,r]:e);fae(i.chunk[o],e,n)}else{const u=pae(e.tSize,n)+1;if(fae(e.tSize,u,n),.75*s<u)((n,i)=>{const s=i.chunk.length,o=s<<1,a=Array.from({length:o},()=>empty$R());let u=0;for(;u<s;){const e=pae(i.chunk[u],n)[Symbol.iterator]();let t;for(;(t=e.next())&&!t.done;){const e=indexOf(t.value[0],o);a[e]=JA(a[e],t.value)}u+=1}const c=indexOf(t,o);a[c]=JA(a[c],[t,r]);const l=[];for(u=0;u<o;)l[u]=new TRefImpl(a[u]),u+=1;const p=new TArrayImpl(l);fae(e.tBuckets,p,n)})(n,i);else{const e=JA(a,[t,r]);fae(i.chunk[o],e,n)}}})),sIe=dual(3,(e,t,r)=>Ase(Jxe(e,t),qt({onNone:()=>iIe(e,t,r),onSome:()=>Voe}))),oIe=dual(2,(e,t)=>pipe(effect(r=>{const n=pae(e.tBuckets,r),i=n.chunk.length,s=pae(e.tSize,r);let o=none$c(),a=0;for(;a<i&&Bt(o);){const e=pae(n.chunk[a],r);if(BC(e,e=>zt(t(e[0],e[1])))){const i=e[Symbol.iterator]();let s,u=empty$R();for(;(s=i.next())&&!s.done&&Bt(o);){const e=t(s.value[0],s.value[1]);zt(e)&&Bt(o)?o=e:u=JA(u,s.value)}fae(n.chunk[a],u,r)}a+=1}return zt(o)&&fae(e.tSize,s-1,r),o}),Zse(e=>zt(e)?Ut(e.value):none$c()))),aIe=dual(2,(e,t)=>pipe(Wxe(e,(e,r)=>Fse(t(e,r),t=>[e,t])),Zse(e=>zt(e)?Ut(e.value):none$c()),Ase(t=>qse(eIe(e,t[0]),t[1])))),uIe=dual(2,(e,t)=>pipe(effect(r=>{const n=pae(e.tBuckets,r),i=n.chunk.length,s=[];let o=0,a=0;for(;a<i;){const e=pae(n.chunk[a],r);if(BC(e,e=>zt(t(e[0],e[1])))){const i=e[Symbol.iterator]();let u,c=empty$R();for(;(u=i.next())&&!u.done;){const e=t(u.value[0],u.value[1]);zt(e)?s.push(e.value):(c=JA(c,u.value),o+=1)}fae(n.chunk[a],c,r)}else o+=e.length;a+=1}return fae(e.tSize,o,r),s.length>0?Ut(s):none$c()}),Zse(e=>zt(e)?Ut(e.value):none$c()))),cIe=dual(2,(e,t)=>pipe(Kxe(e,(e,r)=>Fse(t(e,r),t=>[e,t])),Fse(e=>ui(e)?Ut(e):none$c()),Zse(e=>zt(e)?Ut(e.value):none$c()),Ase(t=>qse(tIe(e,t.map(e=>e[0])),as(t,e=>e[1]))))),toReadonlyArray=e=>effect(t=>{const r=pae(e.tBuckets,t),n=r.chunk.length,i=[];let s=0;for(;s<n;){const e=r.chunk[s];for(const r of pae(e,t))i.push(r);s+=1}return i}),lIe=dual(2,(e,t)=>effect(r=>{const n=pipe(e.tBuckets,pae(r)),i=n.chunk.length,s=Array.from({length:i},()=>empty$R());let o=0,a=0;for(;a<i;){const e=n.chunk[a],u=pae(e,r)[Symbol.iterator]();let c;for(;(c=u.next())&&!c.done;){const e=t(c.value[0],c.value[1]),r=indexOf(e[0],i),n=s[r];BC(n,t=>equals$4(t[0],e[0]))||(s[r]=JA(n,e),o+=1)}a+=1}for(a=0;a<i;)fae(n.chunk[a],s[a],r),a+=1;fae(e.tSize,o,r)})),pIe=dual(2,(e,t)=>pipe(Ase(toReadonlyArray(e),coe(e=>t(e[0],e[1]))),Ase(t=>effect(r=>{const n=pae(e.tBuckets,r),i=n.chunk.length,s=Array.from({length:i},()=>empty$R()),o=t[Symbol.iterator]();let a,u=0;for(;(a=o.next())&&!a.done;){const e=indexOf(a.value[0],i),t=s[e];BC(t,e=>equals$4(e[0])(a.value[0]))||(s[e]=JA(t,a.value),u+=1)}let c=0;for(;c<i;)fae(n.chunk[c],s[c],r),c+=1;fae(e.tSize,u,r)})))),fIe=dual(2,(e,t)=>lIe(e,(e,r)=>[e,t(r)])),hIe=dual(2,(e,t)=>pIe(e,(e,r)=>Fse(t(r),t=>[e,t]))),dIe=dual(3,(e,t,r)=>Ase(Jxe(e,t),n=>qt(r(n),{onNone:()=>qse(eIe(e,t),none$c()),onSome:r=>qse(iIe(e,t,r),Ut(r))})));var mIe=Object.freeze({__proto__:null,TMapTypeId:Bxe,empty:()=>fromIterable$7([]),find:qxe,findAll:Vxe,findAllSTM:Kxe,findSTM:Wxe,forEach:Gxe,fromIterable:fromIterable$7,get:Jxe,getOrElse:Hxe,has:Zxe,isEmpty:isEmpty$7,keys:keys$3,make:(...e)=>fromIterable$7(e),merge:Qxe,reduce:Yxe,reduceSTM:Xxe,remove:eIe,removeAll:tIe,removeIf:rIe,retainIf:nIe,set:iIe,setIfAbsent:sIe,size:e=>get$u(e.tSize),takeFirst:oIe,takeFirstSTM:aIe,takeSome:uIe,takeSomeSTM:cIe,toArray:e=>Yxe(e,[],(e,t,r)=>(e.unshift([r,t]),e)),toChunk:e=>Yxe(e,empty$R(),(e,t,r)=>GA(e,[r,t])),toHashMap:e=>Yxe(e,mP(),(e,t,r)=>pipe(e,vP(r,t))),toMap:e=>Yxe(e,new Map,(e,t,r)=>e.set(r,t)),transform:lIe,transformSTM:pIe,transformValues:fIe,transformValuesSTM:hIe,updateWith:dIe,values:e=>Fse(toReadonlyArray(e),as(e=>e[1]))});const gIe=Symbol.for("effect/TPriorityQueue"),yIe={_A:e=>e};class TPriorityQueueImpl{ref;[gIe]=yIe;constructor(e){this.ref=e}}const fromIterable$5=e=>t=>pipe(make$1h(fromIterable$v(t).reduce((e,t)=>pipe(e,yke(t,pipe(e,fke(t),qt({onNone:()=>of$6(t),onSome:ei(t)})))),empty$c(e))),Fse(e=>new TPriorityQueueImpl(e))),bIe=dual(2,(e,t)=>aae(e.ref,e=>yke(e,t,qt(fke(e,t),{onNone:()=>of$6(t),onSome:ei(t)})))),SIe=dual(2,(e,t)=>aae(e.ref,e=>fromIterable$v(t).reduce((e,t)=>yke(e,t,qt(fke(e,t),{onNone:()=>of$6(t),onSome:ei(t)})),e))),vIe=dual(2,(e,t)=>_Ie(e,e=>!t(e))),_Ie=dual(2,(e,t)=>aae(e.ref,e=>mke(e,empty$c(getOrder(e)),(e,r,n)=>{const i=ds(r,t);return i.length>0?yke(e,n,i):gke(e,n)}))),wIe=dual(2,(e,t)=>sae(e.ref,e=>{const r=[],n=e[Symbol.iterator]();let i,s=e,o=0;for(;(i=n.next())&&!i.done&&o<t;){const[e,n]=i.value,[a,u]=pipe(n,Gi(t-o));for(const e of a)r.push(e);s=u.length>0?yke(s,e,u):gke(s,e),o+=a.length}return[r,s]}));var kIe=Object.freeze({__proto__:null,TPriorityQueueTypeId:gIe,empty:e=>pipe(make$1h(empty$c(e)),Fse(e=>new TPriorityQueueImpl(e))),fromIterable:fromIterable$5,isEmpty:e=>Fse(get$u(e.ref),isEmpty$8),isNonEmpty:e=>Fse(get$u(e.ref),isNonEmpty$2),make:e=>(...t)=>fromIterable$5(e)(t),offer:bIe,offerAll:SIe,peek:e=>withSTMRuntime(t=>{const r=pae(e.ref,t.journal);return qt(headOption$2(r),{onNone:()=>Nse,onSome:e=>succeed$c(e[0])})}),peekOption:e=>sae(e.ref,e=>[er(headOption$2(e),e=>e[0]),e]),removeIf:vIe,retainIf:_Ie,size:e=>sae(e.ref,e=>[mke(e,0,(e,t)=>e+t.length),e]),take:e=>withSTMRuntime(t=>{const r=pae(e.ref,t.journal);return qt(headOption$2(r),{onNone:()=>Nse,onSome:n=>{const i=n[1][0],s=n[1].slice(1);return fae(e.ref,s.length>0?yke(r,i,s):gke(r,i),t.journal),succeed$c(i)}})}),takeAll:e=>sae(e.ref,e=>{const t=[];for(const r of e)for(const e of r[1])t.push(e);return[t,empty$c(getOrder(e))]}),takeOption:e=>effect(t=>{const r=pipe(e.ref,pae(t));return qt(headOption$2(r),{onNone:()=>none$c(),onSome:([n,i])=>{const s=i.slice(1);return fae(e.ref,s.length>0?yke(r,n,s):gke(r,n),t),Ut(i[0])}})}),takeUpTo:wIe,toArray:e=>sae(e.ref,e=>{const t=[];for(const r of e)for(const e of r[1])t.push(e);return[t,e]}),toChunk:e=>sae(e.ref,e=>{const t=[];for(const r of e)for(const e of r[1])t.push(e);return[unsafeFromArray(t),e]})});const xIe=Symbol.for("effect/TRandom"),randomInteger=e=>{const t=new PCGRandom;return t.setState(e),[t.integer(0),t.getState()]},randomNumber=e=>{const t=new PCGRandom;return t.setState(e),[t.number(),t.getState()]},withState=(e,t)=>pipe(e,sae(t)),IIe=GenericTag("effect/TRandom");class TRandomImpl{state;[xIe]=xIe;constructor(e){this.state=e,this.next=withState(this.state,randomNumber),this.nextBoolean=Ase(this.next,e=>succeed$c(e>.5)),this.nextInt=withState(this.state,randomInteger)}next;nextBoolean;nextInt;nextRange(e,t){return Ase(this.next,r=>succeed$c((t-e)*r+e))}nextIntBetween(e,t){return withState(this.state,((e,t)=>r=>{const n=new PCGRandom;return n.setState(r),[n.integer(t-e)+e,n.getState()]})(e,t))}shuffle(e){return t=e=>this.nextIntBetween(0,e),pipe(fromIterable$9(e),Ase(e=>{const r=[];for(let e=r.length;e>=2;e-=1)r.push(e);return pipe(r,coe(r=>pipe(t(r),Ase(t=>((e,t,r)=>pipe(e,_xe(t),Ase(n=>pipe(e,Pxe(t,()=>pipe(e,_xe(r))),Dse(pipe(e,Fxe(r,()=>n)))))))(e,r-1,t))),{discard:!0}),Dse(toArray$7(e)))}));var t}}const TIe=V9(IIe,pipe(make$1h(new PCGRandom(4294967296*Math.random()>>>0).getState()),Fse(e=>new TRandomImpl(e)),commit$1)),OIe=Ase(IIe,e=>e.next),EIe=Ase(IIe,e=>e.nextBoolean),AIe=Ase(IIe,e=>e.nextInt);var CIe=Object.freeze({__proto__:null,TRandomTypeId:xIe,Tag:IIe,live:TIe,next:OIe,nextBoolean:EIe,nextInt:AIe,nextIntBetween:(e,t)=>Ase(IIe,r=>r.nextIntBetween(e,t)),nextRange:(e,t)=>Ase(IIe,r=>r.nextRange(e,t)),shuffle:e=>Ase(IIe,t=>t.shuffle(e))});const MIe=Symbol.for("effect/TReentrantLock"),FIe=Symbol.for("effect/TReentrantLock/WriteLock"),PIe=Symbol.for("effect/TReentrantLock/ReadLock");class TReentranLockImpl{state;[MIe]=MIe;constructor(e){this.state=e}}class ReadLock{readers;[PIe]=PIe;constructor(e){this.readers=e}get readLocks(){return Array.from(this.readers).reduce((e,t)=>e+t[1],0)}get writeLocks(){return 0}readLocksHeld(e){return Kt(yP(this.readers,e),()=>0)}writeLocksHeld(e){return 0}}class WriteLock{readLocks;writeLocks;fiberId;[FIe]=FIe;constructor(e,t,r){this.readLocks=e,this.writeLocks=t,this.fiberId=r}readLocksHeld(e){return equals$4(e)(this.fiberId)?this.readLocks:0}writeLocksHeld(e){return equals$4(e)(this.fiberId)?this.writeLocks:0}}const isReadLock=e=>PIe in e,isWriteLock=e=>FIe in e,NIe=new ReadLock(mP()),adjustRead=(e,t)=>withSTMRuntime(r=>{const n=pae(e.state,r.journal);if(isReadLock(n)){const i=((e,t,r)=>{const n=e.readLocksHeld(t)+r;if(n<0)throw Error("BUG - TReentrantLock.ReadLock.adjust - please report an issue at https://github.com/Effect-TS/effect/issues");return new ReadLock(0===n?IP(e.readers,t):vP(e.readers,t,n))})(n,r.fiberId,t);return fae(e.state,i,r.journal),succeed$c(i.readLocksHeld(r.fiberId))}if(isWriteLock(n)&&equals$4(r.fiberId)(n.fiberId)){const i=n.readLocks+t;if(i<0)throw Error(`Defect: Fiber ${fP(r.fiberId)} releasing read locks it does not hold, newTotal: ${i}`);return fae(e.state,new WriteLock(i,n.writeLocks,r.fiberId),r.journal),succeed$c(i)}return Nse}),acquireRead$1=e=>adjustRead(e,1),acquireWrite$1=e=>withSTMRuntime(t=>{const r=pae(e.state,t.journal);return isReadLock(r)&&((e,t)=>isEmpty$r(e.readers)||1===wP(e.readers)&&SP(e.readers,t))(r,t.fiberId)?(fae(e.state,new WriteLock(r.readLocksHeld(t.fiberId),1,t.fiberId),t.journal),succeed$c(1)):isWriteLock(r)&&equals$4(t.fiberId)(r.fiberId)?(fae(e.state,new WriteLock(r.readLocks,r.writeLocks+1,t.fiberId),t.journal),succeed$c(r.writeLocks+1)):Nse}),jIe=Fse(make$1h(NIe),e=>new TReentranLockImpl(e)),readLocked$1=e=>Fse(get$u(e.state),e=>e.readLocks>0),releaseRead$1=e=>adjustRead(e,-1),releaseWrite$1=e=>withSTMRuntime(t=>{const r=pae(e.state,t.journal);if(isWriteLock(r)&&1===r.writeLocks&&equals$4(t.fiberId)(r.fiberId)){const n=((e,t)=>t<=0?NIe:new ReadLock(make$24([e,t])))(r.fiberId,r.readLocks);return fae(e.state,n,t.journal),succeed$c(n.writeLocksHeld(t.fiberId))}if(isWriteLock(r)&&equals$4(t.fiberId)(r.fiberId)){const n=new WriteLock(r.readLocks,r.writeLocks-1,t.fiberId);return fae(e.state,n,t.journal),succeed$c(n.writeLocksHeld(t.fiberId))}throw Error(`Defect: Fiber ${fP(t.fiberId)} releasing write lock it does not hold`)}),RIe=dual(2,(e,t)=>LIe(e,t)),DIe=dual(2,(e,t)=>T3(r=>j8(r(commit$1(acquireRead$1(t))),q3(e,commit$1(releaseRead$1(t)))))),LIe=dual(2,(e,t)=>T3(r=>j8(r(commit$1(acquireWrite$1(t))),q3(e,commit$1(releaseWrite$1(t)))))),writeLock$1=e=>U3(commit$1(acquireWrite$1(e)),()=>commit$1(releaseWrite$1(e))),writeLocked$1=e=>Fse(get$u(e.state),e=>e.writeLocks>0);var UIe=Object.freeze({__proto__:null,TReentrantLockTypeId:MIe,acquireRead:acquireRead$1,acquireWrite:acquireWrite$1,fiberReadLocks:e=>effect((t,r)=>pae(e.state,t).readLocksHeld(r)),fiberWriteLocks:e=>effect((t,r)=>pae(e.state,t).writeLocksHeld(r)),lock:e=>writeLock$1(e),locked:e=>Lse(readLocked$1(e),writeLocked$1(e),(e,t)=>e||t),make:jIe,readLock:e=>U3(commit$1(acquireRead$1(e)),()=>commit$1(releaseRead$1(e))),readLocked:readLocked$1,readLocks:e=>Fse(get$u(e.state),e=>e.readLocks),releaseRead:releaseRead$1,releaseWrite:releaseWrite$1,withLock:RIe,withReadLock:DIe,withWriteLock:LIe,writeLock:writeLock$1,writeLocked:writeLocked$1,writeLocks:e=>Fse(get$u(e.state),e=>e.writeLocks)});const $Ie=Yoe,BIe=get$u,zIe=make$1h,qIe=eae;var WIe=Object.freeze({__proto__:null,TRefTypeId:$Ie,get:BIe,getAndSet:tae,getAndUpdate:rae,getAndUpdateSome:nae,make:zIe,modify:sae,modifySome:oae,set:qIe,setAndGet:iae,update:aae,updateAndGet:uae,updateSome:cae,updateSomeAndGet:lae});const VIe=Symbol.for("effect/TSemaphore");class TSemaphoreImpl{permits;[VIe]=VIe;constructor(e){this.permits=e}}const KIe=dual(2,(e,t)=>withSTMRuntime(r=>{if(t<0)throw new tY(`Unexpected negative value ${t} passed to Semaphore.acquireN`);const n=pae(e.permits,r.journal);return n<t?tve:ive(fae(e.permits,n-t,r.journal))})),GIe=dual(2,(e,t)=>withSTMRuntime(r=>{if(t<0)throw new tY(`Unexpected negative value ${t} passed to Semaphore.releaseN`);const n=pae(e.permits,r.journal);return ive(fae(e.permits,n+t,r.journal))})),JIe=dual(2,(e,t)=>HIe(e,t,1)),HIe=dual(3,(e,t,r)=>T3(n=>j8(n(commit$1(KIe(r)(t))),q3(e,commit$1(GIe(r)(t)))))),ZIe=dual(2,(e,t)=>$3(commit$1(KIe(e,t)),()=>commit$1(GIe(e,t))));var QIe=Object.freeze({__proto__:null,TSemaphoreTypeId:VIe,acquire:e=>KIe(e,1),acquireN:KIe,available:e=>get$u(e.permits),make:e=>ISe(make$1h(e),e=>new TSemaphoreImpl(e)),release:e=>GIe(e,1),releaseN:GIe,unsafeMake:e=>new TSemaphoreImpl(new TRefImpl(e)),withPermit:JIe,withPermitScoped:e=>ZIe(e,1),withPermits:HIe,withPermitsScoped:ZIe});const YIe=Symbol.for("effect/TSet"),XIe={_A:e=>e};class TSetImpl{tMap;[YIe]=XIe;constructor(e){this.tMap=e}}const isTSet=e=>C(e,YIe),eTe=dual(2,(e,t)=>iIe(e.tMap,t,void 0)),tTe=dual(2,(e,t)=>Ase(toHashSet$1(t),t=>cTe(e,e=>TF(t,e),{discard:!0}))),rTe=dual(2,(e,t)=>oTe(e,void 0,(e,r)=>t(r))),fromIterable$3=e=>Fse(fromIterable$7(Array.from(e).map(e=>[e,void 0])),e=>new TSetImpl(e)),nTe=dual(2,(e,t)=>Zxe(e.tMap,t)),iTe=dual(2,(e,t)=>Ase(toHashSet$1(t),t=>pipe(e,lTe(e=>pipe(t,TF(e)),{discard:!0})))),sTe=dual(3,(e,t,r)=>Yxe(e.tMap,t,(e,t,n)=>r(e,n))),oTe=dual(3,(e,t,r)=>Xxe(e.tMap,t,(e,t,n)=>r(e,n))),aTe=dual(2,(e,t)=>eIe(e.tMap,t)),uTe=dual(2,(e,t)=>tIe(e.tMap,t)),cTe=dual(e=>isTSet(e[0]),(e,t,r)=>!0===r?.discard?rIe(e.tMap,e=>t(e),{discard:!0}):pipe(rIe(e.tMap,e=>t(e)),Fse(as(e=>e[0])))),lTe=dual(e=>isTSet(e[0]),(e,t,r)=>!0===r?.discard?nIe(e.tMap,e=>t(e),{discard:!0}):pipe(nIe(e.tMap,e=>t(e)),Fse(as(e=>e[0])))),pTe=dual(2,(e,t)=>oIe(e.tMap,e=>t(e))),fTe=dual(2,(e,t)=>aIe(e.tMap,e=>t(e))),hTe=dual(2,(e,t)=>uIe(e.tMap,e=>t(e))),dTe=dual(2,(e,t)=>cIe(e.tMap,e=>t(e))),toChunk$1=e=>keys$3(e.tMap).pipe(ISe(unsafeFromArray)),toHashSet$1=e=>sTe(e,IF(),(e,t)=>pipe(e,AF(t))),toArray$1=e=>sTe(e,[],(e,t)=>[...e,t]),mTe=dual(2,(e,t)=>lIe(e.tMap,(e,r)=>[t(e),r])),gTe=dual(2,(e,t)=>pIe(e.tMap,(e,r)=>Fse(t(e),e=>[e,r]))),yTe=dual(2,(e,t)=>rTe(t,t=>eTe(e,t)));var bTe=Object.freeze({__proto__:null,TSetTypeId:YIe,add:eTe,difference:tTe,empty:()=>fromIterable$3([]),forEach:rTe,fromIterable:fromIterable$3,has:nTe,intersection:iTe,isEmpty:e=>isEmpty$7(e.tMap),make:(...e)=>fromIterable$3(e),reduce:sTe,reduceSTM:oTe,remove:aTe,removeAll:uTe,removeIf:cTe,retainIf:lTe,size:e=>Fse(toChunk$1(e),e=>e.length),takeFirst:pTe,takeFirstSTM:fTe,takeSome:hTe,takeSomeSTM:dTe,toArray:toArray$1,toChunk:toChunk$1,toHashSet:toHashSet$1,toReadonlySet:e=>Fse(toArray$1(e),e=>new Set(e)),transform:mTe,transformSTM:gTe,union:yTe});const STe=Symbol.for("effect/TSubscriptionRef"),vTe={_A:e=>e};class TDequeueMerge{first;second;[Mae]=bae;constructor(e,t){this.first=e,this.second=t}peek=gen(this,function*(){const e=yield*this.peekOption;return"Some"===e._tag?e.value:yield*tve});peekOption=gen(this,function*(){const e=yield*this.first.peekOption;if("Some"===e._tag)return e;const t=yield*this.second.peekOption;return"Some"===t._tag?t:none$c()});take=gen(this,function*(){return(yield*this.first.isEmpty)?(yield*this.second.isEmpty)?yield*tve:yield*this.second.take:yield*this.first.take});takeAll=gen(this,function*(){return[...yield*this.first.takeAll,...yield*this.second.takeAll]});takeUpTo(e){return gen(this,function*(){const t=yield*this.first.takeUpTo(e);return t.length>=e?t:[...t,...yield*this.second.takeUpTo(e-t.length)]})}capacity(){return this.first.capacity()+this.second.capacity()}size=gen(this,function*(){return(yield*this.first.size)+(yield*this.second.size)});isFull=gen(this,function*(){return(yield*this.first.isFull)&&(yield*this.second.isFull)});isEmpty=gen(this,function*(){return(yield*this.first.isEmpty)&&(yield*this.second.isEmpty)});shutdown=gen(this,function*(){yield*this.first.shutdown,yield*this.second.shutdown});isShutdown=gen(this,function*(){return(yield*this.first.isShutdown)&&(yield*this.second.isShutdown)});awaitShutdown=gen(this,function*(){yield*this.first.awaitShutdown,yield*this.second.awaitShutdown})}class TSubscriptionRefImpl{ref;pubsub;[STe]=vTe;[$Ie]=Xoe;constructor(e,t){this.ref=e,this.pubsub=t}get todos(){return this.ref.todos}get versioned(){return this.ref.versioned}pipe(){return pipeArguments(this,arguments)}get changes(){return gen(this,function*(){const e=yield*unbounded();return yield*Fae(e,yield*BIe(this.ref)),new TDequeueMerge(e,yield*Aae(this.pubsub))})}modify(e){return pipe(BIe(this.ref),ISe(e),hSe(([e,t])=>pipe(qIe(this.ref,t),Rbe(e),_ve(Eae(this.pubsub,t)))))}}const _Te=dual(2,(e,t)=>e.modify(()=>[void 0,t])),wTe=dual(2,(e,t)=>e.modify(e=>[e,t])),kTe=dual(2,(e,t)=>e.modify(e=>[e,t(e)])),xTe=dual(2,(e,t)=>e.modify(e=>qt(t(e),{onNone:()=>[e,e],onSome:t=>[e,t]}))),ITe=dual(2,(e,t)=>e.modify(()=>[t,t]));var TTe=Object.freeze({__proto__:null,TSubscriptionRefTypeId:STe,changes:e=>e.changes,changesScoped:e=>U3(e.changes,Pae),changesStream:e=>unwrap$6(P3(e.changes,fromTQueue$1)),get:e=>BIe(e.ref),getAndSet:wTe,getAndUpdate:kTe,getAndUpdateSome:xTe,make:e=>pipe(jbe([unbounded$1(),zIe(e)]),ISe(([e,t])=>new TSubscriptionRefImpl(t,e))),modify:dual(2,(e,t)=>e.modify(t)),modifySome:dual(3,(e,t,r)=>e.modify(e=>qt(r(e),{onNone:()=>[t,e],onSome:e=>e}))),set:_Te,setAndGet:ITe,update:dual(2,(e,t)=>e.modify(e=>[void 0,t(e)])),updateAndGet:dual(2,(e,t)=>e.modify(e=>{const r=t(e);return[r,r]})),updateSome:dual(2,(e,t)=>e.modify(e=>[void 0,qt(t(e),{onNone:()=>e,onSome:e=>e})])),updateSomeAndGet:dual(2,(e,t)=>e.modify(e=>qt(t(e),{onNone:()=>[e,e],onSome:e=>[e,e]})))});var OTe=Object.freeze({__proto__:null,TakeTypeId:Gae,chunk:chunk$3,die:e=>new TakeImpl(IU(e)),dieMessage:e=>new TakeImpl(IU(new nY(e))),done:done$5,end:Hae,fail:e=>new TakeImpl(TU(Ut(e))),failCause:failCause$6,fromEffect:e=>q7(e,{onFailure:failCause$6,onSuccess:of$1}),fromExit:e=>new TakeImpl(pipe(e,MU({onFailure:Ut,onSuccess:of$5}))),fromPull:fromPull$3,isDone:e=>FU(e.exit,{onFailure:e=>Bt(flipCauseOption(e)),onSuccess:n}),isFailure:e=>FU(e.exit,{onFailure:e=>zt(flipCauseOption(e)),onSuccess:n}),isSuccess:e=>FU(e.exit,{onFailure:n,onSuccess:r}),make:e=>new TakeImpl(e),map:Yae,match:Zae,matchEffect:Qae,of:of$1,tap:Xae});const ETe="effect/TestAnnotation",ATe=Symbol.for(ETe);class TestAnnotationImpl{identifier;initial;combine;[ATe]={_A:e=>e};constructor(e,t,r){this.identifier=e,this.initial=t,this.combine=r}[Z](){return pipe(hash$3(ETe),combine$h(hash$3(this.identifier)),cached$2(this))}[Y](e){return isTestAnnotation(e)&&this.identifier===e.identifier}}const isTestAnnotation=e=>C(e,ATe),make$7=(e,t,r)=>new TestAnnotationImpl(e,t,r),compose=(e,t)=>{if(Xe(e)&&Xe(t))return He(e.left+t.left);if(et(e)&&et(t))return Ge(pipe(e.right,eC(t.right)));if(et(e)&&Xe(t))return t;if(Xe(e)&&et(t))return t;throw Error(getBugErrorMessage("TestAnnotation.compose"))},CTe=make$7("fibers",He(0),compose);var MTe=Object.freeze({__proto__:null,TestAnnotationTypeId:ATe,compose,fibers:CTe,ignored:make$7("ignored",0,(e,t)=>e+t),isTestAnnotation,make:make$7,repeated:make$7("repeated",0,(e,t)=>e+t),retried:make$7("retried",0,(e,t)=>e+t),tagged:make$7("tagged",IF(),(e,t)=>pipe(e,FF(t)))});const FTe=Symbol.for("effect/TestAnnotationMap");class TestAnnotationMapImpl{map;[FTe]=FTe;constructor(e){this.map=e}}const empty$2=()=>new TestAnnotationMapImpl(mP()),make$6=e=>new TestAnnotationMapImpl(e),PTe=dual(3,(e,t,r)=>make$6(vP(e.map,t,r))),NTe=dual(3,(e,t,r)=>{let n=t.initial;return SP(e.map,t)&&(n=bP(e.map,t)),PTe(e,t,r(n))}),jTe=dual(2,(e,t)=>SP(e.map,t)?bP(e.map,t):t.initial),RTe=dual(3,(e,t,r)=>NTe(e,t,e=>t.combine(e,r)));var DTe=Object.freeze({__proto__:null,TestAnnotationMapTypeId:FTe,annotate:RTe,combine:dual(2,(e,t)=>{let r=e.map;for(const e of t.map)if(SP(r,e[0])){const t=yP(r,e[0]);r=vP(r,e[0],e[0].combine(t,e[1]))}else r=vP(r,e[0],e[1]);return make$6(r)}),empty:empty$2,get:jTe,isTestAnnotationMap:e=>C(e,FTe),make:make$6,overwrite:PTe,update:NTe});const LTe=Symbol.for("effect/TestAnnotations");class AnnotationsImpl{ref;[LTe]=LTe;constructor(e){this.ref=e}get(e){return qR(jz(this.ref),jTe(e))}annotate(e,t){return qz(this.ref,RTe(e,t))}get supervisedFibers(){return descriptorWith$1(e=>PR(this.get(CTe),t=>{switch(t._tag){case"Left":return succeed$u(empty$s(gG));case"Right":return pipe(t.right,LR(e=>sync$l(()=>get$E(e))),qR(ys(empty$s(gG),(e,t)=>mZ(e,t))),qR(iZ(t=>!equals$4(t.id(),e.id))))}}))}}const UTe=GenericTag("effect/Annotations"),make$5=e=>new AnnotationsImpl(e);var $Te=Object.freeze({__proto__:null,TestAnnotations:UTe,TestAnnotationsTypeId:LTe,isTestAnnotations:e=>C(e,LTe),make:make$5});const BTe="Start",zTe="Pending",qTe={_tag:BTe},WTe={_tag:"Done"},VTe="Start",KTe="Pending",start={_tag:VTe},GTe={_tag:"Done"},isStart=e=>e._tag===VTe,JTe=Symbol.for("effect/TestLive"),HTe=GenericTag("effect/TestLive");class LiveImpl{services;[JTe]=JTe;constructor(e){this.services=e}provide(e){return UD(pB,LA(this.services))(e)}}const make$4=e=>new LiveImpl(e);var ZTe=Object.freeze({__proto__:null,TestLive:HTe,TestLiveTypeId:JTe,make:make$4});const makeData=(e,t)=>({instant:e,sleeps:t}),QTe=GenericTag("effect/TestClock");class TestClockImpl{clockState;live;annotations;warningState;suspendedWarningState;[u$]=u$;constructor(e,t,r,n,i){this.clockState=e,this.live=t,this.annotations=r,this.warningState=n,this.suspendedWarningState=i,this.currentTimeMillis=qR(get$z(this.clockState),e=>e.instant),this.currentTimeNanos=qR(get$z(this.clockState),e=>BigInt(1e6*e.instant))}unsafeCurrentTimeMillis(){return unsafeGet$6(this.clockState).instant}unsafeCurrentTimeNanos(){return BigInt(1e6*unsafeGet$6(this.clockState).instant)}currentTimeMillis;currentTimeNanos;get save(){return qR(get$z(this.clockState),e=>wz(this.clockState,e))}setTime(e){return lD(this.warningDone(),this.run(()=>e))}sleep(e){const t=decode$5(e);return PR(deferredMake(),e=>pipe(Oz(this.clockState,r=>{const n=r.instant+toMillis(t);return n>r.instant?[!0,makeData(r.instant,pipe(r.sleeps,JA([n,e])))]:[!1,r]}),PR(t=>t?pipe(this.warningStart(),lD(deferredAwait(e))):pipe(nU(e,void 0),asVoid$9))))}get sleeps(){return qR(get$z(this.clockState),e=>fC(e.sleeps,e=>e[0]))}adjust(e){const t=decode$5(e);return lD(this.warningDone(),this.run(e=>e+toMillis(t)))}adjustWith(e){const t=decode$5(e);return e=>bQ(e,this.adjust(t),{concurrent:!0})}supervisedFibers(){return this.annotations.supervisedFibers}freeze(){return PR(this.supervisedFibers(),e=>pipe(e,Zq(mP(),(e,t)=>pipe(t.status,PR(r=>isDone$5(r)||isSuspended(r)?succeed$u(vP(e,t.id(),r)):fail$r(void 0))))))}warningStart(){return XX(this.warningState,e=>isStart(e)?Ut(pipe(this.live.provide(pipe(Lq("Warning: A test is using time, but is not advancing the test clock, which may result in the test hanging. Use TestClock.adjust to manually advance the time."),dq(seconds(5)))),interruptible$3,fork$2,qR(e=>(e=>({_tag:KTe,fiber:e}))(e)))):none$c())}warningDone(){return XX(this.warningState,e=>isStart(e)?Ut(succeed$u(GTe)):e._tag===KTe?Ut(pipe(interruptFiber(e.fiber),TR(GTe))):none$c())}yieldTimer=async_(e=>{const t=setTimeout(()=>{e(tD)},0);return sync$l(()=>clearTimeout(t))});suspended(){return pipe(this.freeze(),uD(pipe(this.yieldTimer,lD(this.freeze()))),PR(([e,t])=>equals$4(e,t)?succeed$u(e):fail$r(void 0)))}awaitSuspended(){return pipe(this.suspendedWarningStart(),lD(pipe(this.suspended(),pD(pipe(this.yieldTimer,lD(this.suspended())),equals$4),Eq(identity$5,o),eventually$3)),lD(this.suspendedWarningDone()))}suspendedWarningStart(){return XX(this.suspendedWarningState,e=>e._tag===BTe?Ut(pipe(this.live.provide(pipe(Lq("Warning: A test is advancing the test clock, but a fiber is not suspending, which may result in the test hanging. Use TestAspect.diagnose to identity the fiber that is not suspending."),lD(wz(this.suspendedWarningState,WTe)),dq(seconds(5)))),interruptible$3,fork$2,qR(e=>(e=>({_tag:zTe,fiber:e}))(e)))):none$c())}suspendedWarningDone(){return XX(this.suspendedWarningState,e=>e._tag===zTe?Ut(pipe(interruptFiber(e.fiber),TR(qTe))):none$c())}run(e){return pipe(this.awaitSuspended(),lD(pipe(Oz(this.clockState,t=>{const r=e(t.instant),n=pipe(t.sleeps,gC(pipe(qI,Pt(e=>e[0]))));if(isNonEmpty$8(n)){const[e,t]=lC(n);if(e<=r)return[Ut([r,t]),makeData(e,tailNonEmpty(n))]}return[none$c(),makeData(r,t.sleeps)]}),PR(e=>{switch(e._tag){case"None":return tD;case"Some":{const[t,r]=e.value;return pipe(nU(r,void 0),lD(yieldNow$3()),lD(this.run(()=>t)))}}}))))}}const live$2=e=>k0(QTe,gen$4(function*(t){const r=yield*t(HTe),n=yield*t(UTe),i=yield*t(sync$l(()=>unsafeMake$d(e))),s=yield*t(makeSynchronized(start)),o=yield*t(makeSynchronized(qTe)),a=new TestClockImpl(i,r,n,s,o);return yield*t(withClockScoped$1(a)),yield*t(addFinalizer$2(()=>lD(a.warningDone(),a.suspendedWarningDone()))),a})),YTe=live$2(makeData(new Date(0).getTime(),empty$R())),XTe=dual(2,(e,t)=>{const r=decode$5(t);return testClockWith(t=>t.adjustWith(r)(e))}),testClockWith=e=>ED(pB,t=>e(pipe(t,jA(c$))));var eOe=Object.freeze({__proto__:null,TestClock:QTe,TestClockImpl,adjust:e=>{const t=decode$5(e);return testClockWith(e=>e.adjust(t))},adjustWith:XTe,currentTimeMillis:testClockWith(e=>e.currentTimeMillis),defaultTestClock:YTe,live:live$2,makeData,save:()=>testClockWith(e=>e.save),setTime:e=>testClockWith(t=>t.setTime("number"==typeof e?e:ihe(e).epochMillis)),sleep:e=>{const t=decode$5(e);return testClockWith(e=>e.sleep(t))},sleeps:()=>testClockWith(e=>e.sleeps),testClock:()=>testClockWith(succeed$u),testClockWith});const tOe=GenericTag("effect/TestConfig"),make$3=e=>e;var rOe=Object.freeze({__proto__:null,TestConfig:tOe,make:make$3});const nOe=Symbol.for("effect/TestSized"),iOe=GenericTag("effect/TestSized");class SizedImpl{fiberRef;[nOe]=nOe;constructor(e){this.fiberRef=e}get size(){return fiberRefGet(this.fiberRef)}withSize(e){return t=>LD(this.fiberRef,e)(t)}}const make$2=e=>new SizedImpl(fiberRefUnsafeMake(e)),fromFiberRef=e=>new SizedImpl(e);var sOe=Object.freeze({__proto__:null,TestSized:iOe,TestSizedTypeId:nOe,fromFiberRef,make:make$2});const oOe=pipe(PA(UTe,make$5(unsafeMake$d(empty$2()))),NA(HTe,make$4(lB)),NA(iOe,make$2(100)),NA(tOe,make$3({repeats:100,retries:100,samples:200,shrinks:1e3}))),aOe=fiberRefUnsafeMakeContext(oOe),annotationsWith=e=>ED(aOe,t=>e(jA(t,UTe))),uOe=dual(2,(e,t)=>UD(aOe,NA(UTe,t))(e)),withAnnotationsScoped=e=>OQ(aOe,NA(UTe,e)),annotationsLayer=()=>k0(UTe,pipe(sync$l(()=>unsafeMake$d(empty$2())),qR(make$5),XR(withAnnotationsScoped))),liveWith=e=>ED(aOe,t=>e(jA(t,HTe))),cOe=liveWith(succeed$u),lOe=dual(2,(e,t)=>UD(aOe,NA(HTe,t))(e)),withLiveScoped=e=>OQ(aOe,NA(HTe,e)),liveLayer=()=>k0(HTe,pipe(context$c(),qR(make$4),XR(withLiveScoped))),provideLive=e=>liveWith(t=>t.provide(e)),pOe=dual(2,(e,t)=>ED(pB,r=>provideLive(t(LD(pB,r)(e))))),sizedWith=e=>ED(aOe,t=>e(jA(t,iOe))),fOe=sizedWith(succeed$u),hOe=dual(2,(e,t)=>UD(aOe,NA(iOe,t))(e)),withSizedScoped=e=>OQ(aOe,NA(iOe,e)),sizedLayer=e=>k0(iOe,pipe(fiberRefMake(e),qR(fromFiberRef),XR(withSizedScoped))),dOe=sizedWith(e=>e.size),mOe=dual(2,(e,t)=>sizedWith(r=>r.withSize(t)(e))),testConfigWith=e=>ED(aOe,t=>e(jA(t,tOe))),gOe=testConfigWith(succeed$u),yOe=dual(2,(e,t)=>UD(aOe,NA(tOe,t))(e)),withTestConfigScoped=e=>OQ(aOe,NA(tOe,e)),testConfigLayer=e=>k0(tOe,H4(()=>{const t=e;return pipe(withTestConfigScoped(t),TR(t))}));var bOe=Object.freeze({__proto__:null,annotate:(e,t)=>annotationsWith(r=>r.annotate(e,t)),annotations:()=>annotationsWith(succeed$u),annotationsLayer,annotationsWith,currentServices:aOe,get:e=>annotationsWith(t=>t.get(e)),live:cOe,liveLayer,liveServices:oOe,liveWith,provideLive,provideWithLive:pOe,repeats:testConfigWith(e=>succeed$u(e.repeats)),retries:testConfigWith(e=>succeed$u(e.retries)),samples:testConfigWith(e=>succeed$u(e.samples)),shrinks:testConfigWith(e=>succeed$u(e.shrinks)),size:dOe,sized:fOe,sizedLayer,sizedWith,supervisedFibers:()=>annotationsWith(e=>e.supervisedFibers),testConfig:gOe,testConfigLayer,testConfigWith,withAnnotations:uOe,withAnnotationsScoped,withLive:lOe,withLiveScoped,withSize:mOe,withSized:hOe,withSizedScoped,withTestConfig:yOe,withTestConfigScoped});const SOe=pipe(annotationsLayer(),S0(liveLayer()),S0(sizedLayer(100)),S0(pipe(YTe,P0(S0(liveLayer(),annotationsLayer())))),S0(testConfigLayer({repeats:100,retries:100,samples:200,shrinks:1e3}))),vOe=syncContext$1(()=>lB);var _Oe=Object.freeze({__proto__:null,LiveContext:vOe,TestContext:P0(SOe,vOe),live:SOe});const wOe="effect/Trie",kOe=Symbol.for(wOe),xOe={[kOe]:{_Value:e=>e},[Symbol.iterator](){return new TrieIterator(this,(e,t)=>[e,t],()=>!0)},[Z](){let e=hash$3(wOe);for(const t of this)e^=pipe(hash$3(t[0]),combine$h(hash$3(t[1])));return cached$2(this,e)},[Y](e){if(isTrie(e)){const t=Array.from(e);return Array.from(this).every((e,r)=>{const n=t[r];return equals$4(e[0],n[0])&&equals$4(e[1],n[1])})}return!1},toString(){return format$6(this.toJSON())},toJSON(){return{_id:"Trie",values:Array.from(this).map(toJSON)}},[ee](){return this.toJSON()},pipe(){return pipeArguments(this,arguments)}},makeImpl=e=>{const t=Object.create(xOe);return t._root=e,t._count=e?.count??0,t};class TrieIterator{trie;f;filter;stack=[];constructor(e,t,r){this.trie=e,this.f=t,this.filter=r;const n=void 0!==e._root?e._root:void 0;void 0!==n&&this.stack.push([n,"",!1])}next(){for(;this.stack.length>0;){const[e,t,r]=this.stack.pop();if(r){const r=e.value;if(void 0!==r){const n=t+e.key;if(this.filter(n,r))return{done:!1,value:this.f(n,r)}}}else this.addToStack(e,t)}return{done:!0,value:void 0}}addToStack(e,t){void 0!==e.right&&this.stack.push([e.right,t,!1]),void 0!==e.mid&&this.stack.push([e.mid,t+e.key,!1]),this.stack.push([e,t,!0]),void 0!==e.left&&this.stack.push([e.left,t,!1])}[Symbol.iterator](){return new TrieIterator(this.trie,this.f,this.filter)}}const isTrie=e=>C(e,kOe),empty$1=()=>makeImpl(void 0),fromIterable$1=e=>{let t=empty$1();for(const[r,n]of e)t=IOe(t,r,n);return t},IOe=dual(3,(e,t,r)=>{if(0===t.length)return e;const n=[],i=[];let s=e._root??{key:t[0],count:0};const o=s.count+1;let a=0;for(;a<t.length;){const e=t[a];i.push(s),e>s.key?(n.push(1),s=void 0===s.right?{key:e,count:o}:s.right):e<s.key?(n.push(-1),s=void 0===s.left?{key:e,count:o}:s.left):(a===t.length-1?s.value=r:void 0===s.mid?(n.push(0),s={key:t[a+1],count:o}):(n.push(0),s=s.mid),a+=1)}for(let e=i.length-2;e>=0;--e){const t=i[e],r=n[e];i[e]=-1===r?{key:t.key,count:o,value:t.value,left:i[e+1],mid:t.mid,right:t.right}:1===r?{key:t.key,count:o,value:t.value,left:t.left,mid:t.mid,right:i[e+1]}:{key:t.key,count:o,value:t.value,left:t.left,mid:i[e+1],right:t.right}}return i[0].count=o,makeImpl(i[0])}),size$1=e=>e._root?.count??0,TOe=dual(3,(e,t,r)=>{let n=t;for(const t of e)n=r(n,t[1],t[0]);return n}),OOe=dual(2,(e,t)=>TOe(e,empty$1(),(e,r,n)=>IOe(e,n,t(r,n)))),EOe=dual(2,(e,t)=>TOe(e,empty$1(),(e,r,n)=>t(r,n)?IOe(e,n,r):e)),AOe=dual(2,(e,t)=>TOe(e,empty$1(),(e,r,n)=>{const i=t(r,n);return zt(i)?IOe(e,n,i.value):e})),COe=dual(2,(e,t)=>TOe(e,void 0,(e,r,n)=>t(r,n))),MOe=dual(2,(e,t)=>new TrieIterator(e,e=>e,e=>e.startsWith(t))),FOe=dual(2,(e,t)=>new TrieIterator(e,(e,t)=>t,e=>e.startsWith(t))),POe=dual(2,(e,t)=>new TrieIterator(e,(e,t)=>[e,t],e=>e.startsWith(t))),NOe=dual(2,(e,t)=>Array.from(POe(e,t))),jOe=dual(2,(e,t)=>{let r=e._root;if(void 0===r||0===t.length)return none$c();let n=0;for(;n<t.length;){const e=t[n];if(e>r.key){if(void 0===r.right)return none$c();r=r.right}else if(e<r.key){if(void 0===r.left)return none$c();r=r.left}else{if(n===t.length-1)return fromNullable$3(r.value);if(void 0===r.mid)return none$c();r=r.mid,n+=1}}return none$c()}),ROe=dual(2,(e,t)=>zt(jOe(e,t))),DOe=dual(2,(e,t)=>{const r=jOe(e,t);if(Bt(r))throw Error("Expected trie to contain key");return r.value}),LOe=dual(2,(e,t)=>{let r=e._root;if(void 0===r||0===t.length)return e;const n=r.count-1,i=[],s=[];let o=0;for(;o<t.length;){const n=t[o];if(n>r.key){if(void 0===r.right)return e;s.push(r),i.push(1),r=r.right}else if(n<r.key){if(void 0===r.left)return e;s.push(r),i.push(-1),r=r.left}else if(o===t.length-1){if(void 0===r.value)return e;s.push(r),i.push(0),o+=1}else{if(void 0===r.mid)return e;s.push(r),i.push(0),r=r.mid,o+=1}}const a=s[s.length-1];s[s.length-1]={key:a.key,count:n,left:a.left,mid:a.mid,right:a.right};for(let e=s.length-2;e>=0;--e){const t=s[e],r=i[e],o=s[e+1],a=void 0===o.left&&void 0===o.mid&&void 0===o.right?void 0:o;s[e]=-1===r?{key:t.key,count:n,value:t.value,left:a,mid:t.mid,right:t.right}:1===r?{key:t.key,count:n,value:t.value,left:t.left,mid:t.mid,right:a}:{key:t.key,count:n,value:t.value,left:t.left,mid:a,right:t.right}}return s[0].count=n,makeImpl(s[0])}),UOe=dual(2,(e,t)=>{let r=e;for(const e of t)r=LOe(e)(r);return r}),$Oe=dual(2,(e,t)=>{let r=e;for(const[e,n]of t)r=IOe(e,n)(r);return r}),BOe=dual(3,(e,t,r)=>{let n=e._root;if(void 0===n||0===t.length)return e;const i=[],s=[];let o=0;for(;o<t.length;){const r=t[o];if(r>n.key){if(void 0===n.right)return e;s.push(n),i.push(1),n=n.right}else if(r<n.key){if(void 0===n.left)return e;s.push(n),i.push(-1),n=n.left}else if(o===t.length-1){if(void 0===n.value)return e;s.push(n),i.push(0),o+=1}else{if(void 0===n.mid)return e;s.push(n),i.push(0),n=n.mid,o+=1}}const a=s[s.length-1];if(void 0===a.value)return e;s[s.length-1]={key:a.key,count:a.count,value:r(a.value),left:a.left,mid:a.mid,right:a.right};for(let e=s.length-2;e>=0;--e){const t=s[e],r=i[e],n=s[e+1];s[e]=-1===r?{key:t.key,count:t.count,value:t.value,left:n,mid:t.mid,right:t.right}:1===r?{key:t.key,count:t.count,value:t.value,left:t.left,mid:t.mid,right:n}:{key:t.key,count:t.count,value:t.value,left:t.left,mid:n,right:t.right}}return makeImpl(s[0])}),entries=e=>new TrieIterator(e,(e,t)=>[e,t],()=>!0);var zOe=Object.freeze({__proto__:null,compact:e=>AOe(e,identity$5),empty:empty$1,entries,entriesWithPrefix:POe,filter:EOe,filterMap:AOe,forEach:COe,fromIterable:fromIterable$1,get:jOe,has:ROe,insert:IOe,insertMany:$Oe,isEmpty:e=>0===size$1(e),keys:e=>new TrieIterator(e,e=>e,()=>!0),keysWithPrefix:MOe,longestPrefixOf:dual(2,(e,t)=>{let r,n=e._root;if(void 0===n||0===t.length)return none$c();let i=0;for(;i<t.length;){const e=t[i];if(void 0!==n.value&&(r=[t.slice(0,i+1),n.value]),e>n.key){if(void 0===n.right)break;n=n.right}else if(e<n.key){if(void 0===n.left)break;n=n.left}else{if(void 0===n.mid)break;n=n.mid,i+=1}}return fromNullable$3(r)}),make:(...e)=>fromIterable$1(e),map:OOe,modify:BOe,reduce:TOe,remove:LOe,removeMany:UOe,size:size$1,toEntries:e=>Array.from(entries(e)),toEntriesWithPrefix:NOe,unsafeGet:DOe,values:e=>new TrieIterator(e,(e,t)=>t,()=>!0),valuesWithPrefix:FOe}),qOe=Object.freeze({__proto__:null}),WOe=Object.freeze({__proto__:null,unify:identity$5}),VOe=Object.freeze({__proto__:null,NoUpstream:NoUpstream$1,Pulled:Pulled$1,UpstreamPullRequestTypeId:hre,isNoUpstream:e=>e._tag===fre,isPulled:e=>e._tag===pre,isUpstreamPullRequest:e=>C(e,hre),match:mre}),KOe=Object.freeze({__proto__:null,PullAfterAllEnqueued:e=>{const t=Object.create(Tte);return t._tag=xte,t.emitSeparator=e,t},PullAfterNext:PullAfterNext$1,UpstreamPullStrategyTypeId:Ite,isPullAfterAllEnqueued:e=>e._tag===xte,isPullAfterNext:e=>e._tag===kte,isUpstreamPullStrategy:e=>C(e,Ite),match:Ote});export{tE as Arbitrary,js as Array,NE as BigDecimal,rA as BigInt,fA as Boolean,mA as Brand,$Q as Cache,sY as Cause,bfe as Channel,Sfe as ChildExecutorDecision,VC as Chunk,IB as Clock,Wfe as Config,_fe as ConfigError,Vfe as ConfigProvider,Kfe as ConfigProviderPathPatch,Gfe as Console,UA as Context,O2 as Cron,Z0 as Data,rde as DateTime,nde as DefaultServices,vU as Deferred,xZ as Differ,OM as Duration,c9 as Effect,dz as Effectable,Tt as Either,fde as Encoding,X as Equal,w as Equivalence,mde as ExecutionPlan,LW as ExecutionStrategy,UU as Exit,pI as FastCheck,_X as Fiber,kde as FiberHandle,hP as FiberId,Rde as FiberMap,y9 as FiberRef,BB as FiberRefs,BW as FiberRefsPatch,Wde as FiberSet,ZW as FiberStatus,c as Function,I as GlobalValue,Jde as Graph,sme as GroupBy,ome as HKT,Q as Hash,AP as HashMap,DF as HashSet,ie as Inspectable,gn as Iterable,qme as JSONSchema,Zme as KeyedPool,jee as Layer,lge as LayerMap,iN as List,rz as LogLevel,nz as LogSpan,Nge as Logger,Kge as Mailbox,Jge as ManagedRuntime,Oye as Match,fie as MergeDecision,Eye as MergeState,Aye as MergeStrategy,Cye as Metric,Mye as MetricBoundaries,Fye as MetricHook,Pye as MetricKey,Nye as MetricKeyType,jye as MetricLabel,Rye as MetricPair,Uye as MetricPolling,$ye as MetricRegistry,Bye as MetricState,eG as Micro,zye as ModuleVersion,JU as MutableHashMap,Vye as MutableHashSet,XU as MutableList,a$ as MutableQueue,GF as MutableRef,Kye as NonEmptyIterable,XI as Number,Tr as Option,Dt as Order,Zye as Ordering,Rme as ParseResult,ae as Pipeable,Qye as Pool,$ as Predicate,ibe as Pretty,obe as PrimaryKey,ite as PubSub,hte as Queue,A2 as Random,ube as RateLimiter,age as RcMap,bie as RcRef,Sz as Readable,Kn as Record,QH as RedBlackTree,pbe as Redacted,Gz as Ref,eT as RegExp,ybe as Reloadable,a4 as Request,bbe as RequestBlock,Obe as RequestResolver,Cbe as Resource,Eie as Runtime,Mbe as RuntimeFlags,Lj as RuntimeFlagsPatch,xve as STM,Fie as Schedule,jY as ScheduleDecision,bY as ScheduleInterval,MY as ScheduleIntervals,iG as Scheduler,tke as Schema,GO as SchemaAST,qY as Scope,ike as ScopedCache,ske as ScopedRef,oke as Secret,ake as SingleProducerAsyncInput,uke as Sink,Ske as SortedMap,gZ as SortedSet,Ike as Stream,Tke as StreamEmit,qie as StreamHaltStrategy,Eke as Streamable,h2 as String,Cve as Struct,Pke as Subscribable,Vke as SubscriptionRef,Qke as Supervisor,Yke as Symbol,zke as SynchronizedRef,Nxe as TArray,$xe as TDeferred,mIe as TMap,kIe as TPriorityQueue,Cae as TPubSub,Nae as TQueue,CIe as TRandom,UIe as TReentrantLock,WIe as TRef,QIe as TSemaphore,bTe as TSet,TTe as TSubscriptionRef,OTe as Take,MTe as TestAnnotation,DTe as TestAnnotationMap,$Te as TestAnnotations,eOe as TestClock,rOe as TestConfig,_Oe as TestContext,ZTe as TestLive,bOe as TestServices,sOe as TestSized,Hz as Tracer,zOe as Trie,Pr as Tuple,qOe as Types,WOe as Unify,VOe as UpstreamPullRequest,KOe as UpstreamPullStrategy,J as Utils,absurd$2 as absurd,flow,u as hole,identity$5 as identity,pipe,t as unsafeCoerce};
